(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
L.BooleanControl = L.Control.extend({
  options: {
    position: 'topright'
  },

  onAdd: function(map) {
    var container = this._container = L.DomUtil.create('div', 'leaflet-bar');
    this._container.style.background = '#ffffff';
    this._container.style.padding = '10px';
    container.innerHTML = [
      '<form>',
        '<ul style="list-style:none; padding-left: 0">',
          '<li>','<label>', '<input type="radio" name="op" value="0" checked />',  ' Intersection', '</label>', '</li>',
          '<li>','<label>', '<input type="radio" name="op" value="1" />',  ' Union', '</label>', '</li>',
          '<li>','<label>', '<input type="radio" name="op" value="2" />',  ' Difference', '</label>', '</li>',
          '<li>','<label>', '<input type="radio" name="op" value="3" />',  ' Xor', '</label>', '</li>',
        '</ul>',
        '<input type="submit" value="Run">', '<input name="clear" type="button" value="Clear layers">',
      '</form>'].join('');
    var form = container.querySelector('form');
    L.DomEvent
      .on(form, 'submit', function (evt) {
        L.DomEvent.stop(evt);
        var radios = Array.prototype.slice.call(
          form.querySelectorAll('input[type=radio]'));
        for (var i = 0, len = radios.length; i < len; i++) {
          if (radios[i].checked) {
            this.options.callback(parseInt(radios[i].value));
            break;
          }
        }
      }, this)
      .on(form['clear'], 'click', function(evt) {
        L.DomEvent.stop(evt);
        this.options.clear();
      }, this);

    L.DomEvent
      .disableClickPropagation(this._container)
      .disableScrollPropagation(this._container);
    return this._container;
  }

});
},{}],2:[function(require,module,exports){
L.Coordinates = L.Control.extend({
  options: {
    position: 'bottomright'
  },

  onAdd: function(map) {
    this._container = L.DomUtil.create('div', 'leaflet-bar');
    this._container.style.background = '#ffffff';
    map.on('mousemove', this._onMouseMove, this);
    return this._container;
  },

  _onMouseMove: function(e) {
    this._container.innerHTML = '<span style="padding: 5px">' +
      e.latlng.lng + ', ' + e.latlng.lat + '</span>';
  }

});
},{}],3:[function(require,module,exports){
var L = require('leaflet');
var LeafletEditable = require('leaflet-editable');
require('./coordinates');
require('./polygoncontrol');
require('./booleanopcontrol');
var martinez = require('../../');
var xhr = require('superagent');
// var turf = require('turf');
var jsts = window.jsts = require('jsts');

var mode = /geo/.test(window.location.hash) ? 'geo' : 'orthogonal';

console.log(mode);

var path = '../test/fixtures/';
var file = mode === 'geo' ? 'asia.json' : 'horseshoe.json';



var div = document.createElement('div');
div.id = 'image-map';
div.style.width = div.style.height = '100%';
document.body.appendChild(div);

// create the slippy map
var map = window.map = L.map('image-map', {
  minZoom: 1,
  maxZoom: 20,
  center: [0, 0],
  zoom: 1,
  crs: mode === 'geo' ? L.CRS.EPSG4326 : L.CRS.Simple,
  editable: true
});

map.addControl(new L.NewPolygonControl({
  callback: map.editTools.startPolygon
}));
map.addControl(new L.Coordinates());
map.addControl(new L.BooleanControl({
  callback: run,
  clear: clear
}));

var drawnItems = window.drawnItems = L.geoJson().addTo(map);

function loadData(path) {
  console.log(path);
  // var two_triangles = require('../../test/fixtures/two_shapes.json');
  // var oneInside = require('../../test/fixtures/one_inside.json');
  // var twoPointedTriangles = require('../../test/fixtures/two_pointed_triangles.json');
  // var selfIntersecting = require('../../test/fixtures/self_intersecting.json');
  // var holes = require('../../test/fixtures/hole_hole.json');
  //var data =  require('../../test/fixtures/indonesia.json');
  xhr
    .get(path)
    .set('Accept', 'application/json')
    .end(function(e, r) {
      if (!e) {
        drawnItems.addData(r.body);
        map.fitBounds(drawnItems.getBounds().pad(0.05), { animate: false });
      }
    });
}

function clear() {
  drawnItems.clearLayers();
  results.clearLayers();
}

var reader = new jsts.io.GeoJSONReader();
var writer = new jsts.io.GeoJSONWriter();


function run (op) {
  var layers = drawnItems.getLayers();
  if (layers.length < 2) return;
  var subject = layers[0].toGeoJSON();
  var clipping = layers[1].toGeoJSON();

  console.log('input', subject, clipping, op);

  subject = JSON.parse(JSON.stringify(subject));
  clipping = JSON.parse(JSON.stringify(clipping));


  console.time('martinez');
  var result = martinez(subject.geometry.coordinates, clipping.geometry.coordinates, op);
  console.timeEnd('martinez');

  console.time('jsts');
  var s = reader.read(subject);
  var c = reader.read(clipping);
  var res = writer.write(s.geometry.intersection(c.geometry));

  console.timeEnd('jsts');

  //console.log('result', result, res);

  results.clearLayers();
  results.addData({
    'type': 'Feature',
    'geometry': {
      'type': 'Polygon',
      'coordinates': result
    }
  });
}

//drawnItems.addData(oneInside);
//drawnItems.addData(twoPointedTriangles);
//drawnItems.addData(selfIntersecting);
//drawnItems.addData(holes);
//drawnItems.addData(data);

map.on('editable:created', function(evt) {
  drawnItems.addLayer(evt.layer);
  evt.layer.on('click', function(e) {
    if ((e.originalEvent.ctrlKey || e.originalEvent.metaKey) && this.editEnabled()) {
      this.editor.newHole(e.latlng);
    }
  });
});

var results = window.results = L.geoJson(null, {
  style: function(feature) {
    return {
      color: 'red',
      weight: 1
    };
  }
}).addTo(map);

loadData(path + file);

},{"../../":5,"./booleanopcontrol":1,"./coordinates":2,"./polygoncontrol":4,"jsts":11,"leaflet":13,"leaflet-editable":12,"superagent":14}],4:[function(require,module,exports){
L.EditControl = L.Control.extend({

  options: {
    position: 'topleft',
    callback: null,
    kind: '',
    html: ''
  },

  onAdd: function (map) {
    var container = L.DomUtil.create('div', 'leaflet-control leaflet-bar'),
        link = L.DomUtil.create('a', '', container);

    link.href = '#';
    link.title = 'Create a new ' + this.options.kind;
    link.innerHTML = this.options.html;
    L.DomEvent.on(link, 'click', L.DomEvent.stop)
              .on(link, 'click', function () {
                window.LAYER = this.options.callback.call(map.editTools);
              }, this);

    return container;
  }

});

L.NewPolygonControl = L.EditControl.extend({
  options: {
    position: 'topleft',
    kind: 'polygon',
    html: 'â–°'
  }
});
},{}],5:[function(require,module,exports){
module.exports = require('./src/index');

},{"./src/index":23}],6:[function(require,module,exports){
module.exports = {
    RBTree: require('./lib/rbtree'),
    BinTree: require('./lib/bintree')
};

},{"./lib/bintree":7,"./lib/rbtree":8}],7:[function(require,module,exports){

var TreeBase = require('./treebase');

function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}

Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};

Node.prototype.set_child = function(dir, val) {
    if(dir) {
        this.right = val;
    }
    else {
        this.left = val;
    }
};

function BinTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}

BinTree.prototype = new TreeBase();

// returns true if inserted, false if duplicate
BinTree.prototype.insert = function(data) {
    if(this._root === null) {
        // empty tree
        this._root = new Node(data);
        this.size++;
        return true;
    }

    var dir = 0;

    // setup
    var p = null; // parent
    var node = this._root;

    // search down
    while(true) {
        if(node === null) {
            // insert new node at the bottom
            node = new Node(data);
            p.set_child(dir, node);
            ret = true;
            this.size++;
            return true;
        }

        // stop if found
        if(this._comparator(node.data, data) === 0) {
            return false;
        }

        dir = this._comparator(node.data, data) < 0;

        // update helpers
        p = node;
        node = node.get_child(dir);
    }
};

// returns true if removed, false if not found
BinTree.prototype.remove = function(data) {
    if(this._root === null) {
        return false;
    }

    var head = new Node(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var found = null; // found item
    var dir = 1;

    while(node.get_child(dir) !== null) {
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;

        if(cmp === 0) {
            found = node;
        }
    }

    if(found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));

        this._root = head.right;
        this.size--;
        return true;
    }
    else {
        return false;
    }
};

module.exports = BinTree;


},{"./treebase":9}],8:[function(require,module,exports){

var TreeBase = require('./treebase');

function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
    this.red = true;
}

Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};

Node.prototype.set_child = function(dir, val) {
    if(dir) {
        this.right = val;
    }
    else {
        this.left = val;
    }
};

function RBTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}

RBTree.prototype = new TreeBase();

// returns true if inserted, false if duplicate
RBTree.prototype.insert = function(data) {
    var ret = false;

    if(this._root === null) {
        // empty tree
        this._root = new Node(data);
        ret = true;
        this.size++;
    }
    else {
        var head = new Node(undefined); // fake tree root

        var dir = 0;
        var last = 0;

        // setup
        var gp = null; // grandparent
        var ggp = head; // grand-grand-parent
        var p = null; // parent
        var node = this._root;
        ggp.right = this._root;

        // search down
        while(true) {
            if(node === null) {
                // insert new node at the bottom
                node = new Node(data);
                p.set_child(dir, node);
                ret = true;
                this.size++;
            }
            else if(is_red(node.left) && is_red(node.right)) {
                // color flip
                node.red = true;
                node.left.red = false;
                node.right.red = false;
            }

            // fix red violation
            if(is_red(node) && is_red(p)) {
                var dir2 = ggp.right === gp;

                if(node === p.get_child(last)) {
                    ggp.set_child(dir2, single_rotate(gp, !last));
                }
                else {
                    ggp.set_child(dir2, double_rotate(gp, !last));
                }
            }

            var cmp = this._comparator(node.data, data);

            // stop if found
            if(cmp === 0) {
                break;
            }

            last = dir;
            dir = cmp < 0;

            // update helpers
            if(gp !== null) {
                ggp = gp;
            }
            gp = p;
            p = node;
            node = node.get_child(dir);
        }

        // update root
        this._root = head.right;
    }

    // make root black
    this._root.red = false;

    return ret;
};

// returns true if removed, false if not found
RBTree.prototype.remove = function(data) {
    if(this._root === null) {
        return false;
    }

    var head = new Node(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var gp = null; // grand parent
    var found = null; // found item
    var dir = 1;

    while(node.get_child(dir) !== null) {
        var last = dir;

        // update helpers
        gp = p;
        p = node;
        node = node.get_child(dir);

        var cmp = this._comparator(data, node.data);

        dir = cmp > 0;

        // save found node
        if(cmp === 0) {
            found = node;
        }

        // push the red node down
        if(!is_red(node) && !is_red(node.get_child(dir))) {
            if(is_red(node.get_child(!dir))) {
                var sr = single_rotate(node, dir);
                p.set_child(last, sr);
                p = sr;
            }
            else if(!is_red(node.get_child(!dir))) {
                var sibling = p.get_child(!last);
                if(sibling !== null) {
                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
                        // color flip
                        p.red = false;
                        sibling.red = true;
                        node.red = true;
                    }
                    else {
                        var dir2 = gp.right === p;

                        if(is_red(sibling.get_child(last))) {
                            gp.set_child(dir2, double_rotate(p, last));
                        }
                        else if(is_red(sibling.get_child(!last))) {
                            gp.set_child(dir2, single_rotate(p, last));
                        }

                        // ensure correct coloring
                        var gpc = gp.get_child(dir2);
                        gpc.red = true;
                        node.red = true;
                        gpc.left.red = false;
                        gpc.right.red = false;
                    }
                }
            }
        }
    }

    // replace and remove if found
    if(found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this.size--;
    }

    // update root and make it black
    this._root = head.right;
    if(this._root !== null) {
        this._root.red = false;
    }

    return found !== null;
};

function is_red(node) {
    return node !== null && node.red;
}

function single_rotate(root, dir) {
    var save = root.get_child(!dir);

    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);

    root.red = true;
    save.red = false;

    return save;
}

function double_rotate(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
}

module.exports = RBTree;

},{"./treebase":9}],9:[function(require,module,exports){

function TreeBase() {}

// removes all nodes from the tree
TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
};

// returns node data if found, null otherwise
TreeBase.prototype.find = function(data) {
    var res = this._root;

    while(res !== null) {
        var c = this._comparator(data, res.data);
        if(c === 0) {
            return res.data;
        }
        else {
            res = res.get_child(c > 0);
        }
    }

    return null;
};

// returns iterator to node if found, null otherwise
TreeBase.prototype.findIter = function(data) {
    var res = this._root;
    var iter = this.iterator();

    while(res !== null) {
        var c = this._comparator(data, res.data);
        if(c === 0) {
            iter._cursor = res;
            return iter;
        }
        else {
            iter._ancestors.push(res);
            res = res.get_child(c > 0);
        }
    }

    return null;
};

// Returns an iterator to the tree node at or immediately after the item
TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;

    while(cur !== null) {
        var c = cmp(item, cur.data);
        if(c === 0) {
            iter._cursor = cur;
            return iter;
        }
        iter._ancestors.push(cur);
        cur = cur.get_child(c > 0);
    }

    for(var i=iter._ancestors.length - 1; i >= 0; --i) {
        cur = iter._ancestors[i];
        if(cmp(item, cur.data) < 0) {
            iter._cursor = cur;
            iter._ancestors.length = i;
            return iter;
        }
    }

    iter._ancestors.length = 0;
    return iter;
};

// Returns an iterator to the tree node immediately after the item
TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;

    while(iter.data() !== null && cmp(iter.data(), item) === 0) {
        iter.next();
    }

    return iter;
};

// returns null if tree is empty
TreeBase.prototype.min = function() {
    var res = this._root;
    if(res === null) {
        return null;
    }

    while(res.left !== null) {
        res = res.left;
    }

    return res.data;
};

// returns null if tree is empty
TreeBase.prototype.max = function() {
    var res = this._root;
    if(res === null) {
        return null;
    }

    while(res.right !== null) {
        res = res.right;
    }

    return res.data;
};

// returns a null iterator
// call next() or prev() to point to an element
TreeBase.prototype.iterator = function() {
    return new Iterator(this);
};

// calls cb on each node's data, in order
TreeBase.prototype.each = function(cb) {
    var it=this.iterator(), data;
    while((data = it.next()) !== null) {
        cb(data);
    }
};

// calls cb on each node's data, in reverse order
TreeBase.prototype.reach = function(cb) {
    var it=this.iterator(), data;
    while((data = it.prev()) !== null) {
        cb(data);
    }
};


function Iterator(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
}

Iterator.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
};

// if null-iterator, returns first node
// otherwise, returns next node
Iterator.prototype.next = function() {
    if(this._cursor === null) {
        var root = this._tree._root;
        if(root !== null) {
            this._minNode(root);
        }
    }
    else {
        if(this._cursor.right === null) {
            // no greater node in subtree, go up to parent
            // if coming from a right child, continue up the stack
            var save;
            do {
                save = this._cursor;
                if(this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                }
                else {
                    this._cursor = null;
                    break;
                }
            } while(this._cursor.right === save);
        }
        else {
            // get the next node from the subtree
            this._ancestors.push(this._cursor);
            this._minNode(this._cursor.right);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};

// if null-iterator, returns last node
// otherwise, returns previous node
Iterator.prototype.prev = function() {
    if(this._cursor === null) {
        var root = this._tree._root;
        if(root !== null) {
            this._maxNode(root);
        }
    }
    else {
        if(this._cursor.left === null) {
            var save;
            do {
                save = this._cursor;
                if(this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                }
                else {
                    this._cursor = null;
                    break;
                }
            } while(this._cursor.left === save);
        }
        else {
            this._ancestors.push(this._cursor);
            this._maxNode(this._cursor.left);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};

Iterator.prototype._minNode = function(start) {
    while(start.left !== null) {
        this._ancestors.push(start);
        start = start.left;
    }
    this._cursor = start;
};

Iterator.prototype._maxNode = function(start) {
    while(start.right !== null) {
        this._ancestors.push(start);
        start = start.right;
    }
    this._cursor = start;
};

module.exports = TreeBase;


},{}],10:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],11:[function(require,module,exports){
// JSTS. See https://github.com/bjornharrtell/jsts
// Licenses:
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.jsts=t.jsts||{})}(this,function(t){"use strict";function e(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}function n(){}function i(){}function r(){}function s(){}function o(){}function a(){}function u(){}function l(t){this.message=t}function h(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}function c(){if(0===arguments.length)l.call(this);else if(1===arguments.length){var t=arguments[0];l.call(this,t)}}function f(){}function g(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.call(this,0,0);else if(1===arguments.length){var t=arguments[0];g.call(this,t.x,t.y,t.z)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];g.call(this,e,n,g.NULL_ORDINATE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.x=i,this.y=r,this.z=s}}function d(){if(this.dimensionsToTest=2,0===arguments.length)d.call(this,2);else if(1===arguments.length){var t=arguments[0];if(2!==t&&3!==t)throw new i("only 2 or 3 dimensions may be specified");this.dimensionsToTest=t}}function p(){}function v(){}function m(t){this.message=t||""}function y(){}function x(t){this.message=t||""}function E(t){this.message=t||""}function I(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function N(){if(I.apply(this),0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.ensureCapacity(e.length),this.add(e,n)}}function C(){if(this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.init(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];this.init(r,s,o,a)}}function S(){}function w(){S.call(this,"Projective point not representable on the Cartesian plane.")}function L(){}function R(t,e){return t.interfaces_&&t.interfaces_().indexOf(e)>-1}function T(){}function P(t){this.str=t}function b(t){this.value=t}function O(){}function _(){if(this.hi=0,this.lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.init(t)}else if(arguments[0]instanceof _){var e=arguments[0];this.init(e)}else if("string"==typeof arguments[0]){var n=arguments[0];_.call(this,_.parse(n))}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.init(i,r)}}function M(){}function D(){}function A(){}function F(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var e=arguments[0],n=arguments[1];this.x=e,this.y=n,this.w=1}else if(arguments[0]instanceof F&&arguments[1]instanceof F){var i=arguments[0],r=arguments[1];this.x=i.y*r.w-r.y*i.w,this.y=r.x*i.w-i.x*r.w,this.w=i.x*r.y-r.x*i.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1];this.x=s.y-o.y,this.y=o.x-s.x,this.w=s.x*o.y-o.x*s.y}}else if(3===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2];this.x=a,this.y=u,this.w=l}else if(4===arguments.length){var h=arguments[0],c=arguments[1],f=arguments[2],d=arguments[3],p=h.y-c.y,v=c.x-h.x,m=h.x*c.y-c.x*h.y,y=f.y-d.y,x=d.x-f.x,E=f.x*d.y-d.x*f.y;this.x=v*E-x*m,this.y=y*m-p*E,this.w=p*x-y*v}}function G(){}function q(){}function B(){this.envelope=null,this.factory=null,this.SRID=null,this.userData=null;var t=arguments[0];this.factory=t,this.SRID=t.getSRID()}function z(){}function V(){}function k(){}function Y(){}function U(){}function X(){}function H(){}function W(){}function j(){}function K(){}function Z(){}function Q(){}function J(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function $(t){return null==t?$s:t.color}function tt(t){return null==t?null:t.parent}function et(t,e){null!==t&&(t.color=e)}function nt(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}function st(){}function ot(){}function at(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function ut(){}function lt(){}function ht(){}function ct(){}function ft(){this.geometries=null;var t=arguments[0],e=arguments[1];if(B.call(this,e),null===t&&(t=[]),B.hasNullElements(t))throw new i("geometries must not contain null elements");this.geometries=t}function gt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function dt(){if(this.geom=null,this.geomFact=null,this.bnRule=null,this.endpointMap=null,1===arguments.length){var t=arguments[0];dt.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.geom=e,this.geomFact=e.getFactory(),this.bnRule=n}}function pt(){this.count=null}function vt(){}function mt(){}function yt(){}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}function St(){this.points=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function wt(){}function Lt(){this.coordinates=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function Rt(){}function Tt(){this.shell=null,this.holes=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(B.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),B.hasNullElements(e))throw new i("holes must not contain null elements");if(t.isEmpty()&&B.hasNonEmptyElements(e))throw new i("shell is empty but holes are not");this.shell=t,this.holes=e}function Pt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function bt(){if(arguments[0]instanceof g&&arguments[1]instanceof ie){var t=arguments[0],e=arguments[1];bt.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(R(arguments[0],D)&&arguments[1]instanceof ie){var n=arguments[0],i=arguments[1];St.call(this,n,i),this.validateConstruction()}}function Ot(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function _t(){if(this.factory=null,this.isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.factory=t}}function Mt(){}function Dt(){}function At(){}function Ft(){}function Gt(){if(this.dimension=3,this.coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];Gt.call(this,t,3)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.coordinates=new Array(e).fill(null);for(var n=0;e>n;n++)this.coordinates[n]=new g}else if(R(arguments[0],D)){var i=arguments[0];if(null===i)return this.coordinates=new Array(0).fill(null),null;this.dimension=i.getDimension(),this.coordinates=new Array(i.size()).fill(null);for(var n=0;n<this.coordinates.length;n++)this.coordinates[n]=i.getCoordinateCopy(n)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var r=arguments[0],s=arguments[1];this.coordinates=r,this.dimension=s,null===r&&(this.coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var o=arguments[0],a=arguments[1];this.coordinates=new Array(o).fill(null),this.dimension=a;for(var n=0;o>n;n++)this.coordinates[n]=new g}}function qt(){}function Bt(t,e){return t===e||t!==t&&e!==e}function zt(t,e){function n(t){return this&&this.constructor===n?(this._keys=[],this._values=[],this._itp=[],this.objectOnly=e,void(t&&Vt.call(this,t))):new n(t)}return e||io(t,"size",{get:Jt}),t.constructor=n,n.prototype=t,n}function Vt(t){this.add?t.forEach(this.add,this):t.forEach(function(t){this.set(t[0],t[1])},this)}function kt(t){return this.has(t)&&(this._keys.splice(no,1),this._values.splice(no,1),this._itp.forEach(function(t){no<t[0]&&t[0]--})),no>-1}function Yt(t){return this.has(t)?this._values[no]:void 0}function Ut(t,e){if(this.objectOnly&&e!==Object(e))throw new TypeError("Invalid value used as weak collection key");if(e!==e||0===e)for(no=t.length;no--&&!Bt(t[no],e););else no=t.indexOf(e);return no>-1}function Xt(t){return Ut.call(this,this._keys,t)}function Ht(t,e){return this.has(t)?this._values[no]=e:this._values[this._keys.push(t)-1]=e,this}function Wt(){(this._keys||0).length=this._values.length=0}function jt(){return Qt(this._itp,this._keys)}function Kt(){return Qt(this._itp,this._values)}function Zt(){return Qt(this._itp,this._keys,this._values)}function Qt(t,e,n){var i=[0],r=!1;return t.push(i),{next:function(){var s,o=i[0];return!r&&o<e.length?(s=n?[e[o],n[o]]:e[o],i[0]++):(r=!0,t.splice(t.indexOf(i),1)),{done:r,value:s}}}}function Jt(){return this._values.length}function $t(t,e){for(var n=this.entries();;){var i=n.next();if(i.done)break;t.call(e,i.value[1],i.value[0],this)}}function te(){this.map_=new so}function ee(){if(this.modelType=null,this.scale=null,0===arguments.length)this.modelType=ee.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ne){var t=arguments[0];this.modelType=t,t===ee.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var e=arguments[0];this.modelType=ee.FIXED,this.setScale(e)}else if(arguments[0]instanceof ee){var n=arguments[0];this.modelType=n.modelType,this.scale=n.scale}}function ne(){this.name=null;var t=arguments[0];this.name=t,ne.nameToTypeMap.put(t,this)}function ie(){if(this.precisionModel=null,this.coordinateSequenceFactory=null,this.SRID=null,0===arguments.length)ie.call(this,new ee,0);else if(1===arguments.length){if(R(arguments[0],G)){var t=arguments[0];ie.call(this,new ee,0,t)}else if(arguments[0]instanceof ee){var e=arguments[0];ie.call(this,e,0,ie.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];ie.call(this,n,i,ie.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.precisionModel=r,this.coordinateSequenceFactory=o,this.SRID=s}}function re(t){this.geometryFactory=t||new ie}function se(t){this.parser=new re(t)}function oe(){this.result=null,this.inputLines=Array(2).fill().map(function(){return Array(2)}),this.intPt=new Array(2).fill(null),this.intLineIndex=null,this._isProper=null,this.pa=null,this.pb=null,this.precisionModel=null,this.intPt[0]=new g,this.intPt[1]=new g,this.pa=this.intPt[0],this.pb=this.intPt[1],this.result=0}function ae(){oe.apply(this)}function ue(){}function le(){this.p=null,this.crossingCount=0,this.isPointOnSegment=!1;var t=arguments[0];this.p=t}function he(){}function ce(){if(this.p0=null,this.p1=null,0===arguments.length)ce.call(this,new g,new g);else if(1===arguments.length){var t=arguments[0];ce.call(this,t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0=e,this.p1=n}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];ce.call(this,new g(i,r),new g(s,o))}}function fe(){if(this.matrix=null,0===arguments.length)this.matrix=Array(3).fill().map(function(){return Array(3)}),this.setAll(lt.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){var t=arguments[0];fe.call(this),this.set(t)}else if(arguments[0]instanceof fe){var e=arguments[0];fe.call(this),this.matrix[L.INTERIOR][L.INTERIOR]=e.matrix[L.INTERIOR][L.INTERIOR],this.matrix[L.INTERIOR][L.BOUNDARY]=e.matrix[L.INTERIOR][L.BOUNDARY],this.matrix[L.INTERIOR][L.EXTERIOR]=e.matrix[L.INTERIOR][L.EXTERIOR],this.matrix[L.BOUNDARY][L.INTERIOR]=e.matrix[L.BOUNDARY][L.INTERIOR],this.matrix[L.BOUNDARY][L.BOUNDARY]=e.matrix[L.BOUNDARY][L.BOUNDARY],this.matrix[L.BOUNDARY][L.EXTERIOR]=e.matrix[L.BOUNDARY][L.EXTERIOR],this.matrix[L.EXTERIOR][L.INTERIOR]=e.matrix[L.EXTERIOR][L.INTERIOR],this.matrix[L.EXTERIOR][L.BOUNDARY]=e.matrix[L.EXTERIOR][L.BOUNDARY],this.matrix[L.EXTERIOR][L.EXTERIOR]=e.matrix[L.EXTERIOR][L.EXTERIOR]}}function ge(){this.areaBasePt=null,this.triangleCent3=new g,this.areasum2=0,this.cg3=new g,this.lineCentSum=new g,this.totalLength=0,this.ptCount=0,this.ptCentSum=new g;var t=arguments[0];this.areaBasePt=null,this.add(t)}function de(t){this.message=t||""}function pe(){this.array_=[]}function ve(){this.treeSet=new at,this.list=new I}function me(){if(this.geomFactory=null,this.inputPts=null,1===arguments.length){var t=arguments[0];me.call(this,me.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputPts=ve.filterCoordinates(e),this.geomFactory=n}}function ye(){this.origin=null;var t=arguments[0];this.origin=t}function xe(){this.inputGeom=null,this.factory=null,this.pruneEmptyGeometry=!0,this.preserveGeometryCollectionType=!0,this.preserveCollections=!1,this.preserveType=!1}function Ee(){if(this.snapTolerance=0,this.srcPts=null,this.seg=new ce,this.allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof St&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];Ee.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1];this.srcPts=n,this._isClosed=Ee.isClosed(n),this.snapTolerance=i}}function Ie(){this.srcGeom=null;var t=arguments[0];this.srcGeom=t}function Ne(){if(xe.apply(this),this.snapTolerance=null,this.snapPts=null,this.isSelfSnap=!1,2===arguments.length){var t=arguments[0],e=arguments[1];this.snapTolerance=t,this.snapPts=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.snapTolerance=n,this.snapPts=i,this.isSelfSnap=r}}function Ce(){this.isFirst=!0,this.commonMantissaBitsCount=53,this.commonBits=0,this.commonSignExp=null}function Se(){this.commonCoord=null,this.ccFilter=new we}function we(){this.commonBitsX=new Ce,this.commonBitsY=new Ce}function Le(){this.trans=null;var t=arguments[0];this.trans=t}function Re(){this.parent=null,this.atStart=null,this.max=null,this.index=null,this.subcollectionIterator=null;var t=arguments[0];this.parent=t,this.atStart=!0,this.index=0,this.max=t.getNumGeometries()}function Te(){if(this.boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this.isIn=null,this.numBoundaries=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];if(null===t)throw new i("Rule must be non-null");this.boundaryRule=t}}function Pe(){}function be(){}function Oe(){this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function _e(){}function Me(){this.bounds=null,this.item=null;var t=arguments[0],e=arguments[1];this.bounds=t,this.item=e}function De(){this._size=null,this.items=null,this._size=0,this.items=new I,this.items.add(null)}function Ae(){}function Fe(){}function Ge(){if(this.childBoundables=new I,this.bounds=null,this.level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.level=t}}function qe(){this.boundable1=null,this.boundable2=null,this._distance=null,this.itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.boundable1=t,this.boundable2=e,this.itemDistance=n,this._distance=this.distance()}function Be(){if(this.root=null,this.built=!1,this.itemBoundables=new I,this.nodeCapacity=null,0===arguments.length)Be.call(this,Be.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];f.isTrue(t>1,"Node capacity must be greater than 1"),this.nodeCapacity=t}}function ze(){}function Ve(){}function ke(){if(0===arguments.length)ke.call(this,ke.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];Be.call(this,t)}}function Ye(){var t=arguments[0];Ge.call(this,t)}function Ue(){}function Xe(){this.segString=null,this.coord=null,this.segmentIndex=null,this.segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.segString=t,this.coord=new g(e),this.segmentIndex=n,this.segmentOctant=i,this._isInterior=!e.equals2D(t.getCoordinate(n))}function He(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function We(){this.nodeList=null,this.edge=null,this.nodeIt=null,this.currNode=null,this.nextNode=null,this.currSegIndex=0;var t=arguments[0];this.nodeList=t,this.edge=t.getEdge(),this.nodeIt=t.iterator(),this.readNextNode()}function je(){}function Ke(){this.nodeList=new He(this),this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function Ze(){this.tempEnv1=new C,this.tempEnv2=new C,this.overlapSeg1=new ce,this.overlapSeg2=new ce}function Qe(){this.pts=null,this.start=null,this.end=null,this.env=null,this.context=null,this.id=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.pts=t,this.start=e,this.end=n,this.context=i}function Je(){}function $e(){}function tn(){}function en(){if(this.segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t)}}function nn(){if(this.monoChains=new I,this.index=new ke,this.idCounter=0,this.nodedSegStrings=null,this.nOverlaps=0,0===arguments.length);else if(1===arguments.length){var t=arguments[0];en.call(this,t)}}function rn(){Ze.apply(this),this.si=null;var t=arguments[0];this.si=t}function sn(){if(this.pt=null,1===arguments.length){var t=arguments[0];l.call(this,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];l.call(this,sn.msgWithCoord(e,n)),this.pt=new g(n)}}function on(){}function an(){this.findAllIntersections=!1,this.isCheckEndSegmentsOnly=!1,this.li=null,this.interiorIntersection=null,this.intSegments=null,this.intersections=new I,this.intersectionCount=0,this.keepIntersections=!0;var t=arguments[0];this.li=t,this.interiorIntersection=null}function un(){this.li=new ae,this.segStrings=null,this.findAllIntersections=!1,this.segInt=null,this._isValid=!0;var t=arguments[0];this.segStrings=t}function ln(){this.nv=null;var t=arguments[0];this.nv=new un(ln.toSegmentStrings(t))}function hn(){this.mapOp=null;var t=arguments[0];this.mapOp=t}function cn(){}function fn(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.init(1),this.location[cn.ON]=e}else if(arguments[0]instanceof fn){var n=arguments[0];if(this.init(n.location.length),null!==n)for(var i=0;i<this.location.length;i++)this.location[i]=n.location[i]}}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.init(3),this.location[cn.ON]=r,this.location[cn.LEFT]=s,this.location[cn.RIGHT]=o}}function gn(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var t=arguments[0];this.elt[0]=new fn(t),this.elt[1]=new fn(t)}else if(arguments[0]instanceof gn){var e=arguments[0];this.elt[0]=new fn(e.elt[0]),this.elt[1]=new fn(e.elt[1])}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.elt[0]=new fn(L.NONE),this.elt[1]=new fn(L.NONE),this.elt[n].setLocation(i)}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.elt[0]=new fn(r,s,o),this.elt[1]=new fn(r,s,o)}else if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3];this.elt[0]=new fn(L.NONE,L.NONE,L.NONE),this.elt[1]=new fn(L.NONE,L.NONE,L.NONE),this.elt[a].setLocations(u,l,h)}}function dn(){this.startDe=null,this.maxNodeDegree=-1,this.edges=new I,this.pts=new I,this.label=new gn(L.NONE),this.ring=null,this._isHole=null,this.shell=null,this.holes=new I,this.geometryFactory=null;var t=arguments[0],e=arguments[1];this.geometryFactory=e,this.computePoints(t),this.computeRing()}function pn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function vn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function mn(){if(this.label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.label=t}}function yn(){mn.apply(this),this.coord=null,this.edges=null;var t=arguments[0],e=arguments[1];this.coord=t,this.edges=e,this.label=new gn(0,L.NONE)}function xn(){this.nodeMap=new rt,this.nodeFact=null;var t=arguments[0];this.nodeFact=t}function En(){if(this.edge=null,this.label=null,this.node=null,this.p0=null,this.p1=null,this.dx=null,this.dy=null,this.quadrant=null,1===arguments.length){var t=arguments[0];this.edge=t}else if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];En.call(this,e,n,i,null)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];En.call(this,r),this.init(s,o),this.label=a}}function In(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this.sym=null,this.next=null,this.nextMin=null,this.edgeRing=null,this.minEdgeRing=null,this.depth=[0,-999,-999];var t=arguments[0],e=arguments[1];if(En.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{var n=t.getNumPoints()-1;this.init(t.getCoordinate(n),t.getCoordinate(n-1))}this.computeDirectedLabel()}function Nn(){}function Cn(){if(this.edges=new I,this.nodes=null,this.edgeEndList=new I,0===arguments.length)this.nodes=new xn(new Nn);else if(1===arguments.length){var t=arguments[0];this.nodes=new xn(t)}}function Sn(){this.geometryFactory=null,this.shellList=new I;var t=arguments[0];this.geometryFactory=t}function wn(){this.op=null,this.geometryFactory=null,this.ptLocator=null,this.lineEdgesList=new I,this.resultLineList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.op=t,this.geometryFactory=e,this.ptLocator=n}function Ln(){this.op=null,this.geometryFactory=null,this.resultPointList=new I;var t=arguments[0],e=arguments[1];arguments[2];this.op=t,this.geometryFactory=e}function Rn(){}function Tn(){this.geom=null;var t=arguments[0];this.geom=t}function Pn(){this.edgeMap=new rt,this.edgeList=null,this.ptInAreaLocation=[L.NONE,L.NONE]}function bn(){Pn.apply(this),this.resultAreaEdgeList=null,this.label=null,this.SCANNING_FOR_INCOMING=1,this.LINKING_TO_OUTGOING=2}function On(){Nn.apply(this)}function _n(){this.mce=null,this.chainIndex=null;var t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}function Mn(){if(this.label=null,this.xValue=null,this.eventType=null,this.insertEvent=null,this.deleteEventIndex=null,this.obj=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.eventType=Mn.DELETE,this.xValue=t,this.insertEvent=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.eventType=Mn.INSERT,this.label=n,this.xValue=i,this.obj=r}}function Dn(){}function An(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.properIntersectionPoint=null,this.li=null,this.includeProper=null,this.recordIsolated=null,this.isSelfIntersection=null,this.numIntersections=0,this.numTests=0,this.bdyNodes=null,this._isDone=!1,this.isDoneWhenProperInt=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.li=t,this.includeProper=e,this.recordIsolated=n}function Fn(){Dn.apply(this),this.events=new I,this.nOverlaps=null}function Gn(){this.min=r.POSITIVE_INFINITY,this.max=r.NEGATIVE_INFINITY}function qn(){}function Bn(){Gn.apply(this),this.item=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.min=t,this.max=e,this.item=n}function zn(){Gn.apply(this),this.node1=null,this.node2=null;var t=arguments[0],e=arguments[1];this.node1=t,this.node2=e,this.buildExtent(this.node1,this.node2)}function Vn(){this.leaves=new I,this.root=null,this.level=0}function kn(){if(this.lines=null,this.isForcedToLineString=!1,1===arguments.length){var t=arguments[0];this.lines=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.lines=e,this.isForcedToLineString=n}}function Yn(){this.items=new I}function Un(){this.index=null;var t=arguments[0];if(!R(t,Rt))throw new i("Argument must be Polygonal");this.index=new Hn(t)}function Xn(){this.counter=null;var t=arguments[0];this.counter=t}function Hn(){this.index=new Vn;var t=arguments[0];this.init(t)}function Wn(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n}function jn(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function Kn(){}function Zn(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new C,this.env2=new C;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}function Qn(){this.depth=Array(2).fill().map(function(){return Array(3)});for(var t=0;2>t;t++)for(var e=0;3>e;e++)this.depth[t][e]=Qn.NULL_VALUE}function Jn(){if(mn.apply(this),this.pts=null,this.env=null,this.eiList=new jn(this),this.name=null,this.mce=null,this._isIsolated=!0,this.depth=new Qn,this.depthDelta=0,1===arguments.length){var t=arguments[0];Jn.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pts=e,this.label=n}}function $n(){if(Cn.apply(this),this.parentGeom=null,this.lineEdgeMap=new te,this.boundaryNodeRule=null,this.useBoundaryDeterminationRule=!0,this.argIndex=null,this.boundaryNodes=null,this._hasTooFewPoints=!1,this.invalidPoint=null,this.areaPtLocator=null,this.ptLocator=new Te,2===arguments.length){var t=arguments[0],e=arguments[1];$n.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.argIndex=n,this.parentGeom=i,this.boundaryNodeRule=r,null!==i&&this.add(i)}}function ti(){if(this.li=new ae,this.resultPrecisionModel=null,this.arg=null,1===arguments.length){var t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this.arg=new Array(1).fill(null),this.arg[0]=new $n(0,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];ti.call(this,e,n,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];i.getPrecisionModel().compareTo(r.getPrecisionModel())>=0?this.setComputationPrecision(i.getPrecisionModel()):this.setComputationPrecision(r.getPrecisionModel()),this.arg=new Array(2).fill(null),this.arg[0]=new $n(0,i,s),this.arg[1]=new $n(1,r,s)}}function ei(){this.pts=null,this._orientation=null;var t=arguments[0];this.pts=t,this._orientation=ei.orientation(t)}function ni(){this.edges=new I,this.ocaMap=new rt}function ii(){this.ptLocator=new Te,this.geomFact=null,this.resultGeom=null,this.graph=null,this.edgeList=new ni,this.resultPolyList=new I,this.resultLineList=new I,this.resultPointList=new I;var t=arguments[0],e=arguments[1];ti.call(this,t,e),this.graph=new Cn(new On),this.geomFact=t.getFactory()}function ri(){this.geom=new Array(2).fill(null),this.snapTolerance=null,this.cbr=null;var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e,this.computeSnapTolerance()}function si(){this.geom=new Array(2).fill(null);var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e}function oi(){this.factory=null,this.interiorPoint=null,this.maxWidth=0;var t=arguments[0];this.factory=t.getFactory(),this.add(t)}function ai(){this.poly=null,this.centreY=null,this.hiY=r.MAX_VALUE,this.loY=-r.MAX_VALUE;var t=arguments[0];this.poly=t,this.hiY=t.getEnvelopeInternal().getMaxY(),this.loY=t.getEnvelopeInternal().getMinY(),this.centreY=oi.avg(this.loY,this.hiY)}function ui(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.addInterior(t),null===this.interiorPoint&&this.addEndpoints(t)}function li(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.add(t)}function hi(){}function ci(){this.p0=null,this.p1=null,this.p2=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}function fi(){this.input=null,this.extremalPts=null,this.centre=null,this.radius=0;var t=arguments[0];this.input=t}function gi(){if(this.inputGeom=null,this.isConvex=null,this.convexHullPts=null,this.minBaseSeg=new ce,this.minWidthPt=null,this.minPtIndex=null,this.minWidth=0,1===arguments.length){var t=arguments[0];gi.call(this,t,!1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isConvex=n}}function di(){this.inputGeom=null,this.distanceTolerance=null;var t=arguments[0];this.inputGeom=t}function pi(){xe.apply(this),this.distanceTolerance=null;var t=arguments[0];this.distanceTolerance=t}function vi(){this._orig=null,this._sym=null,this._next=null;var t=arguments[0];this._orig=t}function mi(){this._isMarked=!1;var t=arguments[0];vi.call(this,t)}function yi(){this.vertexMap=new te}function xi(){this._isStart=!1;var t=arguments[0];mi.call(this,t)}function Ei(){yi.apply(this)}function Ii(){this.result=null,this.factory=null,this.graph=null,this.lines=new I,this.nodeEdgeStack=new pe,this.ringStartEdge=null,this.graph=new Ei}function Ni(){this.items=new I,this.subnode=new Array(4).fill(null)}function Ci(){}function Si(t,e){var n,i,r,s,o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},a={32:8,64:11}[t];if(s||(n=0>e||0>1/e,isFinite(e)||(s=o[t],n&&(s.d+=1<<t/4-1),i=Math.pow(2,a)-1,r=0)),!s){for(i={32:127,64:1023}[t],r=Math.abs(e);r>=2;)i++,r/=2;for(;1>r&&i>0;)i--,r*=2;0>=i&&(r/=2),32===t&&i>254&&(s={d:n?255:127,c:128,b:0,a:0},i=Math.pow(2,a)-1,r=0)}return i}function wi(){this.pt=new g,this.level=0,this.env=null;var t=arguments[0];this.computeKey(t)}function Li(){Ni.apply(this),this.env=null,this.centrex=null,this.centrey=null,this.level=null;var t=arguments[0],e=arguments[1];this.env=t,this.level=e,this.centrex=(t.getMinX()+t.getMaxX())/2,this.centrey=(t.getMinY()+t.getMaxY())/2}function Ri(){}function Ti(){Ni.apply(this)}function Pi(){this.root=null,this.minExtent=1,this.root=new Ti}function bi(t){this.geometryFactory=t||new ie}function Oi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new bi(this.geometryFactory)}function _i(){this.parser=new bi(this.geometryFactory)}function Mi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new re(this.geometryFactory)}function Di(t){return[t.x,t.y]}function Ai(t){this.geometryFactory=t||new ie}function Fi(){if(this.noder=null,this.scaleFactor=null,this.offsetX=null,this.offsetY=null,this.isScaled=!1,2===arguments.length){var t=arguments[0],e=arguments[1];Fi.call(this,t,e,0,0)}else if(4===arguments.length){var n=arguments[0],i=arguments[1];arguments[2],arguments[3];this.noder=n,this.scaleFactor=i,this.isScaled=!this.isIntegerPrecision()}}function Gi(){if(this.inputGeom=null,this.isClosedEndpointsInInterior=!0,this.nonSimpleLocation=null,1===arguments.length){var t=arguments[0];this.inputGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isClosedEndpointsInInterior=!n.isInBoundary(2)}}function qi(){this.pt=null,this.isClosed=null,this.degree=null;var t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}function Bi(){if(this.quadrantSegments=Bi.DEFAULT_QUADRANT_SEGMENTS,this.endCapStyle=Bi.CAP_ROUND,this.joinStyle=Bi.JOIN_ROUND,this.mitreLimit=Bi.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this.simplifyFactor=Bi.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.setQuadrantSegments(e),this.setEndCapStyle(n)}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];this.setQuadrantSegments(i),this.setEndCapStyle(r),this.setJoinStyle(s),this.setMitreLimit(o)}}function zi(){this.minIndex=-1,this.minCoord=null,this.minDe=null,this.orientedDe=null}function Vi(){this.array_=[]}function ki(){this.finder=null,this.dirEdgeList=new I,this.nodes=new I,this.rightMostCoord=null,this.env=null,this.finder=new zi}function Yi(){this.inputLine=null,
this.distanceTol=null,this.isDeleted=null,this.angleOrientation=he.COUNTERCLOCKWISE;var t=arguments[0];this.inputLine=t}function Ui(){this.ptList=null,this.precisionModel=null,this.minimimVertexDistance=0,this.ptList=new I}function Xi(){this.maxCurveSegmentError=0,this.filletAngleQuantum=null,this.closingSegLengthFactor=1,this.segList=null,this.distance=0,this.precisionModel=null,this.bufParams=null,this.li=null,this.s0=null,this.s1=null,this.s2=null,this.seg0=new ce,this.seg1=new ce,this.offset0=new ce,this.offset1=new ce,this.side=0,this._hasNarrowConcaveAngle=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.precisionModel=t,this.bufParams=e,this.li=new ae,this.filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===Bi.JOIN_ROUND&&(this.closingSegLengthFactor=Xi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}function Hi(){this.distance=0,this.precisionModel=null,this.bufParams=null;var t=arguments[0],e=arguments[1];this.precisionModel=t,this.bufParams=e}function Wi(){this.subgraphs=null,this.seg=new ce,this.cga=new he;var t=arguments[0];this.subgraphs=t}function ji(){this.upwardSeg=null,this.leftDepth=null;var t=arguments[0],e=arguments[1];this.upwardSeg=new ce(t),this.leftDepth=e}function Ki(){this.inputGeom=null,this.distance=null,this.curveBuilder=null,this.curveList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.inputGeom=t,this.distance=e,this.curveBuilder=n}function Zi(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.hasInterior=!1,this.properIntersectionPoint=null,this.li=null,this.isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this.li=t}function Qi(){this.bufParams=null,this.workingPrecisionModel=null,this.workingNoder=null,this.geomFact=null,this.graph=null,this.edgeList=new ni;var t=arguments[0];this.bufParams=t}function Ji(){this.li=new ae,this.segStrings=null;var t=arguments[0];this.segStrings=t}function $i(){this.li=null,this.pt=null,this.originalPt=null,this.ptScaled=null,this.p0Scaled=null,this.p1Scaled=null,this.scaleFactor=null,this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,this.corner=new Array(4).fill(null),this.safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this.originalPt=t,this.pt=t,this.scaleFactor=e,this.li=n,0>=e)throw new i("Scale factor must be non-zero");1!==e&&(this.pt=new g(this.scale(t.x),this.scale(t.y)),this.p0Scaled=new g,this.p1Scaled=new g),this.initCorners(this.pt)}function tr(){this.tempEnv1=new C,this.selectedSegment=new ce}function er(){this.index=null;var t=arguments[0];this.index=t}function nr(){tr.apply(this),this.hotPixel=null,this.parentEdge=null,this.hotPixelVertexIndex=null,this._isNodeAdded=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.hotPixel=t,this.parentEdge=e,this.hotPixelVertexIndex=n}function ir(){this.li=null,this.interiorIntersections=null;var t=arguments[0];this.li=t,this.interiorIntersections=new I}function rr(){this.pm=null,this.li=null,this.scaleFactor=null,this.noder=null,this.pointSnapper=null,this.nodedSegStrings=null;var t=arguments[0];this.pm=t,this.li=new ae,this.li.setPrecisionModel(t),this.scaleFactor=t.getScale()}function sr(){if(this.argGeom=null,this.distance=null,this.bufParams=new Bi,this.resultGeometry=null,this.saveException=null,1===arguments.length){var t=arguments[0];this.argGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.argGeom=e,this.bufParams=n}}function or(){this.comps=null;var t=arguments[0];this.comps=t}function ar(){if(this.component=null,this.segIndex=null,this.pt=null,2===arguments.length){var t=arguments[0],e=arguments[1];ar.call(this,t,ar.INSIDE_AREA,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.component=n,this.segIndex=i,this.pt=r}}function ur(){this.pts=null;var t=arguments[0];this.pts=t}function lr(){this.locations=null;var t=arguments[0];this.locations=t}function hr(){if(this.geom=null,this.terminateDistance=0,this.ptLocator=new Te,this.minDistanceLocation=null,this.minDistance=r.MAX_VALUE,2===arguments.length){var t=arguments[0],e=arguments[1];hr.call(this,t,e,0)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],s=arguments[2];this.geom=new Array(2).fill(null),this.geom[0]=n,this.geom[1]=i,this.terminateDistance=s}}function cr(){this.factory=null,this.directedEdges=new I,this.coordinates=null;var t=arguments[0];this.factory=t}function fr(){this._isMarked=!1,this._isVisited=!1,this.data=null}function gr(){fr.apply(this),this.parentEdge=null,this.from=null,this.to=null,this.p0=null,this.p1=null,this.sym=null,this.edgeDirection=null,this.quadrant=null,this.angle=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.from=t,this.to=e,this.edgeDirection=i,this.p0=t.getCoordinate(),this.p1=n;var r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y;this.quadrant=Je.quadrant(r,s),this.angle=Math.atan2(s,r)}function dr(){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];gr.call(this,t,e,n,i)}function pr(){if(fr.apply(this),this.dirEdge=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}function vr(){this.outEdges=new I,this.sorted=!1}function mr(){if(fr.apply(this),this.pt=null,this.deStar=null,1===arguments.length){var t=arguments[0];mr.call(this,t,new vr)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pt=e,this.deStar=n}}function yr(){pr.apply(this),this.line=null;var t=arguments[0];this.line=t}function xr(){this.nodeMap=new rt}function Er(){this.edges=new J,this.dirEdges=new J,this.nodeMap=new xr}function Ir(){Er.apply(this)}function Nr(){this.graph=new Ir,this.mergedLineStrings=null,this.factory=null,this.edgeStrings=null}function Cr(){this.edgeRing=null,this.next=null,this.label=-1;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];gr.call(this,t,e,n,i)}function Sr(){pr.apply(this),this.line=null;var t=arguments[0];this.line=t}function wr(){this.factory=null,this.deList=new I,this.lowestEdge=null,this.ring=null,this.ringPts=null,this.holes=null,this.shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;var t=arguments[0];this.factory=t}function Lr(){}function Rr(){Er.apply(this),this.factory=null;var t=arguments[0];this.factory=t}function Tr(){if(this.lineStringAdder=new Pr(this),this.graph=null,this.dangles=new I,this.cutEdges=new I,this.invalidRingLines=new I,this.holeList=null,this.shellList=null,this.polyList=null,this.isCheckingRingsValid=!0,this.extractOnlyPolygonal=null,this.geomFactory=null,0===arguments.length)Tr.call(this,!1);else if(1===arguments.length){var t=arguments[0];this.extractOnlyPolygonal=t}}function Pr(){this.p=null;var t=arguments[0];this.p=t}function br(){}function Or(){if(this.edgeEnds=new I,1===arguments.length){var t=arguments[0];Or.call(this,null,t)}else if(2===arguments.length){var e=(arguments[0],arguments[1]);En.call(this,e.getEdge(),e.getCoordinate(),e.getDirectedCoordinate(),new gn(e.getLabel())),this.insert(e)}}function _r(){Pn.apply(this)}function Mr(){var t=arguments[0],e=arguments[1];yn.call(this,t,e)}function Dr(){Nn.apply(this)}function Ar(){this.li=new ae,this.ptLocator=new Te,this.arg=null,this.nodes=new xn(new Dr),this.im=null,this.isolatedEdges=new I,this.invalidPoint=null;var t=arguments[0];this.arg=t}function Fr(){this.rectEnv=null;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal()}function Gr(){this.li=new ae,this.rectEnv=null,this.diagUp0=null,this.diagUp1=null,this.diagDown0=null,this.diagDown1=null;var t=arguments[0];this.rectEnv=t,this.diagUp0=new g(t.getMinX(),t.getMinY()),this.diagUp1=new g(t.getMaxX(),t.getMaxY()),this.diagDown0=new g(t.getMinX(),t.getMaxY()),this.diagDown1=new g(t.getMaxX(),t.getMinY())}function qr(){this._isDone=!1}function Br(){this.rectangle=null,this.rectEnv=null;var t=arguments[0];this.rectangle=t,this.rectEnv=t.getEnvelopeInternal()}function zr(){qr.apply(this),this.rectEnv=null,this._intersects=!1;var t=arguments[0];this.rectEnv=t}function Vr(){qr.apply(this),this.rectSeq=null,this.rectEnv=null,this._containsPoint=!1;var t=arguments[0];this.rectSeq=t.getExteriorRing().getCoordinateSequence(),this.rectEnv=t.getEnvelopeInternal()}function kr(){qr.apply(this),this.rectEnv=null,this.rectIntersector=null,this.hasIntersection=!1,this.p0=new g,this.p1=new g;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal(),this.rectIntersector=new Gr(this.rectEnv)}function Yr(){if(this._relate=null,2===arguments.length){var t=arguments[0],e=arguments[1];ti.call(this,t,e),this._relate=new Ar(this.arg)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];ti.call(this,n,i,r),this._relate=new Ar(this.arg)}}function Ur(){this.geomFactory=null,this.skipEmpty=!1,this.inputGeoms=null;var t=arguments[0];this.geomFactory=Ur.extractFactory(t),this.inputGeoms=t}function Xr(){this.pointGeom=null,this.otherGeom=null,this.geomFact=null;var t=arguments[0],e=arguments[1];this.pointGeom=t,this.otherGeom=e,this.geomFact=e.getFactory()}function Hr(){this.sortIndex=-1,this.comps=null;var t=arguments[0],e=arguments[1];this.sortIndex=t,this.comps=e}function Wr(){this.inputPolys=null,this.geomFactory=null;var t=arguments[0];this.inputPolys=t,null===this.inputPolys&&(this.inputPolys=new I)}function jr(){if(this.polygons=new I,this.lines=new I,this.points=new I,this.geomFact=null,1===arguments.length){if(R(arguments[0],v)){var t=arguments[0];this.extract(t)}else if(arguments[0]instanceof B){var e=arguments[0];this.extract(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.geomFact=i,this.extract(n)}}function Kr(){this.geometryFactory=new ie,this.geomGraph=null,this.disconnectedRingcoord=null;var t=arguments[0];this.geomGraph=t}function Zr(){this.items=new I,this.subnode=[null,null]}function Qr(){if(this.min=null,this.max=null,0===arguments.length)this.min=0,this.max=0;else if(1===arguments.length){var t=arguments[0];this.init(t.min,t.max)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.init(e,n)}}function Jr(){this.pt=0,this.level=0,this.interval=null;var t=arguments[0];this.computeKey(t)}function $r(){Zr.apply(this),this.interval=null,this.centre=null,this.level=null;var t=arguments[0],e=arguments[1];this.interval=t,this.level=e,this.centre=(t.getMin()+t.getMax())/2}function ts(){Zr.apply(this)}function es(){this.root=null,this.minExtent=1,this.root=new ts}function ns(){}function is(){this.ring=null,this.tree=null,this.crossings=0,this.interval=new Qr;var t=arguments[0];this.ring=t,this.buildIndex()}function rs(){tr.apply(this),this.mcp=null,this.p=null;var t=arguments[0],e=arguments[1];this.mcp=t,this.p=e}function ss(){this.nodes=new xn(new Dr)}function os(){this.li=new ae,this.geomGraph=null,this.nodeGraph=new ss,this.invalidPoint=null;var t=arguments[0];this.geomGraph=t}function as(){this.graph=null,this.rings=new I,this.totalEnv=new C,this.index=null,this.nestedPt=null;var t=arguments[0];this.graph=t}function us(){if(this.errorType=null,this.pt=null,1===arguments.length){var t=arguments[0];us.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.errorType=e,null!==n&&(this.pt=n.copy())}}function ls(){this.parentGeometry=null,this.isSelfTouchingRingFormingHoleValid=!1,this.validErr=null;var t=arguments[0];this.parentGeometry=t}function hs(){_t.CoordinateOperation.apply(this),this.targetPM=null,this.removeCollapsed=!0;var t=arguments[0],e=arguments[1];this.targetPM=t,this.removeCollapsed=e}function cs(){this.targetPM=null,this.removeCollapsed=!0,this.changePrecisionModel=!1,this.isPointwise=!1;var t=arguments[0];this.targetPM=t}function fs(){this.pts=null,this.usePt=null,this.distanceTolerance=null,this.seg=new ce;var t=arguments[0];this.pts=t}function gs(){this.inputGeom=null,this.distanceTolerance=null,this.isEnsureValidTopology=!0;var t=arguments[0];this.inputGeom=t}function ds(){xe.apply(this),this.isEnsureValidTopology=!0,this.distanceTolerance=null;var t=arguments[0],e=arguments[1];this.isEnsureValidTopology=t,this.distanceTolerance=e}function ps(){if(this.parent=null,this.index=null,2===arguments.length){var t=arguments[0],e=arguments[1];ps.call(this,t,e,null,-1)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=arguments[3];ce.call(this,n,i),this.parent=r,this.index=s}}function vs(){if(this.parentLine=null,this.segs=null,this.resultSegs=new I,this.minimumSize=null,1===arguments.length){var t=arguments[0];vs.call(this,t,2)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.parentLine=e,this.minimumSize=n,this.init()}}function ms(){this.index=new Pi}function ys(){this.querySeg=null,this.items=new I;var t=arguments[0];this.querySeg=t}function xs(){this.li=new ae,this.inputIndex=new ms,this.outputIndex=new ms,this.line=null,this.linePts=null,this.distanceTolerance=0;var t=arguments[0],e=arguments[1];this.inputIndex=t,this.outputIndex=e}function Es(){this.inputIndex=new ms,this.outputIndex=new ms,this.distanceTolerance=0}function Is(){this.inputGeom=null,this.lineSimplifier=new Es,this.linestringMap=null;var t=arguments[0];this.inputGeom=t}function Ns(){xe.apply(this),this.linestringMap=null;var t=arguments[0];this.linestringMap=t}function Cs(){this.tps=null;var t=arguments[0];this.tps=t}function Ss(){this.seg=null,this.segLen=null,this.splitPt=null,this.minimumLen=0;var t=arguments[0];this.seg=t,this.segLen=t.getLength()}function ws(){}function Ls(){}function Rs(){}function Ts(){if(this.p=null,1===arguments.length){var t=arguments[0];this.p=new g(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p=new g(e,n)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.p=new g(i,r,s)}}function Ps(){this._isOnConstraint=null,this.constraint=null;var t=arguments[0];Ts.call(this,t)}function bs(){this._rot=null,this.vertex=null,this.next=null,this.data=null}function Os(){this.subdiv=null,this.isUsingTolerance=!1;var t=arguments[0];this.subdiv=t,this.isUsingTolerance=t.getTolerance()>0}function _s(){}function Ms(){this.subdiv=null,this.lastEdge=null;var t=arguments[0];this.subdiv=t,this.init()}function Ds(){if(this.seg=null,1===arguments.length){if("string"==typeof arguments[0]){var t=arguments[0];l.call(this,t)}else if(arguments[0]instanceof ce){var e=arguments[0];l.call(this,"Locate failed to converge (at edge: "+e+").  Possible causes include invalid Subdivision topology or very close sites"),this.seg=new ce(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];l.call(this,Ds.msgWithSpatial(n,i)),this.seg=new ce(i)}}function As(){}function Fs(){this.visitedKey=0,this.quadEdges=new I,this.startingEdge=null,this.tolerance=null,this.edgeCoincidenceTolerance=null,this.frameVertex=new Array(3).fill(null),this.frameEnv=null,this.locator=null,this.seg=new ce,this.triEdges=new Array(3).fill(null);var t=arguments[0],e=arguments[1];this.tolerance=e,this.edgeCoincidenceTolerance=e/Fs.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this.startingEdge=this.initSubdiv(),this.locator=new Ms(this)}function Gs(){}function qs(){this.triList=new I}function Bs(){this.triList=new I}function zs(){this.coordList=new N,this.triCoords=new I}function Vs(){if(this.ls=null,this.data=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.ls=new ce(t,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.ls=new ce(n,i),this.data=r}else if(6===arguments.length){var s=arguments[0],o=arguments[1],a=arguments[2],u=arguments[3],l=arguments[4],h=arguments[5];Vs.call(this,new g(s,o,a),new g(u,l,h))}else if(7===arguments.length){var c=arguments[0],f=arguments[1],d=arguments[2],p=arguments[3],v=arguments[4],m=arguments[5],y=arguments[6];Vs.call(this,new g(c,f,d),new g(p,v,m),y)}}function ks(){}function Ys(){if(this.p=null,this.data=null,this.left=null,this.right=null,this.count=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.p=new g(t),this.left=null,this.right=null,this.count=1,this.data=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.p=new g(n,i),this.left=null,this.right=null,this.count=1,this.data=r}}function Us(){if(this.root=null,this.numberOfNodes=null,this.tolerance=null,0===arguments.length)Us.call(this,0);else if(1===arguments.length){var t=arguments[0];this.tolerance=t}}function Xs(){this.tolerance=null,this.matchNode=null,this.matchDist=0,this.p=null;var t=arguments[0],e=arguments[1];this.p=t,this.tolerance=e}function Hs(){this.initialVertices=null,this.segVertices=null,this.segments=new I,this.subdiv=null,this.incDel=null,this.convexHull=null,this.splitFinder=new Ls,this.kdt=null,this.vertexFactory=null,this.computeAreaEnv=null,this.splitPt=null,this.tolerance=null;var t=arguments[0],e=arguments[1];this.initialVertices=new I(t),this.tolerance=e,this.kdt=new Us(e)}function Ws(){this.siteCoords=null,this.tolerance=0,this.subdiv=null}function js(){this.siteCoords=null,this.constraintLines=null,this.tolerance=0,this.subdiv=null,this.constraintVertexMap=new rt}function Ks(){this.siteCoords=null,this.tolerance=0,this.subdiv=null,this.clipEnv=null,this.diagramEnv=null}function Zs(){}Array.prototype.fill||(Array.prototype.fill=function(t){for(var e=Object(this),n=parseInt(e.length,10),i=arguments[1],r=parseInt(i,10)||0,s=0>r?Math.max(n+r,0):Math.min(r,n),o=arguments[2],a=void 0===o?n:parseInt(o,10)||0,u=0>a?Math.max(n+a,0):Math.min(a,n);u>s;s++)e[s]=t;return e}),Number.isFinite=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)},Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(t){return t!==t},Math.trunc=Math.trunc||function(t){return 0>t?Math.ceil(t):Math.floor(t)},e(n.prototype,{interfaces_:function(){return[]},getClass:function(){return n}}),n.equalsWithTolerance=function(t,e,n){return Math.abs(t-e)<=n},r.isNaN=function(t){return Number.isNaN(t)},r.doubleToLongBits=function(t){return t},r.longBitsToDouble=function(t){return t},r.isInfinite=function(t){return!Number.isFinite(t)},r.MAX_VALUE=Number.MAX_VALUE,h(c,l),e(c.prototype,{interfaces_:function(){return[]},getClass:function(){return c}}),e(f.prototype,{interfaces_:function(){return[]},getClass:function(){return f}}),f.shouldNeverReachHere=function(){if(0===arguments.length)f.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new c("Should never reach here"+(null!==t?": "+t:""))}},f.isTrue=function(){if(1===arguments.length){var t=arguments[0];f.isTrue(t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!e)throw null===n?new c:new c(n)}},f.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];f.equals(t,e,null)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(!i.equals(n))throw new c("Expected "+n+" but encountered "+i+(null!==r?": "+r:""))}},e(g.prototype,{setOrdinate:function(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new i("Invalid ordinate index: "+t)}},equals2D:function(){if(1===arguments.length){var t=arguments[0];return this.x!==t.x?!1:this.y===t.y}if(2===arguments.length){var e=arguments[0],i=arguments[1];return n.equalsWithTolerance(this.x,e.x,i)?!!n.equalsWithTolerance(this.y,e.y,i):!1}},getOrdinate:function(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new i("Invalid ordinate index: "+t)},equals3D:function(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||r.isNaN(this.z)&&r.isNaN(t.z))},equals:function(t){return t instanceof g?this.equals2D(t):!1},equalInZ:function(t,e){return n.equalsWithTolerance(this.z,t.z,e)},compareTo:function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0},clone:function(){try{var t=null;return t}catch(t){if(t instanceof CloneNotSupportedException)return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}finally{}},copy:function(){return new g(this)},toString:function(){return"("+this.x+", "+this.y+", "+this.z+")"},distance3D:function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)},distance:function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y)},setCoordinate:function(t){this.x=t.x,this.y=t.y,this.z=t.z},interfaces_:function(){return[s,o,u]},getClass:function(){return g}}),g.hashCode=function(){if(1===arguments.length){var t=arguments[0],e=r.doubleToLongBits(t);return Math.trunc(e^e>>>32)}},e(d.prototype,{compare:function(t,e){var n=t,i=e,r=d.compare(n.x,i.x);if(0!==r)return r;var s=d.compare(n.y,i.y);if(0!==s)return s;if(this.dimensionsToTest<=2)return 0;var o=d.compare(n.z,i.z);return o},interfaces_:function(){return[a]},getClass:function(){return d}}),d.compare=function(t,e){return e>t?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0},g.DimensionalComparator=d,g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=r.NaN,g.X=0,g.Y=1,g.Z=2,p.prototype.hasNext=function(){},p.prototype.next=function(){},p.prototype.remove=function(){},v.prototype.add=function(){},v.prototype.addAll=function(){},v.prototype.isEmpty=function(){},v.prototype.iterator=function(){},v.prototype.size=function(){},v.prototype.toArray=function(){},v.prototype.remove=function(){},m.prototype=new Error,m.prototype.name="IndexOutOfBoundsException",y.prototype=Object.create(v.prototype),y.prototype.constructor=y,y.prototype.get=function(){},y.prototype.set=function(){},y.prototype.isEmpty=function(){},x.prototype=new Error,x.prototype.name="NoSuchElementException",E.prototype=new Error,E.prototype.name="OperationNotSupported",I.prototype=Object.create(y.prototype),I.prototype.constructor=I,I.prototype.ensureCapacity=function(){},I.prototype.interfaces_=function(){return[y,v]},I.prototype.add=function(t){return this.array_.push(t),!0},I.prototype.clear=function(){this.array_=[]},I.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},I.prototype.set=function(t,e){var n=this.array_[t];return this.array_[t]=e,n},I.prototype.iterator=function(){return new Qs(this)},I.prototype.get=function(t){if(0>t||t>=this.size())throw new m;return this.array_[t]},I.prototype.isEmpty=function(){return 0===this.array_.length},I.prototype.size=function(){return this.array_.length},I.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},I.prototype.remove=function(t){for(var e=!1,n=0,i=this.array_.length;i>n;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e};var Qs=function(t){this.arrayList_=t,this.position_=0};Qs.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new x;return this.arrayList_.get(this.position_++)},Qs.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},Qs.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},Qs.prototype.remove=function(){throw new E},h(N,I),e(N.prototype,{getCoordinate:function(t){return this.get(t)},addAll:function(){if(2===arguments.length){for(var t=arguments[0],e=arguments[1],n=!1,i=t.iterator();i.hasNext();)this.add(i.next(),e),n=!0;return n}return I.prototype.addAll.apply(this,arguments)},clone:function t(){for(var t=I.prototype.clone.call(this),e=0;e<this.size();e++)t.add(e,this.get(e).copy());return t},toCoordinateArray:function(){return this.toArray(N.coordArrayType)},add:function(){if(1===arguments.length){var t=arguments[0];I.prototype.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var e=arguments[0],n=arguments[1];return this.add(e,n,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){var i=arguments[0],r=arguments[1];if(!r&&this.size()>=1){var s=this.get(this.size()-1);if(s.equals2D(i))return null}I.prototype.add.call(this,i)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],a=arguments[1];return this.add(o,a),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2];if(h)for(var c=0;c<u.length;c++)this.add(u[c],l);else for(var c=u.length-1;c>=0;c--)this.add(u[c],l);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){var f=arguments[0],d=arguments[1],p=arguments[2];if(!p){var v=this.size();if(v>0){if(f>0){var m=this.get(f-1);if(m.equals2D(d))return null}if(v>f){var y=this.get(f);if(y.equals2D(d))return null}}}I.prototype.add.call(this,f,d)}}else if(4===arguments.length){var x=arguments[0],E=arguments[1],N=arguments[2],C=arguments[3],S=1;N>C&&(S=-1);for(var c=N;c!==C;c+=S)this.add(x[c],E);return!0}},closeRing:function(){this.size()>0&&this.add(new g(this.get(0)),!1)},interfaces_:function(){return[]},getClass:function(){return N}}),N.coordArrayType=new Array(0).fill(null),e(C.prototype,{getArea:function(){return this.getWidth()*this.getHeight()},equals:function(t){if(!(t instanceof C))return!1;var e=t;return this.isNull()?e.isNull():this.maxx===e.getMaxX()&&this.maxy===e.getMaxY()&&this.minx===e.getMinX()&&this.miny===e.getMinY()},intersection:function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new C;var e=this.minx>t.minx?this.minx:t.minx,n=this.miny>t.miny?this.miny:t.miny,i=this.maxx<t.maxx?this.maxx:t.maxx,r=this.maxy<t.maxy?this.maxy:t.maxy;return new C(e,i,n,r)},isNull:function(){return this.maxx<this.minx},getMaxX:function(){return this.maxx},covers:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof C){var e=arguments[0];return this.isNull()||e.isNull()?!1:e.getMinX()>=this.minx&&e.getMaxX()<=this.maxx&&e.getMinY()>=this.miny&&e.getMaxY()<=this.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:n>=this.minx&&n<=this.maxx&&i>=this.miny&&i<=this.maxy}},intersects:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.isNull()||t.isNull()?!1:!(t.minx>this.maxx||t.maxx<this.minx||t.miny>this.maxy||t.maxy<this.miny)}if(arguments[0]instanceof g){var e=arguments[0];return this.intersects(e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:!(n>this.maxx||n<this.minx||i>this.maxy||i<this.miny)}},getMinY:function(){return this.miny},getMinX:function(){return this.minx},expandToInclude:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];if(e.isNull())return null;this.isNull()?(this.minx=e.getMinX(),this.maxx=e.getMaxX(),this.miny=e.getMinY(),this.maxy=e.getMaxY()):(e.minx<this.minx&&(this.minx=e.minx),e.maxx>this.maxx&&(this.maxx=e.maxx),e.miny<this.miny&&(this.miny=e.miny),e.maxy>this.maxy&&(this.maxy=e.maxy))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.isNull()?(this.minx=n,this.maxx=n,this.miny=i,this.maxy=i):(n<this.minx&&(this.minx=n),n>this.maxx&&(this.maxx=n),i<this.miny&&(this.miny=i),i>this.maxy&&(this.maxy=i))}},minExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return e>t?t:e},getWidth:function(){return this.isNull()?0:this.maxx-this.minx},compareTo:function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this.minx<e.minx?-1:this.minx>e.minx?1:this.miny<e.miny?-1:this.miny>e.miny?1:this.maxx<e.maxx?-1:this.maxx>e.maxx?1:this.maxy<e.maxy?-1:this.maxy>e.maxy?1:0},translate:function(t,e){return this.isNull()?null:void this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)},toString:function(){return"Env["+this.minx+" : "+this.maxx+", "+this.miny+" : "+this.maxy+"]"},setToNull:function(){this.minx=0,this.maxx=-1,this.miny=0,this.maxy=-1},getHeight:function(){return this.isNull()?0:this.maxy-this.miny},maxExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e},expandBy:function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this.minx-=e,this.maxx+=e,this.miny-=n,this.maxy+=n,(this.minx>this.maxx||this.miny>this.maxy)&&this.setToNull()}},contains:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.covers(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.covers(n,i)}},centre:function(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},init:function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.minx=e.minx,this.maxx=e.maxx,this.miny=e.miny,this.maxy=e.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];s>r?(this.minx=r,this.maxx=s):(this.minx=s,this.maxx=r),a>o?(this.miny=o,this.maxy=a):(this.miny=a,this.maxy=o)}},getMaxY:function(){return this.maxy},distance:function(t){if(this.intersects(t))return 0;var e=0;this.maxx<t.minx?e=t.minx-this.maxx:this.minx>t.maxx&&(e=this.minx-t.maxx);var n=0;return this.maxy<t.miny?n=t.miny-this.maxy:this.miny>t.maxy&&(n=this.miny-t.maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.minx),t=37*t+g.hashCode(this.maxx),t=37*t+g.hashCode(this.miny),t=37*t+g.hashCode(this.maxy)},interfaces_:function(){return[s,u]},getClass:function(){return C}}),C.intersects=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=Math.min(s.x,o.x),u=Math.max(s.x,o.x),l=Math.min(i.x,r.x),h=Math.max(i.x,r.x);return l>u?!1:a>h?!1:(a=Math.min(s.y,o.y),u=Math.max(s.y,o.y),l=Math.min(i.y,r.y),h=Math.max(i.y,r.y),l>u?!1:!(a>h))}},C.serialVersionUID=0x51845cd552189800,h(w,S),e(w.prototype,{interfaces_:function(){return[]},getClass:function(){return w}}),e(L.prototype,{interfaces_:function(){return[]},getClass:function(){return L}}),L.toLocationSymbol=function(t){switch(t){case L.EXTERIOR:return"e";case L.BOUNDARY:return"b";case L.INTERIOR:return"i";case L.NONE:return"-"}throw new i("Unknown location value: "+t)},L.INTERIOR=0,L.BOUNDARY=1,L.EXTERIOR=2,L.NONE=-1,e(T.prototype,{interfaces_:function(){return[]},getClass:function(){return T}}),T.log10=function(t){var e=Math.log(t);return r.isInfinite(e)?e:r.isNaN(e)?e:e/T.LOG_10},T.min=function(t,e,n,i){var r=t;return r>e&&(r=e),r>n&&(r=n),r>i&&(r=i),r},T.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];return e>t?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var i=arguments[0],r=arguments[1],s=arguments[2];return r>i?r:i>s?s:i}},T.wrap=function(t,e){return 0>t?e- -t%e:t%e},T.max=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=t;return e>i&&(i=e),n>i&&(i=n),i}if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],i=r;return s>i&&(i=s),o>i&&(i=o),a>i&&(i=a),i}},T.average=function(t,e){
return(t+e)/2},T.LOG_10=Math.log(10),P.prototype.append=function(t){this.str+=t},P.prototype.setCharAt=function(t,e){return this.str.substr(0,t)+e+this.str.substr(t+1)},P.prototype.toString=function(t){return this.str},b.prototype.intValue=function(){return this.value},b.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},b.isNaN=function(t){return Number.isNaN(t)},O.isWhitespace=function(t){return 32>=t&&t>=0||127==t},O.toUpperCase=function(t){return t.toUpperCase()},e(_.prototype,{le:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<=t.lo},extractSignificantDigits:function(t,e){var n=this.abs(),i=_.magnitude(n.hi),r=_.TEN.pow(i);n=n.divide(r),n.gt(_.TEN)?(n=n.divide(_.TEN),i+=1):n.lt(_.ONE)&&(n=n.multiply(_.TEN),i-=1);for(var s=i+1,o=new P,a=_.MAX_PRINT_DIGITS-1,u=0;a>=u;u++){t&&u===s&&o.append(".");var l=Math.trunc(n.hi);if(0>l)break;var h=!1,c=0;l>9?(h=!0,c="9"):c="0"+l,o.append(c),n=n.subtract(_.valueOf(l)).multiply(_.TEN),h&&n.selfAdd(_.TEN);var f=!0,g=_.magnitude(n.hi);if(0>g&&Math.abs(g)>=a-u&&(f=!1),!f)break}return e[0]=i,o.toString()},sqr:function(){return this.multiply(this)},doubleValue:function(){return this.hi+this.lo},subtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var e=arguments[0];return this.add(-e)}},equals:function(){if(1===arguments.length){var t=arguments[0];return this.hi===t.hi&&this.lo===t.lo}},isZero:function(){return 0===this.hi&&0===this.lo},selfSubtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t.hi,-t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.isNaN()?this:this.selfAdd(-e,0)}},getSpecialNumberString:function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},min:function(t){return this.le(t)?this:t},selfDivide:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfDivide(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfDivide(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null,h=null,c=null;return u=this.hi/n,l=_.SPLIT*u,r=l-u,c=_.SPLIT*n,r=l-r,s=u-r,o=c-n,h=u*n,o=c-o,a=n-o,c=r*o-h+r*a+s*o+s*a,l=(this.hi-h-c+this.lo-u*i)/n,c=u+l,this.hi=c,this.lo=u-c+l,this}},dump:function(){return"DD<"+this.hi+", "+this.lo+">"},divide:function(){if(arguments[0]instanceof _){var t=arguments[0],e=null,n=null,i=null,s=null,o=null,a=null,u=null,l=null;o=this.hi/t.hi,a=_.SPLIT*o,e=a-o,l=_.SPLIT*t.hi,e=a-e,n=o-e,i=l-t.hi,u=o*t.hi,i=l-i,s=t.hi-i,l=e*i-u+e*s+n*i+n*s,a=(this.hi-u-l+this.lo-o*t.lo)/t.hi,l=o+a;var h=l,c=o-l+a;return new _(h,c)}if("number"==typeof arguments[0]){var f=arguments[0];return r.isNaN(f)?_.createNaN():_.copy(this).selfDivide(f,0)}},ge:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>=t.lo},pow:function(t){if(0===t)return _.valueOf(1);var e=new _(this),n=_.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2===1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return 0>t?n.reciprocal():n},ceil:function(){if(this.isNaN())return _.NaN;var t=Math.ceil(this.hi),e=0;return t===this.hi&&(e=Math.ceil(this.lo)),new _(t,e)},compareTo:function(t){var e=t;return this.hi<e.hi?-1:this.hi>e.hi?1:this.lo<e.lo?-1:this.lo>e.lo?1:0},rint:function(){if(this.isNaN())return this;var t=this.add(.5);return t.floor()},setValue:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var e=arguments[0];return this.init(e),this}},max:function(t){return this.ge(t)?this:t},sqrt:function(){if(this.isZero())return _.valueOf(0);if(this.isNegative())return _.NaN;var t=1/Math.sqrt(this.hi),e=this.hi*t,n=_.valueOf(e),i=this.subtract(n.sqr()),r=i.hi*(.5*t);return n.add(r)},selfAdd:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfAdd(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0],n=null,i=null,r=null,s=null,o=null,a=null;return r=this.hi+e,o=r-this.hi,s=r-o,s=e-o+(this.hi-s),a=s+this.lo,n=r+a,i=a+(r-n),this.hi=n+i,this.lo=i+(n-this.hi),this}}else if(2===arguments.length){var u=arguments[0],l=arguments[1],n=null,i=null,h=null,c=null,r=null,s=null,o=null,a=null;r=this.hi+u,h=this.lo+l,o=r-this.hi,a=h-this.lo,s=r-o,c=h-a,s=u-o+(this.hi-s),c=l-a+(this.lo-c),o=s+h,n=r+o,i=o+(r-n),o=c+i;var f=n+o,g=o+(n-f);return this.hi=f,this.lo=g,this}},selfMultiply:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfMultiply(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfMultiply(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null;u=_.SPLIT*this.hi,r=u-this.hi,l=_.SPLIT*n,r=u-r,s=this.hi-r,o=l-n,u=this.hi*n,o=l-o,a=n-o,l=r*o-u+r*a+s*o+s*a+(this.hi*i+this.lo*n);var h=u+l;r=u-h;var c=l+r;return this.hi=h,this.lo=c,this}},selfSqr:function(){return this.selfMultiply(this)},floor:function(){if(this.isNaN())return _.NaN;var t=Math.floor(this.hi),e=0;return t===this.hi&&(e=Math.floor(this.lo)),new _(t,e)},negate:function(){return this.isNaN()?this:new _(-this.hi,-this.lo)},clone:function(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}finally{}},multiply:function(){if(arguments[0]instanceof _){var t=arguments[0];return t.isNaN()?_.createNaN():_.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var e=arguments[0];return r.isNaN(e)?_.createNaN():_.copy(this).selfMultiply(e,0)}},isNaN:function(){return r.isNaN(this.hi)},intValue:function(){return Math.trunc(this.hi)},toString:function(){var t=_.magnitude(this.hi);return t>=-3&&20>=t?this.toStandardNotation():this.toSciNotation()},toStandardNotation:function(){var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1,r=n;if("."===n.charAt(0))r="0"+n;else if(0>i)r="0."+_.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){var s=i-n.length,o=_.stringOfChar("0",s);r=n+o+".0"}return this.isNegative()?"-"+r:r},reciprocal:function(){var t=null,e=null,n=null,i=null,r=null,s=null,o=null,a=null;r=1/this.hi,s=_.SPLIT*r,t=s-r,a=_.SPLIT*this.hi,t=s-t,e=r-t,n=a-this.hi,o=r*this.hi,n=a-n,i=this.hi-n,a=t*n-o+t*i+e*n+e*i,s=(1-o-a-r*this.lo)/this.hi;var u=r+s,l=r-u+s;return new _(u,l)},toSciNotation:function(){if(this.isZero())return _.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=_.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);var r="";n.length>1&&(r=n.substring(1));var s=n.charAt(0)+"."+r;return this.isNegative()?"-"+s+i:s+i},abs:function(){return this.isNaN()?_.NaN:this.isNegative()?this.negate():new _(this)},isPositive:function(){return this.hi>0||0===this.hi&&this.lo>0},lt:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<t.lo},add:function(){if(arguments[0]instanceof _){var t=arguments[0];return _.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var e=arguments[0];return _.copy(this).selfAdd(e)}},init:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.hi=t,this.lo=0}else if(arguments[0]instanceof _){var e=arguments[0];this.hi=e.hi,this.lo=e.lo}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.hi=n,this.lo=i}},gt:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>t.lo},isNegative:function(){return this.hi<0||0===this.hi&&this.lo<0},trunc:function(){return this.isNaN()?_.NaN:this.isPositive()?this.floor():this.ceil()},signum:function(){return this.hi>0?1:this.hi<0?-1:this.lo>0?1:this.lo<0?-1:0},interfaces_:function(){return[u,s,o]},getClass:function(){return _}}),_.sqr=function(t){return _.valueOf(t).selfMultiply(t)},_.valueOf=function(){if("string"==typeof arguments[0]){var t=arguments[0];return _.parse(t)}if("number"==typeof arguments[0]){var e=arguments[0];return new _(e)}},_.sqrt=function(t){return _.valueOf(t).sqrt()},_.parse=function(t){for(var e=0,n=t.length;O.isWhitespace(t.charAt(e));)e++;var i=!1;if(n>e){var r=t.charAt(e);"-"!==r&&"+"!==r||(e++,"-"===r&&(i=!0))}for(var s=new _,o=0,a=0,u=0;;){if(e>=n)break;var l=t.charAt(e);if(e++,O.isDigit(l)){var h=l-"0";s.selfMultiply(_.TEN),s.selfAdd(h),o++}else{if("."!==l){if("e"===l||"E"===l){var c=t.substring(e);try{u=b.parseInt(c)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+c+" in string "+t):e}finally{}break}throw new NumberFormatException("Unexpected character '"+l+"' at position "+e+" in string "+t)}a=o}}var f=s,g=o-a-u;if(0===g)f=s;else if(g>0){var d=_.TEN.pow(g);f=s.divide(d)}else if(0>g){var d=_.TEN.pow(-g);f=s.multiply(d)}return i?f.negate():f},_.createNaN=function(){return new _(r.NaN,r.NaN)},_.copy=function(t){return new _(t)},_.magnitude=function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),i=Math.trunc(Math.floor(n)),r=Math.pow(10,i);return e>=10*r&&(i+=1),i},_.stringOfChar=function(t,e){for(var n=new P,i=0;e>i;i++)n.append(t);return n.toString()},_.PI=new _(3.141592653589793,1.2246467991473532e-16),_.TWO_PI=new _(6.283185307179586,2.4492935982947064e-16),_.PI_2=new _(1.5707963267948966,6.123233995736766e-17),_.E=new _(2.718281828459045,1.4456468917292502e-16),_.NaN=new _(r.NaN,r.NaN),_.EPS=1.23259516440783e-32,_.SPLIT=134217729,_.MAX_PRINT_DIGITS=32,_.TEN=_.valueOf(10),_.ONE=_.valueOf(1),_.SCI_NOT_EXPONENT_CHAR="E",_.SCI_NOT_ZERO="0.0E0",e(M.prototype,{interfaces_:function(){return[]},getClass:function(){return M}}),M.orientationIndex=function(t,e,n){var i=M.orientationIndexFilter(t,e,n);if(1>=i)return i;var r=_.valueOf(e.x).selfAdd(-t.x),s=_.valueOf(e.y).selfAdd(-t.y),o=_.valueOf(n.x).selfAdd(-e.x),a=_.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum()},M.signOfDet2x2=function(t,e,n,i){var r=t.multiply(i).selfSubtract(e.multiply(n));return r.signum()},M.intersection=function(t,e,n,i){var r=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(e.x).selfSubtract(t.x)),s=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(e.y).selfSubtract(t.y)),o=r.subtract(s),a=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),u=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),l=a.subtract(u),h=l.selfDivide(o).doubleValue(),c=_.valueOf(t.x).selfAdd(_.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),f=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),d=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),p=f.subtract(d),v=p.selfDivide(o).doubleValue(),m=_.valueOf(n.y).selfAdd(_.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();return new g(c,m)},M.orientationIndexFilter=function(t,e,n){var i=null,r=(t.x-n.x)*(e.y-n.y),s=(t.y-n.y)*(e.x-n.x),o=r-s;if(r>0){if(0>=s)return M.signum(o);i=r+s}else{if(!(0>r))return M.signum(o);if(s>=0)return M.signum(o);i=-r-s}var a=M.DP_SAFE_EPSILON*i;return o>=a||-o>=a?M.signum(o):2},M.signum=function(t){return t>0?1:0>t?-1:0},M.DP_SAFE_EPSILON=1e-15,e(D.prototype,{setOrdinate:function(t,e,n){},size:function(){},getOrdinate:function(t,e){},getCoordinate:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},getCoordinateCopy:function(t){},getDimension:function(){},getX:function(t){},clone:function(){},expandEnvelope:function(t){},copy:function(){},getY:function(t){},toCoordinateArray:function(){},interfaces_:function(){return[o]},getClass:function(){return D}}),D.X=0,D.Y=1,D.Z=2,D.M=3,A.arraycopy=function(t,e,n,i,r){for(var s=0,o=e;e+r>o;o++)n[i+s]=t[o],s++},A.getProperty=function(t){return{"line.separator":"\n"}[t]},e(F.prototype,{getY:function(){var t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getX:function(){var t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getCoordinate:function(){var t=new g;return t.x=this.getX(),t.y=this.getY(),t},interfaces_:function(){return[]},getClass:function(){return F}}),F.intersection=function(t,e,n,i){var s=t.y-e.y,o=e.x-t.x,a=t.x*e.y-e.x*t.y,u=n.y-i.y,l=i.x-n.x,h=n.x*i.y-i.x*n.y,c=o*h-l*a,f=u*a-s*h,d=s*l-u*o,p=c/d,v=f/d;if(r.isNaN(p)||r.isInfinite(p)||r.isNaN(v)||r.isInfinite(v))throw new w;return new g(p,v)},e(G.prototype,{create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){arguments[0]}else if(R(arguments[0],D)){arguments[0]}}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return G}}),e(q.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return q}}),e(B.prototype,{isGeometryCollection:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION},getFactory:function(){return this.factory},getGeometryN:function(t){return this},getArea:function(){return 0},isRectangle:function(){return!1},equals:function(){if(1===arguments.length){if(arguments[0]instanceof B){var t=arguments[0];return null===t?!1:this.equalsTopo(t)}if(arguments[0]instanceof Object){var e=arguments[0];if(!(e instanceof B))return!1;var n=e;return this.equalsExact(n)}}},equalsExact:function(t){return this===t||this.equalsExact(t,0)},geometryChanged:function(){this.apply(B.geometryChangedFilter)},geometryChangedAction:function(){this.envelope=null},equalsNorm:function(t){return null===t?!1:this.norm().equalsExact(t.norm())},getLength:function(){return 0},getNumGeometries:function(){return 1},compareTo:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(n,i)}},getUserData:function(){return this.userData},getSRID:function(){return this.SRID},getEnvelope:function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},checkNotGeometryCollection:function(t){if(t.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION)throw new i("This method does not support GeometryCollection arguments")},equal:function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n},norm:function(){var t=this.copy();return t.normalize(),t},getPrecisionModel:function(){return this.factory.getPrecisionModel()},getEnvelopeInternal:function(){return null===this.envelope&&(this.envelope=this.computeEnvelopeInternal()),new C(this.envelope)},setSRID:function(t){this.SRID=t},setUserData:function(t){this.userData=t},compare:function(t,e){for(var n=t.iterator(),i=e.iterator();n.hasNext()&&i.hasNext();){var r=n.next(),s=i.next(),o=r.compareTo(s);if(0!==o)return o}return n.hasNext()?1:i.hasNext()?-1:0},hashCode:function(){return this.getEnvelopeInternal().hashCode()},isGeometryCollectionOrDerived:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===B.SORTINDEX_MULTIPOINT||this.getSortIndex()===B.SORTINDEX_MULTILINESTRING||this.getSortIndex()===B.SORTINDEX_MULTIPOLYGON},interfaces_:function(){return[o,s,u]},getClass:function(){return B}}),B.hasNonEmptyElements=function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1},B.hasNullElements=function(t){for(var e=0;e<t.length;e++)if(null===t[e])return!0;return!1},B.serialVersionUID=0x799ea46522854c00,B.SORTINDEX_POINT=0,B.SORTINDEX_MULTIPOINT=1,B.SORTINDEX_LINESTRING=2,B.SORTINDEX_LINEARRING=3,B.SORTINDEX_MULTILINESTRING=4,B.SORTINDEX_POLYGON=5,B.SORTINDEX_MULTIPOLYGON=6,B.SORTINDEX_GEOMETRYCOLLECTION=7,B.geometryChangedFilter={interfaces_:function(){return[q]},filter:function(t){t.geometryChangedAction()}},e(z.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return z}}),e(V.prototype,{isInBoundary:function(t){},interfaces_:function(){return[]},getClass:function(){return V}}),e(k.prototype,{isInBoundary:function(t){return t%2===1},interfaces_:function(){return[V]},getClass:function(){return k}}),e(Y.prototype,{isInBoundary:function(t){return t>0},interfaces_:function(){return[V]},getClass:function(){return Y}}),e(U.prototype,{isInBoundary:function(t){return t>1},interfaces_:function(){return[V]},getClass:function(){return U}}),e(X.prototype,{isInBoundary:function(t){return 1===t},interfaces_:function(){return[V]},getClass:function(){return X}}),V.Mod2BoundaryNodeRule=k,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=X,V.MOD2_BOUNDARY_RULE=new k,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new X,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE,e(H.prototype,{interfaces_:function(){return[]},getClass:function(){return H}}),H.isRing=function(t){return t.length<4?!1:!!t[0].equals2D(t[t.length-1])},H.ptNotInList=function(t,e){for(var n=0;n<t.length;n++){var i=t[n];if(H.indexOf(i,e)<0)return i}return null},H.scroll=function(t,e){var n=H.indexOf(e,t);if(0>n)return null;var i=new Array(t.length).fill(null);A.arraycopy(t,n,i,0,t.length-n),A.arraycopy(t,0,i,t.length-n,n),A.arraycopy(i,0,t,0,t.length)},H.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];if(i===r)return!0;if(null===i||null===r)return!1;if(i.length!==r.length)return!1;for(var n=0;n<i.length;n++)if(0!==s.compare(i[n],r[n]))return!1;return!0}},H.intersection=function(t,e){for(var n=new N,i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()},H.hasRepeatedPoints=function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1},H.removeRepeatedPoints=function(t){if(!H.hasRepeatedPoints(t))return t;var e=new N(t,!1);return e.toCoordinateArray()},H.reverse=function(t){for(var e=t.length-1,n=Math.trunc(e/2),i=0;n>=i;i++){var r=t[i];t[i]=t[e-i],t[e-i]=r}},H.removeNull=function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var i=new Array(e).fill(null);if(0===e)return i;for(var r=0,n=0;n<t.length;n++)null!==t[n]&&(i[r++]=t[n]);return i},H.copyDeep=function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length)for(var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=arguments[4],n=0;a>n;n++)s[o+n]=new g(i[r+n])},H.isEqualReversed=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[t.length-n-1];if(0!==i.compareTo(r))return!1}return!0},H.envelope=function(t){for(var e=new C,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e},H.toCoordinateArray=function(t){return t.toArray(H.coordArrayType)},H.atLeastNCoordinatesOrNothing=function(t,e){return e.length>=t?e:[]},H.indexOf=function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1},H.increasingDirection=function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1},H.compare=function(t,e){for(var n=0;n<t.length&&n<e.length;){var i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0},H.minCoordinate=function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e},H.extract=function(t,e,n){e=T.clamp(e,0,t.length),n=T.clamp(n,-1,t.length);var i=n-e+1;0>n&&(i=0),e>=t.length&&(i=0),e>n&&(i=0);var r=new Array(i).fill(null);if(0===i)return r;for(var s=0,o=e;n>=o;o++)r[s++]=t[o];return r},e(W.prototype,{compare:function(t,e){var n=t,i=e;return H.compare(n,i)},interfaces_:function(){return[a]},getClass:function(){return W}}),e(j.prototype,{compare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;var r=H.compare(n,i),s=H.isEqualReversed(n,i);return s?0:r},OLDcompare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;for(var r=H.increasingDirection(n),s=H.increasingDirection(i),o=r>0?0:n.length-1,a=s>0?0:n.length-1,u=0;u<n.length;u++){var l=n[o].compareTo(i[a]);if(0!==l)return l;o+=r,a+=s}return 0},interfaces_:function(){return[a]},getClass:function(){return j}}),H.ForwardComparator=W,H.BidirectionalComparator=j,H.coordArrayType=new Array(0).fill(null),K.prototype.get=function(){},K.prototype.put=function(){},K.prototype.size=function(){},K.prototype.values=function(){},K.prototype.entrySet=function(){},Z.prototype=new K,Q.prototype=new v,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(i===t)return!0}return!1},J.prototype.add=function(t){return this.contains(t)?!1:(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new javascript.util.OperationNotSupported},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new Js(this)};var Js=function(t){this.hashSet_=t,this.position_=0};Js.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new x;return this.hashSet_.array_[this.position_++]},Js.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},Js.prototype.remove=function(){throw new E};var $s=0,to=1;rt.prototype=new Z,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(0>n)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,i,r=this.root_;do if(n=r,i=t.compareTo(r.key),0>i)r=r.left;else{if(!(i>0)){var s=r.value;return r.value=e,s}r=r.right}while(null!==r);var o={key:t,left:null,right:null,value:e,parent:n,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}};return 0>i?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){for(t.color=to;null!=t&&t!=this.root_&&t.parent.color==to;)if(tt(t)==nt(tt(tt(t)))){var e=it(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==it(tt(t))&&(t=tt(t),this.rotateLeft(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateRight(tt(tt(t))))}else{var e=nt(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==nt(tt(t))&&(t=tt(t),this.rotateRight(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateLeft(tt(tt(t))))}this.root_.color=$s},rt.prototype.values=function(){var t=new I,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left==t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right==t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){if(null===t)return null;if(null!==t.right){for(var e=t.right;null!==e.left;)e=e.left;return e}for(var e=t.parent,n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},e(st.prototype,{interfaces_:function(){return[]},getClass:function(){return st}}),ot.prototype=new Q,at.prototype=new ot,at.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(0===i.compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(1===i.compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new E},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new eo(this)};var eo=function(t){this.treeSet_=t,this.position_=0};eo.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new x;return this.treeSet_.array_[this.position_++]},eo.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},eo.prototype.remove=function(){throw new E},ut.sort=function(){var t,e,n,i,r=arguments[0];if(1===arguments.length)return i=function(t,e){return t.compareTo(e)},void r.sort(i);if(2===arguments.length)n=arguments[1],i=function(t,e){return n.compare(t,e)},r.sort(i);else{if(3===arguments.length){e=r.slice(arguments[1],arguments[2]),e.sort();var s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length));for(r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}if(4===arguments.length){for(e=r.slice(arguments[1],arguments[2]),n=arguments[3],i=function(t,e){return n.compare(t,e)},e.sort(i),s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length)),r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}}},ut.asList=function(t){for(var e=new I,n=0,i=t.length;i>n;n++)e.add(t[n]);return e},e(lt.prototype,{interfaces_:function(){return[]},getClass:function(){return lt}}),lt.toDimensionSymbol=function(t){switch(t){case lt.FALSE:return lt.SYM_FALSE;case lt.TRUE:return lt.SYM_TRUE;case lt.DONTCARE:return lt.SYM_DONTCARE;case lt.P:return lt.SYM_P;case lt.L:return lt.SYM_L;case lt.A:return lt.SYM_A}throw new i("Unknown dimension value: "+t)},lt.toDimensionValue=function(t){switch(O.toUpperCase(t)){case lt.SYM_FALSE:return lt.FALSE;case lt.SYM_TRUE:return lt.TRUE;case lt.SYM_DONTCARE:return lt.DONTCARE;case lt.SYM_P:return lt.P;case lt.SYM_L:return lt.L;case lt.SYM_A:return lt.A}throw new i("Unknown dimension symbol: "+t)},lt.P=0,lt.L=1,lt.A=2,lt.FALSE=-1,lt.TRUE=-2,lt.DONTCARE=-3,lt.SYM_FALSE="F",lt.SYM_TRUE="T",lt.SYM_DONTCARE="*",lt.SYM_P="0",lt.SYM_L="1",lt.SYM_A="2",e(ht.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return ht}}),e(ct.prototype,{filter:function(t,e){},isDone:function(){},isGeometryChanged:function(){},interfaces_:function(){return[]},getClass:function(){return ct}}),h(ft,B),e(ft.prototype,{computeEnvelopeInternal:function(){for(var t=new C,e=0;e<this.geometries.length;e++)t.expandToInclude(this.geometries[e].getEnvelopeInternal());return t},getGeometryN:function(t){return this.geometries[t]},getSortIndex:function(){return B.SORTINDEX_GEOMETRYCOLLECTION},getCoordinates:function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this.geometries.length;n++)for(var i=this.geometries[n].getCoordinates(),r=0;r<i.length;r++)e++,t[e]=i[r];return t},getArea:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getArea();return t},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.geometries.length!==n.geometries.length)return!1;for(var i=0;i<this.geometries.length;i++)if(!this.geometries[i].equalsExact(n.geometries[i],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<this.geometries.length;t++)this.geometries[t].normalize();ut.sort(this.geometries)},getCoordinate:function(){return this.isEmpty()?null:this.geometries[0].getCoordinate()},getBoundaryDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getBoundaryDimension());return t},getDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getDimension());return t},getLength:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getLength();return t},getNumPoints:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getNumPoints();return t},getNumGeometries:function(){return this.geometries.length},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createGeometryCollection(e)},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=new at(ut.asList(this.geometries)),n=new at(ut.asList(t.geometries));return this.compare(e,n)}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s=i,o=this.getNumGeometries(),a=s.getNumGeometries(),u=0;o>u&&a>u;){var l=this.getGeometryN(u),h=s.getGeometryN(u),c=l.compareToSameClass(h,r);if(0!==c)return c;u++}return o>u?1:a>u?-1:0}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.geometries.length;e++)this.geometries[e].apply(t);else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.geometries.length)return null;for(var e=0;e<this.geometries.length&&(this.geometries[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(i)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(r)}},getBoundary:function(){return this.checkNotGeometryCollection(this),f.shouldNeverReachHere(),null},clone:function(){var t=B.prototype.clone.call(this);t.geometries=new Array(this.geometries.length).fill(null);for(var e=0;e<this.geometries.length;e++)t.geometries[e]=this.geometries[e].clone();return t},getGeometryType:function(){return"GeometryCollection"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new ft(t,this.factory)},isEmpty:function(){for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isEmpty())return!1;return!0},interfaces_:function(){return[]},getClass:function(){return ft}}),ft.serialVersionUID=-0x4f07bcb1f857d800,h(gt,ft),e(gt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTILINESTRING},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){if(this.isEmpty())return!1;for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isClosed())return!1;return!0},getDimension:function(){return 1},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[t-1-n]=this.geometries[n].reverse();return this.getFactory().createMultiLineString(e)},getBoundary:function(){return new dt(this).getBoundary()},getGeometryType:function(){return"MultiLineString"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new gt(t,this.factory)},interfaces_:function(){
return[st]},getClass:function(){return gt}}),gt.serialVersionUID=0x7155d2ab4afa8000,e(dt.prototype,{boundaryMultiLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();var e=this.computeBoundaryCoordinates(t);return 1===e.length?this.geomFact.createPoint(e[0]):this.geomFact.createMultiPointFromCoords(e)},getBoundary:function(){return this.geom instanceof St?this.boundaryLineString(this.geom):this.geom instanceof gt?this.boundaryMultiLineString(this.geom):this.geom.getBoundary()},boundaryLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){var e=this.bnRule.isInBoundary(2);return e?t.getStartPoint():this.geomFact.createMultiPoint()}return this.geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])},getEmptyMultiPoint:function(){return this.geomFact.createMultiPoint()},computeBoundaryCoordinates:function(t){var e=new I;this.endpointMap=new rt;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);0!==i.getNumPoints()&&(this.addEndpoint(i.getCoordinateN(0)),this.addEndpoint(i.getCoordinateN(i.getNumPoints()-1)))}for(var r=this.endpointMap.entrySet().iterator();r.hasNext();){var s=r.next(),o=s.getValue(),a=o.count;this.bnRule.isInBoundary(a)&&e.add(s.getKey())}return H.toCoordinateArray(e)},addEndpoint:function(t){var e=this.endpointMap.get(t);null===e&&(e=new pt,this.endpointMap.put(t,e)),e.count++},interfaces_:function(){return[]},getClass:function(){return dt}}),dt.getBoundary=function(){if(1===arguments.length){var t=arguments[0],e=new dt(t);return e.getBoundary()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new dt(n,i);return e.getBoundary()}},e(pt.prototype,{interfaces_:function(){return[]},getClass:function(){return pt}}),e(Nt.prototype,{interfaces_:function(){return[]},getClass:function(){return Nt}}),Nt.chars=function(t,e){for(var n=new Array(e).fill(null),i=0;e>i;i++)n[i]=t;return new String(n)},Nt.getStackTrace=function(){if(1===arguments.length){var t=arguments[0],e=new xt,n=new vt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s="",o=new mt(Nt.getStackTrace(i)),a=new It(o),u=0;r>u;u++)try{s+=a.readLine()+Nt.NEWLINE}catch(t){if(!(t instanceof Et))throw t;f.shouldNeverReachHere()}finally{}return s}},Nt.split=function(t,e){for(var n=e.length,i=new I,r=""+t,s=r.indexOf(e);s>=0;){var o=r.substring(0,s);i.add(o),r=r.substring(s+n),s=r.indexOf(e)}r.length>0&&i.add(r);for(var a=new Array(i.size()).fill(null),u=0;u<a.length;u++)a[u]=i.get(u);return a},Nt.toString=function(){if(1===arguments.length){var t=arguments[0];return Nt.SIMPLE_ORDINATE_FORMAT.format(t)}},Nt.spaces=function(t){return Nt.chars(" ",t)},Nt.NEWLINE=A.getProperty("line.separator"),Nt.SIMPLE_ORDINATE_FORMAT=new yt("0.#"),e(Ct.prototype,{interfaces_:function(){return[]},getClass:function(){return Ct}}),Ct.copyCoord=function(t,e,n,i){for(var r=Math.min(t.getDimension(),n.getDimension()),s=0;r>s;s++)n.setOrdinate(i,s,t.getOrdinate(e,s))},Ct.isRing=function(t){var e=t.size();return 0===e?!0:3>=e?!1:t.getOrdinate(0,D.X)===t.getOrdinate(e-1,D.X)&&t.getOrdinate(0,D.Y)===t.getOrdinate(e-1,D.Y)},Ct.isEqual=function(t,e){var n=t.size(),i=e.size();if(n!==i)return!1;for(var s=Math.min(t.getDimension(),e.getDimension()),o=0;n>o;o++)for(var a=0;s>a;a++){var u=t.getOrdinate(o,a),l=e.getOrdinate(o,a);if(!(t.getOrdinate(o,a)===e.getOrdinate(o,a)||r.isNaN(u)&&r.isNaN(l)))return!1}return!0},Ct.extend=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();if(Ct.copy(e,0,i,0,r),r>0)for(var s=r;n>s;s++)Ct.copy(e,r-1,i,s,1);return i},Ct.reverse=function(t){for(var e=t.size()-1,n=Math.trunc(e/2),i=0;n>=i;i++)Ct.swap(t,i,e-i)},Ct.swap=function(t,e,n){if(e===n)return null;for(var i=0;i<t.getDimension();i++){var r=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,r)}},Ct.copy=function(t,e,n,i,r){for(var s=0;r>s;s++)Ct.copyCoord(t,e+s,n,i+s)},Ct.toString=function(){if(1===arguments.length){var t=arguments[0],e=t.size();if(0===e)return"()";var n=t.getDimension(),i=new P;i.append("(");for(var r=0;e>r;r++){r>0&&i.append(" ");for(var s=0;n>s;s++)s>0&&i.append(","),i.append(Nt.toString(t.getOrdinate(r,s)))}return i.append(")"),i.toString()}},Ct.ensureValidRing=function(t,e){var n=e.size();if(0===n)return e;if(3>=n)return Ct.createClosedRing(t,e,4);var i=e.getOrdinate(0,D.X)===e.getOrdinate(n-1,D.X)&&e.getOrdinate(0,D.Y)===e.getOrdinate(n-1,D.Y);return i?e:Ct.createClosedRing(t,e,n+1)},Ct.createClosedRing=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();Ct.copy(e,0,i,0,r);for(var s=r;n>s;s++)Ct.copy(e,0,i,s,1);return i},h(St,B),e(St.prototype,{computeEnvelopeInternal:function(){return this.isEmpty()?new C:this.points.expandEnvelope(new C)},isRing:function(){return this.isClosed()&&this.isSimple()},getSortIndex:function(){return B.SORTINDEX_LINESTRING},getCoordinates:function(){return this.points.toCoordinateArray()},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.points.size()!==n.points.size())return!1;for(var i=0;i<this.points.size();i++)if(!this.equal(this.points.getCoordinate(i),n.points.getCoordinate(i),e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<Math.trunc(this.points.size()/2);t++){var e=this.points.size()-1-t;if(!this.points.getCoordinate(t).equals(this.points.getCoordinate(e)))return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e))>0&&Ct.reverse(this.points),null}},getCoordinate:function(){return this.isEmpty()?null:this.points.getCoordinate(0)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){return this.isEmpty()?!1:this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},getEndPoint:function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},getDimension:function(){return 1},getLength:function(){return he.computeLength(this.points)},getNumPoints:function(){return this.points.size()},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLineString(t);return e},compareToSameClass:function(){if(1===arguments.length){for(var t=arguments[0],e=t,n=0,i=0;n<this.points.size()&&i<e.points.size();){var r=this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));if(0!==r)return r;n++,i++}return n<this.points.size()?1:i<e.points.size()?-1:0}if(2===arguments.length){var s=arguments[0],o=arguments[1],e=s;return o.compare(this.points,e.points)}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.points.size();e++)t.filter(this.points.getCoordinate(e));else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.points.size())return null;for(var e=0;e<this.points.size()&&(n.filter(this.points,e),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this)}},getBoundary:function(){return new dt(this).getBoundary()},isEquivalentClass:function(t){return t instanceof St},clone:function(){var t=B.prototype.clone.call(this);return t.points=this.points.clone(),t},getCoordinateN:function(t){return this.points.getCoordinate(t)},getGeometryType:function(){return"LineString"},copy:function(){return new St(this.points.copy(),this.factory)},getCoordinateSequence:function(){return this.points},isEmpty:function(){return 0===this.points.size()},init:function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new i("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this.points=t},isCoordinate:function(t){for(var e=0;e<this.points.size();e++)if(this.points.getCoordinate(e).equals(t))return!0;return!1},getStartPoint:function(){return this.isEmpty()?null:this.getPointN(0)},getPointN:function(t){return this.getFactory().createPoint(this.points.getCoordinate(t))},interfaces_:function(){return[st]},getClass:function(){return St}}),St.serialVersionUID=0x2b2b51ba435c8e00,e(wt.prototype,{interfaces_:function(){return[]},getClass:function(){return wt}}),h(Lt,B),e(Lt.prototype,{computeEnvelopeInternal:function(){if(this.isEmpty())return new C;var t=new C;return t.expandToInclude(this.coordinates.getX(0),this.coordinates.getY(0)),t},getSortIndex:function(){return B.SORTINDEX_POINT},getCoordinates:function(){return this.isEmpty()?[]:[this.getCoordinate()]},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?this.isEmpty()&&t.isEmpty()?!0:this.isEmpty()!==t.isEmpty()?!1:this.equal(t.getCoordinate(),this.getCoordinate(),e):!1}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){},getCoordinate:function(){return 0!==this.coordinates.size()?this.coordinates.getCoordinate(0):null},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getNumPoints:function(){return this.isEmpty()?0:1},reverse:function(){return this.copy()},getX:function(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getCoordinate().compareTo(e.getCoordinate())}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return i.compare(this.coordinates,e.coordinates)}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(R(arguments[0],ct)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this.coordinates,0),e.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var n=arguments[0];n.filter(this)}else if(R(arguments[0],q)){var i=arguments[0];i.filter(this)}},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},clone:function(){var t=B.prototype.clone.call(this);return t.coordinates=this.coordinates.clone(),t},getGeometryType:function(){return"Point"},copy:function(){return new Lt(this.coordinates.copy(),this.factory)},getCoordinateSequence:function(){return this.coordinates},getY:function(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y},isEmpty:function(){return 0===this.coordinates.size()},init:function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),f.isTrue(t.size()<=1),this.coordinates=t},isSimple:function(){return!0},interfaces_:function(){return[wt]},getClass:function(){return Lt}}),Lt.serialVersionUID=0x44077bad161cbc00,e(Rt.prototype,{interfaces_:function(){return[]},getClass:function(){return Rt}}),h(Tt,B),e(Tt.prototype,{computeEnvelopeInternal:function(){return this.shell.getEnvelopeInternal()},getSortIndex:function(){return B.SORTINDEX_POLYGON},getCoordinates:function(){if(this.isEmpty())return[];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this.shell.getCoordinates(),i=0;i<n.length;i++)e++,t[e]=n[i];for(var r=0;r<this.holes.length;r++)for(var s=this.holes[r].getCoordinates(),o=0;o<s.length;o++)e++,t[e]=s[o];return t},getArea:function(){var t=0;t+=Math.abs(he.signedArea(this.shell.getCoordinateSequence()));for(var e=0;e<this.holes.length;e++)t-=Math.abs(he.signedArea(this.holes[e].getCoordinateSequence()));return t},isRectangle:function(){if(0!==this.getNumInteriorRing())return!1;if(null===this.shell)return!1;if(5!==this.shell.getNumPoints())return!1;for(var t=this.shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;5>n;n++){var i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;var r=t.getY(n);if(r!==e.getMinY()&&r!==e.getMaxY())return!1}for(var s=t.getX(0),o=t.getY(0),n=1;4>=n;n++){var i=t.getX(n),r=t.getY(n),a=i!==s,u=r!==o;if(a===u)return!1;s=i,o=r}return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t,i=this.shell,r=n.shell;if(!i.equalsExact(r,e))return!1;if(this.holes.length!==n.holes.length)return!1;for(var s=0;s<this.holes.length;s++)if(!this.holes[s].equalsExact(n.holes[s],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){if(0===arguments.length){this.normalize(this.shell,!0);for(var t=0;t<this.holes.length;t++)this.normalize(this.holes[t],!1);ut.sort(this.holes)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var i=new Array(e.getCoordinates().length-1).fill(null);A.arraycopy(e.getCoordinates(),0,i,0,i.length);var r=H.minCoordinate(e.getCoordinates());H.scroll(i,r),A.arraycopy(i,0,e.getCoordinates(),0,i.length),e.getCoordinates()[i.length]=i[0],he.isCCW(e.getCoordinates())===n&&H.reverse(e.getCoordinates())}},getCoordinate:function(){return this.shell.getCoordinate()},getNumInteriorRing:function(){return this.holes.length},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},getLength:function(){var t=0;t+=this.shell.getLength();for(var e=0;e<this.holes.length;e++)t+=this.holes[e].getLength();return t},getNumPoints:function(){for(var t=this.shell.getNumPoints(),e=0;e<this.holes.length;e++)t+=this.holes[e].getNumPoints();return t},reverse:function(){var t=this.copy();t.shell=this.shell.copy().reverse(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].copy().reverse();return t},convexHull:function(){return this.getExteriorRing().convexHull()},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=this.shell,n=t.shell;return e.compareToSameClass(n)}if(2===arguments.length){var i=arguments[0],r=arguments[1],s=i,e=this.shell,n=s.shell,o=e.compareToSameClass(n,r);if(0!==o)return o;for(var a=this.getNumInteriorRing(),u=s.getNumInteriorRing(),l=0;a>l&&u>l;){var h=this.getInteriorRingN(l),c=s.getInteriorRingN(l),f=h.compareToSameClass(c,r);if(0!==f)return f;l++}return a>l?1:u>l?-1:0}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];this.shell.apply(t);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(t)}else if(R(arguments[0],ct)){var n=arguments[0];if(this.shell.apply(n),!n.isDone())for(var e=0;e<this.holes.length&&(this.holes[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this),this.shell.apply(r);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(r)}},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this.holes.length+1).fill(null);t[0]=this.shell;for(var e=0;e<this.holes.length;e++)t[e+1]=this.holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)},clone:function(){var t=B.prototype.clone.call(this);t.shell=this.shell.clone(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].clone();return t},getGeometryType:function(){return"Polygon"},copy:function(){for(var t=this.shell.copy(),e=new Array(this.holes.length).fill(null),n=0;n<e.length;n++)e[n]=this.holes[n].copy();return new Tt(t,e,this.factory)},getExteriorRing:function(){return this.shell},isEmpty:function(){return this.shell.isEmpty()},getInteriorRingN:function(t){return this.holes[t]},interfaces_:function(){return[Rt]},getClass:function(){return Tt}}),Tt.serialVersionUID=-0x307ffefd8dc97200,h(Pt,ft),e(Pt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOINT},isValid:function(){return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.geometries[t].getCoordinate()}return ft.prototype.getCoordinate.apply(this,arguments)},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},getGeometryType:function(){return"MultiPoint"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Pt(t,this.factory)},interfaces_:function(){return[wt]},getClass:function(){return Pt}}),Pt.serialVersionUID=-0x6fb1ed4162e0fc00,h(bt,St),e(bt.prototype,{getSortIndex:function(){return B.SORTINDEX_LINEARRING},getBoundaryDimension:function(){return lt.FALSE},isClosed:function(){return this.isEmpty()?!0:St.prototype.isClosed.call(this)},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLinearRing(t);return e},validateConstruction:function(){if(!this.isEmpty()&&!St.prototype.isClosed.call(this))throw new i("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<bt.MINIMUM_VALID_SIZE)throw new i("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},getGeometryType:function(){return"LinearRing"},copy:function(){return new bt(this.points.copy(),this.factory)},interfaces_:function(){return[]},getClass:function(){return bt}}),bt.MINIMUM_VALID_SIZE=4,bt.serialVersionUID=-0x3b229e262367a600,h(Ot,ft),e(Ot.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOLYGON},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createMultiPolygon(e)},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new I,e=0;e<this.geometries.length;e++)for(var n=this.geometries[e],i=n.getBoundary(),r=0;r<i.getNumGeometries();r++)t.add(i.getGeometryN(r));var s=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s))},getGeometryType:function(){return"MultiPolygon"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Ot(t,this.factory)},interfaces_:function(){return[Rt]},getClass:function(){return Ot}}),Ot.serialVersionUID=-0x7a5aa1369171980,e(_t.prototype,{setCopyUserData:function(t){this.isUserDataCopied=t},edit:function(t,e){if(null===t)return null;var n=this.editInternal(t,e);return this.isUserDataCopied&&n.setUserData(t.getUserData()),n},editInternal:function(t,e){return null===this.factory&&(this.factory=t.getFactory()),t instanceof ft?this.editGeometryCollection(t,e):t instanceof Tt?this.editPolygon(t,e):t instanceof Lt?e.edit(t,this.factory):t instanceof St?e.edit(t,this.factory):(f.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)},editGeometryCollection:function(t,e){for(var n=e.edit(t,this.factory),i=new I,r=0;r<n.getNumGeometries();r++){var s=this.edit(n.getGeometryN(r),e);null===s||s.isEmpty()||i.add(s)}return n.getClass()===Pt?this.factory.createMultiPoint(i.toArray([])):n.getClass()===gt?this.factory.createMultiLineString(i.toArray([])):n.getClass()===Ot?this.factory.createMultiPolygon(i.toArray([])):this.factory.createGeometryCollection(i.toArray([]))},editPolygon:function(t,e){var n=e.edit(t,this.factory);if(null===n&&(n=this.factory.createPolygon(null)),n.isEmpty())return n;var i=this.edit(n.getExteriorRing(),e);if(null===i||i.isEmpty())return this.factory.createPolygon();for(var r=new I,s=0;s<n.getNumInteriorRing();s++){var o=this.edit(n.getInteriorRingN(s),e);null===o||o.isEmpty()||r.add(o)}return this.factory.createPolygon(i,r.toArray([]))},interfaces_:function(){return[]},getClass:function(){return _t}}),_t.GeometryEditorOperation=Mt,e(Dt.prototype,{edit:function(t,e){return t},interfaces_:function(){return[Mt]},getClass:function(){return Dt}}),e(At.prototype,{edit:function(t,e){if(t instanceof bt)return e.createLinearRing(this.editCoordinates(t.getCoordinates(),t));if(t instanceof St)return e.createLineString(this.editCoordinates(t.getCoordinates(),t));if(t instanceof Lt){var n=this.editCoordinates(t.getCoordinates(),t);return n.length>0?e.createPoint(n[0]):e.createPoint()}return t},interfaces_:function(){return[Mt]},getClass:function(){return At}}),e(Ft.prototype,{edit:function(t,e){return t instanceof bt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof St?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Lt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t},interfaces_:function(){return[Mt]},getClass:function(){return Ft}}),_t.NoOpGeometryOperation=Dt,_t.CoordinateOperation=At,_t.CoordinateSequenceOperation=Ft,e(Gt.prototype,{setOrdinate:function(t,e,n){switch(e){case D.X:this.coordinates[t].x=n;break;case D.Y:this.coordinates[t].y=n;break;case D.Z:this.coordinates[t].z=n;break;default:throw new i("invalid ordinateIndex")}},size:function(){return this.coordinates.length},getOrdinate:function(t,e){switch(e){case D.X:return this.coordinates[t].x;case D.Y:return this.coordinates[t].y;case D.Z:return this.coordinates[t].z}return r.NaN},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.coordinates[t]}if(2===arguments.length){var e=arguments[0],n=arguments[1];n.x=this.coordinates[e].x,n.y=this.coordinates[e].y,n.z=this.coordinates[e].z}},getCoordinateCopy:function(t){return new g(this.coordinates[t])},getDimension:function(){return this.dimension},getX:function(t){return this.coordinates[t].x},clone:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].clone();return new Gt(t,this.dimension)},expandEnvelope:function(t){for(var e=0;e<this.coordinates.length;e++)t.expandToInclude(this.coordinates[e]);return t},copy:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].copy();return new Gt(t,this.dimension)},toString:function(){if(this.coordinates.length>0){var t=new P(17*this.coordinates.length);t.append("("),t.append(this.coordinates[0]);for(var e=1;e<this.coordinates.length;e++)t.append(", "),t.append(this.coordinates[e]);return t.append(")"),t.toString()}return"()"},getY:function(t){return this.coordinates[t].y},toCoordinateArray:function(){return this.coordinates},interfaces_:function(){return[D,u]},getClass:function(){return Gt}}),Gt.serialVersionUID=-0xcb44a778db18e00,e(qt.prototype,{readResolve:function(){return qt.instance()},create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Gt(t)}if(R(arguments[0],D)){var e=arguments[0];return new Gt(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return i>3&&(i=3),2>i?new Gt(n):new Gt(n,i)}},interfaces_:function(){return[G,u]},getClass:function(){return qt}}),qt.instance=function(){return qt.instanceObject},qt.serialVersionUID=-0x38e49fa6cf6f2e00,qt.instanceObject=new qt;var no,io=Object.defineProperty,ro=zt({delete:kt,has:Xt,get:Yt,set:Ht,keys:jt,values:Kt,entries:Zt,forEach:$t,clear:Wt}),so="undefined"!=typeof Map&&Map.prototype.values?Map:ro;te.prototype=new K,te.prototype.get=function(t){return this.map_.get(t)||null},te.prototype.put=function(t,e){return this.map_.set(t,e),e},te.prototype.values=function(){for(var t=new I,e=this.map_.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t},te.prototype.entrySet=function(){var t=new J;return this.map_.entries().forEach(function(e){return t.add(e)}),t},te.prototype.size=function(){return this.map_.size()},e(ee.prototype,{equals:function(t){if(!(t instanceof ee))return!1;var e=t;return this.modelType===e.modelType&&this.scale===e.scale},compareTo:function(t){var e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return new b(n).compareTo(new b(i))},getScale:function(){return this.scale},isFloating:function(){return this.modelType===ee.FLOATING||this.modelType===ee.FLOATING_SINGLE},getType:function(){return this.modelType},toString:function(){var t="UNKNOWN";return this.modelType===ee.FLOATING?t="Floating":this.modelType===ee.FLOATING_SINGLE?t="Floating-Single":this.modelType===ee.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t},makePrecise:function(){if("number"==typeof arguments[0]){var t=arguments[0];if(r.isNaN(t))return t;if(this.modelType===ee.FLOATING_SINGLE){var e=t;return e}return this.modelType===ee.FIXED?Math.round(t*this.scale)/this.scale:t}if(arguments[0]instanceof g){var n=arguments[0];if(this.modelType===ee.FLOATING)return null;n.x=this.makePrecise(n.x),n.y=this.makePrecise(n.y)}},getMaximumSignificantDigits:function(){var t=16;return this.modelType===ee.FLOATING?t=16:this.modelType===ee.FLOATING_SINGLE?t=6:this.modelType===ee.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t},setScale:function(t){this.scale=Math.abs(t)},interfaces_:function(){return[u,s]},getClass:function(){return ee}}),ee.mostPrecise=function(t,e){return t.compareTo(e)>=0?t:e},e(ne.prototype,{readResolve:function(){return ne.nameToTypeMap.get(this.name)},toString:function(){return this.name},interfaces_:function(){return[u]},getClass:function(){return ne}}),ne.serialVersionUID=-552860263173159e4,ne.nameToTypeMap=new te,ee.Type=ne,ee.serialVersionUID=0x6bee6404e9a25c00,ee.FIXED=new ne("FIXED"),ee.FLOATING=new ne("FLOATING"),ee.FLOATING_SINGLE=new ne("FLOATING SINGLE"),ee.maximumPreciseValue=9007199254740992,e(ie.prototype,{toGeometry:function(t){return t.isNull()?this.createPoint(null):t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)},createLineString:function(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new St(e,this)}}},createMultiLineString:function(){if(0===arguments.length)return new gt(null,this);if(1===arguments.length){var t=arguments[0];return new gt(t,this)}},buildGeometry:function(t){for(var e=null,n=!1,i=!1,r=t.iterator();r.hasNext();){var s=r.next(),o=s.getClass();null===e&&(e=o),o!==e&&(n=!0),s.isGeometryCollectionOrDerived()&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(ie.toGeometryArray(t));var a=t.iterator().next(),u=t.size()>1;if(u){if(a instanceof Tt)return this.createMultiPolygon(ie.toPolygonArray(t));if(a instanceof St)return this.createMultiLineString(ie.toLineStringArray(t));if(a instanceof Lt)return this.createMultiPoint(ie.toPointArray(t));f.shouldNeverReachHere("Unhandled class: "+a.getClass().getName())}return a},createMultiPointFromCoords:function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)},createPoint:function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(R(arguments[0],D)){var e=arguments[0];return new Lt(e,this)}}},getCoordinateSequenceFactory:function(){return this.coordinateSequenceFactory},createPolygon:function(){if(0===arguments.length)return new Tt(null,null,this);if(1===arguments.length){if(R(arguments[0],D)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof bt){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];return new Tt(i,r,this)}},getSRID:function(){return this.SRID},createGeometryCollection:function(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){var t=arguments[0];return new ft(t,this)}},createGeometry:function(t){var e=new _t(this);return e.edit(t,{edit:function(){if(2===arguments.length){var t=arguments[0];arguments[1];return this.coordinateSequenceFactory.create(t)}}})},getPrecisionModel:function(){return this.precisionModel},createLinearRing:function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new bt(e,this)}}},createMultiPolygon:function(){if(0===arguments.length)return new Ot(null,this);if(1===arguments.length){var t=arguments[0];return new Ot(t,this)}},createMultiPoint:function(){if(0===arguments.length)return new Pt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Pt(t,this)}if(arguments[0]instanceof Array){var e=arguments[0];return this.createMultiPoint(null!==e?this.getCoordinateSequenceFactory().create(e):null)}if(R(arguments[0],D)){var n=arguments[0];if(null===n)return this.createMultiPoint(new Array(0).fill(null));for(var i=new Array(n.size()).fill(null),r=0;r<n.size();r++){var s=this.getCoordinateSequenceFactory().create(1,n.getDimension());Ct.copy(n,r,s,0,1),i[r]=this.createPoint(s)}return this.createMultiPoint(i)}}},interfaces_:function(){return[u]},getClass:function(){return ie}}),ie.toMultiPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toGeometryArray=function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.getDefaultCoordinateSequenceFactory=function(){return qt.instance()},ie.toMultiLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toMultiPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLinearRingArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},ie.serialVersionUID=-0x5ea75f2051eeb400;var oo={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};e(re.prototype,{read:function(t){var e,n,i;t=t.replace(/[\n\r]/g," ");var r=oo.typeStr.exec(t);if(-1!==t.search("EMPTY")&&(r=oo.emptyTypeStr.exec(t),r[2]=void 0),r&&(n=r[1].toLowerCase(),i=r[2],uo[n]&&(e=uo[n].apply(this,[i]))),void 0===e)throw new Error("Could not parse WKT "+t);return e},write:function(t){return this.extractGeometry(t)},extractGeometry:function(t){var e=t.getGeometryType().toLowerCase();if(!ao[e])return null;var n,i=e.toUpperCase();return n=t.isEmpty()?i+" EMPTY":i+"("+ao[e].apply(this,[t])+")"}});var ao={coordinate:function(t){return t.x+" "+t.y},point:function(t){
return ao.coordinate.call(this,t.coordinates.coordinates[0])},multipoint:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.point.apply(this,[t.geometries[n]])+")");return e.join(",")},linestring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},linearring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},multilinestring:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.geometries[n]])+")");return e.join(",")},polygon:function(t){var e=[];e.push("("+ao.linestring.apply(this,[t.shell])+")");for(var n=0,i=t.holes.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.holes[n]])+")");return e.join(",")},multipolygon:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.polygon.apply(this,[t.geometries[n]])+")");return e.join(",")},geometrycollection:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push(this.extractGeometry(t.geometries[n]));return e.join(",")}},uo={point:function(t){if(void 0===t)return this.geometryFactory.createPoint();var e=t.trim().split(oo.spaces);return this.geometryFactory.createPoint(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])))},multipoint:function(t){if(void 0===t)return this.geometryFactory.createMultiPoint();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.point.apply(this,[e]));return this.geometryFactory.createMultiPoint(i)},linestring:function(t){if(void 0===t)return this.geometryFactory.createLineString();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i)},linearring:function(t){if(void 0===t)return this.geometryFactory.createLinearRing();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i)},multilinestring:function(t){if(void 0===t)return this.geometryFactory.createMultiLineString();for(var e,n=t.trim().split(oo.parenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.linestring.apply(this,[e]));return this.geometryFactory.createMultiLineString(i)},polygon:function(t){if(void 0===t)return this.geometryFactory.createPolygon();for(var e,n,i,r,s=t.trim().split(oo.parenComma),o=[],a=0,u=s.length;u>a;++a)e=s[a].replace(oo.trimParens,"$1"),n=uo.linestring.apply(this,[e]),i=this.geometryFactory.createLinearRing(n.points),0===a?r=i:o.push(i);return this.geometryFactory.createPolygon(r,o)},multipolygon:function(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();for(var e,n=t.trim().split(oo.doubleParenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.polygon.apply(this,[e]));return this.geometryFactory.createMultiPolygon(i)},geometrycollection:function(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();t=t.replace(/,\s*([A-Za-z])/g,"|$1");for(var e=t.trim().split("|"),n=[],i=0,r=e.length;r>i;++i)n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n)}};e(se.prototype,{write:function(t){return this.parser.write(t)}}),e(se,{toLineString:function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}),e(oe.prototype,{getIndexAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intLineIndex[t][e]},getTopologySummary:function(){var t=new P;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()},computeIntersection:function(t,e,n,i){this.inputLines[0][0]=t,this.inputLines[0][1]=e,this.inputLines[1][0]=n,this.inputLines[1][1]=i,this.result=this.computeIntersect(t,e,n,i)},getIntersectionNum:function(){return this.result},computeIntLineIndex:function(){if(0===arguments.length)null===this.intLineIndex&&(this.intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0],e=this.getEdgeDistance(t,0),n=this.getEdgeDistance(t,1);e>n?(this.intLineIndex[t][0]=0,this.intLineIndex[t][1]=1):(this.intLineIndex[t][0]=1,this.intLineIndex[t][1]=0)}},isProper:function(){return this.hasIntersection()&&this._isProper},setPrecisionModel:function(t){this.precisionModel=t},isInteriorIntersection:function(){if(0===arguments.length)return this.isInteriorIntersection(0)?!0:!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this.result;e++)if(!this.intPt[e].equals2D(this.inputLines[t][0])&&!this.intPt[e].equals2D(this.inputLines[t][1]))return!0;return!1}},getIntersection:function(t){return this.intPt[t]},isEndPoint:function(){return this.hasIntersection()&&!this._isProper},hasIntersection:function(){return this.result!==oe.NO_INTERSECTION},getEdgeDistance:function(t,e){var n=oe.computeEdgeDistance(this.intPt[e],this.inputLines[t][0],this.inputLines[t][1]);return n},isCollinear:function(){return this.result===oe.COLLINEAR_INTERSECTION},toString:function(){return se.toLineString(this.inputLines[0][0],this.inputLines[0][1])+" - "+se.toLineString(this.inputLines[1][0],this.inputLines[1][1])+this.getTopologySummary()},getEndpoint:function(t,e){return this.inputLines[t][e]},isIntersection:function(t){for(var e=0;e<this.result;e++)if(this.intPt[e].equals2D(t))return!0;return!1},getIntersectionAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intPt[this.intLineIndex[t][e]]},interfaces_:function(){return[]},getClass:function(){return oe}}),oe.computeEdgeDistance=function(t,e,n){var i=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),s=-1;if(t.equals(e))s=0;else if(t.equals(n))s=i>r?i:r;else{var o=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);s=i>r?o:a,0!==s||t.equals(e)||(s=Math.max(o,a))}return f.isTrue(!(0===s&&!t.equals(e)),"Bad distance calculation"),s},oe.nonRobustComputeEdgeDistance=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=Math.sqrt(i*i+r*r);return f.isTrue(!(0===s&&!t.equals(e)),"Invalid distance calculation"),s},oe.DONT_INTERSECT=0,oe.DO_INTERSECT=1,oe.COLLINEAR=2,oe.NO_INTERSECTION=0,oe.POINT_INTERSECTION=1,oe.COLLINEAR_INTERSECTION=2,h(ae,oe),e(ae.prototype,{isInSegmentEnvelopes:function(t){var e=new C(this.inputLines[0][0],this.inputLines[0][1]),n=new C(this.inputLines[1][0],this.inputLines[1][1]);return e.contains(t)&&n.contains(t)},computeIntersection:function(){if(3!==arguments.length)return oe.prototype.computeIntersection.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2];return this._isProper=!1,C.intersects(e,n,t)&&0===he.orientationIndex(e,n,t)&&0===he.orientationIndex(n,e,t)?(this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this.result=oe.POINT_INTERSECTION,null):void(this.result=oe.NO_INTERSECTION)},normalizeToMinimum:function(t,e,n,i,r){r.x=this.smallestInAbsValue(t.x,e.x,n.x,i.x),r.y=this.smallestInAbsValue(t.y,e.y,n.y,i.y),t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},safeHCoordinateIntersection:function(t,e,n,i){var r=null;try{r=F.intersection(t,e,n,i)}catch(s){if(!(s instanceof w))throw s;r=ae.nearestEndpoint(t,e,n,i)}finally{}return r},intersection:function(t,e,n,i){var r=this.intersectionWithNormalization(t,e,n,i);return this.isInSegmentEnvelopes(r)||(r=new g(ae.nearestEndpoint(t,e,n,i))),null!==this.precisionModel&&this.precisionModel.makePrecise(r),r},smallestInAbsValue:function(t,e,n,i){var r=t,s=Math.abs(r);return Math.abs(e)<s&&(r=e,s=Math.abs(e)),Math.abs(n)<s&&(r=n,s=Math.abs(n)),Math.abs(i)<s&&(r=i),r},checkDD:function(t,e,n,i,r){var s=M.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(s);A.out.println("DD in env = "+o+"  --------------------- "+s),r.distance(s)>1e-4&&A.out.println("Distance = "+r.distance(s))},intersectionWithNormalization:function(t,e,n,i){var r=new g(t),s=new g(e),o=new g(n),a=new g(i),u=new g;this.normalizeToEnvCentre(r,s,o,a,u);var l=this.safeHCoordinateIntersection(r,s,o,a);return l.x+=u.x,l.y+=u.y,l},computeCollinearIntersection:function(t,e,n,i){var r=C.intersects(t,e,n),s=C.intersects(t,e,i),o=C.intersects(n,i,t),a=C.intersects(n,i,e);return r&&s?(this.intPt[0]=n,this.intPt[1]=i,oe.COLLINEAR_INTERSECTION):o&&a?(this.intPt[0]=t,this.intPt[1]=e,oe.COLLINEAR_INTERSECTION):r&&o?(this.intPt[0]=n,this.intPt[1]=t,!n.equals(t)||s||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):r&&a?(this.intPt[0]=n,this.intPt[1]=e,!n.equals(e)||s||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&o?(this.intPt[0]=i,this.intPt[1]=t,!i.equals(t)||r||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&a?(this.intPt[0]=i,this.intPt[1]=e,!i.equals(e)||r||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):oe.NO_INTERSECTION},normalizeToEnvCentre:function(t,e,n,i,r){var s=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,a=t.x>e.x?t.x:e.x,u=t.y>e.y?t.y:e.y,l=n.x<i.x?n.x:i.x,h=n.y<i.y?n.y:i.y,c=n.x>i.x?n.x:i.x,f=n.y>i.y?n.y:i.y,g=s>l?s:l,d=c>a?a:c,p=o>h?o:h,v=f>u?u:f,m=(g+d)/2,y=(p+v)/2;r.x=m,r.y=y,t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},computeIntersect:function(t,e,n,i){if(this._isProper=!1,!C.intersects(t,e,n,i))return oe.NO_INTERSECTION;var r=he.orientationIndex(t,e,n),s=he.orientationIndex(t,e,i);if(r>0&&s>0||0>r&&0>s)return oe.NO_INTERSECTION;var o=he.orientationIndex(n,i,t),a=he.orientationIndex(n,i,e);if(o>0&&a>0||0>o&&0>a)return oe.NO_INTERSECTION;var u=0===r&&0===s&&0===o&&0===a;return u?this.computeCollinearIntersection(t,e,n,i):(0===r||0===s||0===o||0===a?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this.intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this.intPt[0]=e:0===r?this.intPt[0]=new g(n):0===s?this.intPt[0]=new g(i):0===o?this.intPt[0]=new g(t):0===a&&(this.intPt[0]=new g(e))):(this._isProper=!0,this.intPt[0]=this.intersection(t,e,n,i)),oe.POINT_INTERSECTION)},interfaces_:function(){return[]},getClass:function(){return ae}}),ae.nearestEndpoint=function(t,e,n,i){var r=t,s=he.distancePointLine(t,n,i),o=he.distancePointLine(e,n,i);return s>o&&(s=o,r=e),o=he.distancePointLine(n,t,e),s>o&&(s=o,r=n),o=he.distancePointLine(i,t,e),s>o&&(s=o,r=i),r},e(ue.prototype,{interfaces_:function(){return[]},getClass:function(){return ue}}),ue.orientationIndex=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-e.x,o=n.y-e.y;return ue.signOfDet2x2(i,r,s,o)},ue.signOfDet2x2=function(t,e,n,i){var r=null,s=null,o=null,a=0;if(r=1,0===t||0===i)return 0===e||0===n?0:e>0?n>0?-r:r:n>0?r:-r;if(0===e||0===n)return i>0?t>0?r:-r:t>0?-r:r;if(e>0?i>0?i>=e||(r=-r,s=t,t=n,n=s,s=e,e=i,i=s):-i>=e?(r=-r,n=-n,i=-i):(s=t,t=-n,n=s,s=e,e=-i,i=s):i>0?i>=-e?(r=-r,t=-t,e=-e):(s=-t,t=n,n=s,s=-e,e=i,i=s):e>=i?(t=-t,e=-e,n=-n,i=-i):(r=-r,s=-t,t=-n,n=s,s=-e,e=-i,i=s),t>0){if(!(n>0))return r;if(!(n>=t))return r}else{if(n>0)return-r;if(!(t>=n))return-r;r=-r,t=-t,n=-n}for(;;){if(a+=1,o=Math.floor(n/t),n-=o*t,i-=o*e,0>i)return-r;if(i>e)return r;if(t>n+n){if(i+i>e)return r}else{if(e>i+i)return-r;n=t-n,i=e-i,r=-r}if(0===i)return 0===n?0:-r;if(0===n)return r;if(o=Math.floor(t/n),t-=o*n,e-=o*i,0>e)return r;if(e>i)return-r;if(n>t+t){if(e+e>i)return-r}else{if(i>e+e)return r;t=n-t,e=i-e,r=-r}if(0===e)return 0===t?0:r;if(0===t)return-r}},e(le.prototype,{countSegment:function(t,e){if(t.x<this.p.x&&e.x<this.p.x)return null;if(this.p.x===e.x&&this.p.y===e.y)return this.isPointOnSegment=!0,null;if(t.y===this.p.y&&e.y===this.p.y){var n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this.p.x>=n&&this.p.x<=i&&(this.isPointOnSegment=!0),null}if(t.y>this.p.y&&e.y<=this.p.y||e.y>this.p.y&&t.y<=this.p.y){var r=t.x-this.p.x,s=t.y-this.p.y,o=e.x-this.p.x,a=e.y-this.p.y,u=ue.signOfDet2x2(r,s,o,a);if(0===u)return this.isPointOnSegment=!0,null;s>a&&(u=-u),u>0&&this.crossingCount++}},isPointInPolygon:function(){return this.getLocation()!==L.EXTERIOR},getLocation:function(){return this.isPointOnSegment?L.BOUNDARY:this.crossingCount%2===1?L.INTERIOR:L.EXTERIOR},isOnSegment:function(){return this.isPointOnSegment},interfaces_:function(){return[]},getClass:function(){return le}}),le.locatePointInRing=function(){if(arguments[0]instanceof g&&R(arguments[1],D)){for(var t=arguments[0],e=arguments[1],n=new le(t),i=new g,r=new g,s=1;s<e.size();s++)if(e.getCoordinate(s,i),e.getCoordinate(s-1,r),n.countSegment(i,r),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){for(var o=arguments[0],a=arguments[1],n=new le(o),s=1;s<a.length;s++){var i=a[s],r=a[s-1];if(n.countSegment(i,r),n.isOnSegment())return n.getLocation()}return n.getLocation()}},e(he.prototype,{interfaces_:function(){return[]},getClass:function(){return he}}),he.orientationIndex=function(t,e,n){return M.orientationIndex(t,e,n)},he.signedArea=function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,i=1;i<t.length-1;i++){var r=t[i].x-n,s=t[i+1].y,o=t[i-1].y;e+=r*(o-s)}return e/2}if(R(arguments[0],D)){var a=arguments[0],u=a.size();if(3>u)return 0;var l=new g,h=new g,c=new g;a.getCoordinate(0,h),a.getCoordinate(1,c);var n=h.x;c.x-=n;for(var e=0,i=1;u-1>i;i++)l.y=h.y,h.x=c.x,h.y=c.y,a.getCoordinate(i+1,c),c.x-=n,e+=h.x*(l.y-c.y);return e/2}},he.distanceLineLine=function(t,e,n,i){if(t.equals(e))return he.distancePointLine(t,n,i);if(n.equals(i))return he.distancePointLine(i,t,e);var r=!1;if(C.intersects(t,e,n,i)){var s=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===s)r=!0;else{var o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),a=(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y),u=a/s,l=o/s;(0>l||l>1||0>u||u>1)&&(r=!0)}}else r=!0;return r?T.min(he.distancePointLine(t,n,i),he.distancePointLine(e,n,i),he.distancePointLine(n,t,e),he.distancePointLine(i,t,e)):0},he.isPointInRing=function(t,e){return he.locatePointInRing(t,e)!==L.EXTERIOR},he.computeLength=function(t){var e=t.size();if(1>=e)return 0;var n=0,i=new g;t.getCoordinate(0,i);for(var r=i.x,s=i.y,o=1;e>o;o++){t.getCoordinate(o,i);var a=i.x,u=i.y,l=a-r,h=u-s;n+=Math.sqrt(l*l+h*h),r=a,s=u}return n},he.isCCW=function(t){var e=t.length-1;if(3>e)throw new i("Ring has fewer than 4 points, so orientation cannot be determined");for(var n=t[0],r=0,s=1;e>=s;s++){var o=t[s];o.y>n.y&&(n=o,r=s)}var a=r;do a-=1,0>a&&(a=e);while(t[a].equals2D(n)&&a!==r);var u=r;do u=(u+1)%e;while(t[u].equals2D(n)&&u!==r);var l=t[a],h=t[u];if(l.equals2D(n)||h.equals2D(n)||l.equals2D(h))return!1;var c=he.computeOrientation(l,n,h),f=!1;return f=0===c?l.x>h.x:c>0},he.locatePointInRing=function(t,e){return le.locatePointInRing(t,e)},he.distancePointLinePerpendicular=function(t,e,n){var i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)},he.computeOrientation=function(t,e,n){return he.orientationIndex(t,e,n)},he.distancePointLine=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(0===e.length)throw new i("Line array must contain at least one vertex");for(var n=t.distance(e[0]),r=0;r<e.length-1;r++){var s=he.distancePointLine(t,e[r],e[r+1]);n>s&&(n=s)}return n}if(3===arguments.length){var o=arguments[0],a=arguments[1],u=arguments[2];if(a.x===u.x&&a.y===u.y)return o.distance(a);var l=(u.x-a.x)*(u.x-a.x)+(u.y-a.y)*(u.y-a.y),h=((o.x-a.x)*(u.x-a.x)+(o.y-a.y)*(u.y-a.y))/l;if(0>=h)return o.distance(a);if(h>=1)return o.distance(u);var c=((a.y-o.y)*(u.x-a.x)-(a.x-o.x)*(u.y-a.y))/l;return Math.abs(c)*Math.sqrt(l)}},he.isOnLine=function(t,e){for(var n=new ae,i=1;i<e.length;i++){var r=e[i-1],s=e[i];if(n.computeIntersection(t,r,s),n.hasIntersection())return!0}return!1},he.CLOCKWISE=-1,he.RIGHT=he.CLOCKWISE,he.COUNTERCLOCKWISE=1,he.LEFT=he.COUNTERCLOCKWISE,he.COLLINEAR=0,he.STRAIGHT=he.COLLINEAR,e(ce.prototype,{minX:function(){return Math.min(this.p0.x,this.p1.x)},orientationIndex:function(){if(arguments[0]instanceof ce){var t=arguments[0],e=he.orientationIndex(this.p0,this.p1,t.p0),n=he.orientationIndex(this.p0,this.p1,t.p1);return e>=0&&n>=0?Math.max(e,n):0>=e&&0>=n?Math.max(e,n):0}if(arguments[0]instanceof g){var i=arguments[0];return he.orientationIndex(this.p0,this.p1,i)}},toGeometry:function(t){return t.createLineString([this.p0,this.p1])},isVertical:function(){return this.p0.x===this.p1.x},equals:function(t){if(!(t instanceof ce))return!1;var e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)},intersection:function(t){var e=new ae;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null},project:function(){if(arguments[0]instanceof g){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);var e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ce){var i=arguments[0],r=this.projectionFactor(i.p0),s=this.projectionFactor(i.p1);if(r>=1&&s>=1)return null;if(0>=r&&0>=s)return null;var o=this.project(i.p0);0>r&&(o=this.p0),r>1&&(o=this.p1);var a=this.project(i.p1);return 0>s&&(a=this.p0),s>1&&(a=this.p1),new ce(o,a)}},normalize:function(){this.p1.compareTo(this.p0)<0&&this.reverse()},angle:function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},getCoordinate:function(t){return 0===t?this.p0:this.p1},distancePerpendicular:function(t){return he.distancePointLinePerpendicular(t,this.p0,this.p1)},minY:function(){return Math.min(this.p0.y,this.p1.y)},midPoint:function(){return ce.midPoint(this.p0,this.p1)},projectionFactor:function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(0>=i)return r.NaN;var s=((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i;return s},closestPoints:function(t){var e=this.intersection(t);if(null!==e)return[e,e];var n=new Array(2).fill(null),i=r.MAX_VALUE,s=null,o=this.closestPoint(t.p0);i=o.distance(t.p0),n[0]=o,n[1]=t.p0;var a=this.closestPoint(t.p1);s=a.distance(t.p1),i>s&&(i=s,n[0]=a,n[1]=t.p1);var u=t.closestPoint(this.p0);s=u.distance(this.p0),i>s&&(i=s,n[0]=this.p0,n[1]=u);var l=t.closestPoint(this.p1);return s=l.distance(this.p1),i>s&&(i=s,n[0]=this.p1,n[1]=l),n},closestPoint:function(t){var e=this.projectionFactor(t);if(e>0&&1>e)return this.project(t);var n=this.p0.distance(t),i=this.p1.distance(t);return i>n?this.p0:this.p1},maxX:function(){return Math.max(this.p0.x,this.p1.x)},getLength:function(){return this.p0.distance(this.p1)},compareTo:function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)},reverse:function(){var t=this.p0;this.p0=this.p1,this.p1=t},equalsTopo:function(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)},lineIntersection:function(t){try{var e=F.intersection(this.p0,this.p1,t.p0,t.p1);return e}catch(t){if(!(t instanceof w))throw t}finally{}return null},maxY:function(){return Math.max(this.p0.y,this.p1.y)},pointAlongOffset:function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y,o=Math.sqrt(r*r+s*s),a=0,u=0;if(0!==e){if(0>=o)throw new IllegalStateException("Cannot compute offset from zero-length line segment");a=e*r/o,u=e*s/o}var l=n-u,h=i+a,c=new g(l,h);return c},setCoordinates:function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y}},segmentFraction:function(t){var e=this.projectionFactor(t);return 0>e?e=0:(e>1||r.isNaN(e))&&(e=1),e},toString:function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},isHorizontal:function(){return this.p0.y===this.p1.y},distance:function(){if(arguments[0]instanceof ce){var t=arguments[0];return he.distanceLineLine(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){var e=arguments[0];return he.distancePointLine(e,this.p0,this.p1)}},pointAlong:function(t){var e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e},hashCode:function(){var t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=java.lang.Double.doubleToLongBits(this.p1.x);n^=31*java.lang.Double.doubleToLongBits(this.p1.y);var i=Math.trunc(n)^Math.trunc(n>>32);return e^i},interfaces_:function(){return[s,u]},getClass:function(){return ce}}),ce.midPoint=function(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)},ce.serialVersionUID=0x2d2172135f411c00,e(fe.prototype,{isIntersects:function(){return!this.isDisjoint()},isCovers:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},isCoveredBy:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},set:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.matrix[n][i]=lt.toDimensionValue(t.charAt(e))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]=o}},isContains:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},setAtLeast:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,lt.toDimensionValue(t.charAt(e)))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]<o&&(this.matrix[r][s]=o)}},setAtLeastIfValid:function(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)},isWithin:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},isTouches:function(t,e){return t>e?this.isTouches(e,t):t===lt.A&&e===lt.A||t===lt.L&&e===lt.L||t===lt.L&&e===lt.A||t===lt.P&&e===lt.A||t===lt.P&&e===lt.L?this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&(fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY])):!1},isOverlaps:function(t,e){return t===lt.P&&e===lt.P||t===lt.A&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?1===this.matrix[L.INTERIOR][L.INTERIOR]&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):!1},isEquals:function(t,e){return t!==e?!1:fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},toString:function(){for(var t=new P("123456789"),e=0;3>e;e++)for(var n=0;3>n;n++)t.setCharAt(3*e+n,lt.toDimensionSymbol(this.matrix[e][n]));return t.toString()},setAll:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.matrix[e][n]=t},get:function(t,e){return this.matrix[t][e]},transpose:function(){var t=this.matrix[1][0];return this.matrix[1][0]=this.matrix[0][1],this.matrix[0][1]=t,t=this.matrix[2][0],this.matrix[2][0]=this.matrix[0][2],this.matrix[0][2]=t,t=this.matrix[2][1],this.matrix[2][1]=this.matrix[1][2],this.matrix[1][2]=t,this},matches:function(t){if(9!==t.length)throw new i("Should be length 9: "+t);for(var e=0;3>e;e++)for(var n=0;3>n;n++)if(!fe.matches(this.matrix[e][n],t.charAt(3*e+n)))return!1;return!0},add:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.setAtLeast(e,n,t.get(e,n))},isDisjoint:function(){return this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.INTERIOR][L.BOUNDARY]===lt.FALSE&&this.matrix[L.BOUNDARY][L.INTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.BOUNDARY]===lt.FALSE},isCrosses:function(t,e){return t===lt.P&&e===lt.L||t===lt.P&&e===lt.A||t===lt.L&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]):t===lt.L&&e===lt.P||t===lt.A&&e===lt.P||t===lt.A&&e===lt.L?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?0===this.matrix[L.INTERIOR][L.INTERIOR]:!1},interfaces_:function(){return[o]},getClass:function(){return fe}}),fe.matches=function(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){var t=arguments[0],e=arguments[1];return e===lt.SYM_DONTCARE?!0:e===lt.SYM_TRUE&&(t>=0||t===lt.TRUE)?!0:e===lt.SYM_FALSE&&t===lt.FALSE?!0:e===lt.SYM_P&&t===lt.P?!0:e===lt.SYM_L&&t===lt.L?!0:e===lt.SYM_A&&t===lt.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){var n=arguments[0],i=arguments[1],r=new fe(n);return r.matches(i)}},fe.isTrue=function(t){return t>=0||t===lt.TRUE};var lo=Object.freeze({Coordinate:g,CoordinateList:N,Envelope:C,LineSegment:ce,GeometryFactory:ie,Geometry:B,Point:Lt,LineString:St,LinearRing:bt,Polygon:Tt,GeometryCollection:ft,MultiPoint:Pt,MultiLineString:gt,MultiPolygon:Ot,Dimension:lt,IntersectionMatrix:fe});e(ge.prototype,{addPoint:function(t){this.ptCount+=1,this.ptCentSum.x+=t.x,this.ptCentSum.y+=t.y},setBasePoint:function(t){null===this.areaBasePt&&(this.areaBasePt=t)},addLineSegments:function(t){for(var e=0,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);if(0!==i){e+=i;var r=(t[n].x+t[n+1].x)/2;this.lineCentSum.x+=i*r;var s=(t[n].y+t[n+1].y)/2;this.lineCentSum.y+=i*s}}this.totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])},addHole:function(t){for(var e=he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},getCentroid:function(){var t=new g;if(Math.abs(this.areasum2)>0)t.x=this.cg3.x/3/this.areasum2,t.y=this.cg3.y/3/this.areasum2;else if(this.totalLength>0)t.x=this.lineCentSum.x/this.totalLength,t.y=this.lineCentSum.y/this.totalLength;else{if(!(this.ptCount>0))return null;t.x=this.ptCentSum.x/this.ptCount,t.y=this.ptCentSum.y/this.ptCount}return t},addShell:function(t){t.length>0&&this.setBasePoint(t[0]);for(var e=!he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},addTriangle:function(t,e,n,i){var r=i?1:-1;ge.centroid3(t,e,n,this.triangleCent3);var s=ge.area2(t,e,n);this.cg3.x+=r*s*this.triangleCent3.x,this.cg3.y+=r*s*this.triangleCent3.y,this.areasum2+=r*s},add:function(){if(arguments[0]instanceof Tt){var t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(var e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof B){var n=arguments[0];if(n.isEmpty())return null;if(n instanceof Lt)this.addPoint(n.getCoordinate());else if(n instanceof St)this.addLineSegments(n.getCoordinates());else if(n instanceof Tt){var i=n;this.add(i)}else if(n instanceof ft)for(var r=n,e=0;e<r.getNumGeometries();e++)this.add(r.getGeometryN(e))}},interfaces_:function(){return[]},getClass:function(){return ge}}),ge.area2=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)},ge.centroid3=function(t,e,n,i){return i.x=t.x+e.x+n.x,i.y=t.y+e.y+n.y,null},ge.getCentroid=function(t){var e=new ge(t);return e.getCentroid()},de.prototype=new Error,de.prototype.name="EmptyStackException",pe.prototype=new y,pe.prototype.add=function(t){return this.array_.push(t),!0},pe.prototype.get=function(t){if(0>t||t>=this.size())throw new IndexOutOfBoundsException;return this.array_[t]},pe.prototype.push=function(t){return this.array_.push(t),t},pe.prototype.pop=function(t){if(0===this.array_.length)throw new de;return this.array_.pop()},pe.prototype.peek=function(){if(0===this.array_.length)throw new de;return this.array_[this.array_.length-1]},pe.prototype.empty=function(){return 0===this.array_.length},pe.prototype.isEmpty=function(){return this.empty()},pe.prototype.search=function(t){return this.array_.indexOf(t)},pe.prototype.size=function(){return this.array_.length},pe.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},e(ve.prototype,{filter:function(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))},getCoordinates:function(){var t=new Array(this.list.size()).fill(null);return this.list.toArray(t)},interfaces_:function(){return[z]},getClass:function(){return ve}}),ve.filterCoordinates=function(t){for(var e=new ve,n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()},e(me.prototype,{preSort:function(t){for(var e=null,n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ut.sort(t,1,t.length,new ye(t[0])),t},computeOctRing:function(t){var e=this.computeOctPts(t),n=new N;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())},lineOrPolygon:function(t){if(t=this.cleanRing(t),3===t.length)return this.geomFactory.createLineString([t[0],t[1]]);var e=this.geomFactory.createLinearRing(t);return this.geomFactory.createPolygon(e,null)},cleanRing:function(t){f.equals(t[0],t[t.length-1]);for(var e=new I,n=null,i=0;i<=t.length-2;i++){var r=t[i],s=t[i+1];r.equals(s)||null!==n&&this.isBetween(n,r,s)||(e.add(r),n=r)}e.add(t[t.length-1]);var o=new Array(e.size()).fill(null);return e.toArray(o)},isBetween:function(t,e,n){if(0!==he.computeOrientation(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1},reduce:function(t){var e=this.computeOctRing(t);if(null===e)return t;for(var n=new at,i=0;i<e.length;i++)n.add(e[i]);for(var i=0;i<t.length;i++)he.isPointInRing(t[i],e)||n.add(t[i]);var r=H.toCoordinateArray(n);return r.length<3?this.padArray3(r):r},getConvexHull:function(){if(0===this.inputPts.length)return this.geomFactory.createGeometryCollection(null);if(1===this.inputPts.length)return this.geomFactory.createPoint(this.inputPts[0]);if(2===this.inputPts.length)return this.geomFactory.createLineString(this.inputPts);var t=this.inputPts;this.inputPts.length>50&&(t=this.reduce(this.inputPts));var e=this.preSort(t),n=this.grahamScan(e),i=this.toCoordinateArray(n);return this.lineOrPolygon(i)},padArray3:function(t){for(var e=new Array(3).fill(null),n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e},computeOctPts:function(t){for(var e=new Array(8).fill(null),n=0;n<e.length;n++)e[n]=t[0];for(var i=1;i<t.length;i++)t[i].x<e[0].x&&(e[0]=t[i]),t[i].x-t[i].y<e[1].x-e[1].y&&(e[1]=t[i]),t[i].y>e[2].y&&(e[2]=t[i]),t[i].x+t[i].y>e[3].x+e[3].y&&(e[3]=t[i]),t[i].x>e[4].x&&(e[4]=t[i]),t[i].x-t[i].y>e[5].x-e[5].y&&(e[5]=t[i]),t[i].y<e[6].y&&(e[6]=t[i]),t[i].x+t[i].y<e[7].x+e[7].y&&(e[7]=t[i]);return e},toCoordinateArray:function(t){for(var e=new Array(t.size()).fill(null),n=0;n<t.size();n++){var i=t.get(n);e[n]=i}return e},grahamScan:function(t){var e=null,n=new pe;e=n.push(t[0]),e=n.push(t[1]),e=n.push(t[2]);for(var i=3;i<t.length;i++){for(e=n.pop();!n.empty()&&he.computeOrientation(n.peek(),e,t[i])>0;)e=n.pop();e=n.push(e),e=n.push(t[i])}return e=n.push(t[0]),n},interfaces_:function(){return[]},getClass:function(){return me}}),me.extractCoordinates=function(t){var e=new ve;return t.apply(e),e.getCoordinates()},e(ye.prototype,{compare:function(t,e){var n=t,i=e;return ye.polarCompare(this.origin,n,i)},interfaces_:function(){return[a]},getClass:function(){return ye}}),ye.polarCompare=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-t.x,o=n.y-t.y,a=he.computeOrientation(t,e,n);
if(a===he.COUNTERCLOCKWISE)return 1;if(a===he.CLOCKWISE)return-1;var u=i*i+r*r,l=s*s+o*o;return l>u?-1:u>l?1:0},me.RadialComparator=ye,e(xe.prototype,{transformPoint:function(t,e){return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))},transformPolygon:function(t,e){var n=!0,i=this.transformLinearRing(t.getExteriorRing(),t);null!==i&&i instanceof bt&&!i.isEmpty()||(n=!1);for(var r=new I,s=0;s<t.getNumInteriorRing();s++){var o=this.transformLinearRing(t.getInteriorRingN(s),t);null===o||o.isEmpty()||(o instanceof bt||(n=!1),r.add(o))}if(n)return this.factory.createPolygon(i,r.toArray([]));var a=new I;return null!==i&&a.add(i),a.addAll(r),this.factory.buildGeometry(a)},createCoordinateSequence:function(t){return this.factory.getCoordinateSequenceFactory().create(t)},getInputGeometry:function(){return this.inputGeom},transformMultiLineString:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformLineString(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformCoordinates:function(t,e){return this.copy(t)},transformLineString:function(t,e){return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))},transformMultiPoint:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPoint(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformMultiPolygon:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPolygon(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},copy:function(t){return t.copy()},transformGeometryCollection:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transform(t.getGeometryN(i));null!==r&&(this.pruneEmptyGeometry&&r.isEmpty()||n.add(r))}return this.preserveGeometryCollectionType?this.factory.createGeometryCollection(ie.toGeometryArray(n)):this.factory.buildGeometry(n)},transform:function(t){if(this.inputGeom=t,this.factory=t.getFactory(),t instanceof Lt)return this.transformPoint(t,null);if(t instanceof Pt)return this.transformMultiPoint(t,null);if(t instanceof bt)return this.transformLinearRing(t,null);if(t instanceof St)return this.transformLineString(t,null);if(t instanceof gt)return this.transformMultiLineString(t,null);if(t instanceof Tt)return this.transformPolygon(t,null);if(t instanceof Ot)return this.transformMultiPolygon(t,null);if(t instanceof ft)return this.transformGeometryCollection(t,null);throw new i("Unknown Geometry subtype: "+t.getClass().getName())},transformLinearRing:function(t,e){var n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this.factory.createLinearRing(null);var i=n.size();return i>0&&4>i&&!this.preserveType?this.factory.createLineString(n):this.factory.createLinearRing(n)},interfaces_:function(){return[]},getClass:function(){return xe}}),e(Ee.prototype,{snapVertices:function(t,e){for(var n=this._isClosed?t.size()-1:t.size(),i=0;n>i;i++){var r=t.get(i),s=this.findSnapForVertex(r,e);null!==s&&(t.set(i,new g(s)),0===i&&this._isClosed&&t.set(t.size()-1,new g(s)))}},findSnapForVertex:function(t,e){for(var n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this.snapTolerance)return e[n]}return null},snapTo:function(t){var e=new N(this.srcPts);this.snapVertices(e,t),this.snapSegments(e,t);var n=e.toCoordinateArray();return n},snapSegments:function(t,e){if(0===e.length)return null;var n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(var i=0;n>i;i++){var r=e[i],s=this.findSegmentIndexToSnap(r,t);s>=0&&t.add(s+1,new g(r),!1)}},findSegmentIndexToSnap:function(t,e){for(var n=r.MAX_VALUE,i=-1,s=0;s<e.size()-1;s++){if(this.seg.p0=e.get(s),this.seg.p1=e.get(s+1),this.seg.p0.equals2D(t)||this.seg.p1.equals2D(t)){if(this.allowSnappingToSourceVertices)continue;return-1}var o=this.seg.distance(t);o<this.snapTolerance&&n>o&&(n=o,i=s)}return i},setAllowSnappingToSourceVertices:function(t){this.allowSnappingToSourceVertices=t},interfaces_:function(){return[]},getClass:function(){return Ee}}),Ee.isClosed=function(t){return t.length<=1?!1:t[0].equals2D(t[t.length-1])},e(Ie.prototype,{snapTo:function(t,e){var n=this.extractTargetCoordinates(t),i=new Ne(e,n);return i.transform(this.srcGeom)},snapToSelf:function(t,e){var n=this.extractTargetCoordinates(this.srcGeom),i=new Ne(t,n,!0),r=i.transform(this.srcGeom),s=r;return e&&R(s,Rt)&&(s=r.buffer(0)),s},computeSnapTolerance:function(t){var e=this.computeMinimumSegmentLength(t),n=e/10;return n},extractTargetCoordinates:function(t){for(var e=new at,n=t.getCoordinates(),i=0;i<n.length;i++)e.add(n[i]);return e.toArray(new Array(0).fill(null))},computeMinimumSegmentLength:function(t){for(var e=r.MAX_VALUE,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);e>i&&(e=i)}return e},interfaces_:function(){return[]},getClass:function(){return Ie}}),Ie.snap=function(t,e,n){var i=new Array(2).fill(null),r=new Ie(t);i[0]=r.snapTo(e,n);var s=new Ie(e);return i[1]=s.snapTo(i[0],n),i},Ie.computeOverlaySnapTolerance=function(){if(1===arguments.length){var t=arguments[0],e=Ie.computeSizeBasedSnapTolerance(t),n=t.getPrecisionModel();if(n.getType()===ee.FIXED){var i=1/n.getScale()*2/1.415;i>e&&(e=i)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1];return Math.min(Ie.computeOverlaySnapTolerance(r),Ie.computeOverlaySnapTolerance(s))}},Ie.computeSizeBasedSnapTolerance=function(t){var e=t.getEnvelopeInternal(),n=Math.min(e.getHeight(),e.getWidth()),i=n*Ie.SNAP_PRECISION_FACTOR;return i},Ie.snapToSelf=function(t,e,n){var i=new Ie(t);return i.snapToSelf(e,n)},Ie.SNAP_PRECISION_FACTOR=1e-9,h(Ne,xe),e(Ne.prototype,{snapLine:function(t,e){var n=new Ee(t,this.snapTolerance);return n.setAllowSnappingToSourceVertices(this.isSelfSnap),n.snapTo(e)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=this.snapLine(n,this.snapPts);return this.factory.getCoordinateSequenceFactory().create(i)},interfaces_:function(){return[]},getClass:function(){return Ne}}),e(Ce.prototype,{getCommon:function(){return r.longBitsToDouble(this.commonBits)},add:function(t){var e=r.doubleToLongBits(t);if(this.isFirst)return this.commonBits=e,this.commonSignExp=Ce.signExpBits(this.commonBits),this.isFirst=!1,null;var n=Ce.signExpBits(e);return n!==this.commonSignExp?(this.commonBits=0,null):(this.commonMantissaBitsCount=Ce.numCommonMostSigMantissaBits(this.commonBits,e),void(this.commonBits=Ce.zeroLowerBits(this.commonBits,64-(12+this.commonMantissaBitsCount))))},toString:function(){if(1===arguments.length){var t=arguments[0],e=r.longBitsToDouble(t),n=Long.toBinaryString(t),i="0000000000000000000000000000000000000000000000000000000000000000"+n,s=i.substring(i.length-64),o=s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]";return o}},interfaces_:function(){return[]},getClass:function(){return Ce}}),Ce.getBit=function(t,e){var n=1<<e;return 0!==(t&n)?1:0},Ce.signExpBits=function(t){return t>>52},Ce.zeroLowerBits=function(t,e){var n=(1<<e)-1,i=~n,r=t&i;return r},Ce.numCommonMostSigMantissaBits=function(t,e){for(var n=0,i=52;i>=0;i--){if(Ce.getBit(t,i)!==Ce.getBit(e,i))return n;n++}return 52},e(Se.prototype,{addCommonBits:function(t){var e=new Le(this.commonCoord);t.apply(e),t.geometryChanged()},removeCommonBits:function(t){if(0===this.commonCoord.x&&0===this.commonCoord.y)return t;var e=new g(this.commonCoord);e.x=-e.x,e.y=-e.y;var n=new Le(e);return t.apply(n),t.geometryChanged(),t},getCommonCoordinate:function(){return this.commonCoord},add:function(t){t.apply(this.ccFilter),this.commonCoord=this.ccFilter.getCommonCoordinate()},interfaces_:function(){return[]},getClass:function(){return Se}}),e(we.prototype,{filter:function(t){this.commonBitsX.add(t.x),this.commonBitsY.add(t.y)},getCommonCoordinate:function(){return new g(this.commonBitsX.getCommon(),this.commonBitsY.getCommon())},interfaces_:function(){return[z]},getClass:function(){return we}}),e(Le.prototype,{filter:function(t,e){var n=t.getOrdinate(e,0)+this.trans.x,i=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,i)},isDone:function(){return!1},isGeometryChanged:function(){return!0},interfaces_:function(){return[ct]},getClass:function(){return Le}}),Se.CommonCoordinateFilter=we,Se.Translater=Le,e(Re.prototype,{next:function(){if(this.atStart)return this.atStart=!1,Re.isAtomic(this.parent)&&this.index++,this.parent;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return this.subcollectionIterator.next();this.subcollectionIterator=null}if(this.index>=this.max)throw new x;var t=this.parent.getGeometryN(this.index++);return t instanceof ft?(this.subcollectionIterator=new Re(t),this.subcollectionIterator.next()):t},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){if(this.atStart)return!0;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return!0;this.subcollectionIterator=null}return!(this.index>=this.max)},interfaces_:function(){return[p]},getClass:function(){return Re}}),Re.isAtomic=function(t){return!(t instanceof ft)},e(Te.prototype,{locateInternal:function(){if(arguments[0]instanceof g&&arguments[1]instanceof Tt){var t=arguments[0],e=arguments[1];if(e.isEmpty())return L.EXTERIOR;var n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===L.EXTERIOR)return L.EXTERIOR;if(i===L.BOUNDARY)return L.BOUNDARY;for(var r=0;r<e.getNumInteriorRing();r++){var s=e.getInteriorRingN(r),o=this.locateInPolygonRing(t,s);if(o===L.INTERIOR)return L.EXTERIOR;if(o===L.BOUNDARY)return L.BOUNDARY}return L.INTERIOR}if(arguments[0]instanceof g&&arguments[1]instanceof St){var a=arguments[0],u=arguments[1];if(!u.getEnvelopeInternal().intersects(a))return L.EXTERIOR;var l=u.getCoordinates();return u.isClosed()||!a.equals(l[0])&&!a.equals(l[l.length-1])?he.isOnLine(a,l)?L.INTERIOR:L.EXTERIOR:L.BOUNDARY}if(arguments[0]instanceof g&&arguments[1]instanceof Lt){var h=arguments[0],c=arguments[1],f=c.getCoordinate();return f.equals2D(h)?L.INTERIOR:L.EXTERIOR}},locateInPolygonRing:function(t,e){return e.getEnvelopeInternal().intersects(t)?he.locatePointInRing(t,e.getCoordinates()):L.EXTERIOR},intersects:function(t,e){return this.locate(t,e)!==L.EXTERIOR},updateLocationInfo:function(t){t===L.INTERIOR&&(this.isIn=!0),t===L.BOUNDARY&&this.numBoundaries++},computeLocation:function(t,e){if(e instanceof Lt&&this.updateLocationInfo(this.locateInternal(t,e)),e instanceof St)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof Tt)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof gt)for(var n=e,i=0;i<n.getNumGeometries();i++){var r=n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,r))}else if(e instanceof Ot)for(var s=e,i=0;i<s.getNumGeometries();i++){var o=s.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,o))}else if(e instanceof ft)for(var a=new Re(e);a.hasNext();){var u=a.next();u!==e&&this.computeLocation(t,u)}},locate:function(t,e){return e.isEmpty()?L.EXTERIOR:e instanceof St?this.locateInternal(t,e):e instanceof Tt?this.locateInternal(t,e):(this.isIn=!1,this.numBoundaries=0,this.computeLocation(t,e),this.boundaryRule.isInBoundary(this.numBoundaries)?L.BOUNDARY:this.numBoundaries>0||this.isIn?L.INTERIOR:L.EXTERIOR)},interfaces_:function(){return[]},getClass:function(){return Te}}),e(Pe.prototype,{interfaces_:function(){return[]},getClass:function(){return Pe}}),Pe.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the octant for point ( "+t+", "+e+" )");var n=Math.abs(t),r=Math.abs(e);return t>=0?e>=0?n>=r?0:1:n>=r?7:6:e>=0?n>=r?3:2:n>=r?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1],a=o.x-s.x,u=o.y-s.y;if(0===a&&0===u)throw new i("Cannot compute the octant for two identical points "+s);return Pe.octant(a,u)}},e(be.prototype,{getCoordinates:function(){},size:function(){},getCoordinate:function(t){},isClosed:function(){},setData:function(t){},getData:function(){},interfaces_:function(){return[]},getClass:function(){return be}}),e(Oe.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:Pe.octant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},getData:function(){return this.data},toString:function(){return se.toLineString(new Gt(this.pts))},interfaces_:function(){return[be]},getClass:function(){return Oe}}),e(_e.prototype,{getBounds:function(){},interfaces_:function(){return[]},getClass:function(){return _e}}),e(Me.prototype,{getItem:function(){return this.item},getBounds:function(){return this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Me}}),e(De.prototype,{poll:function(){if(this.isEmpty())return null;var t=this.items.get(1);return this.items.set(1,this.items.get(this._size)),this._size-=1,this.reorder(1),t},size:function(){return this._size},reorder:function(t){for(var e=null,n=this.items.get(t);2*t<=this._size&&(e=2*t,e!==this._size&&this.items.get(e+1).compareTo(this.items.get(e))<0&&e++,this.items.get(e).compareTo(n)<0);t=e)this.items.set(t,this.items.get(e));this.items.set(t,n)},clear:function(){this._size=0,this.items.clear()},isEmpty:function(){return 0===this._size},add:function(t){this.items.add(null),this._size+=1;var e=this._size;for(this.items.set(0,t);t.compareTo(this.items.get(Math.trunc(e/2)))<0;e/=2)this.items.set(e,this.items.get(Math.trunc(e/2)));this.items.set(e,t)},interfaces_:function(){return[]},getClass:function(){return De}}),e(Ae.prototype,{visitItem:function(t){},interfaces_:function(){return[]},getClass:function(){return Ae}}),e(Fe.prototype,{insert:function(t,e){},remove:function(t,e){},query:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return Fe}}),e(Ge.prototype,{getLevel:function(){return this.level},size:function(){return this.childBoundables.size()},getChildBoundables:function(){return this.childBoundables},addChildBoundable:function(t){f.isTrue(null===this.bounds),this.childBoundables.add(t)},isEmpty:function(){return this.childBoundables.isEmpty()},getBounds:function(){return null===this.bounds&&(this.bounds=this.computeBounds()),this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Ge}}),Ge.serialVersionUID=0x5a1e55ec41369800;var ho={reverseOrder:function(){return{compare:function(t,e){return e.compareTo(t)}}},min:function(t){return ho.sort(t),t.get(0)},sort:function(t,e){var n=t.toArray();e?ut.sort(n,e):ut.sort(n);for(var i=t.iterator(),r=0,s=n.length;s>r;r++)i.next(),i.set(n[r])},singletonList:function(t){var e=new I;return e.add(t),e}};e(qe.prototype,{expandToQueue:function(t,e){var n=qe.isComposite(this.boundable1),r=qe.isComposite(this.boundable2);if(n&&r)return qe.area(this.boundable1)>qe.area(this.boundable2)?(this.expand(this.boundable1,this.boundable2,t,e),null):(this.expand(this.boundable2,this.boundable1,t,e),null);if(n)return this.expand(this.boundable1,this.boundable2,t,e),null;if(r)return this.expand(this.boundable2,this.boundable1,t,e),null;throw new i("neither boundable is composite")},isLeaves:function(){return!(qe.isComposite(this.boundable1)||qe.isComposite(this.boundable2))},compareTo:function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0},expand:function(t,e,n,i){for(var r=t.getChildBoundables(),s=r.iterator();s.hasNext();){var o=s.next(),a=new qe(o,e,this.itemDistance);a.getDistance()<i&&n.add(a)}},getBoundable:function(t){return 0===t?this.boundable1:this.boundable2},getDistance:function(){return this._distance},distance:function(){return this.isLeaves()?this.itemDistance.distance(this.boundable1,this.boundable2):this.boundable1.getBounds().distance(this.boundable2.getBounds())},interfaces_:function(){return[s]},getClass:function(){return qe}}),qe.area=function(t){return t.getBounds().getArea()},qe.isComposite=function(t){return t instanceof Ge},e(Be.prototype,{getNodeCapacity:function(){return this.nodeCapacity},lastNode:function(t){return t.get(t.size()-1)},size:function t(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this.root));if(1===arguments.length){for(var e=arguments[0],t=0,n=e.getChildBoundables().iterator();n.hasNext();){var i=n.next();i instanceof Ge?t+=this.size(i):i instanceof Me&&(t+=1)}return t}},removeItem:function(t,e){for(var n=null,i=t.getChildBoundables().iterator();i.hasNext();){var r=i.next();r instanceof Me&&r.getItem()===e&&(n=r)}return null!==n?(t.getChildBoundables().remove(n),!0):!1},itemsTree:function(){if(0===arguments.length){this.build();var t=this.itemsTree(this.root);return null===t?new I:t}if(1===arguments.length){for(var e=arguments[0],n=new I,i=e.getChildBoundables().iterator();i.hasNext();){var r=i.next();if(r instanceof Ge){var s=this.itemsTree(r);null!==s&&n.add(s)}else r instanceof Me?n.add(r.getItem()):f.shouldNeverReachHere()}return n.size()<=0?null:n}},insert:function(t,e){f.isTrue(!this.built,"Cannot insert items into an STR packed R-tree after it has been built."),this.itemBoundables.add(new Me(t,e))},boundablesAtLevel:function(){if(1===arguments.length){var t=arguments[0],e=new I;return this.boundablesAtLevel(t,this.root,e),e}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(f.isTrue(n>-2),i.getLevel()===n)return r.add(i),null;for(var s=i.getChildBoundables().iterator();s.hasNext();){var o=s.next();o instanceof Ge?this.boundablesAtLevel(n,o,r):(f.isTrue(o instanceof Me),-1===n&&r.add(o))}return null}},query:function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new I;return this.isEmpty()?e:(this.getIntersectsOp().intersects(this.root.getBounds(),t)&&this.query(t,this.root,e),e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this.root.getBounds(),n)&&this.query(n,this.root,i)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var r=arguments[0],s=arguments[1],o=arguments[2],a=s.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),r)&&(l instanceof Ge?this.query(r,l,o):l instanceof Me?o.visitItem(l.getItem()):f.shouldNeverReachHere())}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var h=arguments[0],c=arguments[1],g=arguments[2],a=c.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),h)&&(l instanceof Ge?this.query(h,l,g):l instanceof Me?g.add(l.getItem()):f.shouldNeverReachHere())}},build:function(){return this.built?null:(this.root=this.itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this.itemBoundables,-1),this.itemBoundables=null,void(this.built=!0))},getRoot:function(){return this.build(),this.root},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),this.getIntersectsOp().intersects(this.root.getBounds(),t)?this.remove(t,this.root,e):!1}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=this.removeItem(i,r);if(s)return!0;for(var o=null,a=i.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&u instanceof Ge&&(s=this.remove(n,u,r))){o=u;break}}return null!==o&&o.getChildBoundables().isEmpty()&&i.getChildBoundables().remove(o),s}},createHigherLevels:function(t,e){f.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)},depth:function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this.root));if(1===arguments.length){for(var t=arguments[0],e=0,n=t.getChildBoundables().iterator();n.hasNext();){var i=n.next();if(i instanceof Ge){var r=this.depth(i);r>e&&(e=r)}}return e+1}},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=new I;n.add(this.createNode(e));var i=new I(t);ho.sort(i,this.getComparator());for(var r=i.iterator();r.hasNext();){var s=r.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n},isEmpty:function(){return this.built?this.root.isEmpty():this.itemBoundables.isEmpty()},interfaces_:function(){return[u]},getClass:function(){return Be}}),Be.compareDoubles=function(t,e){return t>e?1:e>t?-1:0},Be.IntersectsOp=ze,Be.serialVersionUID=-0x35ef64c82d4c5400,Be.DEFAULT_NODE_CAPACITY=10,e(Ve.prototype,{distance:function(t,e){},interfaces_:function(){return[]},getClass:function(){return Ve}}),h(ke,Be),e(ke.prototype,{createParentBoundablesFromVerticalSlices:function(t,e){f.isTrue(t.length>0);for(var n=new I,i=0;i<t.length;i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i],e));return n},createNode:function(t){return new Ye(t)},size:function(){return 0===arguments.length?Be.prototype.size.call(this):Be.prototype.size.apply(this,arguments)},insert:function(){if(2!==arguments.length)return Be.prototype.insert.apply(this,arguments);var t=arguments[0],e=arguments[1];return t.isNull()?null:void Be.prototype.insert.call(this,t,e)},getIntersectsOp:function(){return ke.intersectsOp},verticalSlices:function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),i=new Array(e).fill(null),r=t.iterator(),s=0;e>s;s++){i[s]=new I;for(var o=0;r.hasNext()&&n>o;){var a=r.next();i[s].add(a),o++}}return i},query:function(){if(1===arguments.length){var t=arguments[0];return Be.prototype.query.call(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];Be.prototype.query.call(this,e,n)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var i=arguments[0],r=arguments[1],s=arguments[2];Be.prototype.query.call(this,i,r,s)}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var o=arguments[0],a=arguments[1],u=arguments[2];Be.prototype.query.call(this,o,a,u)}},getComparator:function(){return ke.yComparator},createParentBoundablesFromVerticalSlice:function(t,e){return Be.prototype.createParentBoundables.call(this,t,e)},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Be.prototype.remove.call(this,t,e)}return Be.prototype.remove.apply(this,arguments)},depth:function(){return 0===arguments.length?Be.prototype.depth.call(this):Be.prototype.depth.apply(this,arguments)},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),i=new I(t);ho.sort(i,ke.xComparator);var r=this.verticalSlices(i,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(r,e)},nearestNeighbour:function(){if(1===arguments.length){if(R(arguments[0],Ve)){var t=arguments[0],e=new qe(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe){var n=arguments[0];return this.nearestNeighbour(n,r.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof ke&&R(arguments[1],Ve)){var i=arguments[0],s=arguments[1],e=new qe(this.getRoot(),i.getRoot(),s);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe&&"number"==typeof arguments[1]){var o=arguments[0],a=arguments[1],u=a,l=null,h=new De;for(h.add(o);!h.isEmpty()&&u>0;){var c=h.poll(),f=c.getDistance();if(f>=u)break;c.isLeaves()?(u=f,l=c):c.expandToQueue(h,u)}return[l.getBoundable(0).getItem(),l.getBoundable(1).getItem()]}}else if(3===arguments.length){var g=arguments[0],d=arguments[1],p=arguments[2],v=new Me(g,d),e=new qe(this.getRoot(),v,p);return this.nearestNeighbour(e)[0]}},interfaces_:function(){return[Fe,u]},getClass:function(){return ke}}),ke.centreX=function(t){return ke.avg(t.getMinX(),t.getMaxX())},ke.avg=function(t,e){return(t+e)/2},ke.centreY=function(t){return ke.avg(t.getMinY(),t.getMaxY())},h(Ye,Ge),e(Ye.prototype,{computeBounds:function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new C(n.getBounds()):t.expandToInclude(n.getBounds())}return t},interfaces_:function(){return[]},getClass:function(){return Ye}}),ke.STRtreeNode=Ye,ke.serialVersionUID=0x39920f7d5f261e0,ke.xComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreX(t.getBounds()),ke.centreX(e.getBounds()))}},ke.yComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreY(t.getBounds()),ke.centreY(e.getBounds()))}},ke.intersectsOp={interfaces_:function(){return[IntersectsOp]},intersects:function(t,e){return t.intersects(e)}},ke.DEFAULT_NODE_CAPACITY=10,e(Ue.prototype,{interfaces_:function(){return[]},getClass:function(){return Ue}}),Ue.relativeSign=function(t,e){return e>t?-1:t>e?1:0},Ue.compare=function(t,e,n){if(e.equals2D(n))return 0;var i=Ue.relativeSign(e.x,n.x),r=Ue.relativeSign(e.y,n.y);switch(t){case 0:return Ue.compareValue(i,r);case 1:return Ue.compareValue(r,i);case 2:return Ue.compareValue(r,-i);case 3:return Ue.compareValue(-i,r);case 4:return Ue.compareValue(-i,-r);case 5:return Ue.compareValue(-r,-i);case 6:return Ue.compareValue(-r,i);case 7:return Ue.compareValue(i,-r)}return f.shouldNeverReachHere("invalid octant value"),0},Ue.compareValue=function(t,e){return 0>t?-1:t>0?1:0>e?-1:e>0?1:0},e(Xe.prototype,{getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)},compareTo:function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:Ue.compare(this.segmentOctant,this.coord,e.coord)},isEndPoint:function(t){return 0!==this.segmentIndex||this._isInterior?this.segmentIndex===t:!0},isInterior:function(){return this._isInterior},interfaces_:function(){return[s]},getClass:function(){return Xe}}),e(He.prototype,{getSplitCoordinates:function(){var t=new N;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next();this.addEdgeCoordinates(n,i,t),n=i}return t.toCoordinateArray()},addCollapsedNodes:function(){var t=new I;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this.edge.getCoordinate(n),n)}},print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},findCollapsesFromExistingVertices:function(t){for(var e=0;e<this.edge.size()-2;e++){var n=this.edge.getCoordinate(e),i=(this.edge.getCoordinate(e+1),this.edge.getCoordinate(e+2));n.equals2D(i)&&t.add(new b(e+1))}},addEdgeCoordinates:function(t,e,n){var i=e.segmentIndex-t.segmentIndex+2,r=this.edge.getCoordinate(e.segmentIndex),s=e.isInterior()||!e.coord.equals2D(r);s||i--;n.add(new g(t.coord),!1);for(var o=t.segmentIndex+1;o<=e.segmentIndex;o++)n.add(this.edge.getCoordinate(o));s&&n.add(new g(e.coord))},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},findCollapseIndex:function(t,e,n){if(!t.coord.equals2D(e.coord))return!1;var i=e.segmentIndex-t.segmentIndex;return e.isInterior()||i--,1===i?(n[0]=t.segmentIndex+1,!0):!1},findCollapsesFromInsertedNodes:function(t){for(var e=new Array(1).fill(null),n=this.iterator(),i=n.next();n.hasNext();){var r=n.next(),s=this.findCollapseIndex(i,r,e);s&&t.add(new b(e[0])),i=r}},getEdge:function(){return this.edge},addEndpoints:function(){var t=this.edge.size()-1;this.add(this.edge.getCoordinate(0),0),this.add(this.edge.getCoordinate(t),t)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.getCoordinate(a);return r&&(s[o]=new g(e.coord)),new Ke(s,this.edge.getData())},add:function(t,e){var n=new Xe(this.edge,t,e,this.edge.getSegmentOctant(e)),i=this.nodeMap.get(n);return null!==i?(f.isTrue(i.coord.equals2D(t),"Found equal nodes with different coordinates"),i):(this.nodeMap.put(n,n),n)},checkSplitEdgesCorrectness:function(t){var e=this.edge.getCoordinates(),n=t.get(0),i=n.getCoordinate(0);if(!i.equals2D(e[0]))throw new l("bad split edge start point at "+i);var r=t.get(t.size()-1),s=r.getCoordinates(),o=s[s.length-1];if(!o.equals2D(e[e.length-1]))throw new l("bad split edge end point at "+o)},interfaces_:function(){return[]},getClass:function(){return He}}),e(We.prototype,{next:function(){return null===this.currNode?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):null===this.nextNode?null:this.nextNode.segmentIndex===this.currNode.segmentIndex?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):(this.nextNode.segmentIndex>this.currNode.segmentIndex,null)},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){return null!==this.nextNode},readNextNode:function(){this.nodeIt.hasNext()?this.nextNode=this.nodeIt.next():this.nextNode=null},interfaces_:function(){return[p]},getClass:function(){return We}}),e(je.prototype,{addIntersection:function(t,e){},interfaces_:function(){return[be]},getClass:function(){return je}}),e(Ke.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},safeOctant:function(t,e){return t.equals2D(e)?0:Pe.octant(t,e)},getData:function(){return this.data},addIntersection:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=(arguments[2],arguments[3]),s=new g(n.getIntersection(r));this.addIntersection(s,i)}},toString:function(){return se.toLineString(new Gt(this.pts))},getNodeList:function(){return this.nodeList},addIntersectionNode:function(t,e){var n=e,i=n+1;if(i<this.pts.length){var r=this.pts[i];t.equals2D(r)&&(n=i)}var s=this.nodeList.add(t,n);return s},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[je]},getClass:function(){return Ke}}),Ke.getNodedSubstrings=function(){if(1===arguments.length){var t=arguments[0],e=new I;return Ke.getNodedSubstrings(t,e),e}if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){var s=r.next();s.getNodeList().addSplitEdges(i)}},e(Ze.prototype,{overlap:function(){if(2===arguments.length){arguments[0],arguments[1]}else if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t.getLineSegment(e,this.overlapSeg1),n.getLineSegment(i,this.overlapSeg2),this.overlap(this.overlapSeg1,this.overlapSeg2)}},interfaces_:function(){return[]},getClass:function(){return Ze}}),e(Qe.prototype,{getLineSegment:function(t,e){e.p0=this.pts[t],e.p1=this.pts[t+1]},computeSelect:function(t,e,n,i){var r=this.pts[e],s=this.pts[n];if(i.tempEnv1.init(r,s),n-e===1)return i.select(this,e),null;if(!t.intersects(i.tempEnv1))return null;var o=Math.trunc((e+n)/2);
o>e&&this.computeSelect(t,e,o,i),n>o&&this.computeSelect(t,o,n,i)},getCoordinates:function(){for(var t=new Array(this.end-this.start+1).fill(null),e=0,n=this.start;n<=this.end;n++)t[e++]=this.pts[n];return t},computeOverlaps:function(t,e){this.computeOverlapsInternal(this.start,this.end,t,t.start,t.end,e)},setId:function(t){this.id=t},select:function(t,e){this.computeSelect(t,this.start,this.end,e)},getEnvelope:function(){if(null===this.env){var t=this.pts[this.start],e=this.pts[this.end];this.env=new C(t,e)}return this.env},getEndIndex:function(){return this.end},getStartIndex:function(){return this.start},getContext:function(){return this.context},getId:function(){return this.id},computeOverlapsInternal:function(t,e,n,i,r,s){var o=this.pts[t],a=this.pts[e],u=n.pts[i],l=n.pts[r];if(e-t===1&&r-i===1)return s.overlap(this,t,n,i),null;if(s.tempEnv1.init(o,a),s.tempEnv2.init(u,l),!s.tempEnv1.intersects(s.tempEnv2))return null;var h=Math.trunc((t+e)/2),c=Math.trunc((i+r)/2);h>t&&(c>i&&this.computeOverlapsInternal(t,h,n,i,c,s),r>c&&this.computeOverlapsInternal(t,h,n,c,r,s)),e>h&&(c>i&&this.computeOverlapsInternal(h,e,n,i,c,s),r>c&&this.computeOverlapsInternal(h,e,n,c,r,s))},interfaces_:function(){return[]},getClass:function(){return Qe}}),e(Je.prototype,{interfaces_:function(){return[]},getClass:function(){return Je}}),Je.isNorthern=function(t){return t===Je.NE||t===Je.NW},Je.isOpposite=function(t,e){if(t===e)return!1;var n=(t-e+4)%4;return 2===n},Je.commonHalfPlane=function(t,e){if(t===e)return t;var n=(t-e+4)%4;if(2===n)return-1;var i=e>t?t:e,r=t>e?t:e;return 0===i&&3===r?3:i},Je.isInHalfPlane=function(t,e){return e===Je.SE?t===Je.SE||t===Je.SW:t===e||t===e+1},Je.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Je.NE:Je.SE:e>=0?Je.NW:Je.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){var n=arguments[0],r=arguments[1];if(r.x===n.x&&r.y===n.y)throw new i("Cannot compute the quadrant for two identical points "+n);return r.x>=n.x?r.y>=n.y?Je.NE:Je.SE:r.y>=n.y?Je.NW:Je.SW}},Je.NE=0,Je.NW=1,Je.SW=2,Je.SE=3,e($e.prototype,{interfaces_:function(){return[]},getClass:function(){return $e}}),$e.getChainStartIndices=function(t){var e=0,n=new I;n.add(new b(e));do{var i=$e.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=$e.toIntArray(n);return r},$e.findChainEnd=function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var i=Je.quadrant(t[n],t[n+1]),r=e+1;r<t.length;){if(!t[r-1].equals2D(t[r])){var s=Je.quadrant(t[r-1],t[r]);if(s!==i)break}r++}return r-1},$e.getChains=function(){if(1===arguments.length){var t=arguments[0];return $e.getChains(t,null)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new I,r=$e.getChainStartIndices(e),s=0;s<r.length-1;s++){var o=new Qe(e,r[s],r[s+1],n);i.add(o)}return i}},$e.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(tn.prototype,{computeNodes:function(t){},getNodedSubstrings:function(){},interfaces_:function(){return[]},getClass:function(){return tn}}),e(en.prototype,{setSegmentIntersector:function(t){this.segInt=t},interfaces_:function(){return[tn]},getClass:function(){return en}}),h(nn,en),e(nn.prototype,{getMonotoneChains:function(){return this.monoChains},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},getIndex:function(){return this.index},add:function(t){for(var e=$e.getChains(t.getCoordinates(),t),n=e.iterator();n.hasNext();){var i=n.next();i.setId(this.idCounter++),this.index.insert(i.getEnvelope(),i),this.monoChains.add(i)}},computeNodes:function(t){this.nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()},intersectChains:function(){for(var t=new rn(this.segInt),e=this.monoChains.iterator();e.hasNext();)for(var n=e.next(),i=this.index.query(n.getEnvelope()),r=i.iterator();r.hasNext();){var s=r.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this.nOverlaps++),this.segInt.isDone())return null}},interfaces_:function(){return[]},getClass:function(){return nn}}),h(rn,Ze),e(rn.prototype,{overlap:function(){if(4!==arguments.length)return Ze.prototype.overlap.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],r=t.getContext(),s=n.getContext();this.si.processIntersections(r,e,s,i)},interfaces_:function(){return[]},getClass:function(){return rn}}),nn.SegmentOverlapAction=rn,h(sn,l),e(sn.prototype,{getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return sn}}),sn.msgWithCoord=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(on.prototype,{processIntersections:function(t,e,n,i){},isDone:function(){},interfaces_:function(){return[]},getClass:function(){return on}}),e(an.prototype,{getInteriorIntersection:function(){return this.interiorIntersection},setCheckEndSegmentsOnly:function(t){this.isCheckEndSegmentsOnly=t},getIntersectionSegments:function(){return this.intSegments},count:function(){return this.intersectionCount},getIntersections:function(){return this.intersections},setFindAllIntersections:function(t){this.findAllIntersections=t},setKeepIntersections:function(t){this.keepIntersections=t},processIntersections:function(t,e,n,i){if(!this.findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===i)return null;if(this.isCheckEndSegmentsOnly){var r=this.isEndSegment(t,e)||this.isEndSegment(n,i);if(!r)return null}var s=t.getCoordinates()[e],o=t.getCoordinates()[e+1],a=n.getCoordinates()[i],u=n.getCoordinates()[i+1];this.li.computeIntersection(s,o,a,u),this.li.hasIntersection()&&this.li.isInteriorIntersection()&&(this.intSegments=new Array(4).fill(null),this.intSegments[0]=s,this.intSegments[1]=o,this.intSegments[2]=a,this.intSegments[3]=u,this.interiorIntersection=this.li.getIntersection(0),this.keepIntersections&&this.intersections.add(this.interiorIntersection),this.intersectionCount++)},isEndSegment:function(t,e){return 0===e?!0:e>=t.size()-2},hasIntersection:function(){return null!==this.interiorIntersection},isDone:function(){return this.findAllIntersections?!1:null!==this.interiorIntersection},interfaces_:function(){return[on]},getClass:function(){return an}}),an.createAllIntersectionsFinder=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e},an.createAnyIntersectionFinder=function(t){return new an(t)},an.createIntersectionCounter=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e},e(un.prototype,{execute:function(){return null!==this.segInt?null:void this.checkInteriorIntersections()},getIntersections:function(){return this.segInt.getIntersections()},isValid:function(){return this.execute(),this._isValid},setFindAllIntersections:function(t){this.findAllIntersections=t},checkInteriorIntersections:function(){this._isValid=!0,this.segInt=new an(this.li),this.segInt.setFindAllIntersections(this.findAllIntersections);var t=new nn;return t.setSegmentIntersector(this.segInt),t.computeNodes(this.segStrings),this.segInt.hasIntersection()?(this._isValid=!1,null):void 0},checkValid:function(){if(this.execute(),!this._isValid)throw new sn(this.getErrorMessage(),this.segInt.getInteriorIntersection())},getErrorMessage:function(){if(this._isValid)return"no intersections found";var t=this.segInt.getIntersectionSegments();return"found non-noded intersection between "+se.toLineString(t[0],t[1])+" and "+se.toLineString(t[2],t[3])},interfaces_:function(){return[]},getClass:function(){return un}}),un.computeIntersections=function(t){var e=new un(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()},e(ln.prototype,{checkValid:function(){this.nv.checkValid()},interfaces_:function(){return[]},getClass:function(){return ln}}),ln.toSegmentStrings=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Oe(i.getCoordinates(),i))}return e},ln.checkValid=function(t){var e=new ln(t);e.checkValid()},e(hn.prototype,{map:function(t){for(var e=new I,n=0;n<t.getNumGeometries();n++){var i=this.mapOp.map(t.getGeometryN(n));i.isEmpty()||e.add(i)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(e))},interfaces_:function(){return[]},getClass:function(){return hn}}),hn.map=function(t,e){var n=new hn(e);return n.map(t)},e(cn.prototype,{interfaces_:function(){return[]},getClass:function(){return cn}}),cn.opposite=function(t){return t===cn.LEFT?cn.RIGHT:t===cn.RIGHT?cn.LEFT:t},cn.ON=0,cn.LEFT=1,cn.RIGHT=2,e(fn.prototype,{setAllLocations:function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t},isNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==L.NONE)return!1;return!0},setAllLocationsIfNull:function(t){for(var e=0;e<this.location.length;e++)this.location[e]===L.NONE&&(this.location[e]=t)},isLine:function(){return 1===this.location.length},merge:function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[cn.ON]=this.location[cn.ON],e[cn.LEFT]=L.NONE,e[cn.RIGHT]=L.NONE,this.location=e}for(var n=0;n<this.location.length;n++)this.location[n]===L.NONE&&n<t.location.length&&(this.location[n]=t.location[n])},getLocations:function(){return this.location},flip:function(){if(this.location.length<=1)return null;var t=this.location[cn.LEFT];this.location[cn.LEFT]=this.location[cn.RIGHT],this.location[cn.RIGHT]=t},toString:function(){var t=new P;return this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.LEFT])),t.append(L.toLocationSymbol(this.location[cn.ON])),this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.RIGHT])),t.toString()},setLocations:function(t,e,n){this.location[cn.ON]=t,this.location[cn.LEFT]=e,this.location[cn.RIGHT]=n},get:function(t){return t<this.location.length?this.location[t]:L.NONE},isArea:function(){return this.location.length>1},isAnyNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===L.NONE)return!0;return!1},setLocation:function(){if(1===arguments.length){var t=arguments[0];this.setLocation(cn.ON,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n}},init:function(t){this.location=new Array(t).fill(null),this.setAllLocations(L.NONE)},isEqualOnSide:function(t,e){return this.location[e]===t.location[e]},allPositionsEqual:function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0},interfaces_:function(){return[]},getClass:function(){return fn}}),e(gn.prototype,{getGeometryCount:function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t},setAllLocations:function(t,e){this.elt[t].setAllLocations(e)},isNull:function(t){return this.elt[t].isNull()},setAllLocationsIfNull:function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n)}},isLine:function(t){return this.elt[t].isLine()},merge:function(t){for(var e=0;2>e;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new fn(t.elt[e]):this.elt[e].merge(t.elt[e])},flip:function(){this.elt[0].flip(),this.elt[1].flip()},getLocation:function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(cn.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}},toString:function(){var t=new P;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()},isArea:function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}},isAnyNull:function(t){return this.elt[t].isAnyNull()},setLocation:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(cn.ON,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.elt[n].setLocation(i,r)}},isEqualOnSide:function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)},allPositionsEqual:function(t,e){return this.elt[t].allPositionsEqual(e)},toLine:function(t){this.elt[t].isArea()&&(this.elt[t]=new fn(this.elt[t].location[0]))},interfaces_:function(){return[]},getClass:function(){return gn}}),gn.toLineLabel=function(t){for(var e=new gn(L.NONE),n=0;2>n;n++)e.setLocation(n,t.getLocation(n));return e},e(dn.prototype,{computeRing:function(){if(null!==this.ring)return null;for(var t=new Array(this.pts.size()).fill(null),e=0;e<this.pts.size();e++)t[e]=this.pts.get(e);this.ring=this.geometryFactory.createLinearRing(t),this._isHole=he.isCCW(this.ring.getCoordinates())},isIsolated:function(){return 1===this.label.getGeometryCount()},computePoints:function(t){this.startDe=t;var e=t,n=!0;do{if(null===e)throw new sn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new sn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this.edges.add(e);var i=e.getLabel();f.isTrue(i.isArea()),this.mergeLabel(i),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this.startDe)},getLinearRing:function(){return this.ring},getCoordinate:function(t){return this.pts.get(t)},computeMaxNodeDegree:function(){this.maxNodeDegree=0;var t=this.startDe;do{var e=t.getNode(),n=e.getEdges().getOutgoingDegree(this);n>this.maxNodeDegree&&(this.maxNodeDegree=n),t=this.getNext(t)}while(t!==this.startDe);this.maxNodeDegree*=2},addPoints:function(t,e,n){var i=t.getCoordinates();if(e){var r=1;n&&(r=0);for(var s=r;s<i.length;s++)this.pts.add(i[s])}else{var r=i.length-2;n&&(r=i.length-1);for(var s=r;s>=0;s--)this.pts.add(i[s])}},isHole:function(){return this._isHole},setInResult:function(){var t=this.startDe;do t.getEdge().setInResult(!0),t=t.getNext();while(t!==this.startDe)},containsPoint:function(t){var e=this.getLinearRing(),n=e.getEnvelopeInternal();if(!n.contains(t))return!1;if(!he.isPointInRing(t,e.getCoordinates()))return!1;for(var i=this.holes.iterator();i.hasNext();){var r=i.next();if(r.containsPoint(t))return!1}return!0},addHole:function(t){this.holes.add(t)},isShell:function(){return null===this.shell},getLabel:function(){return this.label},getEdges:function(){return this.edges},getMaxNodeDegree:function(){return this.maxNodeDegree<0&&this.computeMaxNodeDegree(),this.maxNodeDegree},getShell:function(){return this.shell},mergeLabel:function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=e.getLocation(n,cn.RIGHT);if(i===L.NONE)return null;if(this.label.getLocation(n)===L.NONE)return this.label.setLocation(n,i),null}},setShell:function(t){this.shell=t,null!==t&&t.addHole(this)},toPolygon:function(t){for(var e=new Array(this.holes.size()).fill(null),n=0;n<this.holes.size();n++)e[n]=this.holes.get(n).getLinearRing();var i=t.createPolygon(this.getLinearRing(),e);return i},interfaces_:function(){return[]},getClass:function(){return dn}}),h(pn,dn),e(pn.prototype,{setEdgeRing:function(t,e){t.setMinEdgeRing(e)},getNext:function(t){return t.getNextMin()},interfaces_:function(){return[]},getClass:function(){return pn}}),h(vn,dn),e(vn.prototype,{buildMinimalRings:function(){var t=new I,e=this.startDe;do{if(null===e.getMinEdgeRing()){var n=new pn(e,this.geometryFactory);t.add(n)}e=e.getNext()}while(e!==this.startDe);return t},setEdgeRing:function(t,e){t.setEdgeRing(e)},linkDirectedEdgesForMinimalEdgeRings:function(){var t=this.startDe;do{var e=t.getNode();e.getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this.startDe)},getNext:function(t){return t.getNext()},interfaces_:function(){return[]},getClass:function(){return vn}}),e(mn.prototype,{setVisited:function(t){this._isVisited=t},setInResult:function(t){this._isInResult=t},isCovered:function(){return this._isCovered},isCoveredSet:function(){return this._isCoveredSet},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setCovered:function(t){this._isCovered=t,this._isCoveredSet=!0},updateIM:function(t){f.isTrue(this.label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)},isInResult:function(){return this._isInResult},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return mn}}),h(yn,mn),e(yn.prototype,{isIncidentEdgeInResult:function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();){var e=t.next();if(e.getEdge().isInResult())return!0}return!1},isIsolated:function(){return 1===this.label.getGeometryCount()},getCoordinate:function(){return this.coord},print:function(t){t.println("node "+this.coord+" lbl: "+this.label)},computeIM:function(t){},computeMergedLocation:function(t,e){var n=L.NONE;if(n=this.label.getLocation(e),!t.isNull(e)){var i=t.getLocation(e);n!==L.BOUNDARY&&(n=i)}return n},setLabel:function(){if(2!==arguments.length)return mn.prototype.setLabel.apply(this,arguments);var t=arguments[0],e=arguments[1];null===this.label?this.label=new gn(t,e):this.label.setLocation(t,e)},getEdges:function(){return this.edges},mergeLabel:function(){if(arguments[0]instanceof yn){var t=arguments[0];this.mergeLabel(t.label)}else if(arguments[0]instanceof gn)for(var e=arguments[0],n=0;2>n;n++){var i=this.computeMergedLocation(e,n),r=this.label.getLocation(n);r===L.NONE&&this.label.setLocation(n,i)}},add:function(t){this.edges.insert(t),t.setNode(this)},setLabelBoundary:function(t){if(null===this.label)return null;var e=L.NONE;null!==this.label&&(e=this.label.getLocation(t));var n=null;switch(e){case L.BOUNDARY:n=L.INTERIOR;break;case L.INTERIOR:n=L.BOUNDARY;break;default:n=L.BOUNDARY}this.label.setLocation(t,n)},interfaces_:function(){return[]},getClass:function(){return yn}}),e(xn.prototype,{find:function(t){return this.nodeMap.get(t)},addNode:function(){if(arguments[0]instanceof g){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof yn){var n=arguments[0],e=this.nodeMap.get(n.getCoordinate());return null===e?(this.nodeMap.put(n.getCoordinate(),n),n):(e.mergeLabel(n),e)}},print:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},values:function(){return this.nodeMap.values()},getBoundaryNodes:function(t){for(var e=new I,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().getLocation(t)===L.BOUNDARY&&e.add(i)}return e},add:function(t){var e=t.getCoordinate(),n=this.addNode(e);n.add(t)},interfaces_:function(){return[]},getClass:function(){return xn}}),e(En.prototype,{compareDirection:function(t){return this.dx===t.dx&&this.dy===t.dy?0:this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getDy:function(){return this.dy},getCoordinate:function(){return this.p0},setNode:function(t){this.node=t},print:function(t){var e=Math.atan2(this.dy,this.dx),n=this.getClass().getName(),i=n.lastIndexOf("."),r=n.substring(i+1);t.print("  "+r+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+e+"   "+this.label)},compareTo:function(t){var e=t;return this.compareDirection(e)},getDirectedCoordinate:function(){return this.p1},getDx:function(){return this.dx},getLabel:function(){return this.label},getEdge:function(){return this.edge},getQuadrant:function(){return this.quadrant},getNode:function(){return this.node},toString:function(){var t=Math.atan2(this.dy,this.dx),e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);return"  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+t+"   "+this.label},computeLabel:function(t){},init:function(t,e){this.p0=t,this.p1=e,this.dx=e.x-t.x,this.dy=e.y-t.y,this.quadrant=Je.quadrant(this.dx,this.dy),f.isTrue(!(0===this.dx&&0===this.dy),"EdgeEnd with identical endpoints found")},interfaces_:function(){return[s]},getClass:function(){return En}}),h(In,En),e(In.prototype,{getNextMin:function(){return this.nextMin},getDepth:function(t){return this.depth[t]},setVisited:function(t){this._isVisited=t},computeDirectedLabel:function(){this.label=new gn(this.edge.getLabel()),this._isForward||this.label.flip()},getNext:function(){return this.next},setDepth:function(t,e){if(-999!==this.depth[t]&&this.depth[t]!==e)throw new sn("assigned depths do not match",this.getCoordinate());this.depth[t]=e},isInteriorAreaEdge:function t(){for(var t=!0,e=0;2>e;e++)this.label.isArea(e)&&this.label.getLocation(e,cn.LEFT)===L.INTERIOR&&this.label.getLocation(e,cn.RIGHT)===L.INTERIOR||(t=!1);return t},setNextMin:function(t){this.nextMin=t},print:function(t){En.prototype.print.call(this,t),t.print(" "+this.depth[cn.LEFT]+"/"+this.depth[cn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")},setMinEdgeRing:function(t){this.minEdgeRing=t},isLineEdge:function(){var t=this.label.isLine(0)||this.label.isLine(1),e=!this.label.isArea(0)||this.label.allPositionsEqual(0,L.EXTERIOR),n=!this.label.isArea(1)||this.label.allPositionsEqual(1,L.EXTERIOR);return t&&e&&n},setEdgeRing:function(t){this.edgeRing=t},getMinEdgeRing:function(){return this.minEdgeRing},getDepthDelta:function(){var t=this.edge.getDepthDelta();return this._isForward||(t=-t),t},setInResult:function(t){this._isInResult=t},getSym:function(){return this.sym},isForward:function(){return this._isForward},getEdge:function(){return this.edge},printEdge:function(t){this.print(t),t.print(" "),this._isForward?this.edge.print(t):this.edge.printReverse(t)},setSym:function(t){this.sym=t},setVisitedEdge:function(t){this.setVisited(t),this.sym.setVisited(t)},setEdgeDepths:function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var i=1;t===cn.LEFT&&(i=-1);var r=cn.opposite(t),s=n*i,o=e+s;this.setDepth(t,e),this.setDepth(r,o)},getEdgeRing:function(){return this.edgeRing},isInResult:function(){return this._isInResult},setNext:function(t){this.next=t},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return In}}),In.depthFactor=function(t,e){return t===L.EXTERIOR&&e===L.INTERIOR?1:t===L.INTERIOR&&e===L.EXTERIOR?-1:0},e(Nn.prototype,{createNode:function(t){return new yn(t,null)},interfaces_:function(){return[]},getClass:function(){return Nn}}),e(Cn.prototype,{printEdges:function(t){t.println("Edges:");for(var e=0;e<this.edges.size();e++){t.println("edge "+e+":");var n=this.edges.get(e);n.print(t),n.eiList.print(t)}},find:function(t){return this.nodes.find(t)},addNode:function(){if(arguments[0]instanceof yn){var t=arguments[0];return this.nodes.addNode(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.nodes.addNode(e)}},getNodeIterator:function(){return this.nodes.iterator()},linkResultDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkResultDirectedEdges()}},debugPrintln:function(t){A.out.println(t)},isBoundaryNode:function(t,e){var n=this.nodes.find(e);if(null===n)return!1;var i=n.getLabel();return null!==i&&i.getLocation(t)===L.BOUNDARY},linkAllDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkAllDirectedEdges()}},matchInSameDirection:function(t,e,n,i){return t.equals(n)?he.computeOrientation(t,e,i)===he.COLLINEAR&&Je.quadrant(t,e)===Je.quadrant(n,i):!1},getEdgeEnds:function(){return this.edgeEndList},debugPrint:function(t){A.out.print(t)},getEdgeIterator:function(){return this.edges.iterator()},findEdgeInSameDirection:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(this.matchInSameDirection(t,e,r[0],r[1]))return i;if(this.matchInSameDirection(t,e,r[r.length-1],r[r.length-2]))return i}return null},insertEdge:function(t){this.edges.add(t)},findEdgeEnd:function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null},addEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.edges.add(n);var i=new In(n,!0),r=new In(n,!1);i.setSym(r),r.setSym(i),this.add(i),this.add(r)}},add:function(t){this.nodes.add(t),this.edgeEndList.add(t)},getNodes:function(){return this.nodes.values()},findEdge:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(t.equals(r[0])&&e.equals(r[1]))return i}return null},interfaces_:function(){return[]},getClass:function(){return Cn}}),Cn.linkResultDirectedEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.getEdges().linkResultDirectedEdges()}},e(Sn.prototype,{sortShellsAndHoles:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isHole()?n.add(r):e.add(r)}},computePolygons:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=i.toPolygon(this.geometryFactory);e.add(r)}return e},placeFreeHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(null===i.getShell()){var r=this.findEdgeRingContaining(i,t);if(null===r)throw new sn("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(r)}}},buildMinimalEdgeRings:function(t,e,n){for(var i=new I,r=t.iterator();r.hasNext();){var s=r.next();if(s.getMaxNodeDegree()>2){s.linkDirectedEdgesForMinimalEdgeRings();var o=s.buildMinimalRings(),a=this.findShell(o);null!==a?(this.placePolygonHoles(a,o),e.add(a)):n.addAll(o)}else i.add(s)}return i},containsPoint:function(t){for(var e=this.shellList.iterator();e.hasNext();){var n=e.next();if(n.containsPoint(t))return!0}return!1},buildMaximalEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&i.getLabel().isArea()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);e.add(r),r.setInResult()}}return e},placePolygonHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();i.isHole()&&i.setShell(t)}},getPolygons:function(){var t=this.computePolygons(this.shellList);return t},findEdgeRingContaining:function(t,e){for(var n=t.getLinearRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),h=l.getEnvelopeInternal();null!==s&&(o=s.getLinearRing().getEnvelopeInternal());var c=!1;h.contains(i)&&he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u)}return s},findShell:function(t){for(var e=0,n=null,i=t.iterator();i.hasNext();){var r=i.next();r.isHole()||(n=r,e++)}return f.isTrue(1>=e,"found two shells in MinimalEdgeRing list"),n},add:function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];Cn.linkResultDirectedEdges(n);var i=this.buildMaximalEdgeRings(e),r=new I,s=this.buildMinimalEdgeRings(i,this.shellList,r);this.sortShellsAndHoles(s,this.shellList,r),this.placeFreeHoles(this.shellList,r)}},interfaces_:function(){return[]},getClass:function(){return Sn}}),e(wn.prototype,{collectLines:function(t){for(var e=this.op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next();this.collectLineEdge(n,t,this.lineEdgesList),this.collectBoundaryTouchEdge(n,t,this.lineEdgesList)}},labelIsolatedLine:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.op.getArgGeometry(e));t.getLabel().setLocation(e,n)},build:function(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this.resultLineList},collectLineEdge:function(t,e,n){var i=t.getLabel(),r=t.getEdge();t.isLineEdge()&&(t.isVisited()||!ii.isResultOfOp(i,e)||r.isCovered()||(n.add(r),t.setVisitedEdge(!0)))},findCoveredLineEdges:function(){for(var t=this.op.getGraph().getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().findCoveredLineEdges()}for(var n=this.op.getGraph().getEdgeEnds().iterator();n.hasNext();){var i=n.next(),r=i.getEdge();if(i.isLineEdge()&&!r.isCoveredSet()){var s=this.op.isCoveredByA(i.getCoordinate());r.setCovered(s)}}},labelIsolatedLines:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(i.isNull(0)?this.labelIsolatedLine(n,0):this.labelIsolatedLine(n,1))}},buildLines:function(t){for(var e=this.lineEdgesList.iterator();e.hasNext();){var n=e.next(),i=(n.getLabel(),this.geometryFactory.createLineString(n.getCoordinates()));this.resultLineList.add(i),n.setInResult(!0)}},collectBoundaryTouchEdge:function(t,e,n){var i=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(f.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(ii.isResultOfOp(i,e)&&e===ii.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))},interfaces_:function(){return[]},getClass:function(){return wn}}),e(Ln.prototype,{filterCoveredNodeToPoint:function(t){var e=t.getCoordinate();if(!this.op.isCoveredByLA(e)){var n=this.geometryFactory.createPoint(e);this.resultPointList.add(n)}},extractNonCoveredResultNodes:function(t){for(var e=this.op.getGraph().getNodes().iterator();e.hasNext();){var n=e.next();if(!(n.isInResult()||n.isIncidentEdgeInResult()||0!==n.getEdges().getDegree()&&t!==ii.INTERSECTION)){var i=n.getLabel();ii.isResultOfOp(i,t)&&this.filterCoveredNodeToPoint(n)}}},build:function(t){return this.extractNonCoveredResultNodes(t),this.resultPointList},interfaces_:function(){return[]},getClass:function(){return Ln}}),e(Rn.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return Rn}}),e(Tn.prototype,{locate:function(t){return Tn.locate(t,this.geom)},interfaces_:function(){return[Rn]},getClass:function(){return Tn}}),Tn.isPointInRing=function(t,e){return e.getEnvelopeInternal().intersects(t)?he.isPointInRing(t,e.getCoordinates()):!1},Tn.containsPointInPolygon=function(t,e){if(e.isEmpty())return!1;var n=e.getExteriorRing();if(!Tn.isPointInRing(t,n))return!1;for(var i=0;i<e.getNumInteriorRing();i++){var r=e.getInteriorRingN(i);if(Tn.isPointInRing(t,r))return!1}return!0},Tn.containsPoint=function(t,e){if(e instanceof Tt)return Tn.containsPointInPolygon(t,e);if(e instanceof ft)for(var n=new Re(e);n.hasNext();){var i=n.next();if(i!==e&&Tn.containsPoint(t,i))return!0}return!1},Tn.locate=function(t,e){return e.isEmpty()?L.EXTERIOR:Tn.containsPoint(t,e)?L.INTERIOR:L.EXTERIOR},e(Pn.prototype,{getNextCW:function(t){this.getEdges();var e=this.edgeList.indexOf(t),n=e-1;return 0===e&&(n=this.edgeList.size()-1),this.edgeList.get(n)},propagateSideLabels:function(t){for(var e=L.NONE,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();r.isArea(t)&&r.getLocation(t,cn.LEFT)!==L.NONE&&(e=r.getLocation(t,cn.LEFT))}if(e===L.NONE)return null;for(var s=e,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();if(r.getLocation(t,cn.ON)===L.NONE&&r.setLocation(t,cn.ON,s),r.isArea(t)){var o=r.getLocation(t,cn.LEFT),a=r.getLocation(t,cn.RIGHT);if(a!==L.NONE){if(a!==s)throw new sn("side location conflict",i.getCoordinate());o===L.NONE&&f.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),s=o}else f.isTrue(r.getLocation(t,cn.LEFT)===L.NONE,"found single null side"),r.setLocation(t,cn.RIGHT,s),r.setLocation(t,cn.LEFT,s)}}},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},print:function(t){A.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},isAreaLabelsConsistent:function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},checkAreaLabelsConsistent:function(t){var e=this.getEdges();if(e.size()<=0)return!0;var n=e.size()-1,i=e.get(n).getLabel(),r=i.getLocation(t,cn.LEFT);f.isTrue(r!==L.NONE,"Found unlabelled area edge");for(var s=r,o=this.iterator();o.hasNext();){var a=o.next(),u=a.getLabel();
f.isTrue(u.isArea(t),"Found non-area edge");var l=u.getLocation(t,cn.LEFT),h=u.getLocation(t,cn.RIGHT);if(l===h)return!1;if(h!==s)return!1;s=l}return!0},findIndex:function(t){this.iterator();for(var e=0;e<this.edgeList.size();e++){var n=this.edgeList.get(e);if(n===t)return e}return-1},iterator:function(){return this.getEdges().iterator()},getEdges:function(){return null===this.edgeList&&(this.edgeList=new I(this.edgeMap.values())),this.edgeList},getLocation:function(t,e,n){return this.ptInAreaLocation[t]===L.NONE&&(this.ptInAreaLocation[t]=Tn.locate(e,n[t].getGeometry())),this.ptInAreaLocation[t]},toString:function(){var t=new P;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n")}return t.toString()},computeEdgeEndLabels:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.computeLabel(t)}},computeLabelling:function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)r.isLine(s)&&r.getLocation(s)===L.BOUNDARY&&(e[s]=!0);for(var n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)if(r.isAnyNull(s)){var o=L.NONE;if(e[s])o=L.EXTERIOR;else{var a=i.getCoordinate();o=this.getLocation(s,a,t)}r.setAllLocationsIfNull(s,o)}},getDegree:function(){return this.edgeMap.size()},insertEdgeEnd:function(t,e){this.edgeMap.put(t,e),this.edgeList=null},interfaces_:function(){return[]},getClass:function(){return Pn}}),h(bn,Pn),e(bn.prototype,{linkResultDirectedEdges:function(){this.getResultAreaEdges();for(var t=null,e=null,n=this.SCANNING_FOR_INCOMING,i=0;i<this.resultAreaEdgeList.size();i++){var r=this.resultAreaEdgeList.get(i),s=r.getSym();if(r.getLabel().isArea())switch(null===t&&r.isInResult()&&(t=r),n){case this.SCANNING_FOR_INCOMING:if(!s.isInResult())continue;e=s,n=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(!r.isInResult())continue;e.setNext(r),n=this.SCANNING_FOR_INCOMING}}if(n===this.LINKING_TO_OUTGOING){if(null===t)throw new sn("no outgoing dirEdge found",this.getCoordinate());f.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}},insert:function(t){var e=t;this.insertEdgeEnd(e,e)},getRightmostEdge:function(){var t=this.getEdges(),e=t.size();if(1>e)return null;var n=t.get(0);if(1===e)return n;var i=t.get(e-1),r=n.getQuadrant(),s=i.getQuadrant();if(Je.isNorthern(r)&&Je.isNorthern(s))return n;if(!Je.isNorthern(r)&&!Je.isNorthern(s))return i;return 0!==n.getDy()?n:0!==i.getDy()?i:(f.shouldNeverReachHere("found two horizontal edges incident on node"),null)},print:function(t){A.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}},getResultAreaEdges:function(){if(null!==this.resultAreaEdgeList)return this.resultAreaEdgeList;this.resultAreaEdgeList=new I;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this.resultAreaEdgeList.add(e)}return this.resultAreaEdgeList},updateLabelling:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.setAllLocationsIfNull(0,t.getLocation(0)),i.setAllLocationsIfNull(1,t.getLocation(1))}},linkAllDirectedEdges:function(){this.getEdges();for(var t=null,e=null,n=this.edgeList.size()-1;n>=0;n--){var i=this.edgeList.get(n),r=i.getSym();null===e&&(e=r),null!==t&&r.setNext(t),t=i}e.setNext(t)},computeDepths:function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=(t.getLabel(),t.getDepth(cn.LEFT)),i=t.getDepth(cn.RIGHT),r=this.computeDepths(e+1,this.edgeList.size(),n),s=this.computeDepths(0,e,r);if(s!==i)throw new sn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=u,h=o;a>h;h++){var c=this.edgeList.get(h);c.getLabel();c.setEdgeDepths(cn.RIGHT,l),l=c.getDepth(cn.LEFT)}return l}},mergeSymLabels:function(){for(var t=this.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();n.merge(e.getSym().getLabel())}},linkMinimalDirectedEdges:function(t){for(var e=null,n=null,i=this.SCANNING_FOR_INCOMING,r=this.resultAreaEdgeList.size()-1;r>=0;r--){var s=this.resultAreaEdgeList.get(r),o=s.getSym();switch(null===e&&s.getEdgeRing()===t&&(e=s),i){case this.SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,i=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(s.getEdgeRing()!==t)continue;n.setNextMin(s),i=this.SCANNING_FOR_INCOMING}}i===this.LINKING_TO_OUTGOING&&(f.isTrue(null!==e,"found null for first outgoing dirEdge"),f.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))},getOutgoingDegree:function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();){var n=e.next();n.isInResult()&&t++}return t}if(1===arguments.length){for(var i=arguments[0],t=0,e=this.iterator();e.hasNext();){var n=e.next();n.getEdgeRing()===i&&t++}return t}},getLabel:function(){return this.label},findCoveredLineEdges:function(){for(var t=L.NONE,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=L.INTERIOR;break}if(i.isInResult()){t=L.EXTERIOR;break}}}if(t===L.NONE)return null;for(var r=t,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();n.isLineEdge()?n.getEdge().setCovered(r===L.INTERIOR):(n.isInResult()&&(r=L.EXTERIOR),i.isInResult()&&(r=L.INTERIOR))}},computeLabelling:function(t){Pn.prototype.computeLabelling.call(this,t),this.label=new gn(L.NONE);for(var e=this.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge(),r=i.getLabel(),s=0;2>s;s++){var o=r.getLocation(s);o!==L.INTERIOR&&o!==L.BOUNDARY||this.label.setLocation(s,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return bn}}),h(On,Nn),e(On.prototype,{createNode:function(t){return new yn(t,new bn)},interfaces_:function(){return[]},getClass:function(){return On}}),e(_n.prototype,{computeIntersections:function(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)},interfaces_:function(){return[]},getClass:function(){return _n}}),e(Mn.prototype,{isDelete:function(){return this.eventType===Mn.DELETE},setDeleteEventIndex:function(t){this.deleteEventIndex=t},getObject:function(){return this.obj},compareTo:function(t){var e=t;return this.xValue<e.xValue?-1:this.xValue>e.xValue?1:this.eventType<e.eventType?-1:this.eventType>e.eventType?1:0},getInsertEvent:function(){return this.insertEvent},isInsert:function(){return this.eventType===Mn.INSERT},isSameLabel:function(t){return null===this.label?!1:this.label===t.label},getDeleteEventIndex:function(){return this.deleteEventIndex},interfaces_:function(){return[s]},getClass:function(){return Mn}}),Mn.INSERT=1,Mn.DELETE=2,e(Dn.prototype,{interfaces_:function(){return[]},getClass:function(){return Dn}}),e(An.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(An.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.getNumPoints()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},setIsDoneIfProperInt:function(t){this.isDoneWhenProperInt=t},hasProperInteriorIntersection:function(){return this.hasProperInterior},isBoundaryPointInternal:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinate();if(t.isIntersection(r))return!0}return!1},hasProperIntersection:function(){return this.hasProper},hasIntersection:function(){return this._hasIntersection},isDone:function(){return this._isDone},isBoundaryPoint:function(t,e){return null===e?!1:this.isBoundaryPointInternal(t,e[0])?!0:!!this.isBoundaryPointInternal(t,e[1])},setBoundaryNodes:function(t,e){this.bdyNodes=new Array(2).fill(null),this.bdyNodes[0]=t,this.bdyNodes[1]=e},addIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this.numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this.includeProper&&this.li.isProper()||(t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)),this.li.isProper()&&(this.properIntersectionPoint=this.li.getIntersection(0).copy(),this.hasProper=!0,this.isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this.li,this.bdyNodes)||(this.hasProperInterior=!0))))},interfaces_:function(){return[]},getClass:function(){return An}}),An.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},h(Fn,Dn),e(Fn.prototype,{prepareEvents:function(){ho.sort(this.events);for(var t=0;t<this.events.size();t++){var e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}},computeIntersections:function(){if(1===arguments.length){var t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var e=0;e<this.events.size();e++){var n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof An&&R(arguments[0],y)&&R(arguments[1],y)){var i=arguments[0],r=arguments[1],s=arguments[2];this.addEdges(i,i),this.addEdges(r,r),this.computeIntersections(s)}else if("boolean"==typeof arguments[2]&&R(arguments[0],y)&&arguments[1]instanceof An){var o=arguments[0],a=arguments[1],u=arguments[2];u?this.addEdges(o,null):this.addEdges(o),this.computeIntersections(a)}},addEdge:function(t,e){for(var n=t.getMonotoneChainEdge(),i=n.getStartIndexes(),r=0;r<i.length-1;r++){var s=new _n(n,r),o=new Mn(e,n.getMinX(r),s);this.events.add(o),this.events.add(new Mn(n.getMaxX(r),o))}},processOverlaps:function(t,e,n,i){for(var r=n.getObject(),s=t;e>s;s++){var o=this.events.get(s);if(o.isInsert()){var a=o.getObject();n.isSameLabel(o)||(r.computeIntersections(a,i),this.nOverlaps++)}}},addEdges:function(){if(1===arguments.length)for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.addEdge(n,n)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],e=i.iterator();e.hasNext();){var n=e.next();this.addEdge(n,r)}},interfaces_:function(){return[]},getClass:function(){return Fn}}),e(Gn.prototype,{getMin:function(){return this.min},intersects:function(t,e){return!(this.min>e||this.max<t)},getMax:function(){return this.max},toString:function(){return se.toLineString(new g(this.min,0),new g(this.max,0))},interfaces_:function(){return[]},getClass:function(){return Gn}}),e(qn.prototype,{compare:function(t,e){var n=t,i=e,r=(n.min+n.max)/2,s=(i.min+i.max)/2;return s>r?-1:r>s?1:0},interfaces_:function(){return[a]},getClass:function(){return qn}}),Gn.NodeComparator=qn,h(Bn,Gn),e(Bn.prototype,{query:function(t,e,n){return this.intersects(t,e)?void n.visitItem(this.item):null},interfaces_:function(){return[]},getClass:function(){return Bn}}),h(zn,Gn),e(zn.prototype,{buildExtent:function(t,e){this.min=Math.min(t.min,e.min),this.max=Math.max(t.max,e.max)},query:function(t,e,n){return this.intersects(t,e)?(null!==this.node1&&this.node1.query(t,e,n),void(null!==this.node2&&this.node2.query(t,e,n))):null},interfaces_:function(){return[]},getClass:function(){return zn}}),e(Vn.prototype,{buildTree:function(){ho.sort(this.leaves,new IntervalRTreeNode.NodeComparator);for(var t=this.leaves,e=null,n=new I;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}},insert:function(t,e,n){if(null!==this.root)throw new IllegalStateException("Index cannot be added to once it has been queried");this.leaves.add(new Bn(t,e,n))},query:function(t,e,n){this.init(),this.root.query(t,e,n)},buildRoot:function(){return null!==this.root?null:void(this.root=this.buildTree())},printNode:function(t){A.out.println(se.toLineString(new g(t.min,this.level),new g(t.max,this.level)))},init:function(){return null!==this.root?null:void this.buildRoot()},buildLevel:function(t,e){this.level++,e.clear();for(var n=0;n<t.size();n+=2){var i=t.get(n),r=n+1<t.size()?t.get(n):null;if(null===r)e.add(i);else{var s=new zn(t.get(n),t.get(n+1));e.add(s)}}},interfaces_:function(){return[]},getClass:function(){return Vn}}),e(kn.prototype,{filter:function(t){if(this.isForcedToLineString&&t instanceof bt){var e=t.getFactory().createLineString(t.getCoordinateSequence());return this.lines.add(e),null}t instanceof St&&this.lines.add(t)},setForceToLineString:function(t){this.isForcedToLineString=t},interfaces_:function(){return[q]},getClass:function(){return kn}}),kn.getGeometry=function(){if(1===arguments.length){var t=arguments[0];return t.getFactory().buildGeometry(kn.getLines(t))}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().buildGeometry(kn.getLines(e,n))}},kn.getLines=function(){if(1===arguments.length){var t=arguments[0];return kn.getLines(t,!1)}if(2===arguments.length){if(R(arguments[0],v)&&R(arguments[1],v)){for(var e=arguments[0],n=arguments[1],i=e.iterator();i.hasNext();){var r=i.next();kn.getLines(r,n)}return n}if(arguments[0]instanceof B&&"boolean"==typeof arguments[1]){var s=arguments[0],o=arguments[1],a=new I;return s.apply(new kn(a,o)),a}if(arguments[0]instanceof B&&R(arguments[1],v)){var u=arguments[0],l=arguments[1];return u instanceof St?l.add(u):u.apply(new kn(l)),l}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&R(arguments[0],v)&&R(arguments[1],v)){for(var h=arguments[0],c=arguments[1],f=arguments[2],i=h.iterator();i.hasNext();){var r=i.next();kn.getLines(r,c,f)}return c}if("boolean"==typeof arguments[2]&&arguments[0]instanceof B&&R(arguments[1],v)){var g=arguments[0],d=arguments[1],p=arguments[2];return g.apply(new kn(d,p)),d}}},e(Yn.prototype,{visitItem:function(t){this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return Yn}}),e(Un.prototype,{locate:function(t){var e=new le(t),n=new Xn(e);return this.index.query(t.y,t.y,n),e.getLocation()},interfaces_:function(){return[Rn]},getClass:function(){return Un}}),e(Xn.prototype,{visitItem:function(t){var e=t;this.counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))},interfaces_:function(){return[Ae]},getClass:function(){return Xn}}),e(Hn.prototype,{init:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinates();this.addLine(r)}},addLine:function(t){for(var e=1;e<t.length;e++){var n=new ce(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),r=Math.max(n.p0.y,n.p1.y);this.index.insert(i,r,n)}},query:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yn;return this.index.query(t,e,n),n.getItems()}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.index.query(i,r,s)}},interfaces_:function(){return[]},getClass:function(){return Hn}}),Un.SegmentVisitor=Xn,Un.IntervalIndexedGeometry=Hn,e(Wn.prototype,{getSegmentIndex:function(){return this.segmentIndex},getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)},compareTo:function(t){var e=t;return this.compare(e.segmentIndex,e.dist)},isEndPoint:function(t){return 0===this.segmentIndex&&0===this.dist?!0:this.segmentIndex===t},toString:function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},getDistance:function(){return this.dist},compare:function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0},interfaces_:function(){return[s]},getClass:function(){return Wn}}),e(jn.prototype,{print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},addEndpoints:function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.pts[e.segmentIndex],r=e.dist>0||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.pts[a];return r&&(s[o]=e.coord),new Jn(s,new gn(this.edge.label))},add:function(t,e,n){var i=new Wn(t,e,n),r=this.nodeMap.get(i);return null!==r?r:(this.nodeMap.put(i,i),i)},isIntersection:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();if(n.coord.equals(t))return!0}return!1},interfaces_:function(){return[]},getClass:function(){return jn}}),e(Kn.prototype,{getChainStartIndices:function(t){var e=0,n=new I;n.add(new b(e));do{var i=this.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=Kn.toIntArray(n);return r},findChainEnd:function(t,e){for(var n=Je.quadrant(t[e],t[e+1]),i=e+1;i<t.length;){var r=Je.quadrant(t[i-1],t[i]);if(r!==n)break;i++}return i-1},interfaces_:function(){return[]},getClass:function(){return Kn}}),Kn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(Zn.prototype,{getCoordinates:function(){return this.pts},getMaxX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n},getMinX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return n>e?e:n},computeIntersectsForChain:function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5],h=this.pts[r],c=this.pts[s],f=o.pts[a],g=o.pts[u];if(s-r===1&&u-a===1)return l.addIntersections(this.e,r,o.e,a),null;if(this.env1.init(h,c),this.env2.init(f,g),!this.env1.intersects(this.env2))return null;var d=Math.trunc((r+s)/2),p=Math.trunc((a+u)/2);d>r&&(p>a&&this.computeIntersectsForChain(r,d,o,a,p,l),u>p&&this.computeIntersectsForChain(r,d,o,p,u,l)),s>d&&(p>a&&this.computeIntersectsForChain(d,s,o,a,p,l),u>p&&this.computeIntersectsForChain(d,s,o,p,u,l))}},getStartIndexes:function(){return this.startIndex},computeIntersects:function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)},interfaces_:function(){return[]},getClass:function(){return Zn}}),e(Qn.prototype,{getDepth:function(t,e){return this.depth[t][e]},setDepth:function(t,e,n){this.depth[t][e]=n},isNull:function(){if(0===arguments.length){for(var t=0;2>t;t++)for(var e=0;3>e;e++)if(this.depth[t][e]!==Qn.NULL_VALUE)return!1;return!0}if(1===arguments.length){var n=arguments[0];return this.depth[n][1]===Qn.NULL_VALUE}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this.depth[i][r]===Qn.NULL_VALUE}},normalize:function(){for(var t=0;2>t;t++)if(!this.isNull(t)){var e=this.depth[t][1];this.depth[t][2]<e&&(e=this.depth[t][2]),0>e&&(e=0);for(var n=1;3>n;n++){var i=0;this.depth[t][n]>e&&(i=1),this.depth[t][n]=i}}},getDelta:function(t){return this.depth[t][cn.RIGHT]-this.depth[t][cn.LEFT]},getLocation:function(t,e){return this.depth[t][e]<=0?L.EXTERIOR:L.INTERIOR},toString:function(){return"A: "+this.depth[0][1]+","+this.depth[0][2]+" B: "+this.depth[1][1]+","+this.depth[1][2]},add:function(){if(1===arguments.length)for(var t=arguments[0],e=0;2>e;e++)for(var n=1;3>n;n++){var i=t.getLocation(e,n);i!==L.EXTERIOR&&i!==L.INTERIOR||(this.isNull(e,n)?this.depth[e][n]=Qn.depthAtLocation(i):this.depth[e][n]+=Qn.depthAtLocation(i))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];o===L.INTERIOR&&this.depth[r][s]++}},interfaces_:function(){return[]},getClass:function(){return Qn}}),Qn.depthAtLocation=function(t){return t===L.EXTERIOR?0:t===L.INTERIOR?1:Qn.NULL_VALUE},Qn.NULL_VALUE=-1,h(Jn,mn),e(Jn.prototype,{getDepth:function(){return this.depth},getCollapsedEdge:function(){var t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];var e=new Jn(t,gn.toLineLabel(this.label));return e},isIsolated:function(){return this._isIsolated},getCoordinates:function(){return this.pts},setIsolated:function(t){this._isIsolated=t},setName:function(t){this.name=t},equals:function(t){if(!(t instanceof Jn))return!1;var e=t;if(this.pts.length!==e.pts.length)return!1;for(var n=!0,i=!0,r=this.pts.length,s=0;s<this.pts.length;s++)if(this.pts[s].equals2D(e.pts[s])||(n=!1),this.pts[s].equals2D(e.pts[--r])||(i=!1),!n&&!i)return!1;return!0},getCoordinate:function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}},print:function(t){t.print("edge "+this.name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this.label+" "+this.depthDelta)},computeIM:function(t){Jn.updateIM(this.label,t)},isCollapsed:function(){return this.label.isArea()?3!==this.pts.length?!1:!!this.pts[0].equals(this.pts[2]):!1},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getMaximumSegmentIndex:function(){return this.pts.length-1},getDepthDelta:function(){return this.depthDelta},getNumPoints:function(){return this.pts.length},printReverse:function(t){t.print("edge "+this.name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")},getMonotoneChainEdge:function(){return null===this.mce&&(this.mce=new Zn(this)),this.mce},getEnvelope:function(){if(null===this.env){this.env=new C;for(var t=0;t<this.pts.length;t++)this.env.expandToInclude(this.pts[t])}return this.env},addIntersection:function(t,e,n,i){var r=new g(t.getIntersection(i)),s=e,o=t.getEdgeDistance(n,i),a=s+1;if(a<this.pts.length){var u=this.pts[a];r.equals2D(u)&&(s=a,o=0)}this.eiList.add(r,s,o)},toString:function(){var t=new P;t.append("edge "+this.name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this.label+" "+this.depthDelta),t.toString()},isPointwiseEqual:function(t){if(this.pts.length!==t.pts.length)return!1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0},setDepthDelta:function(t){this.depthDelta=t},getEdgeIntersectionList:function(){return this.eiList},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[]},getClass:function(){return Jn}}),Jn.updateIM=function(){if(2!==arguments.length)return mn.prototype.updateIM.apply(this,arguments);var t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,cn.ON),t.getLocation(1,cn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,cn.LEFT),t.getLocation(1,cn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,cn.RIGHT),t.getLocation(1,cn.RIGHT),2))},h($n,Cn),e($n.prototype,{insertBoundaryPoint:function(t,e){var n=this.nodes.addNode(e),i=n.getLabel(),r=1,s=L.NONE;s=i.getLocation(t,cn.ON),s===L.BOUNDARY&&r++;var o=$n.determineBoundary(this.boundaryNodeRule,r);i.setLocation(t,o)},computeSelfNodes:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=new An(n,!0,!1);s.setIsDoneIfProperInt(r);var o=this.createEdgeSetIntersector(),a=this.parentGeom instanceof bt||this.parentGeom instanceof Tt||this.parentGeom instanceof Ot,u=i||!a;return o.computeIntersections(this.edges,s,u),this.addSelfIntersectionNodes(this.argIndex),s}},computeSplitEdges:function(t){for(var e=this.edges.iterator();e.hasNext();){var n=e.next();n.eiList.addSplitEdges(t)}},computeEdgeIntersections:function(t,e,n){var i=new An(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());var r=this.createEdgeSetIntersector();return r.computeIntersections(this.edges,t.edges,i),i},getGeometry:function(){return this.parentGeom},getBoundaryNodeRule:function(){return this.boundaryNodeRule},hasTooFewPoints:function(){return this._hasTooFewPoints},addPoint:function(){if(arguments[0]instanceof Lt){var t=arguments[0],e=t.getCoordinate();this.insertPoint(this.argIndex,e,L.INTERIOR)}else if(arguments[0]instanceof g){var n=arguments[0];this.insertPoint(this.argIndex,n,L.INTERIOR)}},addPolygon:function(t){this.addPolygonRing(t.getExteriorRing(),L.EXTERIOR,L.INTERIOR);for(var e=0;e<t.getNumInteriorRing();e++){var n=t.getInteriorRingN(e);this.addPolygonRing(n,L.INTERIOR,L.EXTERIOR)}},addEdge:function(t){this.insertEdge(t);var e=t.getCoordinates();this.insertPoint(this.argIndex,e[0],L.BOUNDARY),this.insertPoint(this.argIndex,e[e.length-1],L.BOUNDARY)},addLineString:function(t){var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this.invalidPoint=e[0],null;var n=new Jn(e,new gn(this.argIndex,L.INTERIOR));this.lineEdgeMap.put(t,n),this.insertEdge(n),f.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this.argIndex,e[0]),this.insertBoundaryPoint(this.argIndex,e[e.length-1])},getInvalidPoint:function(){return this.invalidPoint},getBoundaryPoints:function(){for(var t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null),n=0,i=t.iterator();i.hasNext();){var r=i.next();e[n++]=r.getCoordinate().copy()}return e},getBoundaryNodes:function(){return null===this.boundaryNodes&&(this.boundaryNodes=this.nodes.getBoundaryNodes(this.argIndex)),this.boundaryNodes},addSelfIntersectionNode:function(t,e,n){return this.isBoundaryNode(t,e)?null:void(n===L.BOUNDARY&&this.useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n))},addPolygonRing:function(t,e,n){if(t.isEmpty())return null;var i=H.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this.invalidPoint=i[0],null;var r=e,s=n;he.isCCW(i)&&(r=n,s=e);var o=new Jn(i,new gn(this.argIndex,L.BOUNDARY,r,s));this.lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this.argIndex,i[0],L.BOUNDARY)},insertPoint:function(t,e,n){var i=this.nodes.addNode(e),r=i.getLabel();null===r?i.label=new gn(t,n):r.setLocation(t,n)},createEdgeSetIntersector:function(){return new Fn},addSelfIntersectionNodes:function(t){for(var e=this.edges.iterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.eiList.iterator();r.hasNext();){var s=r.next();this.addSelfIntersectionNode(t,s.coord,i)}},add:function(){if(1!==arguments.length)return Cn.prototype.add.apply(this,arguments);var t=arguments[0];if(t.isEmpty())return null;if(t instanceof Ot&&(this.useBoundaryDeterminationRule=!1),t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},locate:function(t){return R(this.parentGeom,Rt)&&this.parentGeom.getNumGeometries()>50?(null===this.areaPtLocator&&(this.areaPtLocator=new Un(this.parentGeom)),this.areaPtLocator.locate(t)):this.ptLocator.locate(t,this.parentGeom)},findEdge:function(){if(1===arguments.length){var t=arguments[0];return this.lineEdgeMap.get(t)}return Cn.prototype.findEdge.apply(this,arguments)},interfaces_:function(){return[]},getClass:function(){return $n}}),$n.determineBoundary=function(t,e){return t.isInBoundary(e)?L.BOUNDARY:L.INTERIOR},e(ti.prototype,{getArgGeometry:function(t){return this.arg[t].getGeometry()},setComputationPrecision:function(t){this.resultPrecisionModel=t,this.li.setPrecisionModel(this.resultPrecisionModel)},interfaces_:function(){return[]},getClass:function(){return ti}}),e(ei.prototype,{compareTo:function(t){var e=t,n=ei.compareOriented(this.pts,this._orientation,e.pts,e._orientation);return n},interfaces_:function(){return[s]},getClass:function(){return ei}}),ei.orientation=function(t){return 1===H.increasingDirection(t)},ei.compareOriented=function(t,e,n,i){for(var r=e?1:-1,s=i?1:-1,o=e?t.length:-1,a=i?n.length:-1,u=e?0:t.length-1,l=i?0:n.length-1;;){var h=t[u].compareTo(n[l]);if(0!==h)return h;u+=r,l+=s;var c=u===o,f=l===a;if(c&&!f)return-1;if(!c&&f)return 1;if(c&&f)return 0}},e(ni.prototype,{print:function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this.edges.size();e++){var n=this.edges.get(e);e>0&&t.print(","),t.print("(");for(var i=n.getCoordinates(),r=0;r<i.length;r++)r>0&&t.print(","),t.print(i[r].x+" "+i[r].y);t.println(")")}t.print(")  ")},addAll:function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next())},findEdgeIndex:function(t){for(var e=0;e<this.edges.size();e++)if(this.edges.get(e).equals(t))return e;return-1},iterator:function(){return this.edges.iterator()},getEdges:function(){return this.edges},get:function(t){return this.edges.get(t)},findEqualEdge:function(t){var e=new ei(t.getCoordinates()),n=this.ocaMap.get(e);return n},add:function(t){this.edges.add(t);var e=new ei(t.getCoordinates());this.ocaMap.put(e,t)},interfaces_:function(){return[]},getClass:function(){return ni}}),h(ii,ti),e(ii.prototype,{insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip());var r=e.getDepth();r.isNull()&&r.add(n),r.add(i),n.merge(i)}else this.edgeList.add(t)},getGraph:function(){return this.graph},cancelDuplicateResultEdges:function(){for(var t=this.graph.getEdgeEnds().iterator();t.hasNext();){var e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}},isCoveredByLA:function(t){return this.isCovered(t,this.resultLineList)?!0:!!this.isCovered(t,this.resultPolyList)},computeGeometry:function(t,e,n,i){var r=new I;return r.addAll(t),r.addAll(e),r.addAll(n),r.isEmpty()?ii.createEmptyResult(i,this.arg[0].getGeometry(),this.arg[1].getGeometry(),this.geomFact):this.geomFact.buildGeometry(r)},mergeSymLabels:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().mergeSymLabels()}},isCovered:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=this.ptLocator.locate(t,i);if(r!==L.EXTERIOR)return!0}return!1},replaceCollapsedEdges:function(){for(var t=new I,e=this.edgeList.iterator();e.hasNext();){var n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this.edgeList.addAll(t)},updateNodeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}},getResultGeometry:function(t){return this.computeOverlay(t),this.resultGeom},insertUniqueEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertUniqueEdge(n)}},computeOverlay:function(t){this.copyPoints(0),this.copyPoints(1),this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1),this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!0);var e=new I;this.arg[0].computeSplitEdges(e),this.arg[1].computeSplitEdges(e);this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),ln.checkValid(this.edgeList.getEdges()),this.graph.addEdges(this.edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();var n=new Sn(this.geomFact);n.add(this.graph),this.resultPolyList=n.getPolygons();var i=new wn(this,this.geomFact,this.ptLocator);this.resultLineList=i.build(t);var r=new Ln(this,this.geomFact,this.ptLocator);this.resultPointList=r.build(t),
this.resultGeom=this.computeGeometry(this.resultPointList,this.resultLineList,this.resultPolyList,t)},labelIncompleteNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setLocation(e,n)},copyPoints:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.graph.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},findResultAreaEdges:function(t){for(var e=this.graph.getEdgeEnds().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.isArea()&&!n.isInteriorAreaEdge()&&ii.isResultOfOp(i.getLocation(0,cn.RIGHT),i.getLocation(1,cn.RIGHT),t)&&n.setInResult(!0)}},computeLabelsFromDepths:function(){for(var t=this.edgeList.iterator();t.hasNext();){var e=t.next(),n=e.getLabel(),i=e.getDepth();if(!i.isNull()){i.normalize();for(var r=0;2>r;r++)n.isNull(r)||!n.isArea()||i.isNull(r)||(0===i.getDelta(r)?n.toLine(r):(f.isTrue(!i.isNull(r,cn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(r,cn.LEFT,i.getLocation(r,cn.LEFT)),f.isTrue(!i.isNull(r,cn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(r,cn.RIGHT,i.getLocation(r,cn.RIGHT))))}}},computeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}this.mergeSymLabels(),this.updateNodeLabelling()},labelIncompleteNodes:function(){for(var t=0,e=this.graph.getNodes().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(t++,i.isNull(0)?this.labelIncompleteNode(n,0):this.labelIncompleteNode(n,1)),n.getEdges().updateLabelling(i)}},isCoveredByA:function(t){return!!this.isCovered(t,this.resultPolyList)},interfaces_:function(){return[]},getClass:function(){return ii}}),ii.overlayOp=function(t,e,n){var i=new ii(t,e),r=i.getResultGeometry(n);return r},ii.intersection=function(t,e){if(t.isEmpty()||e.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){var n=e;return hn.map(t,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(n)}})}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.INTERSECTION)},ii.symDifference=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.SYMDIFFERENCE)},ii.resultDimension=function(t,e,n){var i=e.getDimension(),r=n.getDimension(),s=-1;switch(t){case ii.INTERSECTION:s=Math.min(i,r);break;case ii.UNION:s=Math.max(i,r);break;case ii.DIFFERENCE:s=i;break;case ii.SYMDIFFERENCE:s=Math.max(i,r)}return s},ii.createEmptyResult=function(t,e,n,i){var r=null;switch(ii.resultDimension(t,e,n)){case-1:r=i.createGeometryCollection(new Array(0).fill(null));break;case 0:r=i.createPoint();break;case 1:r=i.createLineString();break;case 2:r=i.createPolygon()}return r},ii.difference=function(t,e){return t.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,t,e,t.getFactory()):e.isEmpty()?t.copy():(t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.DIFFERENCE))},ii.isResultOfOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=t.getLocation(0),i=t.getLocation(1);return ii.isResultOfOp(n,i,e)}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];switch(r===L.BOUNDARY&&(r=L.INTERIOR),s===L.BOUNDARY&&(s=L.INTERIOR),o){case ii.INTERSECTION:return r===L.INTERIOR&&s===L.INTERIOR;case ii.UNION:return r===L.INTERIOR||s===L.INTERIOR;case ii.DIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR;case ii.SYMDIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR||r!==L.INTERIOR&&s===L.INTERIOR}return!1}},ii.INTERSECTION=1,ii.UNION=2,ii.DIFFERENCE=3,ii.SYMDIFFERENCE=4,e(ri.prototype,{selfSnap:function(t){var e=new Ie(t),n=e.snapTo(t,this.snapTolerance);return n},removeCommonBits:function(t){this.cbr=new Se,this.cbr.add(t[0]),this.cbr.add(t[1]);var e=new Array(2).fill(null);return e[0]=this.cbr.removeCommonBits(t[0].copy()),e[1]=this.cbr.removeCommonBits(t[1].copy()),e},prepareResult:function(t){return this.cbr.addCommonBits(t),t},getResultGeometry:function(t){var e=this.snap(this.geom),n=ii.overlayOp(e[0],e[1],t);return this.prepareResult(n)},checkValid:function(t){t.isValid()||A.out.println("Snapped geometry is invalid")},computeSnapTolerance:function(){this.snapTolerance=Ie.computeOverlaySnapTolerance(this.geom[0],this.geom[1])},snap:function(t){var e=this.removeCommonBits(t),n=Ie.snap(e[0],e[1],this.snapTolerance);return n},interfaces_:function(){return[]},getClass:function(){return ri}}),ri.overlayOp=function(t,e,n){var i=new ri(t,e);return i.getResultGeometry(n)},ri.union=function(t,e){return ri.overlayOp(t,e,ii.UNION)},ri.intersection=function(t,e){return ri.overlayOp(t,e,ii.INTERSECTION)},ri.symDifference=function(t,e){return ri.overlayOp(t,e,ii.SYMDIFFERENCE)},ri.difference=function(t,e){return ri.overlayOp(t,e,ii.DIFFERENCE)},e(si.prototype,{getResultGeometry:function(t){var e=null,n=!1,i=null;try{e=ii.overlayOp(this.geom[0],this.geom[1],t);var r=!0;r&&(n=!0)}catch(t){if(!(t instanceof l))throw t;i=t}finally{}if(!n)try{e=ri.overlayOp(this.geom[0],this.geom[1],t)}catch(t){throw t instanceof l?i:t}finally{}return e},interfaces_:function(){return[]},getClass:function(){return si}}),si.overlayOp=function(t,e,n){var i=new si(t,e);return i.getResultGeometry(n)},si.union=function(t,e){return si.overlayOp(t,e,ii.UNION)},si.intersection=function(t,e){return si.overlayOp(t,e,ii.INTERSECTION)},si.symDifference=function(t,e){return si.overlayOp(t,e,ii.SYMDIFFERENCE)},si.difference=function(t,e){return si.overlayOp(t,e,ii.DIFFERENCE)},e(oi.prototype,{addPolygon:function(t){if(t.isEmpty())return null;var e=null,n=0,i=this.horizontalBisector(t);if(0===i.getLength())n=0,e=i.getCoordinate();else{var r=si.overlayOp(i,t,ii.INTERSECTION),s=this.widestGeometry(r);n=s.getEnvelopeInternal().getWidth(),e=oi.centre(s.getEnvelopeInternal())}(null===this.interiorPoint||n>this.maxWidth)&&(this.interiorPoint=e,this.maxWidth=n)},getInteriorPoint:function(){return this.interiorPoint},widestGeometry:function t(){if(arguments[0]instanceof ft){var e=arguments[0];if(e.isEmpty())return e;for(var t=e.getGeometryN(0),n=1;n<e.getNumGeometries();n++)e.getGeometryN(n).getEnvelopeInternal().getWidth()>t.getEnvelopeInternal().getWidth()&&(t=e.getGeometryN(n));return t}if(arguments[0]instanceof B){var i=arguments[0];return i instanceof ft?this.widestGeometry(i):i}},horizontalBisector:function(t){var e=t.getEnvelopeInternal(),n=ai.getBisectorY(t);return this.factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])},add:function(t){if(t instanceof Tt)this.addPolygon(t);else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))},interfaces_:function(){return[]},getClass:function(){return oi}}),oi.centre=function(t){return new g(oi.avg(t.getMinX(),t.getMaxX()),oi.avg(t.getMinY(),t.getMaxY()))},oi.avg=function(t,e){return(t+e)/2},e(ai.prototype,{updateInterval:function(t){t<=this.centreY?t>this.loY&&(this.loY=t):t>this.centreY&&t<this.hiY&&(this.hiY=t)},getBisectorY:function(){this.process(this.poly.getExteriorRing());for(var t=0;t<this.poly.getNumInteriorRing();t++)this.process(this.poly.getInteriorRingN(t));var e=oi.avg(this.hiY,this.loY);return e},process:function(t){for(var e=t.getCoordinateSequence(),n=0;n<e.size();n++){var i=e.getY(n);this.updateInterval(i)}},interfaces_:function(){return[]},getClass:function(){return ai}}),ai.getBisectorY=function(t){var e=new ai(t);return e.getBisectorY()},oi.SafeBisectorFinder=ai,e(ui.prototype,{addEndpoints:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addEndpoints(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addEndpoints(e.getGeometryN(n))}else if(arguments[0]instanceof Array){var i=arguments[0];this.add(i[0]),this.add(i[i.length-1])}},getInteriorPoint:function(){return this.interiorPoint},addInterior:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addInterior(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addInterior(e.getGeometryN(n))}else if(arguments[0]instanceof Array)for(var i=arguments[0],n=1;n<i.length-1;n++)this.add(i[n])},add:function(t){var e=t.distance(this.centroid);e<this.minDistance&&(this.interiorPoint=new g(t),this.minDistance=e)},interfaces_:function(){return[]},getClass:function(){return ui}}),e(li.prototype,{getInteriorPoint:function(){return this.interiorPoint},add:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof Lt)this.add(t.getCoordinate());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))}else if(arguments[0]instanceof g){var i=arguments[0],r=i.distance(this.centroid);r<this.minDistance&&(this.interiorPoint=new g(i),this.minDistance=r)}},interfaces_:function(){return[]},getClass:function(){return li}}),e(hi.prototype,{interfaces_:function(){return[]},getClass:function(){return hi}}),hi.toDegrees=function(t){return 180*t/Math.PI},hi.normalize=function(t){for(;t>Math.PI;)t-=hi.PI_TIMES_2;for(;t<=-Math.PI;)t+=hi.PI_TIMES_2;return t},hi.angle=function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],i=n.x-e.x,r=n.y-e.y;return Math.atan2(r,i)}},hi.isAcute=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return a>0},hi.isObtuse=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return 0>a},hi.interiorAngle=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n);return Math.abs(r-i)},hi.normalizePositive=function(t){if(0>t){for(;0>t;)t+=hi.PI_TIMES_2;t>=hi.PI_TIMES_2&&(t=0)}else{for(;t>=hi.PI_TIMES_2;)t-=hi.PI_TIMES_2;0>t&&(t=0)}return t},hi.angleBetween=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n);return hi.diff(i,r)},hi.diff=function(t,e){var n=null;return n=e>t?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n},hi.toRadians=function(t){return t*Math.PI/180},hi.getTurn=function(t,e){var n=Math.sin(e-t);return n>0?hi.COUNTERCLOCKWISE:0>n?hi.CLOCKWISE:hi.NONE},hi.angleBetweenOriented=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n),s=r-i;return s<=-Math.PI?s+hi.PI_TIMES_2:s>Math.PI?s-hi.PI_TIMES_2:s},hi.PI_TIMES_2=2*Math.PI,hi.PI_OVER_2=Math.PI/2,hi.PI_OVER_4=Math.PI/4,hi.COUNTERCLOCKWISE=he.COUNTERCLOCKWISE,hi.CLOCKWISE=he.CLOCKWISE,hi.NONE=he.COLLINEAR,e(ci.prototype,{area:function(){return ci.area(this.p0,this.p1,this.p2)},signedArea:function(){return ci.signedArea(this.p0,this.p1,this.p2)},interpolateZ:function(t){if(null===t)throw new i("Supplied point is null.");return ci.interpolateZ(t,this.p0,this.p1,this.p2)},longestSideLength:function(){return ci.longestSideLength(this.p0,this.p1,this.p2)},isAcute:function(){return ci.isAcute(this.p0,this.p1,this.p2)},circumcentre:function(){return ci.circumcentre(this.p0,this.p1,this.p2)},area3D:function(){return ci.area3D(this.p0,this.p1,this.p2)},centroid:function(){return ci.centroid(this.p0,this.p1,this.p2)},inCentre:function(){return ci.inCentre(this.p0,this.p1,this.p2)},interfaces_:function(){return[]},getClass:function(){return ci}}),ci.area=function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)},ci.signedArea=function(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2},ci.det=function(t,e,n,i){return t*i-e*n},ci.interpolateZ=function(t,e,n,i){var r=e.x,s=e.y,o=n.x-r,a=i.x-r,u=n.y-s,l=i.y-s,h=o*l-a*u,c=t.x-r,f=t.y-s,g=(l*c-a*f)/h,d=(-u*c+o*f)/h,p=e.z+g*(n.z-e.z)+d*(i.z-e.z);return p},ci.longestSideLength=function(t,e,n){var i=t.distance(e),r=e.distance(n),s=n.distance(t),o=i;return r>o&&(o=r),s>o&&(o=s),o},ci.isAcute=function(t,e,n){return hi.isAcute(t,e,n)&&hi.isAcute(e,n,t)?!!hi.isAcute(n,t,e):!1},ci.circumcentre=function(t,e,n){var i=n.x,r=n.y,s=t.x-i,o=t.y-r,a=e.x-i,u=e.y-r,l=2*ci.det(s,o,a,u),h=ci.det(o,s*s+o*o,u,a*a+u*u),c=ci.det(s,s*s+o*o,a,a*a+u*u),f=i-h/l,d=r+c/l;return new g(f,d)},ci.perpendicularBisector=function(t,e){var n=e.x-t.x,i=e.y-t.y,r=new F(t.x+n/2,t.y+i/2,1),s=new F(t.x-i+n/2,t.y+n+i/2,1);return new F(r,s)},ci.angleBisector=function(t,e,n){var i=e.distance(t),r=e.distance(n),s=i/(i+r),o=n.x-t.x,a=n.y-t.y,u=new g(t.x+s*o,t.y+s*a);return u},ci.area3D=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=e.z-t.z,o=n.x-t.x,a=n.y-t.y,u=n.z-t.z,l=r*u-s*a,h=s*o-i*u,c=i*a-r*o,f=l*l+h*h+c*c,g=Math.sqrt(f)/2;return g},ci.centroid=function(t,e,n){var i=(t.x+e.x+n.x)/3,r=(t.y+e.y+n.y)/3;return new g(i,r)},ci.inCentre=function(t,e,n){var i=e.distance(n),r=t.distance(n),s=t.distance(e),o=i+r+s,a=(i*t.x+r*e.x+s*n.x)/o,u=(i*t.y+r*e.y+s*n.y)/o;return new g(a,u)},e(fi.prototype,{getRadius:function(){return this.compute(),this.radius},getDiameter:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[1];return this.input.getFactory().createLineString([t,e])},getExtremalPoints:function(){return this.compute(),this.extremalPts},computeCirclePoints:function(){if(this.input.isEmpty())return this.extremalPts=new Array(0).fill(null),null;if(1===this.input.getNumPoints()){var t=this.input.getCoordinates();return this.extremalPts=[new g(t[0])],null}var e=this.input.convexHull(),n=e.getCoordinates(),t=n;if(n[0].equals2D(n[n.length-1])&&(t=new Array(n.length-1).fill(null),H.copyDeep(n,0,t,0,n.length-1)),t.length<=2)return this.extremalPts=H.copyDeep(t),null;for(var i=fi.lowestPoint(t),r=fi.pointWitMinAngleWithX(t,i),s=0;s<t.length;s++){var o=fi.pointWithMinAngleWithSegment(t,i,r);if(hi.isObtuse(i,o,r))return this.extremalPts=[new g(i),new g(r)],null;if(hi.isObtuse(o,i,r))i=o;else{if(!hi.isObtuse(o,r,i))return this.extremalPts=[new g(i),new g(r),new g(o)],null;r=o}}f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")},compute:function(){return null!==this.extremalPts?null:(this.computeCirclePoints(),this.computeCentre(),void(null!==this.centre&&(this.radius=this.centre.distance(this.extremalPts[0]))))},getFarthestPoints:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[this.extremalPts.length-1];return this.input.getFactory().createLineString([t,e])},getCircle:function(){if(this.compute(),null===this.centre)return this.input.getFactory().createPolygon();var t=this.input.getFactory().createPoint(this.centre);return 0===this.radius?t:t.buffer(this.radius)},getCentre:function(){return this.compute(),this.centre},computeCentre:function(){switch(this.extremalPts.length){case 0:this.centre=null;break;case 1:this.centre=this.extremalPts[0];break;case 2:this.centre=new g((this.extremalPts[0].x+this.extremalPts[1].x)/2,(this.extremalPts[0].y+this.extremalPts[1].y)/2);break;case 3:this.centre=ci.circumcentre(this.extremalPts[0],this.extremalPts[1],this.extremalPts[2])}},interfaces_:function(){return[]},getClass:function(){return fi}}),fi.pointWitMinAngleWithX=function(t,e){for(var n=r.MAX_VALUE,i=null,s=0;s<t.length;s++){var o=t[s];if(o!==e){var a=o.x-e.x,u=o.y-e.y;0>u&&(u=-u);var l=Math.sqrt(a*a+u*u),h=u/l;n>h&&(n=h,i=o)}}return i},fi.lowestPoint=function(t){for(var e=t[0],n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e},fi.pointWithMinAngleWithSegment=function(t,e,n){for(var i=r.MAX_VALUE,s=null,o=0;o<t.length;o++){var a=t[o];if(a!==e&&a!==n){var u=hi.angleBetween(e,a,n);i>u&&(i=u,s=a)}}return s},e(gi.prototype,{getWidthCoordinate:function(){return this.computeMinimumDiameter(),this.minWidthPt},getSupportingSegment:function(){return this.computeMinimumDiameter(),this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0,this.minBaseSeg.p1])},getDiameter:function(){if(this.computeMinimumDiameter(),null===this.minWidthPt)return this.inputGeom.getFactory().createLineString(null);var t=this.minBaseSeg.project(this.minWidthPt);return this.inputGeom.getFactory().createLineString([t,this.minWidthPt])},computeWidthConvex:function(t){t instanceof Tt?this.convexHullPts=t.getExteriorRing().getCoordinates():this.convexHullPts=t.getCoordinates(),0===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=null,this.minBaseSeg=null):1===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[0]):2===this.convexHullPts.length||3===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[1]):this.computeConvexRingMinDiameter(this.convexHullPts)},computeConvexRingMinDiameter:function(t){this.minWidth=r.MAX_VALUE;for(var e=1,n=new ce,i=0;i<t.length-1;i++)n.p0=t[i],n.p1=t[i+1],e=this.findMaxPerpDistance(t,n,e)},computeMinimumDiameter:function(){if(null!==this.minWidthPt)return null;if(this.isConvex)this.computeWidthConvex(this.inputGeom);else{var t=new me(this.inputGeom).getConvexHull();this.computeWidthConvex(t)}},getLength:function(){return this.computeMinimumDiameter(),this.minWidth},findMaxPerpDistance:function(t,e,n){for(var i=e.distancePerpendicular(t[n]),r=i,s=n,o=s;r>=i;)i=r,s=o,o=gi.nextIndex(t,s),r=e.distancePerpendicular(t[o]);return i<this.minWidth&&(this.minPtIndex=s,this.minWidth=i,this.minWidthPt=t[this.minPtIndex],this.minBaseSeg=new ce(e)),s},getMinimumRectangle:function(){if(this.computeMinimumDiameter(),0===this.minWidth)return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)?this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0):this.minBaseSeg.toGeometry(this.inputGeom.getFactory());for(var t=this.minBaseSeg.p1.x-this.minBaseSeg.p0.x,e=this.minBaseSeg.p1.y-this.minBaseSeg.p0.y,n=r.MAX_VALUE,i=-r.MAX_VALUE,s=r.MAX_VALUE,o=-r.MAX_VALUE,a=0;a<this.convexHullPts.length;a++){var u=gi.computeC(t,e,this.convexHullPts[a]);u>i&&(i=u),n>u&&(n=u);var l=gi.computeC(-e,t,this.convexHullPts[a]);l>o&&(o=l),s>l&&(s=l)}var h=gi.computeSegmentForLine(-t,-e,o),c=gi.computeSegmentForLine(-t,-e,s),f=gi.computeSegmentForLine(-e,t,i),g=gi.computeSegmentForLine(-e,t,n),d=f.lineIntersection(h),p=g.lineIntersection(h),v=g.lineIntersection(c),m=f.lineIntersection(c),y=this.inputGeom.getFactory().createLinearRing([d,p,v,m,d]);return this.inputGeom.getFactory().createPolygon(y,null)},interfaces_:function(){return[]},getClass:function(){return gi}}),gi.nextIndex=function(t,e){return e++,e>=t.length&&(e=0),e},gi.computeC=function(t,e,n){return t*n.y-e*n.x},gi.getMinimumDiameter=function(t){return new gi(t).getDiameter()},gi.getMinimumRectangle=function(t){return new gi(t).getMinimumRectangle()},gi.computeSegmentForLine=function(t,e,n){var i=null,r=null;return Math.abs(e)>Math.abs(t)?(i=new g(0,n/e),r=new g(1,n/e-t/e)):(i=new g(n/t,0),r=new g(n/t-e/t,1)),new ce(i,r)};var co=Object.freeze({Centroid:ge,CGAlgorithms:he,ConvexHull:me,InteriorPointArea:oi,InteriorPointLine:ui,InteriorPointPoint:li,RobustLineIntersector:ae,MinimumBoundingCircle:fi,MinimumDiameter:gi});e(di.prototype,{getResultGeometry:function(){return new pi(this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>=t)throw new i("Tolerance must be positive");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return di}}),di.densifyPoints=function(t,e,n){for(var i=new ce,r=new N,s=0;s<t.length-1;s++){i.p0=t[s],i.p1=t[s+1],r.add(i.p0,!1);var o=i.getLength(),a=Math.trunc(o/e)+1;if(a>1)for(var u=o/a,l=1;a>l;l++){var h=l*u/o,c=i.pointAlong(h);n.makePrecise(c),r.add(c,!1)}}return r.add(t[t.length-1],!1),r.toCoordinateArray()},di.densify=function(t,e){var n=new di(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(pi,xe),e(pi.prototype,{transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformPolygon:function(t,e){var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=di.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof St&&1===i.length&&(i=new Array(0).fill(null)),this.factory.getCoordinateSequenceFactory().create(i)},createValidArea:function(t){return t.buffer(0)},interfaces_:function(){return[]},getClass:function(){return pi}}),di.DensifyTransformer=pi;var fo=Object.freeze({Densifier:di});e(vi.prototype,{find:function(t){var e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null},dest:function(){return this._sym._orig},oNext:function(){return this._sym._next},insert:function(t){if(this.oNext()===this)return this.insertAfter(t),null;var e=this.compareTo(t),n=this;do{var i=n.oNext(),r=i.compareTo(t);if(r!==e||i===this)return n.insertAfter(t),null;n=i}while(n!==this);f.shouldNeverReachHere()},insertAfter:function(t){f.equals(this._orig,t.orig());var e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)},degree:function t(){var t=0,e=this;do t++,e=e.oNext();while(e!==this);return t},equals:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}},deltaY:function(){return this._sym._orig.y-this._orig.y},sym:function(){return this._sym},prev:function(){return this._sym.next()._sym},compareAngularDirection:function(t){var e=this.deltaX(),n=this.deltaY(),i=t.deltaX(),r=t.deltaY();if(e===i&&n===r)return 0;var s=Je.quadrant(e,n),o=Je.quadrant(i,r);return s>o?1:o>s?-1:he.computeOrientation(t._orig,t.dest(),this.dest())},prevNode:function(){for(var t=this;2===t.degree();)if(t=t.prev(),t===this)return null;return t},compareTo:function(t){var e=t,n=this.compareAngularDirection(e);return n},next:function(){return this._next},setSym:function(t){this._sym=t},orig:function(){return this._orig},toString:function(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"},setNext:function(t){this._next=t},init:function(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)},deltaX:function(){return this._sym._orig.x-this._orig.x},interfaces_:function(){return[]},getClass:function(){return vi}}),vi.init=function(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t},vi.create=function(t,e){var n=new vi(t),i=new vi(e);return n.init(i),n},h(mi,vi),e(mi.prototype,{mark:function(){this._isMarked=!0},setMark:function(t){this._isMarked=t},isMarked:function(){return this._isMarked},interfaces_:function(){return[]},getClass:function(){return mi}}),mi.setMarkBoth=function(t,e){t.setMark(e),t.sym().setMark(e)},mi.isMarked=function(t){return t.isMarked()},mi.setMark=function(t,e){t.setMark(e)},mi.markBoth=function(t){t.mark(),t.sym().mark()},mi.mark=function(t){t.mark()},e(yi.prototype,{insert:function(t,e,n){var i=this.create(t,e);null!==n?n.insert(i):this.vertexMap.put(t,i);var r=this.vertexMap.get(e);return null!==r?r.insert(i.sym()):this.vertexMap.put(e,i.sym()),i},create:function(t,e){var n=this.createEdge(t),i=this.createEdge(e);return vi.init(n,i),n},createEdge:function(t){return new vi(t)},addEdge:function(t,e){if(!yi.isValidEdge(t,e))return null;var n=this.vertexMap.get(t),i=null;if(null!==n&&(i=n.find(e)),null!==i)return i;var r=this.insert(t,e,n);return r},getVertexEdges:function(){return this.vertexMap.values()},findEdge:function(t,e){var n=this.vertexMap.get(t);return null===n?null:n.find(e)},interfaces_:function(){return[]},getClass:function(){return yi}}),yi.isValidEdge=function(t,e){var n=e.compareTo(t);return 0!==n},h(xi,mi),e(xi.prototype,{setStart:function(){this._isStart=!0},isStart:function(){return this._isStart},interfaces_:function(){return[]},getClass:function(){return xi}}),h(Ei,yi),e(Ei.prototype,{createEdge:function(t){return new xi(t)},interfaces_:function(){return[]},getClass:function(){return Ei}}),e(Ii.prototype,{addLine:function(t){this.lines.add(this.factory.createLineString(t.toCoordinateArray()))},updateRingStartEdge:function(t){return t.isStart()||(t=t.sym(),t.isStart())?null===this.ringStartEdge?(this.ringStartEdge=t,null):void(t.orig().compareTo(this.ringStartEdge.orig())<0&&(this.ringStartEdge=t)):null},getResult:function(){return null===this.result&&this.computeResult(),this.result},process:function(t){var e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()},buildRing:function(t){var e=new N,n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){var i=n.next();if(i===t)break;e.add(i.orig().copy(),!1),n=i}e.add(n.dest().copy(),!1),this.addLine(e)},buildLine:function(t){var e=new N,n=t;for(this.ringStartEdge=null,mi.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);var i=n.next();if(i===t)return this.buildRing(this.ringStartEdge),null;e.add(i.orig().copy(),!1),n=i,mi.markBoth(n)}e.add(n.dest().copy(),!1),this.stackEdges(n.sym()),this.addLine(e)},stackEdges:function(t){var e=t;do mi.isMarked(e)||this.nodeEdgeStack.add(e),e=e.oNext();while(e!==t)},computeResult:function(){for(var t=this.graph.getVertexEdges(),e=t.iterator();e.hasNext();){var n=e.next();mi.isMarked(n)||this.process(n)}this.result=this.factory.buildGeometry(this.lines)},buildLines:function(){for(;!this.nodeEdgeStack.empty();){var t=this.nodeEdgeStack.pop();mi.isMarked(t)||this.buildLine(t)}},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v))for(var e=arguments[0],n=e.iterator();n.hasNext();){var i=n.next();this.add(i)}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory());for(var s=r.getCoordinateSequence(),o=!1,n=1;n<s.size();n++){var a=this.graph.addEdge(s.getCoordinate(n-1),s.getCoordinate(n));null!==a&&(o||(a.setStart(),o=!0))}}},interfaces_:function(){return[]},getClass:function(){return Ii}}),Ii.dissolve=function(t){var e=new Ii;return e.add(t),e.getResult()};var go=Object.freeze({LineDissolver:Ii});e(Ni.prototype,{hasChildren:function(){for(var t=0;4>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;4>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},getNodeCount:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+1},size:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this.items);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].addAllItemsFromOverlapping(t,e)},visitItems:function(t,e){for(var n=this.items.iterator();n.hasNext();)e.visitItem(n.next())},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;4>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},visit:function(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].visit(t,e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;4>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},isEmpty:function t(){var t=!0;this.items.isEmpty()||(t=!1);for(var e=0;4>e;e++)null!==this.subnode[e]&&(this.subnode[e].isEmpty()||(t=!1));return t},add:function(t){this.items.add(t)},interfaces_:function(){return[u]},getClass:function(){return Ni}}),Ni.getSubnodeIndex=function(t,e,n){var i=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(i=3),t.getMaxY()<=n&&(i=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(i=2),t.getMaxY()<=n&&(i=0)),i},Ci.exponent=function(t){return Si(64,t)-1023},Ci.powerOf2=function(t){return Math.pow(2,t)},e(wi.prototype,{getLevel:function(){return this.level},computeKey:function(){if(1===arguments.length){var t=arguments[0];for(this.level=wi.computeQuadLevel(t),this.env=new C,this.computeKey(this.level,t);!this.env.contains(t);)this.level+=1,this.computeKey(this.level,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=Ci.powerOf2(e);this.pt.x=Math.floor(n.getMinX()/i)*i,this.pt.y=Math.floor(n.getMinY()/i)*i,this.env.init(this.pt.x,this.pt.x+i,this.pt.y,this.pt.y+i)}},getEnvelope:function(){return this.env},getCentre:function(){return new g((this.env.getMinX()+this.env.getMaxX())/2,(this.env.getMinY()+this.env.getMaxY())/2)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return wi}}),wi.computeQuadLevel=function(t){var e=t.getWidth(),n=t.getHeight(),i=e>n?e:n,r=Ci.exponent(i)+1;return r},h(Li,Ni),e(Li.prototype,{find:function(t){var e=Ni.getSubnodeIndex(t,this.centrex,this.centrey);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},isSearchMatch:function(t){return this.env.intersects(t)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getEnvelope:function(){return this.env},getNode:function(t){var e=Ni.getSubnodeIndex(t,this.centrex,this.centrey);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0,i=0,r=0;switch(t){case 0:e=this.env.getMinX(),n=this.centrex,i=this.env.getMinY(),r=this.centrey;break;case 1:e=this.centrex,n=this.env.getMaxX(),i=this.env.getMinY(),r=this.centrey;break;case 2:e=this.env.getMinX(),n=this.centrex,i=this.centrey,r=this.env.getMaxY();break;case 3:e=this.centrex,n=this.env.getMaxX(),i=this.centrey,r=this.env.getMaxY()}var s=new C(e,n,i,r),o=new Li(s,this.level-1);return o},insertNode:function(t){f.isTrue(null===this.env||this.env.contains(t.env));var e=Ni.getSubnodeIndex(t.env,this.centrex,this.centrey);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insertNode(t),this.subnode[e]=n}},interfaces_:function(){return[]},getClass:function(){return Li}}),Li.createNode=function(t){var e=new wi(t),n=new Li(e.getEnvelope(),e.getLevel());return n},Li.createExpanded=function(t,e){var n=new C(e);null!==t&&n.expandToInclude(t.env);var i=Li.createNode(n);return null!==t&&i.insertNode(t),i},e(Ri.prototype,{interfaces_:function(){return[]},getClass:function(){return Ri}}),Ri.isZeroWidth=function(t,e){var n=e-t;if(0===n)return!0;var i=Math.max(Math.abs(t),Math.abs(e)),r=n/i,s=Ci.exponent(r);return s<=Ri.MIN_BINARY_EXPONENT},Ri.MIN_BINARY_EXPONENT=-50,h(Ti,Ni),e(Ti.prototype,{insert:function(t,e){var n=Ni.getSubnodeIndex(t,Ti.origin.x,Ti.origin.y);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getEnvelope().contains(t)){var r=Li.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getEnvelope().contains(e));var i=Ri.isZeroWidth(e.getMinX(),e.getMaxX()),r=Ri.isZeroWidth(e.getMinY(),e.getMaxY()),s=null;s=i||r?t.find(e):t.getNode(e),s.add(n)},interfaces_:function(){return[]},getClass:function(){return Ti}}),Ti.origin=new g(0,0),e(Pi.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=Pi.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){var t=arguments[0],e=new Yn;return this.query(t,e),e.getItems()}if(2===arguments.length){var n=arguments[0],i=arguments[1];this.root.visit(n,i)}},queryAll:function(){var t=new I;return this.root.addAllItems(t),
t},remove:function(t,e){var n=Pi.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e);var n=t.getHeight();n<this.minExtent&&n>0&&(this.minExtent=n)},depth:function(){return null!==this.root?this.root.depth():0},isEmpty:function(){return null===this.root},interfaces_:function(){return[Fe,u]},getClass:function(){return Pi}}),Pi.ensureExtent=function(t,e){var n=t.getMinX(),i=t.getMaxX(),r=t.getMinY(),s=t.getMaxY();return n!==i&&r!==s?t:(n===i&&(n-=e/2,i=n+e/2),r===s&&(r-=e/2,s=r+e/2),new C(n,i,r,s))},Pi.serialVersionUID=-0x678b60c967a25400;var po=Object.freeze({Quadtree:Pi}),vo=Object.freeze({STRtree:ke}),mo=Object.freeze({quadtree:po,strtree:vo}),yo=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];e(bi.prototype,{read:function(t){var e=void 0;e="string"==typeof t?JSON.parse(t):t;var n=e.type;if(!xo[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==yo.indexOf(n)?xo[n].apply(this,[e.coordinates]):"GeometryCollection"===n?xo[n].apply(this,[e.geometries]):xo[n].apply(this,[e])},write:function(t){var e=t.getGeometryType();if(!Eo[e])throw new Error("Geometry is not supported");return Eo[e].apply(this,[t])}});var xo={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var i=t.geometry.type;if(!xo[i])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=xo.bbox.apply(this,[t.bbox])),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.apply(this,[t.bbox])),e},coordinates:function t(e){for(var t=[],n=0;n<e.length;++n){var i=e[n];t.push(new g(i[0],i[1]))}return t},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){var e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(xo.Point.apply(this,[t[n]]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=xo.coordinates.apply(this,[t]);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(xo.LineString.apply(this,[t[n]]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=xo.coordinates.apply(this,[t[0]]),n=this.geometryFactory.createLinearRing(e),i=[],r=1;r<t.length;++r){var s=t[r],o=xo.coordinates.apply(this,[s]),a=this.geometryFactory.createLinearRing(o);i.push(a)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(xo.Polygon.apply(this,[i]))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},Eo={coordinate:function(t){return[t.x,t.y]},Point:function(t){var e=Eo.coordinate.apply(this,[t.getCoordinate()]);return{type:"Point",coordinates:e}},MultiPoint:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.Point.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),i=0;i<n.length;++i){var r=n[i];e.push(Eo.coordinate.apply(this,[r]))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.LineString.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=Eo.LineString.apply(this,[t.shell]);e.push(n.coordinates);for(var i=0;i<t.holes.length;++i){var r=t.holes[i],s=Eo.LineString.apply(this,[r]);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.Polygon.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=i.getGeometryType();e.push(Eo[r].apply(this,[i]))}return{type:"GeometryCollection",geometries:e}}};e(Oi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){var e,n;if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(e=0,n=t.points.length;n>e;e++)this.precisionModel.makePrecise(t.points[e]);else if(t.geometries)for(e=0,n=t.geometries.length;n>e;e++)this.reducePrecision(t.geometries[e])}}),e(_i.prototype,{write:function(t){return this.parser.write(t)}}),e(Mi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(var e=0,n=t.points.coordinates.length;n>e;e++)this.precisionModel.makePrecise(t.points.coordinates[e]);else if(t.geometries)for(var i=0,r=t.geometries.length;r>i;i++)this.reducePrecision(t.geometries[i])}}),e(Ai.prototype,{read:function(t){return t instanceof ol.geom.Point?this.convertFromPoint(t):t instanceof ol.geom.LineString?this.convertFromLineString(t):t instanceof ol.geom.LinearRing?this.convertFromLinearRing(t):t instanceof ol.geom.Polygon?this.convertFromPolygon(t):t instanceof ol.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof ol.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof ol.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof ol.geom.GeometryCollection?this.convertFromCollection(t):void 0},convertFromPoint:function(t){var e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))},convertFromLineString:function(t){return this.geometryFactory.createLineString(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromLinearRing:function(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromPolygon:function(t){for(var e=t.getLinearRings(),n=null,i=[],r=0;r<e.length;r++){var s=this.convertFromLinearRing(e[r]);0===r?n=s:i.push(s)}return this.geometryFactory.createPolygon(n,i)},convertFromMultiPoint:function(t){var e=t.getPoints().map(function(t){return this.convertFromPoint(t)},this);return this.geometryFactory.createMultiPoint(e)},convertFromMultiLineString:function(t){var e=t.getLineStrings().map(function(t){return this.convertFromLineString(t)},this);return this.geometryFactory.createMultiLineString(e)},convertFromMultiPolygon:function(t){var e=t.getPolygons().map(function(t){return this.convertFromPolygon(t)},this);return this.geometryFactory.createMultiPolygon(e)},convertFromCollection:function(t){var e=t.getGeometries().map(function(t){return this.read(t)},this);return this.geometryFactory.createGeometryCollection(e)},write:function(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0},convertToPoint:function(t){return new ol.geom.Point([t.x,t.y])},convertToLineString:function(t){var e=t.points.coordinates.map(Di);return new ol.geom.LineString(e)},convertToLinearRing:function(t){var e=t.points.coordinates.map(Di);return new ol.geom.LinearRing(e)},convertToPolygon:function(t){for(var e=[t.shell.points.coordinates.map(Di)],n=0;n<t.holes.length;n++)e.push(t.holes[n].points.coordinates.map(Di));return new ol.geom.Polygon(e)},convertToMultiPoint:function(t){return new ol.geom.MultiPoint(t.getCoordinates().map(Di))},convertToMultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToLineString(t.geometries[n]).getCoordinates());return new ol.geom.MultiLineString(e)},convertToMultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());return new ol.geom.MultiPolygon(e)},convertToCollection:function(t){for(var e=[],n=0;n<t.geometries.length;n++){var i=t.geometries[n];e.push(this.write(i))}return new ol.geom.GeometryCollection(e)}});var Io=Object.freeze({GeoJSONReader:Oi,GeoJSONWriter:_i,OL3Parser:Ai,WKTReader:Mi,WKTWriter:se});e(Fi.prototype,{rescale:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.rescale(n.getCoordinates())}else if(arguments[0]instanceof Array){var i=arguments[0],r=null,s=null;2===i.length&&(r=new g(i[0]),s=new g(i[1]));for(var e=0;e<i.length;e++)i[e].x=i[e].x/this.scaleFactor+this.offsetX,i[e].y=i[e].y/this.scaleFactor+this.offsetY;2===i.length&&i[0].equals2D(i[1])&&A.out.println(i)}},scale:function(){if(R(arguments[0],v)){for(var t=arguments[0],e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ke(this.scale(i.getCoordinates()),i.getData()))}return e}if(arguments[0]instanceof Array){for(var r=arguments[0],s=new Array(r.length).fill(null),n=0;n<r.length;n++)s[n]=new g(Math.round((r[n].x-this.offsetX)*this.scaleFactor),Math.round((r[n].y-this.offsetY)*this.scaleFactor),r[n].z);var o=H.removeRepeatedPoints(s);return o}},isIntegerPrecision:function(){return 1===this.scaleFactor},getNodedSubstrings:function(){var t=this.noder.getNodedSubstrings();return this.isScaled&&this.rescale(t),t},computeNodes:function(t){var e=t;this.isScaled&&(e=this.scale(t)),this.noder.computeNodes(e)},interfaces_:function(){return[tn]},getClass:function(){return Fi}});var No=Object.freeze({MCIndexNoder:nn,ScaledNoder:Fi,SegmentString:be});e(Gi.prototype,{isSimpleMultiPoint:function(t){if(t.isEmpty())return!0;for(var e=new at,n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n),r=i.getCoordinate();if(e.contains(r))return this.nonSimpleLocation=r,!1;e.add(r)}return!0},isSimplePolygonal:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next();if(!this.isSimpleLinearGeometry(i))return!1}return!0},hasClosedEndpointIntersection:function(t){for(var e=new rt,n=t.getEdgeIterator();n.hasNext();){var i=n.next(),r=(i.getMaximumSegmentIndex(),i.isClosed()),s=i.getCoordinate(0);this.addEndpoint(e,s,r);var o=i.getCoordinate(i.getNumPoints()-1);this.addEndpoint(e,o,r)}for(var n=e.values().iterator();n.hasNext();){var a=n.next();if(a.isClosed&&2!==a.degree)return this.nonSimpleLocation=a.getCoordinate(),!0}return!1},getNonSimpleLocation:function(){return this.nonSimpleLocation},isSimpleLinearGeometry:function(t){if(t.isEmpty())return!0;var e=new $n(0,t),n=new ae,i=e.computeSelfNodes(n,!0);return i.hasIntersection()?i.hasProperIntersection()?(this.nonSimpleLocation=i.getProperIntersectionPoint(),!1):this.hasNonEndpointIntersection(e)?!1:!this.isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e):!0},hasNonEndpointIntersection:function(t){for(var e=t.getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getMaximumSegmentIndex(),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next();if(!s.isEndPoint(i))return this.nonSimpleLocation=s.getCoordinate(),!0}return!1},addEndpoint:function(t,e,n){var i=t.get(e);null===i&&(i=new qi(e),t.put(e,i)),i.addEndpoint(n)},computeSimple:function(t){return this.nonSimpleLocation=null,t.isEmpty()?!0:t instanceof St?this.isSimpleLinearGeometry(t):t instanceof gt?this.isSimpleLinearGeometry(t):t instanceof Pt?this.isSimpleMultiPoint(t):R(t,Rt)?this.isSimplePolygonal(t):t instanceof ft?this.isSimpleGeometryCollection(t):!0},isSimple:function(){return this.nonSimpleLocation=null,this.computeSimple(this.inputGeom)},isSimpleGeometryCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0},interfaces_:function(){return[]},getClass:function(){return Gi}}),e(qi.prototype,{addEndpoint:function(t){this.degree++,this.isClosed|=t},getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return qi}}),Gi.EndpointInfo=qi,e(Bi.prototype,{getEndCapStyle:function(){return this.endCapStyle},isSingleSided:function(){return this._isSingleSided},setQuadrantSegments:function(t){this.quadrantSegments=t,0===this.quadrantSegments&&(this.joinStyle=Bi.JOIN_BEVEL),this.quadrantSegments<0&&(this.joinStyle=Bi.JOIN_MITRE,this.mitreLimit=Math.abs(this.quadrantSegments)),0>=t&&(this.quadrantSegments=1),this.joinStyle!==Bi.JOIN_ROUND&&(this.quadrantSegments=Bi.DEFAULT_QUADRANT_SEGMENTS)},getJoinStyle:function(){return this.joinStyle},setJoinStyle:function(t){this.joinStyle=t},setSimplifyFactor:function(t){this.simplifyFactor=0>t?0:t},getSimplifyFactor:function(){return this.simplifyFactor},getQuadrantSegments:function(){return this.quadrantSegments},setEndCapStyle:function(t){this.endCapStyle=t},getMitreLimit:function(){return this.mitreLimit},setMitreLimit:function(t){this.mitreLimit=t},setSingleSided:function(t){this._isSingleSided=t},interfaces_:function(){return[]},getClass:function(){return Bi}}),Bi.bufferDistanceError=function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)},Bi.CAP_ROUND=1,Bi.CAP_FLAT=2,Bi.CAP_SQUARE=3,Bi.JOIN_ROUND=1,Bi.JOIN_MITRE=2,Bi.JOIN_BEVEL=3,Bi.DEFAULT_QUADRANT_SEGMENTS=8,Bi.DEFAULT_MITRE_LIMIT=5,Bi.DEFAULT_SIMPLIFY_FACTOR=.01,e(zi.prototype,{getCoordinate:function(){return this.minCoord},getRightmostSide:function(t,e){var n=this.getRightmostSideOfSegment(t,e);return 0>n&&(n=this.getRightmostSideOfSegment(t,e-1)),0>n&&(this.minCoord=null,this.checkForRightmostCoordinate(t)),n},findRightmostEdgeAtVertex:function(){var t=this.minDe.getEdge().getCoordinates();f.isTrue(this.minIndex>0&&this.minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this.minIndex-1],n=t[this.minIndex+1],i=he.computeOrientation(this.minCoord,n,e),r=!1;e.y<this.minCoord.y&&n.y<this.minCoord.y&&i===he.COUNTERCLOCKWISE?r=!0:e.y>this.minCoord.y&&n.y>this.minCoord.y&&i===he.CLOCKWISE&&(r=!0),r&&(this.minIndex=this.minIndex-1)},getRightmostSideOfSegment:function(t,e){var n=t.getEdge(),i=n.getCoordinates();if(0>e||e+1>=i.length)return-1;if(i[e].y===i[e+1].y)return-1;var r=cn.LEFT;return i[e].y<i[e+1].y&&(r=cn.RIGHT),r},getEdge:function(){return this.orientedDe},checkForRightmostCoordinate:function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this.minCoord||e[n].x>this.minCoord.x)&&(this.minDe=t,this.minIndex=n,this.minCoord=e[n])},findRightmostEdgeAtNode:function(){var t=this.minDe.getNode(),e=t.getEdges();this.minDe=e.getRightmostEdge(),this.minDe.isForward()||(this.minDe=this.minDe.getSym(),this.minIndex=this.minDe.getEdge().getCoordinates().length-1)},findEdge:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n)}f.isTrue(0!==this.minIndex||this.minCoord.equals(this.minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this.minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this.orientedDe=this.minDe;var i=this.getRightmostSide(this.minDe,this.minIndex);i===cn.LEFT&&(this.orientedDe=this.minDe.getSym())},interfaces_:function(){return[]},getClass:function(){return zi}}),Vi.prototype.addLast=function(t){this.array_.push(t)},Vi.prototype.removeFirst=function(){return this.array_.shift()},Vi.prototype.isEmpty=function(){return 0===this.array_.length},e(ki.prototype,{clearVisitedEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.setVisited(!1)}},getRightmostCoordinate:function(){return this.rightMostCoord},computeNodeDepth:function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var i=n.next();if(i.isVisited()||i.getSym().isVisited()){e=i;break}}if(null===e)throw new sn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();i.setVisited(!0),this.copySymDepths(i)}},computeDepth:function(t){this.clearVisitedEdges();var e=this.finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(cn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)},create:function(t){this.addReachable(t),this.finder.findEdge(this.dirEdgeList),this.rightMostCoord=this.finder.getCoordinate()},findResultEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(cn.RIGHT)>=1&&e.getDepth(cn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}},computeDepths:function(t){var e=new J,n=new Vi,i=t.getNode();for(n.addLast(i),e.add(i),t.setVisited(!0);!n.isEmpty();){var r=n.removeFirst();e.add(r),this.computeNodeDepth(r);for(var s=r.getEdges().iterator();s.hasNext();){var o=s.next(),a=o.getSym();if(!a.isVisited()){var u=a.getNode();e.contains(u)||(n.addLast(u),e.add(u))}}}},compareTo:function(t){var e=t;return this.rightMostCoord.x<e.rightMostCoord.x?-1:this.rightMostCoord.x>e.rightMostCoord.x?1:0},getEnvelope:function(){if(null===this.env){for(var t=new C,e=this.dirEdgeList.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge().getCoordinates(),r=0;r<i.length-1;r++)t.expandToInclude(i[r]);this.env=t}return this.env},addReachable:function(t){var e=new pe;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e)}},copySymDepths:function(t){var e=t.getSym();e.setDepth(cn.LEFT,t.getDepth(cn.RIGHT)),e.setDepth(cn.RIGHT,t.getDepth(cn.LEFT))},add:function(t,e){t.setVisited(!0),this.nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();this.dirEdgeList.add(i);var r=i.getSym(),s=r.getNode();s.isVisited()||e.push(s)}},getNodes:function(){return this.nodes},getDirectedEdges:function(){return this.dirEdgeList},interfaces_:function(){return[s]},getClass:function(){return ki}}),e(Yi.prototype,{isDeletable:function(t,e,n,i){var r=this.inputLine[t],s=this.inputLine[e],o=this.inputLine[n];return this.isConcave(r,s,o)&&this.isShallow(r,s,o,i)?this.isShallowSampled(r,s,t,n,i):!1},deleteShallowConcavities:function(){for(var t=1,e=(this.inputLine.length-1,this.findNextNonDeletedIndex(t)),n=this.findNextNonDeletedIndex(e),i=!1;n<this.inputLine.length;){var r=!1;this.isDeletable(t,e,n,this.distanceTol)&&(this.isDeleted[e]=Yi.DELETE,r=!0,i=!0),t=r?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return i},isShallowConcavity:function(t,e,n,i){var r=he.computeOrientation(t,e,n),s=r===this.angleOrientation;if(!s)return!1;var o=he.distancePointLine(e,t,n);return i>o},isShallowSampled:function(t,e,n,i,r){var s=Math.trunc((i-n)/Yi.NUM_PTS_TO_CHECK);0>=s&&(s=1);for(var o=n;i>o;o+=s)if(!this.isShallow(t,e,this.inputLine[o],r))return!1;return!0},isConcave:function t(e,n,i){var r=he.computeOrientation(e,n,i),t=r===this.angleOrientation;return t},simplify:function(t){this.distanceTol=Math.abs(t),0>t&&(this.angleOrientation=he.CLOCKWISE),this.isDeleted=new Array(this.inputLine.length).fill(null);var e=!1;do e=this.deleteShallowConcavities();while(e);return this.collapseLine()},findNextNonDeletedIndex:function(t){for(var e=t+1;e<this.inputLine.length&&this.isDeleted[e]===Yi.DELETE;)e++;return e},isShallow:function(t,e,n,i){var r=he.distancePointLine(e,t,n);return i>r},collapseLine:function(){for(var t=new N,e=0;e<this.inputLine.length;e++)this.isDeleted[e]!==Yi.DELETE&&t.add(this.inputLine[e]);return t.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return Yi}}),Yi.simplify=function(t,e){var n=new Yi(t);return n.simplify(e)},Yi.INIT=0,Yi.DELETE=1,Yi.KEEP=1,Yi.NUM_PTS_TO_CHECK=10,e(Ui.prototype,{getCoordinates:function(){var t=this.ptList.toArray(Ui.COORDINATE_ARRAY_TYPE);return t},setPrecisionModel:function(t){this.precisionModel=t},addPt:function(t){var e=new g(t);return this.precisionModel.makePrecise(e),this.isRedundant(e)?null:void this.ptList.add(e)},reverse:function(){},addPts:function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var n=t.length-1;n>=0;n--)this.addPt(t[n])},isRedundant:function(t){if(this.ptList.size()<1)return!1;var e=this.ptList.get(this.ptList.size()-1),n=t.distance(e);return n<this.minimimVertexDistance},toString:function(){var t=new ie,e=t.createLineString(this.getCoordinates());return e.toString()},closeRing:function(){if(this.ptList.size()<1)return null;var t=new g(this.ptList.get(0)),e=this.ptList.get(this.ptList.size()-1),n=null;return this.ptList.size()>=2&&(n=this.ptList.get(this.ptList.size()-2)),t.equals(e)?null:void this.ptList.add(t)},setMinimumVertexDistance:function(t){this.minimimVertexDistance=t},interfaces_:function(){return[]},getClass:function(){return Ui}}),Ui.COORDINATE_ARRAY_TYPE=new Array(0).fill(null),e(Xi.prototype,{addNextSegment:function(t,e){if(this.s0=this.s1,this.s1=this.s2,this.s2=t,this.seg0.setCoordinates(this.s0,this.s1),this.computeOffsetSegment(this.seg0,this.side,this.distance,this.offset0),this.seg1.setCoordinates(this.s1,this.s2),this.computeOffsetSegment(this.seg1,this.side,this.distance,this.offset1),this.s1.equals(this.s2))return null;var n=he.computeOrientation(this.s0,this.s1,this.s2),i=n===he.CLOCKWISE&&this.side===cn.LEFT||n===he.COUNTERCLOCKWISE&&this.side===cn.RIGHT;0===n?this.addCollinear(e):i?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)},addLineEndCap:function(t,e){var n=new ce(t,e),i=new ce;this.computeOffsetSegment(n,cn.LEFT,this.distance,i);var r=new ce;this.computeOffsetSegment(n,cn.RIGHT,this.distance,r);var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s);switch(this.bufParams.getEndCapStyle()){case Bi.CAP_ROUND:this.segList.addPt(i.p1),this.addFilletArc(e,a+Math.PI/2,a-Math.PI/2,he.CLOCKWISE,this.distance),this.segList.addPt(r.p1);break;case Bi.CAP_FLAT:this.segList.addPt(i.p1),this.segList.addPt(r.p1);break;case Bi.CAP_SQUARE:var u=new g;u.x=Math.abs(this.distance)*Math.cos(a),u.y=Math.abs(this.distance)*Math.sin(a);var l=new g(i.p1.x+u.x,i.p1.y+u.y),h=new g(r.p1.x+u.x,r.p1.y+u.y);this.segList.addPt(l),this.segList.addPt(h)}},getCoordinates:function(){var t=this.segList.getCoordinates();return t},addMitreJoin:function(t,e,n,i){var r=!0,s=null;try{s=F.intersection(e.p0,e.p1,n.p0,n.p1);var o=0>=i?1:s.distance(t)/Math.abs(i);o>this.bufParams.getMitreLimit()&&(r=!1)}catch(t){if(!(t instanceof w))throw t;s=new g(0,0),r=!1}finally{}r?this.segList.addPt(s):this.addLimitedMitreJoin(e,n,i,this.bufParams.getMitreLimit())},addFilletCorner:function(t,e,n,i,r){var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s),u=n.x-t.x,l=n.y-t.y,h=Math.atan2(l,u);i===he.CLOCKWISE?h>=a&&(a+=2*Math.PI):a>=h&&(a-=2*Math.PI),this.segList.addPt(e),this.addFilletArc(t,a,h,i,r),this.segList.addPt(n)},addOutsideTurn:function(t,e){return this.offset0.p1.distance(this.offset1.p0)<this.distance*Xi.OFFSET_SEGMENT_SEPARATION_FACTOR?(this.segList.addPt(this.offset0.p1),null):void(this.bufParams.getJoinStyle()===Bi.JOIN_MITRE?this.addMitreJoin(this.s1,this.offset0,this.offset1,this.distance):this.bufParams.getJoinStyle()===Bi.JOIN_BEVEL?this.addBevelJoin(this.offset0,this.offset1):(e&&this.segList.addPt(this.offset0.p1),this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,t,this.distance),this.segList.addPt(this.offset1.p0)))},createSquare:function(t){this.segList.addPt(new g(t.x+this.distance,t.y+this.distance)),this.segList.addPt(new g(t.x+this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y+this.distance)),this.segList.closeRing()},addSegments:function(t,e){this.segList.addPts(t,e)},addFirstSegment:function(){this.segList.addPt(this.offset1.p0)},addLastSegment:function(){this.segList.addPt(this.offset1.p1)},initSideSegments:function(t,e,n){this.s1=t,this.s2=e,this.side=n,this.seg1.setCoordinates(t,e),this.computeOffsetSegment(this.seg1,n,this.distance,this.offset1)},addLimitedMitreJoin:function(t,e,n,i){var r=this.seg0.p1,s=hi.angle(r,this.seg0.p0),o=(hi.angle(r,this.seg1.p1),hi.angleBetweenOriented(this.seg0.p0,r,this.seg1.p1)),a=o/2,u=hi.normalize(s+a),l=hi.normalize(u+Math.PI),h=i*n,c=h*Math.abs(Math.sin(a)),f=n-c,d=r.x+h*Math.cos(l),p=r.y+h*Math.sin(l),v=new g(d,p),m=new ce(r,v),y=m.pointAlongOffset(1,f),x=m.pointAlongOffset(1,-f);this.side===cn.LEFT?(this.segList.addPt(y),this.segList.addPt(x)):(this.segList.addPt(x),this.segList.addPt(y))},computeOffsetSegment:function(t,e,n,i){var r=e===cn.LEFT?1:-1,s=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,a=Math.sqrt(s*s+o*o),u=r*n*s/a,l=r*n*o/a;i.p0.x=t.p0.x-l,i.p0.y=t.p0.y+u,i.p1.x=t.p1.x-l,i.p1.y=t.p1.y+u},addFilletArc:function(t,e,n,i,r){var s=i===he.CLOCKWISE?-1:1,o=Math.abs(e-n),a=Math.trunc(o/this.filletAngleQuantum+.5);if(1>a)return null;var u=null,l=null;u=0,l=o/a;for(var h=u,c=new g;o>h;){var f=e+s*h;c.x=t.x+r*Math.cos(f),c.y=t.y+r*Math.sin(f),this.segList.addPt(c),h+=l}},addInsideTurn:function(t,e){if(this.li.computeIntersection(this.offset0.p0,this.offset0.p1,this.offset1.p0,this.offset1.p1),this.li.hasIntersection())this.segList.addPt(this.li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this.offset0.p1.distance(this.offset1.p0)<this.distance*Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this.segList.addPt(this.offset0.p1);else{if(this.segList.addPt(this.offset0.p1),this.closingSegLengthFactor>0){var n=new g((this.closingSegLengthFactor*this.offset0.p1.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset0.p1.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(n);var i=new g((this.closingSegLengthFactor*this.offset1.p0.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset1.p0.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(i)}else this.segList.addPt(this.s1);this.segList.addPt(this.offset1.p0)}},createCircle:function(t){var e=new g(t.x+this.distance,t.y);this.segList.addPt(e),this.addFilletArc(t,0,2*Math.PI,-1,this.distance),this.segList.closeRing()},addBevelJoin:function(t,e){this.segList.addPt(t.p1),this.segList.addPt(e.p0)},init:function(t){this.distance=t,this.maxCurveSegmentError=t*(1-Math.cos(this.filletAngleQuantum/2)),this.segList=new Ui,this.segList.setPrecisionModel(this.precisionModel),this.segList.setMinimumVertexDistance(t*Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},addCollinear:function(t){this.li.computeIntersection(this.s0,this.s1,this.s1,this.s2);var e=this.li.getIntersectionNum();e>=2&&(this.bufParams.getJoinStyle()===Bi.JOIN_BEVEL||this.bufParams.getJoinStyle()===Bi.JOIN_MITRE?(t&&this.segList.addPt(this.offset0.p1),this.segList.addPt(this.offset1.p0)):this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,he.CLOCKWISE,this.distance))},closeRing:function(){this.segList.closeRing()},hasNarrowConcaveAngle:function(){return this._hasNarrowConcaveAngle},interfaces_:function(){return[]},getClass:function(){return Xi}}),Xi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,Xi.MAX_CLOSING_SEG_LEN_FACTOR=80,e(Hi.prototype,{getOffsetCurve:function(t,e){if(this.distance=e,0===e)return null;var n=0>e,i=Math.abs(e),r=this.getSegGen(i);t.length<=1?this.computePointCurve(t[0],r):this.computeOffsetCurve(t,n,r);var s=r.getCoordinates();return n&&H.reverse(s),s},computeSingleSidedBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){n.addSegments(t,!0);var r=Yi.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{n.addSegments(t,!1);var a=Yi.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment(),n.closeRing()},computeRingBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);e===cn.RIGHT&&(i=-i);var r=Yi.simplify(t,i),s=r.length-1;n.initSideSegments(r[s-1],r[0],e);for(var o=1;s>=o;o++){var a=1!==o;n.addNextSegment(r[o],a)}n.closeRing()},computeLineBufferCurve:function(t,e){var n=this.simplifyTolerance(this.distance),i=Yi.simplify(t,n),r=i.length-1;e.initSideSegments(i[0],i[1],cn.LEFT);for(var s=2;r>=s;s++)e.addNextSegment(i[s],!0);e.addLastSegment(),e.addLineEndCap(i[r-1],i[r]);var o=Yi.simplify(t,-n),a=o.length-1;e.initSideSegments(o[a],o[a-1],cn.LEFT);for(var s=a-2;s>=0;s--)e.addNextSegment(o[s],!0);e.addLastSegment(),e.addLineEndCap(o[1],o[0]),e.closeRing()},computePointCurve:function(t,e){switch(this.bufParams.getEndCapStyle()){case Bi.CAP_ROUND:e.createCircle(t);break;case Bi.CAP_SQUARE:e.createSquare(t)}},getLineCurve:function(t,e){if(this.distance=e,0>e&&!this.bufParams.isSingleSided())return null;if(0===e)return null;var n=Math.abs(e),i=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],i);else if(this.bufParams.isSingleSided()){var r=0>e;this.computeSingleSidedBufferCurve(t,r,i)}else this.computeLineBufferCurve(t,i);var s=i.getCoordinates();return s},getBufferParameters:function(){return this.bufParams},simplifyTolerance:function(t){return t*this.bufParams.getSimplifyFactor()},getRingCurve:function(t,e,n){if(this.distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return Hi.copyCoordinates(t);var i=this.getSegGen(n);return this.computeRingBufferCurve(t,e,i),i.getCoordinates()},computeOffsetCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){var r=Yi.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{var a=Yi.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment()},getSegGen:function(t){return new Xi(this.precisionModel,this.bufParams,t)},interfaces_:function(){return[]},getClass:function(){return Hi}}),Hi.copyCoordinates=function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new g(t[n]);return e},e(Wi.prototype,{findStabbedSegments:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=this.subgraphs.iterator();n.hasNext();){var i=n.next(),r=i.getEnvelope();t.y<r.getMinY()||t.y>r.getMaxY()||this.findStabbedSegments(t,i.getDirectedEdges(),e)}return e}if(3===arguments.length)if(R(arguments[2],y)&&arguments[0]instanceof g&&arguments[1]instanceof In)for(var s=arguments[0],o=arguments[1],a=arguments[2],u=o.getEdge().getCoordinates(),n=0;n<u.length-1;n++){this.seg.p0=u[n],this.seg.p1=u[n+1],this.seg.p0.y>this.seg.p1.y&&this.seg.reverse();var l=Math.max(this.seg.p0.x,this.seg.p1.x);if(!(l<s.x||this.seg.isHorizontal()||s.y<this.seg.p0.y||s.y>this.seg.p1.y||he.computeOrientation(this.seg.p0,this.seg.p1,s)===he.RIGHT)){var h=o.getDepth(cn.LEFT);this.seg.p0.equals(u[n])||(h=o.getDepth(cn.RIGHT));var c=new ji(this.seg,h);a.add(c)}}else if(R(arguments[2],y)&&arguments[0]instanceof g&&R(arguments[1],y))for(var f=arguments[0],d=arguments[1],p=arguments[2],n=d.iterator();n.hasNext();){var v=n.next();v.isForward()&&this.findStabbedSegments(f,v,p)}},getDepth:function(t){var e=this.findStabbedSegments(t);if(0===e.size())return 0;var n=ho.min(e);return n.leftDepth},interfaces_:function(){return[]},getClass:function(){return Wi}}),e(ji.prototype,{compareTo:function(t){var e=t;if(this.upwardSeg.minX()>=e.upwardSeg.maxX())return 1;if(this.upwardSeg.maxX()<=e.upwardSeg.minX())return-1;var n=this.upwardSeg.orientationIndex(e.upwardSeg);return 0!==n?n:(n=-1*e.upwardSeg.orientationIndex(this.upwardSeg),0!==n?n:this.upwardSeg.compareTo(e.upwardSeg))},compareX:function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)},toString:function(){return this.upwardSeg.toString()},interfaces_:function(){return[s]},getClass:function(){return ji}}),Wi.DepthSegment=ji,e(Ki.prototype,{addPoint:function(t){if(this.distance<=0)return null;
var e=t.getCoordinates(),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addPolygon:function(t){var e=this.distance,n=cn.LEFT;this.distance<0&&(e=-this.distance,n=cn.RIGHT);var i=t.getExteriorRing(),r=H.removeRepeatedPoints(i.getCoordinates());if(this.distance<0&&this.isErodedCompletely(i,this.distance))return null;if(this.distance<=0&&r.length<3)return null;this.addPolygonRing(r,e,n,L.EXTERIOR,L.INTERIOR);for(var s=0;s<t.getNumInteriorRing();s++){var o=t.getInteriorRingN(s),a=H.removeRepeatedPoints(o.getCoordinates());this.distance>0&&this.isErodedCompletely(o,-this.distance)||this.addPolygonRing(a,e,cn.opposite(n),L.INTERIOR,L.EXTERIOR)}},isTriangleErodedCompletely:function(t,e){var n=new ci(t[0],t[1],t[2]),i=n.inCentre(),r=he.distancePointLine(i,n.p0,n.p1);return r<Math.abs(e)},addLineString:function(t){if(this.distance<=0&&!this.curveBuilder.getBufferParameters().isSingleSided())return null;var e=H.removeRepeatedPoints(t.getCoordinates()),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addCurve:function(t,e,n){if(null===t||t.length<2)return null;var i=new Ke(t,new gn(0,L.BOUNDARY,e,n));this.curveList.add(i)},getCurves:function(){return this.add(this.inputGeom),this.curveList},addPolygonRing:function(t,e,n,i,r){if(0===e&&t.length<bt.MINIMUM_VALID_SIZE)return null;var s=i,o=r;t.length>=bt.MINIMUM_VALID_SIZE&&he.isCCW(t)&&(s=r,o=i,n=cn.opposite(n));var a=this.curveBuilder.getRingCurve(t,n,e);this.addCurve(a,s,o)},add:function(t){if(t.isEmpty())return null;if(t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},isErodedCompletely:function(t,e){var n=t.getCoordinates();if(n.length<4)return 0>e;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var i=t.getEnvelopeInternal(),r=Math.min(i.getHeight(),i.getWidth());return 0>e&&2*Math.abs(e)>r},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},interfaces_:function(){return[]},getClass:function(){return Ki}}),e(Zi.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(Zi.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.size()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},hasProperInteriorIntersection:function(){return this.hasProperInterior},getLineIntersector:function(){return this.li},hasProperIntersection:function(){return this.hasProper},processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.numIntersections++,this.li.isInteriorIntersection()&&(this.numInteriorIntersections++,this.hasInterior=!0),this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1),this.li.isProper()&&(this.numProperIntersections++,this.hasProper=!0,this.hasProperInterior=!0)))},hasIntersection:function(){return this._hasIntersection},isDone:function(){return!1},hasInteriorIntersection:function(){return this.hasInterior},interfaces_:function(){return[on]},getClass:function(){return Zi}}),Zi.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},e(Qi.prototype,{setWorkingPrecisionModel:function(t){this.workingPrecisionModel=t},insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip()),n.merge(i);var r=Qi.depthDelta(i),s=e.getDepthDelta(),o=s+r;e.setDepthDelta(o)}else this.edgeList.add(t),t.setDepthDelta(Qi.depthDelta(t.getLabel()))},buildSubgraphs:function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next(),s=r.getRightmostCoordinate(),o=new Wi(n),a=o.getDepth(s);r.computeDepth(a),r.findResultEdges(),n.add(r),e.add(r.getDirectedEdges(),r.getNodes())}},createSubgraphs:function(t){for(var e=new I,n=t.getNodes().iterator();n.hasNext();){var i=n.next();if(!i.isVisited()){var r=new ki;r.create(i),e.add(r)}}return ho.sort(e,ho.reverseOrder()),e},createEmptyResultGeometry:function(){var t=this.geomFact.createPolygon();return t},getNoder:function(t){if(null!==this.workingNoder)return this.workingNoder;var e=new nn,n=new ae;return n.setPrecisionModel(t),e.setSegmentIntersector(new Zi(n)),e},buffer:function(t,e){var n=this.workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this.geomFact=t.getFactory();var i=new Hi(n,this.bufParams),r=new Ki(t,e,i),s=r.getCurves();if(s.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(s,n),this.graph=new Cn(new On),this.graph.addEdges(this.edgeList.getEdges());var o=this.createSubgraphs(this.graph),a=new Sn(this.geomFact);this.buildSubgraphs(o,a);var u=a.getPolygons();if(u.size()<=0)return this.createEmptyResultGeometry();var l=this.geomFact.buildGeometry(u);return l},computeNodedEdges:function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var i=n.getNodedSubstrings(),r=i.iterator();r.hasNext();){var s=r.next(),o=s.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var a=s.getData(),u=new Jn(s.getCoordinates(),new gn(a));this.insertUniqueEdge(u)}}},setNoder:function(t){this.workingNoder=t},interfaces_:function(){return[]},getClass:function(){return Qi}}),Qi.depthDelta=function(t){var e=t.getLocation(0,cn.LEFT),n=t.getLocation(0,cn.RIGHT);return e===L.INTERIOR&&n===L.EXTERIOR?1:e===L.EXTERIOR&&n===L.INTERIOR?-1:0},Qi.convertSegStrings=function(t){for(var e=new ie,n=new I;t.hasNext();){var i=t.next(),r=e.createLineString(i.getCoordinates());n.add(r)}return e.buildGeometry(n)},e(Ji.prototype,{checkEndPtVertexIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next(),n=e.getCoordinates();this.checkEndPtVertexIntersections(n[0],this.segStrings),this.checkEndPtVertexIntersections(n[n.length-1],this.segStrings)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],t=r.iterator();t.hasNext();)for(var e=t.next(),n=e.getCoordinates(),s=1;s<n.length-1;s++)if(n[s].equals(i))throw new l("found endpt/interior pt intersection at index "+s+" :pt "+i)},checkInteriorIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this.segStrings.iterator();n.hasNext();){var i=n.next();this.checkInteriorIntersections(e,i)}else if(2===arguments.length)for(var r=arguments[0],s=arguments[1],o=r.getCoordinates(),a=s.getCoordinates(),u=0;u<o.length-1;u++)for(var h=0;h<a.length-1;h++)this.checkInteriorIntersections(r,u,s,h);else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3];if(c===g&&f===d)return null;var p=c.getCoordinates()[f],v=c.getCoordinates()[f+1],m=g.getCoordinates()[d],y=g.getCoordinates()[d+1];if(this.li.computeIntersection(p,v,m,y),this.li.hasIntersection()&&(this.li.isProper()||this.hasInteriorIntersection(this.li,p,v)||this.hasInteriorIntersection(this.li,m,y)))throw new l("found non-noded intersection at "+p+"-"+v+" and "+m+"-"+y)}},checkValid:function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},checkCollapses:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e)}else if(1===arguments.length)for(var n=arguments[0],i=n.getCoordinates(),t=0;t<i.length-2;t++)this.checkCollapse(i[t],i[t+1],i[t+2])},hasInteriorIntersection:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++){var r=t.getIntersection(i);if(!r.equals(e)&&!r.equals(n))return!0}return!1},checkCollapse:function(t,e,n){if(t.equals(n))throw new l("found non-noded collapse at "+Ji.fact.createLineString([t,e,n]))},interfaces_:function(){return[]},getClass:function(){return Ji}}),Ji.fact=new ie,e($i.prototype,{intersectsScaled:function(t,e){var n=Math.min(t.x,e.x),i=Math.max(t.x,e.x),r=Math.min(t.y,e.y),s=Math.max(t.y,e.y),o=this.maxx<n||this.minx>i||this.maxy<r||this.miny>s;if(o)return!1;var a=this.intersectsToleranceSquare(t,e);return f.isTrue(!(o&&a),"Found bad envelope test"),a},initCorners:function(t){var e=.5;this.minx=t.x-e,this.maxx=t.x+e,this.miny=t.y-e,this.maxy=t.y+e,this.corner[0]=new g(this.maxx,this.maxy),this.corner[1]=new g(this.minx,this.maxy),this.corner[2]=new g(this.minx,this.miny),this.corner[3]=new g(this.maxx,this.miny)},intersects:function(t,e){return 1===this.scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this.p0Scaled),this.copyScaled(e,this.p1Scaled),this.intersectsScaled(this.p0Scaled,this.p1Scaled))},scale:function(t){return Math.round(t*this.scaleFactor)},getCoordinate:function(){return this.originalPt},copyScaled:function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)},getSafeEnvelope:function(){if(null===this.safeEnv){var t=$i.SAFE_ENV_EXPANSION_FACTOR/this.scaleFactor;this.safeEnv=new C(this.originalPt.x-t,this.originalPt.x+t,this.originalPt.y-t,this.originalPt.y+t)}return this.safeEnv},intersectsPixelClosure:function(t,e){return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),!!this.li.hasIntersection())))},intersectsToleranceSquare:function(t,e){var n=!1,i=!1;return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.isProper()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.isProper()?!0:(this.li.hasIntersection()&&(n=!0),this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.isProper()?!0:(this.li.hasIntersection()&&(i=!0),this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),this.li.isProper()?!0:n&&i?!0:t.equals(this.pt)?!0:!!e.equals(this.pt))))},addSnappedNode:function(t,e){var n=t.getCoordinate(e),i=t.getCoordinate(e+1);return this.intersects(n,i)?(t.addIntersection(this.getCoordinate(),e),!0):!1},interfaces_:function(){return[]},getClass:function(){return $i}}),$i.SAFE_ENV_EXPANSION_FACTOR=.75,e(tr.prototype,{select:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){var t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}},interfaces_:function(){return[]},getClass:function(){return tr}}),e(er.prototype,{snap:function(){if(1===arguments.length){var t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=e.getSafeEnvelope(),s=new nr(e,n,i);return this.index.query(r,{interfaces_:function(){return[Ae]},visitItem:function(t){var e=t;e.select(r,s)}}),s.isNodeAdded()}},interfaces_:function(){return[]},getClass:function(){return er}}),h(nr,tr),e(nr.prototype,{isNodeAdded:function(){return this._isNodeAdded},select:function(){if(2!==arguments.length)return tr.prototype.select.apply(this,arguments);var t=arguments[0],e=arguments[1],n=t.getContext();return null!==this.parentEdge&&n===this.parentEdge&&e===this.hotPixelVertexIndex?null:void(this._isNodeAdded=this.hotPixel.addSnappedNode(n,e))},interfaces_:function(){return[]},getClass:function(){return nr}}),er.HotPixelSnapAction=nr,e(ir.prototype,{processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];if(this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&this.li.isInteriorIntersection()){for(var u=0;u<this.li.getIntersectionNum();u++)this.interiorIntersections.add(this.li.getIntersection(u));t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)}},isDone:function(){return!1},getInteriorIntersections:function(){return this.interiorIntersections},interfaces_:function(){return[on]},getClass:function(){return ir}}),e(rr.prototype,{checkCorrectness:function(t){var e=Ke.getNodedSubstrings(t),n=new Ji(e);try{n.checkValid()}catch(t){if(!(t instanceof S))throw t;t.printStackTrace()}finally{}},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},snapRound:function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)},findInteriorIntersections:function(t,e){var n=new ir(e);return this.noder.setSegmentIntersector(n),this.noder.computeNodes(t),n.getInteriorIntersections()},computeVertexSnaps:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.computeVertexSnaps(n)}else if(arguments[0]instanceof Ke)for(var i=arguments[0],r=i.getCoordinates(),s=0;s<r.length;s++){var o=new $i(r[s],this.scaleFactor,this.li),a=this.pointSnapper.snap(o,i,s);a&&i.addIntersection(r[s],s)}},computeNodes:function(t){this.nodedSegStrings=t,this.noder=new nn,this.pointSnapper=new er(this.noder.getIndex()),this.snapRound(t,this.li)},computeIntersectionSnaps:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=new $i(n,this.scaleFactor,this.li);this.pointSnapper.snap(i)}},interfaces_:function(){return[tn]},getClass:function(){return rr}}),e(sr.prototype,{bufferFixedPrecision:function(t){var e=new Fi(new rr(new ee(1)),t.getScale()),n=new Qi(this.bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this.resultGeometry=n.buffer(this.argGeom,this.distance)},bufferReducedPrecision:function(){if(0===arguments.length){for(var t=sr.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof sn))throw t;this.saveException=t}finally{}if(null!==this.resultGeometry)return null}throw this.saveException}if(1===arguments.length){var e=arguments[0],n=sr.precisionScaleFactor(this.argGeom,this.distance,e),i=new ee(n);this.bufferFixedPrecision(i)}},computeGeometry:function(){if(this.bufferOriginalPrecision(),null!==this.resultGeometry)return null;var t=this.argGeom.getFactory().getPrecisionModel();t.getType()===ee.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()},setQuadrantSegments:function(t){this.bufParams.setQuadrantSegments(t)},bufferOriginalPrecision:function(){try{var t=new Qi(this.bufParams);this.resultGeometry=t.buffer(this.argGeom,this.distance)}catch(t){if(!(t instanceof l))throw t;this.saveException=t}finally{}},getResultGeometry:function(t){return this.distance=t,this.computeGeometry(),this.resultGeometry},setEndCapStyle:function(t){this.bufParams.setEndCapStyle(t)},interfaces_:function(){return[]},getClass:function(){return sr}}),sr.bufferOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new sr(t),i=n.getResultGeometry(e);return i}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var r=arguments[0],s=arguments[1],o=arguments[2],a=new sr(r);a.setQuadrantSegments(o);var i=a.getResultGeometry(s);return i}if(arguments[2]instanceof Bi&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2],a=new sr(u,h),i=a.getResultGeometry(l);return i}}else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3],a=new sr(c);a.setQuadrantSegments(g),a.setEndCapStyle(d);var i=a.getResultGeometry(f);return i}},sr.precisionScaleFactor=function(t,e,n){var i=t.getEnvelopeInternal(),r=T.max(Math.abs(i.getMaxX()),Math.abs(i.getMaxY()),Math.abs(i.getMinX()),Math.abs(i.getMinY())),s=e>0?e:0,o=r+2*s,a=Math.trunc(Math.log(o)/Math.log(10)+1),u=n-a,l=Math.pow(10,u);return l},sr.CAP_ROUND=Bi.CAP_ROUND,sr.CAP_BUTT=Bi.CAP_FLAT,sr.CAP_FLAT=Bi.CAP_FLAT,sr.CAP_SQUARE=Bi.CAP_SQUARE,sr.MAX_PRECISION_DIGITS=12;var Co=Object.freeze({BufferOp:sr,BufferParameters:Bi});e(or.prototype,{filter:function(t){t instanceof Tt&&this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return or}}),or.getPolygons=function(){if(1===arguments.length){var t=arguments[0];return or.getPolygons(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Tt?n.add(e):e instanceof ft&&e.apply(new or(n)),n}},e(ar.prototype,{isInsideArea:function(){return this.segIndex===ar.INSIDE_AREA},getCoordinate:function(){return this.pt},getGeometryComponent:function(){return this.component},getSegmentIndex:function(){return this.segIndex},interfaces_:function(){return[]},getClass:function(){return ar}}),ar.INSIDE_AREA=-1,e(ur.prototype,{filter:function(t){t instanceof Lt&&this.pts.add(t)},interfaces_:function(){return[ht]},getClass:function(){return ur}}),ur.getPoints=function(){if(1===arguments.length){var t=arguments[0];return t instanceof Lt?ho.singletonList(t):ur.getPoints(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Lt?n.add(e):e instanceof ft&&e.apply(new ur(n)),n}},e(lr.prototype,{filter:function(t){(t instanceof Lt||t instanceof St||t instanceof Tt)&&this.locations.add(new ar(t,0,t.getCoordinate()))},interfaces_:function(){return[ht]},getClass:function(){return lr}}),lr.getLocations=function(t){var e=new I;return t.apply(new lr(e)),e},e(hr.prototype,{computeContainmentDistance:function(){if(0===arguments.length){var t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this.minDistance<=this.terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=1-e,r=or.getPolygons(this.geom[e]);if(r.size()>0){var s=lr.getLocations(this.geom[i]);if(this.computeContainmentDistance(s,r,n),this.minDistance<=this.terminateDistance)return this.minDistanceLocation[i]=n[0],this.minDistanceLocation[e]=n[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&R(arguments[0],y)&&R(arguments[1],y)){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=0;l<o.size();l++)for(var h=o.get(l),c=0;c<a.size();c++)if(this.computeContainmentDistance(h,a.get(c),u),this.minDistance<=this.terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof ar&&arguments[1]instanceof Tt){var f=arguments[0],g=arguments[1],d=arguments[2],p=f.getCoordinate();if(L.EXTERIOR!==this.ptLocator.locate(p,g))return this.minDistance=0,d[0]=f,d[1]=new ar(g,p),null}},computeMinDistanceLinesPoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},computeFacetDistance:function(){var t=new Array(2).fill(null),e=kn.getLines(this.geom[0]),n=kn.getLines(this.geom[1]),i=ur.getPoints(this.geom[0]),r=ur.getPoints(this.geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,r,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,i,t),this.updateMinDistance(t,!0),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(i,r,t),void this.updateMinDistance(t,!1))))},nearestLocations:function(){return this.computeMinDistance(),this.minDistanceLocation},updateMinDistance:function(t,e){return null===t[0]?null:void(e?(this.minDistanceLocation[0]=t[1],this.minDistanceLocation[1]=t[0]):(this.minDistanceLocation[0]=t[0],this.minDistanceLocation[1]=t[1]))},nearestPoints:function(){this.computeMinDistance();var t=[this.minDistanceLocation[0].getCoordinate(),this.minDistanceLocation[1].getCoordinate()];return t},computeMinDistance:function(){if(0===arguments.length){if(null!==this.minDistanceLocation)return null;if(this.minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this.minDistance<=this.terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof Lt){var t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this.minDistance)return null;for(var i=t.getCoordinates(),r=e.getCoordinate(),s=0;s<i.length-1;s++){var o=he.distancePointLine(r,i[s],i[s+1]);if(o<this.minDistance){this.minDistance=o;var a=new ce(i[s],i[s+1]),u=a.closestPoint(r);n[0]=new ar(t,s,u),n[1]=new ar(e,0,r)}if(this.minDistance<=this.terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof St){var l=arguments[0],h=arguments[1],c=arguments[2];if(l.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this.minDistance)return null;for(var i=l.getCoordinates(),f=h.getCoordinates(),s=0;s<i.length-1;s++)for(var g=0;g<f.length-1;g++){var o=he.distanceLineLine(i[s],i[s+1],f[g],f[g+1]);if(o<this.minDistance){this.minDistance=o;var d=new ce(i[s],i[s+1]),p=new ce(f[g],f[g+1]),v=d.closestPoints(p);c[0]=new ar(l,s,v[0]),c[1]=new ar(h,g,v[1])}if(this.minDistance<=this.terminateDistance)return null}}},computeMinDistancePoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s),a=r.getCoordinate().distance(o.getCoordinate());if(a<this.minDistance&&(this.minDistance=a,n[0]=new ar(r,0,r.getCoordinate()),n[1]=new ar(o,0,o.getCoordinate())),this.minDistance<=this.terminateDistance)return null}},distance:function(){if(null===this.geom[0]||null===this.geom[1])throw new i("null geometries are not supported");return this.geom[0].isEmpty()||this.geom[1].isEmpty()?0:(this.computeMinDistance(),this.minDistance)},computeMinDistanceLines:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},interfaces_:function(){return[]},getClass:function(){return hr}}),hr.distance=function(t,e){var n=new hr(t,e);return n.distance()},hr.isWithinDistance=function(t,e,n){var i=new hr(t,e,n);return i.distance()<=n},hr.nearestPoints=function(t,e){var n=new hr(t,e);return n.nearestPoints()};var So=Object.freeze({DistanceOp:hr});e(cr.prototype,{getCoordinates:function(){if(null===this.coordinates){for(var t=0,e=0,n=new N,i=this.directedEdges.iterator();i.hasNext();){var r=i.next();r.getEdgeDirection()?t++:e++,n.add(r.getEdge().getLine().getCoordinates(),!1,r.getEdgeDirection())}this.coordinates=n.toCoordinateArray(),e>t&&H.reverse(this.coordinates)}return this.coordinates},toLineString:function(){return this.factory.createLineString(this.getCoordinates())},add:function(t){this.directedEdges.add(t)},interfaces_:function(){return[]},getClass:function(){return cr}}),e(fr.prototype,{setVisited:function(t){this._isVisited=t},isMarked:function(){return this._isMarked},setData:function(t){this.data=t},getData:function(){return this.data},setMarked:function(t){this._isMarked=t},getContext:function(){return this.data},isVisited:function(){return this._isVisited},setContext:function(t){this.data=t},interfaces_:function(){return[]},getClass:function(){return fr}}),fr.getComponentWithVisitedState=function(t,e){for(;t.hasNext();){var n=t.next();if(n.isVisited()===e)return n}return null},fr.setVisited=function(t,e){for(;t.hasNext();){var n=t.next();n.setVisited(e)}},fr.setMarked=function(t,e){for(;t.hasNext();){var n=t.next();n.setMarked(e)}},h(gr,fr),e(gr.prototype,{isRemoved:function(){return null===this.parentEdge},compareDirection:function(t){return this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getCoordinate:function(){return this.from.getCoordinate()},print:function(t){var e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);t.print("  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+this.angle)},getDirectionPt:function(){return this.p1},getAngle:function(){return this.angle},compareTo:function(t){var e=t;return this.compareDirection(e)},getFromNode:function(){return this.from},getSym:function(){return this.sym},setEdge:function(t){this.parentEdge=t},remove:function(){this.sym=null,this.parentEdge=null},getEdge:function(){return this.parentEdge},getQuadrant:function(){return this.quadrant},setSym:function(t){this.sym=t},getToNode:function(){return this.to},getEdgeDirection:function(){return this.edgeDirection},interfaces_:function(){return[s]},getClass:function(){return gr}}),gr.toEdges=function(t){for(var e=new I,n=t.iterator();n.hasNext();)e.add(n.next().parentEdge);return e},h(dr,gr),e(dr.prototype,{getNext:function(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(f.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))},interfaces_:function(){return[]},getClass:function(){return dr}}),h(pr,fr),e(pr.prototype,{isRemoved:function(){return null===this.dirEdge},setDirectedEdges:function(t,e){this.dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)},getDirEdge:function(){if(Number.isInteger(arguments[0])){var t=arguments[0];return this.dirEdge[t]}if(arguments[0]instanceof mr){var e=arguments[0];return this.dirEdge[0].getFromNode()===e?this.dirEdge[0]:this.dirEdge[1].getFromNode()===e?this.dirEdge[1]:null}},remove:function(){this.dirEdge=null},getOppositeNode:function(t){return this.dirEdge[0].getFromNode()===t?this.dirEdge[0].getToNode():this.dirEdge[1].getFromNode()===t?this.dirEdge[1].getToNode():null},interfaces_:function(){return[]},getClass:function(){return pr}}),e(vr.prototype,{getNextEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e+1))},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},iterator:function(){return this.sortEdges(),this.outEdges.iterator()},sortEdges:function(){this.sorted||(ho.sort(this.outEdges),this.sorted=!0)},remove:function(t){this.outEdges.remove(t)},getEdges:function(){return this.sortEdges(),this.outEdges},getNextCWEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e-1))},getIndex:function(){if(arguments[0]instanceof pr){var t=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n.getEdge()===t)return e}return-1}if(arguments[0]instanceof gr){var i=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n===i)return e}return-1}if(Number.isInteger(arguments[0])){var r=arguments[0],s=r%this.outEdges.size();return 0>s&&(s+=this.outEdges.size()),s}},add:function(t){this.outEdges.add(t),this.sorted=!1},getDegree:function(){return this.outEdges.size()},interfaces_:function(){return[]},getClass:function(){return vr}}),h(mr,fr),e(mr.prototype,{isRemoved:function(){return null===this.pt},addOutEdge:function(t){this.deStar.add(t)},getCoordinate:function(){return this.pt},getOutEdges:function(){return this.deStar},remove:function(){if(0===arguments.length)this.pt=null;else if(1===arguments.length){var t=arguments[0];this.deStar.remove(t)}},getIndex:function(t){return this.deStar.getIndex(t)},getDegree:function(){return this.deStar.getDegree()},interfaces_:function(){return[]},getClass:function(){return mr}}),mr.getEdgesBetween=function(t,e){var n=gr.toEdges(t.getOutEdges().getEdges()),i=new J(n),r=gr.toEdges(e.getOutEdges().getEdges());return i.retainAll(r),i},h(yr,pr),e(yr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return yr}}),e(xr.prototype,{find:function(t){return this.nodeMap.get(t)},iterator:function(){return this.nodeMap.values().iterator()},remove:function(t){return this.nodeMap.remove(t)},values:function(){return this.nodeMap.values()},add:function(t){return this.nodeMap.put(t.getCoordinate(),t),t},interfaces_:function(){return[]},getClass:function(){return xr}}),e(Er.prototype,{findNodesOfDegree:function(t){for(var e=new I,n=this.nodeIterator();n.hasNext();){var i=n.next();i.getDegree()===t&&e.add(i)}return e},dirEdgeIterator:function(){return this.dirEdges.iterator()},edgeIterator:function(){return this.edges.iterator()},remove:function(){if(arguments[0]instanceof pr){var t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this.edges.remove(t),t.remove()}else if(arguments[0]instanceof gr){var e=arguments[0],n=e.getSym();null!==n&&n.setSym(null),e.getFromNode().remove(e),e.remove(),this.dirEdges.remove(e)}else if(arguments[0]instanceof mr){for(var i=arguments[0],r=i.getOutEdges().getEdges(),s=r.iterator();s.hasNext();){var o=s.next(),n=o.getSym();null!==n&&this.remove(n),this.dirEdges.remove(o);var a=o.getEdge();null!==a&&this.edges.remove(a)}this.nodeMap.remove(i.getCoordinate()),i.remove()}},findNode:function(t){return this.nodeMap.find(t)},getEdges:function(){return this.edges},nodeIterator:function(){return this.nodeMap.iterator()},contains:function(){if(arguments[0]instanceof pr){var t=arguments[0];return this.edges.contains(t)}if(arguments[0]instanceof gr){var e=arguments[0];return this.dirEdges.contains(e)}},add:function(){if(arguments[0]instanceof mr){var t=arguments[0];this.nodeMap.add(t)}else if(arguments[0]instanceof pr){var e=arguments[0];this.edges.add(e),this.add(e.getDirEdge(0)),this.add(e.getDirEdge(1))}else if(arguments[0]instanceof gr){var n=arguments[0];this.dirEdges.add(n)}},getNodes:function(){return this.nodeMap.values()},interfaces_:function(){return[]},getClass:function(){return Er}}),h(Ir,Er),e(Ir.prototype,{addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new dr(r,s,e[1],!0),a=new dr(s,r,e[e.length-2],!1),u=new yr(t);u.setDirectedEdges(o,a),this.add(u)},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new mr(t),this.add(e)),e},interfaces_:function(){return[]},getClass:function(){return Ir}}),e(Nr.prototype,{buildEdgeStringsForUnprocessedNodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.isMarked()||(f.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForNonDegree2Nodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForObviousStartNodes:function(){this.buildEdgeStringsForNonDegree2Nodes()},getMergedLineStrings:function(){return this.merge(),this.mergedLineStrings},buildEdgeStringsStartingAt:function(t){for(var e=t.getOutEdges().iterator();e.hasNext();){var n=e.next();n.getEdge().isMarked()||this.edgeStrings.add(this.buildEdgeStringStartingWith(n))}},merge:function(){if(null!==this.mergedLineStrings)return null;fr.setMarked(this.graph.nodeIterator(),!1),fr.setMarked(this.graph.edgeIterator(),!1),this.edgeStrings=new I,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this.mergedLineStrings=new I;for(var t=this.edgeStrings.iterator();t.hasNext();){var e=t.next();this.mergedLineStrings.add(e.toLineString())}},buildEdgeStringStartingWith:function(t){var e=new cr(this.factory),n=t;do e.add(n),n.getEdge().setMarked(!0),n=n.getNext();while(null!==n&&n!==t);return e},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v)){var e=arguments[0];this.mergedLineStrings=null;for(var n=e.iterator();n.hasNext();){
var i=n.next();this.add(i)}}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory()),this.graph.addEdge(r)}},buildEdgeStringsForIsolatedLoops:function(){this.buildEdgeStringsForUnprocessedNodes()},interfaces_:function(){return[]},getClass:function(){return Nr}});var wo=Object.freeze({LineMerger:Nr}),Lo=Object.freeze({OverlayOp:ii});h(Cr,gr),e(Cr.prototype,{getNext:function(){return this.next},isInRing:function(){return null!==this.edgeRing},setRing:function(t){this.edgeRing=t},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setNext:function(t){this.next=t},getRing:function(){return this.edgeRing},interfaces_:function(){return[]},getClass:function(){return Cr}}),h(Sr,pr),e(Sr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return Sr}}),e(wr.prototype,{isIncluded:function(){return this._isIncluded},getCoordinates:function(){if(null===this.ringPts){for(var t=new N,e=this.deList.iterator();e.hasNext();){var n=e.next(),i=n.getEdge();wr.addEdge(i.getLine().getCoordinates(),n.getEdgeDirection(),t)}this.ringPts=t.toCoordinateArray()}return this.ringPts},isIncludedSet:function(){return this._isIncludedSet},isValid:function(){return this.getCoordinates(),this.ringPts.length<=3?!1:(this.getRing(),this.ring.isValid())},build:function(t){var e=t;do this.add(e),e.setRing(this),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t)},isOuterHole:function(){return this._isHole?!this.hasShell():!1},getPolygon:function(){var t=null;if(null!==this.holes){t=new Array(this.holes.size()).fill(null);for(var e=0;e<this.holes.size();e++)t[e]=this.holes.get(e)}var n=this.factory.createPolygon(this.ring,t);return n},isHole:function(){return this._isHole},isProcessed:function(){return this._isProcessed},addHole:function(){if(arguments[0]instanceof bt){var t=arguments[0];null===this.holes&&(this.holes=new I),this.holes.add(t)}else if(arguments[0]instanceof wr){var e=arguments[0];e.setShell(this);var n=e.getRing();null===this.holes&&(this.holes=new I),this.holes.add(n)}},setIncluded:function(t){this._isIncluded=t,this._isIncludedSet=!0},getOuterHole:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing();if(n.isOuterHole())return n}return null},computeHole:function(){var t=this.getRing();this._isHole=he.isCCW(t.getCoordinates())},hasShell:function(){return null!==this.shell},isOuterShell:function(){return null!==this.getOuterHole()},getLineString:function(){return this.getCoordinates(),this.factory.createLineString(this.ringPts)},toString:function(){return se.toLineString(new Gt(this.getCoordinates()))},getShell:function(){return this.isHole()?this.shell:this},add:function(t){this.deList.add(t)},getRing:function(){if(null!==this.ring)return this.ring;this.getCoordinates(),this.ringPts.length<3&&A.out.println(this.ringPts);try{this.ring=this.factory.createLinearRing(this.ringPts)}catch(t){if(!(t instanceof S))throw t;A.out.println(this.ringPts)}finally{}return this.ring},updateIncluded:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing().getShell();if(null!==n&&n.isIncludedSet())return this.setIncluded(!n.isIncluded()),null}},setShell:function(t){this.shell=t},setProcessed:function(t){this._isProcessed=t},interfaces_:function(){return[]},getClass:function(){return wr}}),wr.findDirEdgesInRing=function(t){var e=t,n=new I;do n.add(e),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t);return n},wr.addEdge=function(t,e,n){if(e)for(var i=0;i<t.length;i++)n.add(t[i],!1);else for(var i=t.length-1;i>=0;i--)n.add(t[i],!1)},wr.findEdgeRingContaining=function(t,e){for(var n=t.getRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getRing(),h=l.getEnvelopeInternal();if(!h.equals(i)&&h.contains(i)){r=H.ptNotInList(n.getCoordinates(),l.getCoordinates());var c=!1;he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u,o=s.getRing().getEnvelopeInternal())}}return s},e(Lr.prototype,{compare:function(t,e){var n=t,i=e;return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope())},interfaces_:function(){return[a]},getClass:function(){return Lr}}),wr.EnvelopeComparator=Lr,h(Rr,Er),e(Rr.prototype,{findEdgeRing:function(t){var e=new wr(this.factory);return e.build(t),e},computeDepthParity:function(){if(0===arguments.length)for(;;){var t=null;if(null===t)return null;this.computeDepthParity(t)}else if(1===arguments.length){arguments[0]}},computeNextCWEdges:function(){for(var t=this.nodeIterator();t.hasNext();){var e=t.next();Rr.computeNextCWEdges(e)}},addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new Cr(r,s,e[1],!0),a=new Cr(s,r,e[e.length-2],!1),u=new Sr(t);u.setDirectedEdges(o,a),this.add(u)},deleteCutEdges:function(){this.computeNextCWEdges(),Rr.findLabeledEdgeRings(this.dirEdges);for(var t=new I,e=this.dirEdges.iterator();e.hasNext();){var n=e.next();if(!n.isMarked()){var i=n.getSym();if(n.getLabel()===i.getLabel()){n.setMarked(!0),i.setMarked(!0);var r=n.getEdge();t.add(r.getLine())}}}return t},getEdgeRings:function(){this.computeNextCWEdges(),Rr.label(this.dirEdges,-1);var t=Rr.findLabeledEdgeRings(this.dirEdges);this.convertMaximalToMinimalEdgeRings(t);for(var e=new I,n=this.dirEdges.iterator();n.hasNext();){var i=n.next();if(!i.isMarked()&&!i.isInRing()){var r=this.findEdgeRing(i);e.add(r)}}return e},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new mr(t),this.add(e)),e},convertMaximalToMinimalEdgeRings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel(),r=Rr.findIntersectionNodes(n,i);if(null!==r)for(var s=r.iterator();s.hasNext();){var o=s.next();Rr.computeNextCCWEdges(o,i)}}},deleteDangles:function(){for(var t=this.findNodesOfDegree(1),e=new J,n=new pe,i=t.iterator();i.hasNext();)n.push(i.next());for(;!n.isEmpty();){var r=n.pop();Rr.deleteAllEdges(r);for(var s=r.getOutEdges().getEdges(),i=s.iterator();i.hasNext();){var o=i.next();o.setMarked(!0);var a=o.getSym();null!==a&&a.setMarked(!0);var u=o.getEdge();e.add(u.getLine());var l=o.getToNode();1===Rr.getDegreeNonDeleted(l)&&n.push(l)}}return e},interfaces_:function(){return[]},getClass:function(){return Rr}}),Rr.findLabeledEdgeRings=function(t){for(var e=new I,n=1,i=t.iterator();i.hasNext();){var r=i.next();if(!(r.isMarked()||r.getLabel()>=0)){e.add(r);var s=wr.findDirEdgesInRing(r);Rr.label(s,n),n++}}return e},Rr.getDegreeNonDeleted=function(t){for(var e=t.getOutEdges().getEdges(),n=0,i=e.iterator();i.hasNext();){var r=i.next();r.isMarked()||n++}return n},Rr.deleteAllEdges=function(t){for(var e=t.getOutEdges().getEdges(),n=e.iterator();n.hasNext();){var i=n.next();i.setMarked(!0);var r=i.getSym();null!==r&&r.setMarked(!0)}},Rr.label=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();i.setLabel(e)}},Rr.computeNextCWEdges=function(t){for(var e=t.getOutEdges(),n=null,i=null,r=e.getEdges().iterator();r.hasNext();){var s=r.next();if(!s.isMarked()){if(null===n&&(n=s),null!==i){var o=i.getSym();o.setNext(s)}i=s}}if(null!==i){var o=i.getSym();o.setNext(n)}},Rr.computeNextCCWEdges=function(t,e){for(var n=t.getOutEdges(),i=null,r=null,s=n.getEdges(),o=s.size()-1;o>=0;o--){var a=s.get(o),u=a.getSym(),l=null;a.getLabel()===e&&(l=a);var h=null;u.getLabel()===e&&(h=u),null===l&&null===h||(null!==h&&(r=h),null!==l&&(null!==r&&(r.setNext(l),r=null),null===i&&(i=l)))}null!==r&&(f.isTrue(null!==i),r.setNext(i))},Rr.getDegree=function(t,e){for(var n=t.getOutEdges().getEdges(),i=0,r=n.iterator();r.hasNext();){var s=r.next();s.getLabel()===e&&i++}return i},Rr.findIntersectionNodes=function(t,e){var n=t,i=null;do{var r=n.getFromNode();Rr.getDegree(r,e)>1&&(null===i&&(i=new I),i.add(r)),n=n.getNext(),f.isTrue(null!==n,"found null DE in ring"),f.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return i},e(Tr.prototype,{getGeometry:function(){return null===this.geomFactory&&(this.geomFactory=new ie),this.polygonize(),this.extractOnlyPolygonal?this.geomFactory.buildGeometry(this.polyList):this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList))},getInvalidRingLines:function(){return this.polygonize(),this.invalidRingLines},findValidRings:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isValid()?e.add(r):n.add(r.getLineString())}},polygonize:function(){if(null!==this.polyList)return null;if(this.polyList=new I,null===this.graph)return null;this.dangles=this.graph.deleteDangles(),this.cutEdges=this.graph.deleteCutEdges();var t=this.graph.getEdgeRings(),e=new I;this.invalidRingLines=new I,this.isCheckingRingsValid?this.findValidRings(t,e,this.invalidRingLines):e=t,this.findShellsAndHoles(e),Tr.assignHolesToShells(this.holeList,this.shellList),ho.sort(this.shellList,new wr.EnvelopeComparator);var n=!0;this.extractOnlyPolygonal&&(Tr.findDisjointShells(this.shellList),n=!1),this.polyList=Tr.extractPolygons(this.shellList,n)},getDangles:function(){return this.polygonize(),this.dangles},getCutEdges:function(){return this.polygonize(),this.cutEdges},getPolygons:function(){return this.polygonize(),this.polyList},add:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.add(n)}else if(arguments[0]instanceof St){var i=arguments[0];this.geomFactory=i.getFactory(),null===this.graph&&(this.graph=new Rr(this.geomFactory)),this.graph.addEdge(i)}else if(arguments[0]instanceof B){var r=arguments[0];r.apply(this.lineStringAdder)}},setCheckRingsValid:function(t){this.isCheckingRingsValid=t},findShellsAndHoles:function(t){this.holeList=new I,this.shellList=new I;for(var e=t.iterator();e.hasNext();){var n=e.next();n.computeHole(),n.isHole()?this.holeList.add(n):this.shellList.add(n)}},interfaces_:function(){return[]},getClass:function(){return Tr}}),Tr.findOuterShells=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getOuterHole();null===i||i.isProcessed()||(n.setIncluded(!0),i.setProcessed(!0))}},Tr.extractPolygons=function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next();(e||r.isIncluded())&&n.add(r.getPolygon())}return n},Tr.assignHolesToShells=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();Tr.assignHoleToShell(i,e)}},Tr.assignHoleToShell=function(t,e){var n=wr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)},Tr.findDisjointShells=function(t){Tr.findOuterShells(t);var e=null;do{e=!1;for(var n=t.iterator();n.hasNext();){var i=n.next();i.isIncludedSet()||(i.updateIncluded(),i.isIncludedSet()||(e=!0))}}while(e)},e(Pr.prototype,{filter:function(t){t instanceof St&&this.p.add(t)},interfaces_:function(){return[q]},getClass:function(){return Pr}}),Tr.LineStringAdder=Pr;var Ro=Object.freeze({Polygonizer:Tr});e(br.prototype,{createEdgeEndForNext:function(t,e,n,i){var r=n.segmentIndex+1;if(r>=t.getNumPoints()&&null===i)return null;var s=t.getCoordinate(r);null!==i&&i.segmentIndex===n.segmentIndex&&(s=i.coord);var o=new En(t,n.coord,s,new gn(t.getLabel()));e.add(o)},createEdgeEndForPrev:function(t,e,n,i){var r=n.segmentIndex;if(0===n.dist){if(0===r)return null;r--}var s=t.getCoordinate(r);null!==i&&i.segmentIndex>=r&&(s=i.coord);var o=new gn(t.getLabel());o.flip();var a=new En(t,n.coord,s,o);e.add(a)},computeEdgeEnds:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=t;n.hasNext();){var i=n.next();this.computeEdgeEnds(i,e)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1],o=r.getEdgeIntersectionList();o.addEndpoints();var a=o.iterator(),u=null,l=null;if(!a.hasNext())return null;var h=a.next();do u=l,l=h,h=null,a.hasNext()&&(h=a.next()),null!==l&&(this.createEdgeEndForPrev(r,s,l,u),this.createEdgeEndForNext(r,s,l,h));while(null!==l)}},interfaces_:function(){return[]},getClass:function(){return br}}),h(Or,En),e(Or.prototype,{insert:function(t){this.edgeEnds.add(t)},print:function(t){t.println("EdgeEndBundle--> Label: "+this.label);for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t),t.println()}},iterator:function(){return this.edgeEnds.iterator()},getEdgeEnds:function(){return this.edgeEnds},computeLabelOn:function(t,e){for(var n=0,i=!1,r=this.iterator();r.hasNext();){var s=r.next(),o=s.getLabel().getLocation(t);o===L.BOUNDARY&&n++,o===L.INTERIOR&&(i=!0)}var o=L.NONE;i&&(o=L.INTERIOR),n>0&&(o=$n.determineBoundary(e,n)),this.label.setLocation(t,o)},computeLabelSide:function(t,e){for(var n=this.iterator();n.hasNext();){var i=n.next();if(i.getLabel().isArea()){var r=i.getLabel().getLocation(t,e);if(r===L.INTERIOR)return this.label.setLocation(t,e,L.INTERIOR),null;r===L.EXTERIOR&&this.label.setLocation(t,e,L.EXTERIOR)}}},getLabel:function(){return this.label},computeLabelSides:function(t){this.computeLabelSide(t,cn.LEFT),this.computeLabelSide(t,cn.RIGHT)},updateIM:function(t){Jn.updateIM(this.label,t)},computeLabel:function(t){for(var e=!1,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().isArea()&&(e=!0)}e?this.label=new gn(L.NONE,L.NONE,L.NONE):this.label=new gn(L.NONE);for(var r=0;2>r;r++)this.computeLabelOn(r,t),e&&this.computeLabelSides(r)},interfaces_:function(){return[]},getClass:function(){return Or}}),h(_r,Pn),e(_r.prototype,{updateIM:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}},insert:function(t){var e=this.edgeMap.get(t);null===e?(e=new Or(t),this.insertEdgeEnd(t,e)):e.insert(t)},interfaces_:function(){return[]},getClass:function(){return _r}}),h(Mr,yn),e(Mr.prototype,{updateIMFromEdges:function(t){this.edges.updateIM(t)},computeIM:function(t){t.setAtLeastIfValid(this.label.getLocation(0),this.label.getLocation(1),0)},interfaces_:function(){return[]},getClass:function(){return Mr}}),h(Dr,Nn),e(Dr.prototype,{createNode:function(t){return new Mr(t,new _r)},interfaces_:function(){return[]},getClass:function(){return Dr}}),e(Ar.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},computeProperIntersectionIM:function(t,e){var n=this.arg[0].getGeometry().getDimension(),i=this.arg[1].getGeometry().getDimension(),r=t.hasProperIntersection(),s=t.hasProperInteriorIntersection();2===n&&2===i?r&&e.setAtLeast("212101212"):2===n&&1===i?(r&&e.setAtLeast("FFF0FFFF2"),s&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(r&&e.setAtLeast("F0FFFFFF2"),s&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&s&&e.setAtLeast("0FFFFFFFF")},labelIsolatedEdges:function(t,e){for(var n=this.arg[t].getEdgeIterator();n.hasNext();){var i=n.next();i.isIsolated()&&(this.labelIsolatedEdge(i,e,this.arg[e].getGeometry()),this.isolatedEdges.add(i))}},labelIsolatedEdge:function(t,e,n){if(n.getDimension()>0){var i=this.ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,L.EXTERIOR)},computeIM:function(){var t=new fe;if(t.set(L.EXTERIOR,L.EXTERIOR,2),!this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1);var e=this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);var n=new br,i=n.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(i);var r=n.computeEdgeEnds(this.arg[1].getEdgeIterator());return this.insertEdgeEnds(r),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t},labelNodeEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}},copyNodesAndLabels:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.nodes.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},labelIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.find(s.coord);o.getLabel().isNull(t)&&(i===L.BOUNDARY?o.setLabelBoundary(t):o.setLabel(t,L.INTERIOR))}},labelIsolatedNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setAllLocations(e,n)},computeIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.addNode(s.coord);i===L.BOUNDARY?o.setLabelBoundary(t):o.getLabel().isNull(t)&&o.setLabel(t,L.INTERIOR)}},labelIsolatedNodes:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();f.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}},updateIM:function(t){for(var e=this.isolatedEdges.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}for(var i=this.nodes.iterator();i.hasNext();){var r=i.next();r.updateIM(t),r.updateIMFromEdges(t)}},computeDisjointIM:function(t){var e=this.arg[0].getGeometry();e.isEmpty()||(t.set(L.INTERIOR,L.EXTERIOR,e.getDimension()),t.set(L.BOUNDARY,L.EXTERIOR,e.getBoundaryDimension()));var n=this.arg[1].getGeometry();n.isEmpty()||(t.set(L.EXTERIOR,L.INTERIOR,n.getDimension()),t.set(L.EXTERIOR,L.BOUNDARY,n.getBoundaryDimension()))},interfaces_:function(){return[]},getClass:function(){return Ar}}),e(Fr.prototype,{isContainedInBoundary:function(t){if(t instanceof Tt)return!1;if(t instanceof Lt)return this.isPointContainedInBoundary(t);if(t instanceof St)return this.isLineStringContainedInBoundary(t);for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0},isLineSegmentContainedInBoundary:function(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this.rectEnv.getMinX()||t.x===this.rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this.rectEnv.getMinY()||t.y===this.rectEnv.getMaxY()))return!0;return!1},isLineStringContainedInBoundary:function(t){for(var e=t.getCoordinateSequence(),n=new g,i=new g,r=0;r<e.size()-1;r++)if(e.getCoordinate(r,n),e.getCoordinate(r+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0},isPointContainedInBoundary:function(){if(arguments[0]instanceof Lt){var t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){var e=arguments[0];return e.x===this.rectEnv.getMinX()||e.x===this.rectEnv.getMaxX()||e.y===this.rectEnv.getMinY()||e.y===this.rectEnv.getMaxY()}},contains:function(t){return this.rectEnv.contains(t.getEnvelopeInternal())?!this.isContainedInBoundary(t):!1},interfaces_:function(){return[]},getClass:function(){return Fr}}),Fr.contains=function(t,e){var n=new Fr(t);return n.contains(e)},e(Gr.prototype,{intersects:function(t,e){var n=new C(t,e);if(!this.rectEnv.intersects(n))return!1;if(this.rectEnv.intersects(t))return!0;if(this.rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){var i=t;t=e,e=i}var r=!1;return e.y>t.y&&(r=!0),r?this.li.computeIntersection(t,e,this.diagDown0,this.diagDown1):this.li.computeIntersection(t,e,this.diagUp0,this.diagUp1),!!this.li.hasIntersection()},interfaces_:function(){return[]},getClass:function(){return Gr}}),e(qr.prototype,{applyTo:function(t){for(var e=0;e<t.getNumGeometries()&&!this._isDone;e++){var n=t.getGeometryN(e);if(n instanceof ft)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}},interfaces_:function(){return[]},getClass:function(){return qr}}),e(Br.prototype,{intersects:function(t){if(!this.rectEnv.intersects(t.getEnvelopeInternal()))return!1;var e=new zr(this.rectEnv);if(e.applyTo(t),e.intersects())return!0;var n=new Vr(this.rectangle);if(n.applyTo(t),n.containsPoint())return!0;var i=new kr(this.rectangle);return i.applyTo(t),!!i.intersects()},interfaces_:function(){return[]},getClass:function(){return Br}}),Br.intersects=function(t,e){var n=new Br(t);return n.intersects(e)},h(zr,qr),e(zr.prototype,{isDone:function(){return this._intersects===!0},visit:function(t){var e=t.getEnvelopeInternal();return this.rectEnv.intersects(e)?this.rectEnv.contains(e)?(this._intersects=!0,null):e.getMinX()>=this.rectEnv.getMinX()&&e.getMaxX()<=this.rectEnv.getMaxX()?(this._intersects=!0,null):e.getMinY()>=this.rectEnv.getMinY()&&e.getMaxY()<=this.rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null},intersects:function(){return this._intersects},interfaces_:function(){return[]},getClass:function(){return zr}}),h(Vr,qr),e(Vr.prototype,{isDone:function(){return this._containsPoint===!0},visit:function(t){if(!(t instanceof Tt))return null;var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;for(var n=new g,i=0;4>i;i++)if(this.rectSeq.getCoordinate(i,n),e.contains(n)&&Tn.containsPointInPolygon(n,t))return this._containsPoint=!0,null},containsPoint:function(){return this._containsPoint},interfaces_:function(){return[]},getClass:function(){return Vr}}),h(kr,qr),e(kr.prototype,{intersects:function(){return this.hasIntersection},isDone:function(){return this.hasIntersection===!0},visit:function(t){var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;var n=kn.getLines(t);this.checkIntersectionWithLineStrings(n)},checkIntersectionWithLineStrings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();if(this.checkIntersectionWithSegments(n),this.hasIntersection)return null}},checkIntersectionWithSegments:function(t){for(var e=t.getCoordinateSequence(),n=1;n<e.size();n++)if(e.getCoordinate(n-1,this.p0),e.getCoordinate(n,this.p1),this.rectIntersector.intersects(this.p0,this.p1))return this.hasIntersection=!0,null},interfaces_:function(){return[]},getClass:function(){return kr}}),h(Yr,ti),e(Yr.prototype,{getIntersectionMatrix:function(){return this._relate.computeIM()},interfaces_:function(){return[]},getClass:function(){return Yr}}),Yr.covers=function(t,e){return t.getEnvelopeInternal().covers(e.getEnvelopeInternal())?t.isRectangle()?!0:Yr.relate(t,e).isCovers():!1},Yr.intersects=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?t.isRectangle()?Br.intersects(t,e):e.isRectangle()?Br.intersects(e,t):Yr.relate(t,e).isIntersects():!1},Yr.touches=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isTouches(t.getDimension(),e.getDimension()):!1},Yr.within=function(t,e){return e.contains(t)},Yr.coveredBy=function(t,e){return Yr.covers(e,t)},Yr.relate=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yr(t,e),i=n.getIntersectionMatrix();return i}if(3===arguments.length){if("string"==typeof arguments[2]&&arguments[0]instanceof B&&arguments[1]instanceof B){var r=arguments[0],s=arguments[1],o=arguments[2];return Yr.relateWithCheck(r,s).matches(o)}if(R(arguments[2],V)&&arguments[0]instanceof B&&arguments[1]instanceof B){var a=arguments[0],u=arguments[1],l=arguments[2],n=new Yr(a,u,l),i=n.getIntersectionMatrix();return i}}},Yr.overlaps=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isOverlaps(t.getDimension(),e.getDimension()):!1},Yr.disjoint=function(t,e){return!t.intersects(e)},Yr.relateWithCheck=function(t,e){return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),Yr.relate(t,e)},Yr.crosses=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isCrosses(t.getDimension(),e.getDimension()):!1},Yr.contains=function(t,e){return t.getEnvelopeInternal().contains(e.getEnvelopeInternal())?t.isRectangle()?Fr.contains(t,e):Yr.relate(t,e).isContains():!1};var To=Object.freeze({RelateOp:Yr});e(Ur.prototype,{extractElements:function(t,e){if(null===t)return null;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);this.skipEmpty&&i.isEmpty()||e.add(i)}},combine:function(){for(var t=new I,e=this.inputGeoms.iterator();e.hasNext();){var n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this.geomFactory?this.geomFactory.createGeometryCollection(null):null:this.geomFactory.buildGeometry(t)},interfaces_:function(){return[]},getClass:function(){return Ur}}),Ur.combine=function(){if(1===arguments.length){var t=arguments[0],e=new Ur(t);return e.combine()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new Ur(Ur.createList(n,i));return e.combine()}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],e=new Ur(Ur.createList(r,s,o));return e.combine()}},Ur.extractFactory=function(t){return t.isEmpty()?null:t.iterator().next().getFactory()},Ur.createList=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new I;return n.add(t),n.add(e),n}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],n=new I;return n.add(i),n.add(r),n.add(s),n}},e(Xr.prototype,{union:function(){for(var t=new Te,e=new at,n=0;n<this.pointGeom.getNumGeometries();n++){var i=this.pointGeom.getGeometryN(n),r=i.getCoordinate(),s=t.locate(r,this.otherGeom);s===L.EXTERIOR&&e.add(r)}if(0===e.size())return this.otherGeom;var o=null,a=H.toCoordinateArray(e);return o=1===a.length?this.geomFact.createPoint(a[0]):this.geomFact.createMultiPointFromCoords(a),Ur.combine(o,this.otherGeom)},interfaces_:function(){return[]},getClass:function(){return Xr}}),Xr.union=function(t,e){var n=new Xr(t,e);return n.union()},e(Hr.prototype,{filter:function(t){-1!==this.sortIndex&&t.getSortIndex()!==this.sortIndex||this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return Hr}}),Hr.extract=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Hr.extract(t,e,new I)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];return n.getSortIndex()===i?r.add(n):n instanceof ft&&n.apply(new Hr(i,r)),r}},e(Wr.prototype,{reduceToGeometries:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=null;R(i,y)?r=this.unionTree(i):i instanceof B&&(r=i),e.add(r)}return e},extractByEnvelope:function(t,e,n){for(var i=new I,r=0;r<e.getNumGeometries();r++){var s=e.getGeometryN(r);s.getEnvelopeInternal().intersects(t)?i.add(s):n.add(s)}return this.geomFactory.buildGeometry(i)},unionOptimized:function(t,e){var n=t.getEnvelopeInternal(),i=e.getEnvelopeInternal();if(!n.intersects(i)){var r=Ur.combine(t,e);return r}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);var s=n.intersection(i);return this.unionUsingEnvelopeIntersection(t,e,s)},union:function(){if(null===this.inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this.inputPolys.isEmpty())return null;this.geomFactory=this.inputPolys.iterator().next().getFactory();for(var t=new ke(Wr.STRTREE_NODE_CAPACITY),e=this.inputPolys.iterator();e.hasNext();){var n=e.next();t.insert(n.getEnvelopeInternal(),n)}this.inputPolys=null;var i=t.itemsTree(),r=this.unionTree(i);return r},binaryUnion:function(){if(1===arguments.length){var t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];if(1>=i-n){var r=Wr.getGeometry(e,n);return this.unionSafe(r,null)}if(i-n===2)return this.unionSafe(Wr.getGeometry(e,n),Wr.getGeometry(e,n+1));var s=Math.trunc((i+n)/2),r=this.binaryUnion(e,n,s),o=this.binaryUnion(e,s,i);return this.unionSafe(r,o)}},repeatedUnion:function(t){for(var e=null,n=t.iterator();n.hasNext();){var i=n.next();e=null===e?i.copy():e.union(i)}return e},unionSafe:function(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)},unionActual:function(t,e){return Wr.restrictToPolygons(t.union(e))},unionTree:function(t){var e=this.reduceToGeometries(t),n=this.binaryUnion(e);return n},unionUsingEnvelopeIntersection:function(t,e,n){var i=new I,r=this.extractByEnvelope(n,t,i),s=this.extractByEnvelope(n,e,i),o=this.unionActual(r,s);i.add(o);var a=Ur.combine(i);return a},bufferUnion:function(){if(1===arguments.length){var t=arguments[0],e=t.get(0).getFactory(),n=e.buildGeometry(t),i=n.buffer(0);return i}if(2===arguments.length){var r=arguments[0],s=arguments[1],e=r.getFactory(),n=e.createGeometryCollection([r,s]),i=n.buffer(0);return i}},interfaces_:function(){return[]},getClass:function(){return Wr}}),Wr.restrictToPolygons=function(t){if(R(t,Rt))return t;var e=or.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(ie.toPolygonArray(e))},Wr.getGeometry=function(t,e){return e>=t.size()?null:t.get(e)},Wr.union=function(t){var e=new Wr(t);return e.union()},Wr.STRTREE_NODE_CAPACITY=4,e(jr.prototype,{unionNoOpt:function(t){var e=this.geomFact.createPoint();return si.overlayOp(t,e,ii.UNION)},unionWithNull:function(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)},extract:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.extract(n)}else if(arguments[0]instanceof B){var i=arguments[0];null===this.geomFact&&(this.geomFact=i.getFactory()),Hr.extract(i,B.SORTINDEX_POLYGON,this.polygons),Hr.extract(i,B.SORTINDEX_LINESTRING,this.lines),Hr.extract(i,B.SORTINDEX_POINT,this.points)}},union:function t(){if(null===this.geomFact)return null;var e=null;if(this.points.size()>0){var n=this.geomFact.buildGeometry(this.points);e=this.unionNoOpt(n)}var i=null;if(this.lines.size()>0){var r=this.geomFact.buildGeometry(this.lines);i=this.unionNoOpt(r)}var s=null;this.polygons.size()>0&&(s=Wr.union(this.polygons));var o=this.unionWithNull(i,s),t=null;return t=null===e?o:null===o?e:Xr.union(e,o),null===t?this.geomFact.createGeometryCollection():t},interfaces_:function(){return[]},getClass:function(){return jr}}),jr.union=function(){if(1===arguments.length){if(R(arguments[0],v)){var t=arguments[0],e=new jr(t);return e.union()}if(arguments[0]instanceof B){var n=arguments[0],e=new jr(n);return e.union()}}else if(2===arguments.length){var i=arguments[0],r=arguments[1],e=new jr(i,r);return e.union()}};var Po=Object.freeze({UnaryUnionOp:jr});e(Kr.prototype,{visitInteriorRing:function(t,e){var n=t.getCoordinates(),i=n[0],r=Kr.findDifferentPoint(n,i),s=e.findEdgeInSameDirection(i,r),o=e.findEdgeEnd(s),a=null;o.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR?a=o:o.getSym().getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&(a=o.getSym()),f.isTrue(null!==a,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(a)},visitShellInteriors:function(t,e){if(t instanceof Tt){var n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof Ot)for(var i=t,r=0;r<i.getNumGeometries();r++){var n=i.getGeometryN(r);this.visitInteriorRing(n.getExteriorRing(),e)}},getCoordinate:function(){return this.disconnectedRingcoord},setInteriorEdgesInResult:function(t){for(var e=t.getEdgeEnds().iterator();e.hasNext();){var n=e.next();n.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&n.setInResult(!0)}},visitLinkedDirectedEdges:function(t){var e=t,n=t;do f.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext();while(n!==e)},buildEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);r.linkDirectedEdgesForMinimalEdgeRings();var s=r.buildMinimalRings();e.addAll(s)}}return e},hasUnvisitedShellEdge:function(t){for(var e=0;e<t.size();e++){var n=t.get(e);if(!n.isHole()){var i=n.getEdges(),r=i.get(0);if(r.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR)for(var s=0;s<i.size();s++)if(r=i.get(s),
!r.isVisited())return this.disconnectedRingcoord=r.getCoordinate(),!0}}return!1},isInteriorsConnected:function(){var t=new I;this.geomGraph.computeSplitEdges(t);var e=new Cn(new On);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();var n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this.geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)},interfaces_:function(){return[]},getClass:function(){return Kr}}),Kr.findDifferentPoint=function(t,e){for(var n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null},e(Zr.prototype,{hasChildren:function(){for(var t=0;2>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;2>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},size:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){return null===t||this.isSearchMatch(t)?(e.addAll(this.items),null!==this.subnode[0]&&this.subnode[0].addAllItemsFromOverlapping(t,e),void(null!==this.subnode[1]&&this.subnode[1].addAllItemsFromOverlapping(t,e))):null},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;2>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;2>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},nodeSize:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].nodeSize());return t+1},add:function(t){this.items.add(t)},interfaces_:function(){return[]},getClass:function(){return Zr}}),Zr.getSubnodeIndex=function(t,e){var n=-1;return t.min>=e&&(n=1),t.max<=e&&(n=0),n},e(Qr.prototype,{expandToInclude:function(t){t.max>this.max&&(this.max=t.max),t.min<this.min&&(this.min=t.min)},getWidth:function(){return this.max-this.min},overlaps:function(){if(1===arguments.length){var t=arguments[0];return this.overlaps(t.min,t.max)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return!(this.min>n||this.max<e)}},getMin:function(){return this.min},toString:function(){return"["+this.min+", "+this.max+"]"},contains:function(){if(1===arguments.length){if(arguments[0]instanceof Qr){var t=arguments[0];return this.contains(t.min,t.max)}if("number"==typeof arguments[0]){var e=arguments[0];return e>=this.min&&e<=this.max}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return n>=this.min&&i<=this.max}},init:function(t,e){this.min=t,this.max=e,t>e&&(this.min=e,this.max=t)},getMax:function(){return this.max},interfaces_:function(){return[]},getClass:function(){return Qr}}),e(Jr.prototype,{getInterval:function(){return this.interval},getLevel:function(){return this.level},computeKey:function(t){for(this.level=Jr.computeLevel(t),this.interval=new Qr,this.computeInterval(this.level,t);!this.interval.contains(t);)this.level+=1,this.computeInterval(this.level,t)},computeInterval:function(t,e){var n=Ci.powerOf2(t);this.pt=Math.floor(e.getMin()/n)*n,this.interval.init(this.pt,this.pt+n)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return Jr}}),Jr.computeLevel=function(t){var e=t.getWidth(),n=Ci.exponent(e)+1;return n},h($r,Zr),e($r.prototype,{getInterval:function(){return this.interval},find:function(t){var e=Zr.getSubnodeIndex(t,this.centre);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},insert:function(t){f.isTrue(null===this.interval||this.interval.contains(t.interval));var e=Zr.getSubnodeIndex(t.interval,this.centre);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insert(t),this.subnode[e]=n}},isSearchMatch:function(t){return t.overlaps(this.interval)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getNode:function(t){var e=Zr.getSubnodeIndex(t,this.centre);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0;switch(t){case 0:e=this.interval.getMin(),n=this.centre;break;case 1:e=this.centre,n=this.interval.getMax()}var i=new Qr(e,n),r=new $r(i,this.level-1);return r},interfaces_:function(){return[]},getClass:function(){return $r}}),$r.createNode=function(t){var e=new Jr(t),n=new $r(e.getInterval(),e.getLevel());return n},$r.createExpanded=function(t,e){var n=new Qr(e);null!==t&&n.expandToInclude(t.interval);var i=$r.createNode(n);return null!==t&&i.insert(t),i},h(ts,Zr),e(ts.prototype,{insert:function(t,e){var n=Zr.getSubnodeIndex(t,ts.origin);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getInterval().contains(t)){var r=$r.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getInterval().contains(e));var i=Ri.isZeroWidth(e.getMin(),e.getMax()),r=null;r=i?t.find(e):t.getNode(e),r.add(n)},interfaces_:function(){return[]},getClass:function(){return ts}}),ts.origin=0,e(es.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=es.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];return this.query(new Qr(t,t))}if(arguments[0]instanceof Qr){var e=arguments[0],n=new I;return this.query(e,n),n}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.root.addAllItemsFromOverlapping(i,r)}},iterator:function(){var t=new I;return this.root.addAllItems(t),t.iterator()},remove:function(t,e){var n=es.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e)},depth:function(){return null!==this.root?this.root.depth():0},nodeSize:function(){return null!==this.root?this.root.nodeSize():0},interfaces_:function(){return[]},getClass:function(){return es}}),es.ensureExtent=function(t,e){var n=t.getMin(),i=t.getMax();return n!==i?t:(n===i&&(n-=e/2,i=n+e/2),new Qr(n,i))},e(ns.prototype,{isInside:function(t){},interfaces_:function(){return[]},getClass:function(){return ns}}),e(is.prototype,{testLineSegment:function(t,e){var n=null,i=null,r=null,s=null,o=null,a=e.p0,u=e.p1;i=a.x-t.x,r=a.y-t.y,s=u.x-t.x,o=u.y-t.y,(r>0&&0>=o||o>0&&0>=r)&&(n=ue.signOfDet2x2(i,r,s,o)/(o-r),n>0&&this.crossings++)},buildIndex:function(){this.tree=new es;for(var t=H.removeRepeatedPoints(this.ring.getCoordinates()),e=$e.getChains(t),n=0;n<e.size();n++){var i=e.get(n),r=i.getEnvelope();this.interval.min=r.getMinY(),this.interval.max=r.getMaxY(),this.tree.insert(this.interval,i)}},testMonotoneChain:function(t,e,n){n.select(t,e)},isInside:function(t){this.crossings=0;var e=new C(r.NEGATIVE_INFINITY,r.POSITIVE_INFINITY,t.y,t.y);this.interval.min=t.y,this.interval.max=t.y;for(var n=this.tree.query(this.interval),i=new rs(this,t),s=n.iterator();s.hasNext();){var o=s.next();this.testMonotoneChain(e,i,o)}return this.crossings%2===1},interfaces_:function(){return[ns]},getClass:function(){return is}}),h(rs,tr),e(rs.prototype,{select:function(){if(1!==arguments.length)return tr.prototype.select.apply(this,arguments);var t=arguments[0];this.mcp.testLineSegment(this.p,t)},interfaces_:function(){return[]},getClass:function(){return rs}}),is.MCSelecter=rs,e(ss.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},getNodeIterator:function(){return this.nodes.iterator()},copyNodesAndLabels:function(t,e){for(var n=t.getNodeIterator();n.hasNext();){var i=n.next(),r=this.nodes.addNode(i.getCoordinate());r.setLabel(e,i.getLabel().getLocation(e))}},build:function(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);var e=new br,n=e.computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(n)},computeIntersectionNodes:function(t,e){for(var n=t.getEdgeIterator();n.hasNext();)for(var i=n.next(),r=i.getLabel().getLocation(e),s=i.getEdgeIntersectionList().iterator();s.hasNext();){var o=s.next(),a=this.nodes.addNode(o.coord);r===L.BOUNDARY?a.setLabelBoundary(e):a.getLabel().isNull(e)&&a.setLabel(e,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return ss}}),e(os.prototype,{isNodeEdgeAreaLabelsConsistent:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();){var e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this.geomGraph))return this.invalidPoint=e.getCoordinate().copy(),!1}return!0},getInvalidPoint:function(){return this.invalidPoint},hasDuplicateRings:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();)for(var e=t.next(),n=e.getEdges().iterator();n.hasNext();){var i=n.next();if(i.getEdgeEnds().size()>1)return this.invalidPoint=i.getEdge().getCoordinate(0),!0}return!1},isNodeConsistentArea:function(){var t=this.geomGraph.computeSelfNodes(this.li,!0,!0);return t.hasProperIntersection()?(this.invalidPoint=t.getProperIntersectionPoint(),!1):(this.nodeGraph.build(this.geomGraph),this.isNodeEdgeAreaLabelsConsistent())},interfaces_:function(){return[]},getClass:function(){return os}}),e(as.prototype,{buildIndex:function(){this.index=new ke;for(var t=0;t<this.rings.size();t++){var e=this.rings.get(t),n=e.getEnvelopeInternal();this.index.insert(n,e)}},getNestedPoint:function(){return this.nestedPt},isNonNested:function(){this.buildIndex();for(var t=0;t<this.rings.size();t++)for(var e=this.rings.get(t),n=e.getCoordinates(),i=this.index.query(e.getEnvelopeInternal()),r=0;r<i.size();r++){var s=i.get(r),o=s.getCoordinates();if(e!==s&&e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())){var a=ls.findPtNotNode(n,s,this.graph);if(null!==a){var u=he.isPointInRing(a,o);if(u)return this.nestedPt=a,!1}}}return!0},add:function(t){this.rings.add(t),this.totalEnv.expandToInclude(t.getEnvelopeInternal())},interfaces_:function(){return[]},getClass:function(){return as}}),e(us.prototype,{getErrorType:function(){return this.errorType},getMessage:function(){return us.errMsg[this.errorType]},getCoordinate:function(){return this.pt},toString:function(){var t="";return null!==this.pt&&(t=" at or near point "+this.pt),this.getMessage()+t},interfaces_:function(){return[]},getClass:function(){return us}}),us.ERROR=0,us.REPEATED_POINT=1,us.HOLE_OUTSIDE_SHELL=2,us.NESTED_HOLES=3,us.DISCONNECTED_INTERIOR=4,us.SELF_INTERSECTION=5,us.RING_SELF_INTERSECTION=6,us.NESTED_SHELLS=7,us.DUPLICATE_RINGS=8,us.TOO_FEW_POINTS=9,us.INVALID_COORDINATE=10,us.RING_NOT_CLOSED=11,us.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"],e(ls.prototype,{checkInvalidCoordinates:function(){if(arguments[0]instanceof Array){for(var t=arguments[0],e=0;e<t.length;e++)if(!ls.isValid(t[e]))return this.validErr=new us(us.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof Tt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()),null!==this.validErr)return null;for(var e=0;e<n.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()),null!==this.validErr)return null}},checkHolesNotNested:function(t,e){for(var n=new as(e),i=0;i<t.getNumInteriorRing();i++){var r=t.getInteriorRingN(i);n.add(r)}var s=n.isNonNested();s||(this.validErr=new us(us.NESTED_HOLES,n.getNestedPoint()))},checkConsistentArea:function(t){var e=new os(t),n=e.isNodeConsistentArea();return n?void(e.hasDuplicateRings()&&(this.validErr=new us(us.DUPLICATE_RINGS,e.getInvalidPoint()))):(this.validErr=new us(us.SELF_INTERSECTION,e.getInvalidPoint()),null)},isValid:function(){return this.checkValid(this.parentGeometry),null===this.validErr},checkShellInsideHole:function(t,e,n){var i=t.getCoordinates(),r=e.getCoordinates(),s=ls.findPtNotNode(i,e,n);if(null!==s){var o=he.isPointInRing(s,r);if(!o)return s}var a=ls.findPtNotNode(r,t,n);if(null!==a){var u=he.isPointInRing(a,i);return u?a:null}return f.shouldNeverReachHere("points in shell and hole appear to be equal"),null},checkNoSelfIntersectingRings:function(t){for(var e=t.getEdgeIterator();e.hasNext();){var n=e.next();if(this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()),null!==this.validErr)return null}},checkConnectedInteriors:function(t){var e=new Kr(t);e.isInteriorsConnected()||(this.validErr=new us(us.DISCONNECTED_INTERIOR,e.getCoordinate()))},checkNoSelfIntersectingRing:function(t){for(var e=new at,n=!0,i=t.iterator();i.hasNext();){var r=i.next();if(n)n=!1;else{if(e.contains(r.coord))return this.validErr=new us(us.RING_SELF_INTERSECTION,r.coord),null;e.add(r.coord)}}},checkHolesInShell:function(t,e){for(var n=t.getExteriorRing(),i=new is(n),r=0;r<t.getNumInteriorRing();r++){var s=t.getInteriorRingN(r),o=ls.findPtNotNode(s.getCoordinates(),n,e);if(null===o)return null;var a=!i.isInside(o);if(a)return this.validErr=new us(us.HOLE_OUTSIDE_SHELL,o),null}},checkTooFewPoints:function(t){return t.hasTooFewPoints()?(this.validErr=new us(us.TOO_FEW_POINTS,t.getInvalidPoint()),null):void 0},getValidationError:function(){return this.checkValid(this.parentGeometry),this.validErr},checkValid:function(){if(arguments[0]instanceof Lt){var t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Pt){var e=arguments[0];this.checkInvalidCoordinates(e.getCoordinates())}else if(arguments[0]instanceof bt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getCoordinates()),null!==this.validErr)return null;if(this.checkClosedRing(n),null!==this.validErr)return null;var i=new $n(0,n);if(this.checkTooFewPoints(i),null!==this.validErr)return null;var r=new ae;i.computeSelfNodes(r,!0,!0),this.checkNoSelfIntersectingRings(i)}else if(arguments[0]instanceof St){var s=arguments[0];if(this.checkInvalidCoordinates(s.getCoordinates()),null!==this.validErr)return null;var i=new $n(0,s);this.checkTooFewPoints(i)}else if(arguments[0]instanceof Tt){var o=arguments[0];if(this.checkInvalidCoordinates(o),null!==this.validErr)return null;if(this.checkClosedRings(o),null!==this.validErr)return null;var i=new $n(0,o);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;if(this.checkHolesInShell(o,i),null!==this.validErr)return null;if(this.checkHolesNotNested(o,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof Ot){for(var a=arguments[0],u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkInvalidCoordinates(l),null!==this.validErr)return null;if(this.checkClosedRings(l),null!==this.validErr)return null}var i=new $n(0,a);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesInShell(l,i),null!==this.validErr)return null}for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesNotNested(l,i),null!==this.validErr)return null}if(this.checkShellsNotNested(a,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof ft)for(var h=arguments[0],u=0;u<h.getNumGeometries();u++){var c=h.getGeometryN(u);if(this.checkValid(c),null!==this.validErr)return null}else if(arguments[0]instanceof B){var f=arguments[0];if(this.validErr=null,f.isEmpty())return null;if(f instanceof Lt)this.checkValid(f);else if(f instanceof Pt)this.checkValid(f);else if(f instanceof bt)this.checkValid(f);else if(f instanceof St)this.checkValid(f);else if(f instanceof Tt)this.checkValid(f);else if(f instanceof Ot)this.checkValid(f);else{if(!(f instanceof ft))throw new UnsupportedOperationException(f.getClass().getName());this.checkValid(f)}}},setSelfTouchingRingFormingHoleValid:function(t){this.isSelfTouchingRingFormingHoleValid=t},checkShellNotNested:function(t,e,n){var i=t.getCoordinates(),r=e.getExteriorRing(),s=r.getCoordinates(),o=ls.findPtNotNode(i,r,n);if(null===o)return null;var a=he.isPointInRing(o,s);if(!a)return null;if(e.getNumInteriorRing()<=0)return this.validErr=new us(us.NESTED_SHELLS,o),null;for(var u=null,l=0;l<e.getNumInteriorRing();l++){var h=e.getInteriorRingN(l);if(u=this.checkShellInsideHole(t,h,n),null===u)return null}this.validErr=new us(us.NESTED_SHELLS,u)},checkClosedRings:function(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this.validErr)return null;for(var e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this.validErr)return null},checkClosedRing:function(t){if(!t.isClosed()){var e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this.validErr=new us(us.RING_NOT_CLOSED,e)}},checkShellsNotNested:function(t,e){for(var n=0;n<t.getNumGeometries();n++)for(var i=t.getGeometryN(n),r=i.getExteriorRing(),s=0;s<t.getNumGeometries();s++)if(n!==s){var o=t.getGeometryN(s);if(this.checkShellNotNested(r,o,e),null!==this.validErr)return null}},interfaces_:function(){return[]},getClass:function(){return ls}}),ls.findPtNotNode=function(t,e,n){for(var i=n.findEdge(e),r=i.getEdgeIntersectionList(),s=0;s<t.length;s++){var o=t[s];if(!r.isIntersection(o))return o}return null},ls.isValid=function(){if(arguments[0]instanceof B){var t=arguments[0],e=new ls(t);return e.isValid()}if(arguments[0]instanceof g){var n=arguments[0];return r.isNaN(n.x)?!1:r.isInfinite(n.x)?!1:r.isNaN(n.y)?!1:!r.isInfinite(n.y)}};var bo=Object.freeze({IsValidOp:ls}),Oo=Object.freeze({BoundaryOp:dt,IsSimpleOp:Gi,buffer:Co,distance:So,linemerge:wo,overlay:Lo,polygonize:Ro,relate:To,union:Po,valid:bo});h(hs,_t.CoordinateOperation),e(hs.prototype,{editCoordinates:function(t,e){if(0===t.length)return null;for(var n=new Array(t.length).fill(null),i=0;i<t.length;i++){var r=new g(t[i]);this.targetPM.makePrecise(r),n[i]=r}var s=new N(n,!1),o=s.toCoordinateArray(),a=0;e instanceof St&&(a=2),e instanceof bt&&(a=4);var u=n;return this.removeCollapsed&&(u=null),o.length<a?u:o},interfaces_:function(){return[]},getClass:function(){return hs}}),e(cs.prototype,{fixPolygonalTopology:function(t){var e=t;this.changePrecisionModel||(e=this.changePM(t,this.targetPM));var n=e.buffer(0),i=n;return this.changePrecisionModel||(i=t.getFactory().createGeometry(n)),i},reducePointwise:function(t){var e=null;if(this.changePrecisionModel){var n=this.createFactory(t.getFactory(),this.targetPM);e=new _t(n)}else e=new _t;var i=this.removeCollapsed;t.getDimension()>=2&&(i=!0);var r=e.edit(t,new hs(this.targetPM,i));return r},changePM:function(t,e){var n=this.createEditor(t.getFactory(),e);return n.edit(t,new _t.NoOpGeometryOperation)},setRemoveCollapsedComponents:function(t){this.removeCollapsed=t},createFactory:function(t,e){var n=new ie(e,t.getSRID(),t.getCoordinateSequenceFactory());return n},setChangePrecisionModel:function(t){this.changePrecisionModel=t},reduce:function(t){var e=this.reducePointwise(t);return this.isPointwise?e:R(e,Rt)?e.isValid()?e:this.fixPolygonalTopology(e):e},setPointwise:function(t){this.isPointwise=t},createEditor:function(t,e){if(t.getPrecisionModel()===e)return new _t;var n=this.createFactory(t,e),i=new _t(n);return i},interfaces_:function(){return[]},getClass:function(){return cs}}),cs.reduce=function(t,e){var n=new cs(e);return n.reduce(t)},cs.reducePointwise=function(t,e){var n=new cs(e);return n.setPointwise(!0),n.reduce(t)};var _o=Object.freeze({GeometryPrecisionReducer:cs});e(fs.prototype,{simplifySection:function(t,e){if(t+1===e)return null;this.seg.p0=this.pts[t],this.seg.p1=this.pts[e];for(var n=-1,i=t,r=t+1;e>r;r++){var s=this.seg.distance(this.pts[r]);s>n&&(n=s,i=r)}if(n<=this.distanceTolerance)for(var r=t+1;e>r;r++)this.usePt[r]=!1;else this.simplifySection(t,i),this.simplifySection(i,e)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(){this.usePt=new Array(this.pts.length).fill(null);for(var t=0;t<this.pts.length;t++)this.usePt[t]=!0;this.simplifySection(0,this.pts.length-1);for(var e=new N,t=0;t<this.pts.length;t++)this.usePt[t]&&e.add(new g(this.pts[t]));return e.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return fs}}),fs.simplify=function(t,e){var n=new fs(t);return n.setDistanceTolerance(e),n.simplify()},e(gs.prototype,{setEnsureValid:function(t){this.isEnsureValidTopology=t},getResultGeometry:function(){return this.inputGeom.isEmpty()?this.inputGeom.copy():new ds(this.isEnsureValidTopology,this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return gs}}),gs.simplify=function(t,e){var n=new gs(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(ds,xe),e(ds.prototype,{transformPolygon:function(t,e){if(t.isEmpty())return null;var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},createValidArea:function(t){return this.isEnsureValidTopology?t.buffer(0):t},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=null;return i=0===n.length?new Array(0).fill(null):fs.simplify(n,this.distanceTolerance),this.factory.getCoordinateSequenceFactory().create(i)},transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformLinearRing:function(t,e){var n=e instanceof Tt,i=xe.prototype.transformLinearRing.call(this,t,e);return!n||i instanceof bt?i:null},interfaces_:function(){return[]},getClass:function(){return ds}}),gs.DPTransformer=ds,h(ps,ce),e(ps.prototype,{getIndex:function(){return this.index},getParent:function(){return this.parent},interfaces_:function(){return[]},getClass:function(){return ps}}),e(vs.prototype,{addToResult:function(t){this.resultSegs.add(t)},asLineString:function(){return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs))},getResultSize:function(){var t=this.resultSegs.size();return 0===t?0:t+1},getParent:function(){return this.parentLine},getSegment:function(t){return this.segs[t]},getParentCoordinates:function(){return this.parentLine.getCoordinates()},getMinimumSize:function(){return this.minimumSize},asLinearRing:function(){return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs))},getSegments:function(){return this.segs},init:function(){var t=this.parentLine.getCoordinates();this.segs=new Array(t.length-1).fill(null);for(var e=0;e<t.length-1;e++){var n=new ps(t[e],t[e+1],this.parentLine,e);this.segs[e]=n}},getResultCoordinates:function(){return vs.extractCoordinates(this.resultSegs)},interfaces_:function(){return[]},getClass:function(){return vs}}),vs.extractCoordinates=function(t){for(var e=new Array(t.size()+1).fill(null),n=null,i=0;i<t.size();i++)n=t.get(i),e[i]=n.p0;return e[e.length-1]=n.p1,e},e(ms.prototype,{remove:function(t){this.index.remove(new C(t.p0,t.p1),t)},add:function(){if(arguments[0]instanceof vs)for(var t=arguments[0],e=t.getSegments(),n=0;n<e.length;n++){var i=e[n];this.add(i)}else if(arguments[0]instanceof ce){var r=arguments[0];this.index.insert(new C(r.p0,r.p1),r)}},query:function(t){var e=new C(t.p0,t.p1),n=new ys(t);this.index.query(e,n);var i=n.getItems();return i},interfaces_:function(){return[]},getClass:function(){return ms}}),e(ys.prototype,{visitItem:function(t){var e=t;C.intersects(e.p0,e.p1,this.querySeg.p0,this.querySeg.p1)&&this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return ys}}),e(xs.prototype,{flatten:function(t,e){var n=this.linePts[t],i=this.linePts[e],r=new ce(n,i);return this.remove(this.line,t,e),this.outputIndex.add(r),r},hasBadIntersection:function(t,e,n){return this.hasBadOutputIntersection(n)?!0:!!this.hasBadInputIntersection(t,e,n)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplifySection:function(t,e,n){n+=1;var i=new Array(2).fill(null);if(t+1===e){var r=this.line.getSegment(t);return this.line.addToResult(r),null}var s=!0;if(this.line.getResultSize()<this.line.getMinimumSize()){var o=n+1;o<this.line.getMinimumSize()&&(s=!1)}var a=new Array(1).fill(null),u=this.findFurthestPoint(this.linePts,t,e,a);a[0]>this.distanceTolerance&&(s=!1);var l=new ce;if(l.p0=this.linePts[t],l.p1=this.linePts[e],i[0]=t,i[1]=e,this.hasBadIntersection(this.line,i,l)&&(s=!1),s){var r=this.flatten(t,e);return this.line.addToResult(r),null}this.simplifySection(t,u,n),this.simplifySection(u,e,n)},hasBadOutputIntersection:function(t){for(var e=this.outputIndex.query(t),n=e.iterator();n.hasNext();){var i=n.next();if(this.hasInteriorIntersection(i,t))return!0}return!1},findFurthestPoint:function(t,e,n,i){var r=new ce;r.p0=t[e],r.p1=t[n];for(var s=-1,o=e,a=e+1;n>a;a++){var u=t[a],l=r.distance(u);l>s&&(s=l,o=a)}return i[0]=s,o},simplify:function(t){this.line=t,this.linePts=t.getParentCoordinates(),this.simplifySection(0,this.linePts.length-1,0)},remove:function(t,e,n){for(var i=e;n>i;i++){var r=t.getSegment(i);this.inputIndex.remove(r)}},hasInteriorIntersection:function(t,e){return this.li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this.li.isInteriorIntersection()},hasBadInputIntersection:function(t,e,n){for(var i=this.inputIndex.query(n),r=i.iterator();r.hasNext();){var s=r.next();if(this.hasInteriorIntersection(s,n)){if(xs.isInLineSection(t,e,s))continue;return!0}}return!1},interfaces_:function(){return[]},getClass:function(){return xs}}),xs.isInLineSection=function(t,e,n){if(n.getParent()!==t.getParent())return!1;var i=n.getIndex();return i>=e[0]&&i<e[1]},e(Es.prototype,{setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(t){for(var e=t.iterator();e.hasNext();)this.inputIndex.add(e.next());for(var e=t.iterator();e.hasNext();){var n=new xs(this.inputIndex,this.outputIndex);n.setDistanceTolerance(this.distanceTolerance),n.simplify(e.next())}},interfaces_:function(){return[]},getClass:function(){return Es}}),e(Is.prototype,{getResultGeometry:function(){if(this.inputGeom.isEmpty())return this.inputGeom.copy();this.linestringMap=new te,this.inputGeom.apply(new Cs(this)),this.lineSimplifier.simplify(this.linestringMap.values());var t=new Ns(this.linestringMap).transform(this.inputGeom);return t},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.lineSimplifier.setDistanceTolerance(t)},interfaces_:function(){return[]},getClass:function(){return Is}}),Is.simplify=function(t,e){var n=new Is(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(Ns,xe),e(Ns.prototype,{transformCoordinates:function(t,e){if(0===t.size())return null;if(e instanceof St){var n=this.linestringMap.get(e);return this.createCoordinateSequence(n.getResultCoordinates())}return xe.prototype.transformCoordinates.call(this,t,e)},interfaces_:function(){return[]},getClass:function(){return Ns}}),e(Cs.prototype,{filter:function(t){if(t instanceof St){var e=t;if(e.isEmpty())return null;var n=e.isClosed()?4:2,i=new vs(e,n);this.tps.linestringMap.put(e,i)}},interfaces_:function(){return[q]},getClass:function(){return Cs}}),Is.LineStringTransformer=Ns,Is.LineStringMapBuilderFilter=Cs;var Mo=Object.freeze({DouglasPeuckerSimplifier:gs,TopologyPreservingSimplifier:Is});e(Ss.prototype,{splitAt:function(){if(1===arguments.length){var t=arguments[0],e=this.minimumLen/this.segLen;if(t.distance(this.seg.p0)<this.minimumLen)return this.splitPt=this.seg.pointAlong(e),null;if(t.distance(this.seg.p1)<this.minimumLen)return this.splitPt=Ss.pointAlongReverse(this.seg,e),null;this.splitPt=t}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.getConstrainedLength(n),s=r/this.segLen;i.equals2D(this.seg.p0)?this.splitPt=this.seg.pointAlong(s):this.splitPt=Ss.pointAlongReverse(this.seg,s)}},setMinimumLength:function(t){this.minimumLen=t},getConstrainedLength:function(t){return t<this.minimumLen?this.minimumLen:t},getSplitPoint:function(){return this.splitPt},interfaces_:function(){return[]},getClass:function(){return Ss}}),Ss.pointAlongReverse=function(t,e){var n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n},e(ws.prototype,{findSplitPoint:function(t,e){},interfaces_:function(){return[]},getClass:function(){return ws}}),e(Ls.prototype,{findSplitPoint:function(t,e){var n=t.getLineSegment(),i=n.getLength(),r=i/2,s=new Ss(n),o=Ls.projectedSplitPoint(t,e),a=2*o.distance(e)*.8,u=a;return u>r&&(u=r),s.setMinimumLength(u),s.splitAt(o),s.getSplitPoint()},interfaces_:function(){return[ws]},getClass:function(){return Ls}}),Ls.projectedSplitPoint=function(t,e){var n=t.getLineSegment(),i=n.project(e);return i},e(Rs.prototype,{interfaces_:function(){return[]},getClass:function(){return Rs}}),Rs.triArea=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)},Rs.isInCircleDDNormalized=function(t,e,n,i){var r=_.valueOf(t.x).selfSubtract(i.x),s=_.valueOf(t.y).selfSubtract(i.y),o=_.valueOf(e.x).selfSubtract(i.x),a=_.valueOf(e.y).selfSubtract(i.y),u=_.valueOf(n.x).selfSubtract(i.x),l=_.valueOf(n.y).selfSubtract(i.y),h=r.multiply(a).selfSubtract(o.multiply(s)),c=o.multiply(l).selfSubtract(u.multiply(a)),f=u.multiply(s).selfSubtract(r.multiply(l)),g=r.multiply(r).selfAdd(s.multiply(s)),d=o.multiply(o).selfAdd(a.multiply(a)),p=u.multiply(u).selfAdd(l.multiply(l)),v=g.selfMultiply(c).selfAdd(d.selfMultiply(f)).selfAdd(p.selfMultiply(h)),m=v.doubleValue()>0;return m},Rs.checkRobustInCircle=function(t,e,n,i){var r=Rs.isInCircleNonRobust(t,e,n,i),s=Rs.isInCircleDDSlow(t,e,n,i),o=Rs.isInCircleCC(t,e,n,i),a=ci.circumcentre(t,e,n);A.out.println("p radius diff a = "+Math.abs(i.distance(a)-t.distance(a))/t.distance(a)),r===s&&r===o||(A.out.println("inCircle robustness failure (double result = "+r+", DD result = "+s+", CC result = "+o+")"),A.out.println(se.toLineString(new Gt([t,e,n,i]))),A.out.println("Circumcentre = "+se.toPoint(a)+" radius = "+t.distance(a)),A.out.println("p radius diff a = "+Math.abs(i.distance(a)/t.distance(a)-1)),A.out.println("p radius diff b = "+Math.abs(i.distance(a)/e.distance(a)-1)),A.out.println("p radius diff c = "+Math.abs(i.distance(a)/n.distance(a)-1)),A.out.println())},Rs.isInCircleDDFast=function(t,e,n,i){var r=_.sqr(t.x).selfAdd(_.sqr(t.y)).selfMultiply(Rs.triAreaDDFast(e,n,i)),s=_.sqr(e.x).selfAdd(_.sqr(e.y)).selfMultiply(Rs.triAreaDDFast(t,n,i)),o=_.sqr(n.x).selfAdd(_.sqr(n.y)).selfMultiply(Rs.triAreaDDFast(t,e,i)),a=_.sqr(i.x).selfAdd(_.sqr(i.y)).selfMultiply(Rs.triAreaDDFast(t,e,n)),u=r.selfSubtract(s).selfAdd(o).selfSubtract(a),l=u.doubleValue()>0;return l},Rs.isInCircleCC=function(t,e,n,i){var r=ci.circumcentre(t,e,n),s=t.distance(r),o=i.distance(r)-s;return 0>=o},Rs.isInCircleNormalized=function(t,e,n,i){var r=t.x-i.x,s=t.y-i.y,o=e.x-i.x,a=e.y-i.y,u=n.x-i.x,l=n.y-i.y,h=r*a-o*s,c=o*l-u*a,f=u*s-r*l,g=r*r+s*s,d=o*o+a*a,p=u*u+l*l,v=g*c+d*f+p*h;return v>0},Rs.isInCircleDDSlow=function(t,e,n,i){var r=_.valueOf(i.x),s=_.valueOf(i.y),o=_.valueOf(t.x),a=_.valueOf(t.y),u=_.valueOf(e.x),l=_.valueOf(e.y),h=_.valueOf(n.x),c=_.valueOf(n.y),f=o.multiply(o).add(a.multiply(a)).multiply(Rs.triAreaDDSlow(u,l,h,c,r,s)),g=u.multiply(u).add(l.multiply(l)).multiply(Rs.triAreaDDSlow(o,a,h,c,r,s)),d=h.multiply(h).add(c.multiply(c)).multiply(Rs.triAreaDDSlow(o,a,u,l,r,s)),p=r.multiply(r).add(s.multiply(s)).multiply(Rs.triAreaDDSlow(o,a,u,l,h,c)),v=f.subtract(g).add(d).subtract(p),m=v.doubleValue()>0;
return m},Rs.isInCircleNonRobust=function(t,e,n,i){var r=(t.x*t.x+t.y*t.y)*Rs.triArea(e,n,i)-(e.x*e.x+e.y*e.y)*Rs.triArea(t,n,i)+(n.x*n.x+n.y*n.y)*Rs.triArea(t,e,i)-(i.x*i.x+i.y*i.y)*Rs.triArea(t,e,n)>0;return r},Rs.isInCircleRobust=function(t,e,n,i){return Rs.isInCircleNormalized(t,e,n,i)},Rs.triAreaDDSlow=function(t,e,n,i,r,s){return n.subtract(t).multiply(s.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)))},Rs.triAreaDDFast=function(t,e,n){var i=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(n.y).selfSubtract(t.y)),r=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(n.x).selfSubtract(t.x));return i.selfSubtract(r)},e(Ts.prototype,{circleCenter:function(t,e){var n=new Ts(this.getX(),this.getY()),i=this.bisector(n,t),r=this.bisector(t,e),s=new F(i,r),o=null;try{o=new Ts(s.getX(),s.getY())}catch(i){if(!(i instanceof w))throw i;A.err.println("a: "+n+"  b: "+t+"  c: "+e),A.err.println(i)}finally{}return o},dot:function(t){return this.p.x*t.getX()+this.p.y*t.getY()},magn:function(){return Math.sqrt(this.p.x*this.p.x+this.p.y*this.p.y)},getZ:function(){return this.p.z},bisector:function(t,e){var n=e.getX()-t.getX(),i=e.getY()-t.getY(),r=new F(t.getX()+n/2,t.getY()+i/2,1),s=new F(t.getX()-i+n/2,t.getY()+n+i/2,1);return new F(r,s)},equals:function(){if(1===arguments.length){var t=arguments[0];return this.p.x===t.getX()&&this.p.y===t.getY()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.p.distance(e.getCoordinate())<n}},getCoordinate:function(){return this.p},isInCircle:function(t,e,n){return Rs.isInCircleRobust(t.p,e.p,n.p,this.p)},interpolateZValue:function(t,e,n){var i=t.getX(),r=t.getY(),s=e.getX()-i,o=n.getX()-i,a=e.getY()-r,u=n.getY()-r,l=s*u-o*a,h=this.getX()-i,c=this.getY()-r,f=(u*h-o*c)/l,g=(-a*h+s*c)/l,d=t.getZ()+f*(e.getZ()-t.getZ())+g*(n.getZ()-t.getZ());return d},midPoint:function(t){var e=(this.p.x+t.getX())/2,n=(this.p.y+t.getY())/2,i=(this.p.z+t.getZ())/2;return new Ts(e,n,i)},rightOf:function(t){return this.isCCW(t.dest(),t.orig())},isCCW:function(t,e){return(t.p.x-this.p.x)*(e.p.y-this.p.y)-(t.p.y-this.p.y)*(e.p.x-this.p.x)>0},getX:function(){return this.p.x},crossProduct:function(t){return this.p.x*t.getY()-this.p.y*t.getX()},setZ:function(t){this.p.z=t},times:function(t){return new Ts(t*this.p.x,t*this.p.y)},cross:function(){return new Ts(this.p.y,-this.p.x)},leftOf:function(t){return this.isCCW(t.orig(),t.dest())},toString:function(){return"POINT ("+this.p.x+" "+this.p.y+")"},sub:function(t){return new Ts(this.p.x-t.getX(),this.p.y-t.getY())},getY:function(){return this.p.y},classify:function(t,e){var n=this,i=e.sub(t),r=n.sub(t),s=i.crossProduct(r);return s>0?Ts.LEFT:0>s?Ts.RIGHT:i.getX()*r.getX()<0||i.getY()*r.getY()<0?Ts.BEHIND:i.magn()<r.magn()?Ts.BEYOND:t.equals(n)?Ts.ORIGIN:e.equals(n)?Ts.DESTINATION:Ts.BETWEEN},sum:function(t){return new Ts(this.p.x+t.getX(),this.p.y+t.getY())},distance:function(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))},circumRadiusRatio:function(t,e){var n=this.circleCenter(t,e),i=this.distance(n,t),r=this.distance(this,t),s=this.distance(t,e);return r>s&&(r=s),s=this.distance(e,this),r>s&&(r=s),i/r},interfaces_:function(){return[]},getClass:function(){return Ts}}),Ts.interpolateZ=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=e.distance(n),r=t.distance(e),s=n.z-e.z,o=e.z+s*(r/i);return o}if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3],c=u.x,f=u.y,g=l.x-c,d=h.x-c,p=l.y-f,v=h.y-f,m=g*v-d*p,y=a.x-c,x=a.y-f,E=(v*y-d*x)/m,I=(-p*y+g*x)/m,N=u.z+E*(l.z-u.z)+I*(h.z-u.z);return N}},Ts.LEFT=0,Ts.RIGHT=1,Ts.BEYOND=2,Ts.BEHIND=3,Ts.BETWEEN=4,Ts.ORIGIN=5,Ts.DESTINATION=6,h(Ps,Ts),e(Ps.prototype,{getConstraint:function(){return this.constraint},setOnConstraint:function(t){this._isOnConstraint=t},merge:function(t){t._isOnConstraint&&(this._isOnConstraint=!0,this.constraint=t.constraint)},isOnConstraint:function(){return this._isOnConstraint},setConstraint:function(t){this._isOnConstraint=!0,this.constraint=t},interfaces_:function(){return[]},getClass:function(){return Ps}}),e(bs.prototype,{equalsNonOriented:function(t){return this.equalsOriented(t)?!0:!!this.equalsOriented(t.sym())},toLineSegment:function(){return new ce(this.vertex.getCoordinate(),this.dest().getCoordinate())},dest:function(){return this.sym().orig()},oNext:function(){return this.next},equalsOriented:function(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))},dNext:function(){return this.sym().oNext().sym()},lPrev:function(){return this.next.sym()},rPrev:function(){return this.sym().oNext()},rot:function(){return this._rot},oPrev:function(){return this._rot.next._rot},sym:function(){return this._rot._rot},setOrig:function(t){this.vertex=t},lNext:function(){return this.invRot().oNext().rot()},getLength:function(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())},invRot:function(){return this._rot.sym()},setDest:function(t){this.sym().setOrig(t)},setData:function(t){this.data=t},getData:function(){return this.data},delete:function(){this._rot=null},orig:function(){return this.vertex},rNext:function(){return this._rot.next.invRot()},toString:function(){var t=this.vertex.getCoordinate(),e=this.dest().getCoordinate();return se.toLineString(t,e)},isLive:function(){return null!==this._rot},getPrimary:function(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()},dPrev:function(){return this.invRot().oNext().invRot()},setNext:function(t){this.next=t},interfaces_:function(){return[]},getClass:function(){return bs}}),bs.makeEdge=function(t,e){var n=new bs,i=new bs,r=new bs,s=new bs;n._rot=i,i._rot=r,r._rot=s,s._rot=n,n.setNext(n),i.setNext(s),r.setNext(r),s.setNext(i);var o=n;return o.setOrig(t),o.setDest(e),o},bs.swap=function(t){var e=t.oPrev(),n=t.sym().oPrev();bs.splice(t,e),bs.splice(t.sym(),n),bs.splice(t,e.lNext()),bs.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())},bs.splice=function(t,e){var n=t.oNext().rot(),i=e.oNext().rot(),r=e.oNext(),s=t.oNext(),o=i.oNext(),a=n.oNext();t.setNext(r),e.setNext(s),n.setNext(o),i.setNext(a)},bs.connect=function(t,e){var n=bs.makeEdge(t.dest(),e.orig());return bs.splice(n,t.lNext()),bs.splice(n.sym(),e),n},e(Os.prototype,{insertSite:function(t){var e=this.subdiv.locate(t);if(this.subdiv.isVertexOfEdge(e,t))return e;this.subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this.subdiv.delete(e.oNext()));var n=this.subdiv.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.subdiv.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);for(;;){var r=e.oPrev();if(r.dest().rightOf(e)&&t.isInCircle(e.orig(),r.dest(),e.dest()))bs.swap(e),e=e.oPrev();else{if(e.oNext()===i)return n;e=e.oNext().lPrev()}}},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},interfaces_:function(){return[]},getClass:function(){return Os}}),e(_s.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return _s}}),e(Ms.prototype,{init:function(){this.lastEdge=this.findEdge()},locate:function(t){this.lastEdge.isLive()||this.init();var e=this.subdiv.locateFromEdge(t,this.lastEdge);return this.lastEdge=e,e},findEdge:function(){var t=this.subdiv.getEdges();return t.iterator().next()},interfaces_:function(){return[_s]},getClass:function(){return Ms}}),h(Ds,l),e(Ds.prototype,{getSegment:function(){return this.seg},interfaces_:function(){return[]},getClass:function(){return Ds}}),Ds.msgWithSpatial=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(As.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return As}}),e(Fs.prototype,{getTriangleVertices:function(t){var e=new Bs;return this.visitTriangles(e,t),e.getTriangleVertices()},isFrameVertex:function(t){return t.equals(this.frameVertex[0])?!0:t.equals(this.frameVertex[1])?!0:!!t.equals(this.frameVertex[2])},isVertexOfEdge:function(t,e){return!(!e.equals(t.orig(),this.tolerance)&&!e.equals(t.dest(),this.tolerance))},connect:function(t,e){var n=bs.connect(t,e);return this.quadEdges.add(n),n},getVoronoiCellPolygon:function(t,e){var n=new I,i=t;do{var r=t.rot().orig().getCoordinate();n.add(r),t=t.oPrev()}while(t!==i);var s=new N;s.addAll(n,!1),s.closeRing(),s.size()<4&&(A.out.println(s),s.add(s.get(s.size()-1),!0));var o=s.toCoordinateArray(),a=e.createPolygon(e.createLinearRing(o),null),u=i.orig();return a.setUserData(u.getCoordinate()),a},setLocator:function(t){this.locator=t},initSubdiv:function(){var t=this.makeEdge(this.frameVertex[0],this.frameVertex[1]),e=this.makeEdge(this.frameVertex[1],this.frameVertex[2]);bs.splice(t.sym(),e);var n=this.makeEdge(this.frameVertex[2],this.frameVertex[0]);return bs.splice(e.sym(),n),bs.splice(n.sym(),t),t},isFrameBorderEdge:function(t){var e=new Array(3).fill(null);Fs.getTriangleEdges(t,e);var n=new Array(3).fill(null);Fs.getTriangleEdges(t.sym(),n);var i=t.lNext().dest();if(this.isFrameVertex(i))return!0;var r=t.sym().lNext().dest();return!!this.isFrameVertex(r)},makeEdge:function(t,e){var n=bs.makeEdge(t,e);return this.quadEdges.add(n),n},visitTriangles:function(t,e){this.visitedKey++;var n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=this.fetchTriangleToVisit(r,n,e,i);null!==s&&t.visit(s)}}},isFrameEdge:function(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))},isOnEdge:function(t,e){this.seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());var n=this.seg.distance(e);return n<this.edgeCoincidenceTolerance},getEnvelope:function(){return new C(this.frameEnv)},createFrame:function(t){var e=t.getWidth(),n=t.getHeight(),i=0;i=e>n?10*e:10*n,this.frameVertex[0]=new Ts((t.getMaxX()+t.getMinX())/2,t.getMaxY()+i),this.frameVertex[1]=new Ts(t.getMinX()-i,t.getMinY()-i),this.frameVertex[2]=new Ts(t.getMaxX()+i,t.getMinY()-i),this.frameEnv=new C(this.frameVertex[0].getCoordinate(),this.frameVertex[1].getCoordinate()),this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())},getTriangleCoordinates:function(t){var e=new zs;return this.visitTriangles(e,t),e.getTriangles()},getVertices:function(t){for(var e=new J,n=this.quadEdges.iterator();n.hasNext();){var i=n.next(),r=i.orig();!t&&this.isFrameVertex(r)||e.add(r);var s=i.dest();!t&&this.isFrameVertex(s)||e.add(s)}return e},fetchTriangleToVisit:function(t,e,n,i){var r=t,s=0,o=!1;do{this.triEdges[s]=r,this.isFrameEdge(r)&&(o=!0);var a=r.sym();i.contains(a)||e.push(a),i.add(r),s++,r=r.lNext()}while(r!==t);return o&&!n?null:this.triEdges},getEdges:function(){if(0===arguments.length)return this.quadEdges;if(1===arguments.length){for(var t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createLineString([s.orig().getCoordinate(),s.dest().getCoordinate()])}return t.createMultiLineString(n)}},getVertexUniqueEdges:function(t){for(var e=new I,n=new J,i=this.quadEdges.iterator();i.hasNext();){var r=i.next(),s=r.orig();n.contains(s)||(n.add(s),!t&&this.isFrameVertex(s)||e.add(r));var o=r.sym(),a=o.orig();n.contains(a)||(n.add(a),!t&&this.isFrameVertex(a)||e.add(o))}return e},getTriangleEdges:function(t){var e=new qs;return this.visitTriangles(e,t),e.getTriangleEdges()},getPrimaryEdges:function(t){this.visitedKey++;var e=new I,n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=r.getPrimary();!t&&this.isFrameEdge(s)||e.add(s),n.push(r.oNext()),n.push(r.sym().oNext()),i.add(r),i.add(r.sym())}}return e},delete:function(t){bs.splice(t,t.oPrev()),bs.splice(t.sym(),t.sym().oPrev());var e=t.sym(),n=t.rot(),i=t.rot().sym();this.quadEdges.remove(t),this.quadEdges.remove(e),this.quadEdges.remove(n),this.quadEdges.remove(i),t.delete(),e.delete(),n.delete(),i.delete()},locateFromEdge:function(t,e){for(var n=0,i=this.quadEdges.size(),r=e;;){if(n++,n>i)throw new Ds(r.toLineSegment());if(t.equals(r.orig())||t.equals(r.dest()))break;if(t.rightOf(r))r=r.sym();else if(t.rightOf(r.oNext())){if(t.rightOf(r.dPrev()))break;r=r.dPrev()}else r=r.oNext()}return r},getTolerance:function(){return this.tolerance},getVoronoiCellPolygons:function(t){this.visitTriangles(new Gs,!0);for(var e=new I,n=this.getVertexUniqueEdges(!1),i=n.iterator();i.hasNext();){var r=i.next();e.add(this.getVoronoiCellPolygon(r,t))}return e},getVoronoiDiagram:function(t){var e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(ie.toGeometryArray(e))},getTriangles:function(t){for(var e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createPolygon(t.createLinearRing(s),null)}return t.createGeometryCollection(n)},insertSite:function(t){var e=this.locate(t);if(t.equals(e.orig(),this.tolerance)||t.equals(e.dest(),this.tolerance))return e;var n=this.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);return i},locate:function(){if(1===arguments.length){if(arguments[0]instanceof Ts){var t=arguments[0];return this.locator.locate(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.locator.locate(new Ts(e))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.locator.locate(new Ts(n));if(null===r)return null;var s=r;r.dest().getCoordinate().equals2D(n)&&(s=r.sym());var o=s;do{if(o.dest().getCoordinate().equals2D(i))return o;o=o.oNext()}while(o!==s);return null}},interfaces_:function(){return[]},getClass:function(){return Fs}}),Fs.getTriangleEdges=function(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new i("Edges do not form a triangle")},e(Gs.prototype,{visit:function(t){for(var e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),i=t[2].orig().getCoordinate(),r=ci.circumcentre(e,n,i),s=new Ts(r),o=0;3>o;o++)t[o].rot().setOrig(s)},interfaces_:function(){return[As]},getClass:function(){return Gs}}),e(qs.prototype,{getTriangleEdges:function(){return this.triList},visit:function(t){this.triList.add(t.clone())},interfaces_:function(){return[As]},getClass:function(){return qs}}),e(Bs.prototype,{visit:function(t){this.triList.add([t[0].orig(),t[1].orig(),t[2].orig()])},getTriangleVertices:function(){return this.triList},interfaces_:function(){return[As]},getClass:function(){return Bs}}),e(zs.prototype,{checkTriangleSize:function(t){var e="";t.length>=2?e=se.toLineString(t[0],t[1]):t.length>=1&&(e=se.toPoint(t[0]))},visit:function(t){this.coordList.clear();for(var e=0;3>e;e++){var n=t[e].orig();this.coordList.add(n.getCoordinate())}if(this.coordList.size()>0){this.coordList.closeRing();var i=this.coordList.toCoordinateArray();if(4!==i.length)return null;this.triCoords.add(i)}},getTriangles:function(){return this.triCoords},interfaces_:function(){return[As]},getClass:function(){return zs}}),Fs.TriangleCircumcentreVisitor=Gs,Fs.TriangleEdgesListVisitor=qs,Fs.TriangleVertexListVisitor=Bs,Fs.TriangleCoordinatesVisitor=zs,Fs.EDGE_COINCIDENCE_TOL_FACTOR=1e3,e(Vs.prototype,{getLineSegment:function(){return this.ls},getEndZ:function(){var t=this.ls.getCoordinate(1);return t.z},getStartZ:function(){var t=this.ls.getCoordinate(0);return t.z},intersection:function(t){return this.ls.intersection(t.getLineSegment())},getStart:function(){return this.ls.getCoordinate(0)},getEnd:function(){return this.ls.getCoordinate(1)},getEndY:function(){var t=this.ls.getCoordinate(1);return t.y},getStartX:function(){var t=this.ls.getCoordinate(0);return t.x},equalsTopo:function(t){return this.ls.equalsTopo(t.getLineSegment())},getStartY:function(){var t=this.ls.getCoordinate(0);return t.y},setData:function(t){this.data=t},getData:function(){return this.data},getEndX:function(){var t=this.ls.getCoordinate(1);return t.x},toString:function(){return this.ls.toString()},interfaces_:function(){return[]},getClass:function(){return Vs}}),e(ks.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return ks}}),e(Ys.prototype,{isRepeated:function(){return this.count>1},getRight:function(){return this.right},getCoordinate:function(){return this.p},setLeft:function(t){this.left=t},getX:function(){return this.p.x},getData:function(){return this.data},getCount:function(){return this.count},getLeft:function(){return this.left},getY:function(){return this.p.y},increment:function(){this.count=this.count+1},setRight:function(t){this.right=t},interfaces_:function(){return[]},getClass:function(){return Ys}}),e(Us.prototype,{insert:function(){if(1===arguments.length){var t=arguments[0];return this.insert(t,null)}if(2===arguments.length){var e=arguments[0],n=arguments[1];if(null===this.root)return this.root=new Ys(e,n),this.root;if(this.tolerance>0){var i=this.findBestMatchNode(e);if(null!==i)return i.increment(),i}return this.insertExact(e,n)}},query:function(){var t=arguments,e=this;if(1===arguments.length){var n=arguments[0],i=new I;return this.query(n,i),i}if(2===arguments.length)if(arguments[0]instanceof C&&R(arguments[1],y))!function(){var n=t[0],i=t[1];e.queryNode(e.root,n,!0,{interfaces_:function(){return[ks]},visit:function(t){i.add(t)}})}();else if(arguments[0]instanceof C&&R(arguments[1],ks)){var r=arguments[0],s=arguments[1];this.queryNode(this.root,r,!0,s)}},queryNode:function(t,e,n,i){if(null===t)return null;var r=null,s=null,o=null;n?(r=e.getMinX(),s=e.getMaxX(),o=t.getX()):(r=e.getMinY(),s=e.getMaxY(),o=t.getY());var a=o>r,u=s>=o;a&&this.queryNode(t.getLeft(),e,!n,i),e.contains(t.getCoordinate())&&i.visit(t),u&&this.queryNode(t.getRight(),e,!n,i)},findBestMatchNode:function(t){var e=new Xs(t,this.tolerance);return this.query(e.queryEnvelope(),e),e.getNode()},isEmpty:function(){return null===this.root},insertExact:function(t,e){for(var n=this.root,i=this.root,r=!0,s=!0;null!==n;){if(null!==n){var o=t.distance(n.getCoordinate())<=this.tolerance;if(o)return n.increment(),n}s=r?t.x<n.getX():t.y<n.getY(),i=n,n=s?n.getLeft():n.getRight(),r=!r}this.numberOfNodes=this.numberOfNodes+1;var a=new Ys(t,e);return s?i.setLeft(a):i.setRight(a),a},interfaces_:function(){return[]},getClass:function(){return Us}}),Us.toCoordinates=function(){if(1===arguments.length){var t=arguments[0];return Us.toCoordinates(t,!1)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new N,r=e.iterator();r.hasNext();)for(var s=r.next(),o=n?s.getCount():1,a=0;o>a;a++)i.add(s.getCoordinate(),!0);return i.toCoordinateArray()}},e(Xs.prototype,{visit:function(t){var e=this.p.distance(t.getCoordinate()),n=e<=this.tolerance;if(!n)return null;var i=!1;(null===this.matchNode||e<this.matchDist||null!==this.matchNode&&e===this.matchDist&&t.getCoordinate().compareTo(this.matchNode.getCoordinate())<1)&&(i=!0),i&&(this.matchNode=t,this.matchDist=e)},queryEnvelope:function(){var t=new C(this.p);return t.expandBy(this.tolerance),t},getNode:function(){return this.matchNode},interfaces_:function(){return[ks]},getClass:function(){return Xs}}),Us.BestMatchVisitor=Xs,e(Hs.prototype,{getInitialVertices:function(){return this.initialVertices},getKDT:function(){return this.kdt},enforceConstraints:function(){this.addConstraintVertices();var t=0,e=0;do e=this.enforceGabriel(this.segments),t++;while(e>0&&t<Hs.MAX_SPLIT_ITER)},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},getVertexFactory:function(){return this.vertexFactory},getPointArray:function(){for(var t=new Array(this.initialVertices.size()+this.segVertices.size()).fill(null),e=0,n=this.initialVertices.iterator();n.hasNext();){var i=n.next();t[e++]=i.getCoordinate()}for(var r=this.segVertices.iterator();r.hasNext();){var i=r.next();t[e++]=i.getCoordinate()}return t},setConstraints:function(t,e){this.segments=t,this.segVertices=e},computeConvexHull:function(){var t=new ie,e=this.getPointArray(),n=new me(e,t);this.convexHull=n.getConvexHull()},addConstraintVertices:function(){this.computeConvexHull(),this.insertSites(this.segVertices)},findNonGabrielPoint:function(t){var e=t.getStart(),n=t.getEnd(),i=new g((e.x+n.x)/2,(e.y+n.y)/2),s=e.distance(i),o=new C(i);o.expandBy(s);for(var a=this.kdt.query(o),u=null,l=r.MAX_VALUE,h=a.iterator();h.hasNext();){var c=h.next(),f=c.getCoordinate();if(!f.equals2D(e)&&!f.equals2D(n)){var d=i.distance(f);if(s>d){var p=d;(null===u||l>p)&&(u=f,l=p)}}}return u},getConstraintSegments:function(){return this.segments},setSplitPointFinder:function(t){this.splitFinder=t},getConvexHull:function(){return this.convexHull},getTolerance:function(){return this.tolerance},enforceGabriel:function(t){for(var e=new I,n=0,i=new I,r=t.iterator();r.hasNext();){var s=r.next(),o=this.findNonGabrielPoint(s);if(null!==o){this.splitPt=this.splitFinder.findSplitPoint(s,o);var a=this.createVertex(this.splitPt,s),u=(this.insertSite(a),new Vs(s.getStartX(),s.getStartY(),s.getStartZ(),a.getX(),a.getY(),a.getZ(),s.getData())),l=new Vs(a.getX(),a.getY(),a.getZ(),s.getEndX(),s.getEndY(),s.getEndZ(),s.getData());e.add(u),e.add(l),i.add(s),n+=1}}return t.removeAll(i),t.addAll(e),n},createVertex:function(){if(1===arguments.length){var t=arguments[0],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(t,null):new Ps(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(n,i):new Ps(n),e.setOnConstraint(!0),e}},getSubdivision:function(){return this.subdiv},computeBoundingBox:function(){var t=Hs.computeVertexEnvelope(this.initialVertices),e=Hs.computeVertexEnvelope(this.segVertices),n=new C(t);n.expandToInclude(e);var i=.2*n.getWidth(),r=.2*n.getHeight(),s=Math.max(i,r);this.computeAreaEnv=new C(n),this.computeAreaEnv.expandBy(s)},setVertexFactory:function(t){this.vertexFactory=t},formInitialDelaunay:function(){this.computeBoundingBox(),this.subdiv=new Fs(this.computeAreaEnv,this.tolerance),this.subdiv.setLocator(new Ms(this.subdiv)),this.incDel=new Os(this.subdiv),this.insertSites(this.initialVertices)},insertSite:function(){if(arguments[0]instanceof Ps){var t=arguments[0],e=this.kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){var n=e.getData();return n.merge(t),n}return this.incDel.insertSite(t),t}if(arguments[0]instanceof g){var i=arguments[0];this.insertSite(this.createVertex(i))}},interfaces_:function(){return[]},getClass:function(){return Hs}}),Hs.computeVertexEnvelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i.getCoordinate())}return e},Hs.MAX_SPLIT_ITER=99,e(Ws.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var n=new Os(this.subdiv);n.insertSites(e)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},interfaces_:function(){return[]},getClass:function(){return Ws}}),Ws.extractUniqueCoordinates=function(t){if(null===t)return new N;var e=t.getCoordinates();return Ws.unique(e)},Ws.envelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i)}return e},Ws.unique=function(t){var e=H.copyDeep(t);ut.sort(e);var n=new N(e,!1);return n},Ws.toVertices=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ts(i))}return e},e(js.prototype,{createSiteVertices:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();this.constraintVertexMap.containsKey(i)||e.add(new Ps(i))}return e},create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=new I;null!==this.constraintLines&&(t.expandToInclude(this.constraintLines.getEnvelopeInternal()),this.createVertices(this.constraintLines),e=js.createConstraintSegments(this.constraintLines));var n=this.createSiteVertices(this.siteCoords),i=new Hs(n,this.tolerance);i.setConstraints(e,new I(this.constraintVertexMap.values())),i.formInitialDelaunay(),i.enforceConstraints(),this.subdiv=i.getSubdivision()},setTolerance:function(t){this.tolerance=t},setConstraints:function(t){this.constraintLines=t},setSites:function(t){this.siteCoords=Ws.extractUniqueCoordinates(t)},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},createVertices:function(t){for(var e=t.getCoordinates(),n=0;n<e.length;n++){var i=new Ps(e[n]);this.constraintVertexMap.put(e[n],i)}},interfaces_:function(){return[]},getClass:function(){return js}}),js.createConstraintSegments=function(){if(1===arguments.length){for(var t=arguments[0],e=kn.getLines(t),n=new I,i=e.iterator();i.hasNext();){var r=i.next();js.createConstraintSegments(r,n)}return n}if(2===arguments.length)for(var s=arguments[0],o=arguments[1],a=s.getCoordinates(),i=1;i<a.length;i++)o.add(new Vs(a[i-1],a[i]))},e(Ks.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords);this.diagramEnv=t;var e=Math.max(this.diagramEnv.getWidth(),this.diagramEnv.getHeight());this.diagramEnv.expandBy(e),null!==this.clipEnv&&this.diagramEnv.expandToInclude(this.clipEnv);var n=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var i=new Os(this.subdiv);i.insertSites(n)},getDiagram:function(t){this.create();var e=this.subdiv.getVoronoiDiagram(t);return Ks.clipGeometryCollection(e,this.diagramEnv)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},setClipEnvelope:function(t){this.clipEnv=t},getSubdivision:function(){return this.create(),this.subdiv},interfaces_:function(){return[]},getClass:function(){return Ks}}),Ks.clipGeometryCollection=function(t,e){for(var n=t.getFactory().toGeometry(e),i=new I,r=0;r<t.getNumGeometries();r++){var s=t.getGeometryN(r),o=null;e.contains(s.getEnvelopeInternal())?o=s:e.intersects(s.getEnvelopeInternal())&&(o=n.intersection(s),o.setUserData(s.getUserData())),null===o||o.isEmpty()||i.add(o)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(i))};var Do=Object.freeze({ConformingDelaunayTriangulationBuilder:js,DelaunayTriangulationBuilder:Ws,VoronoiDiagramBuilder:Ks});e(Zs.prototype,{interfaces_:function(){return[]},getClass:function(){return Zs}}),Zs.union=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.UNION)},e(B.prototype,{equalsTopo:function(t){return this.getEnvelopeInternal().equals(t.getEnvelopeInternal())?Yr.relate(this,t).isEquals(this.getDimension(),t.getDimension()):!1},union:function(){if(0===arguments.length)return jr.union(this);if(1===arguments.length){var t=arguments[0];return Zs.union(this,t)}},isValid:function(){return ls.isValid(this)},intersection:function(t){if(this.isEmpty()||t.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,this,t,this.factory);if(this.isGeometryCollection()){var e=t;return hn.map(this,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(e)}})}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.INTERSECTION)},covers:function(t){return Yr.covers(this,t)},coveredBy:function(t){return Yr.coveredBy(this,t)},touches:function(t){return Yr.touches(this,t)},intersects:function(t){return Yr.intersects(this,t)},within:function(t){return Yr.within(this,t)},overlaps:function(t){return Yr.overlaps(this,t)},disjoint:function(t){return Yr.disjoint(this,t)},crosses:function(t){return Yr.crosses(this,t)},buffer:function(){if(1===arguments.length){var t=arguments[0];return sr.bufferOp(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return sr.bufferOp(this,e,n)}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];return sr.bufferOp(this,i,r,s)}},convexHull:function(){return new me(this).getConvexHull()},relate:function(){for(var t=arguments.length,e=Array(t),n=0;t>n;n++)e[n]=arguments[n];return Yr.relate.apply(Yr,[this].concat(e))},getCentroid:function(){if(this.isEmpty())return this.factory.createPoint();var t=ge.getCentroid(this);return this.createPointFromInternalCoord(t,this)},getInteriorPoint:function(){if(this.isEmpty())return this.factory.createPoint();var t=null,e=this.getDimension();if(0===e){var n=new li(this);t=n.getInteriorPoint()}else if(1===e){var n=new ui(this);t=n.getInteriorPoint()}else{var n=new oi(this);t=n.getInteriorPoint()}return this.createPointFromInternalCoord(t,this)},symDifference:function(t){if(this.isEmpty()||t.isEmpty()){if(this.isEmpty()&&t.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,this,t,this.factory);if(this.isEmpty())return t.copy();if(t.isEmpty())return this.copy()}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.SYMDIFFERENCE)},createPointFromInternalCoord:function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},toText:function(){var t=new se;return t.write(this)},toString:function(){this.toText()},contains:function(t){return Yr.contains(this,t)},difference:function(t){return this.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,this,t,this.factory):t.isEmpty()?this.copy():(this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.DIFFERENCE))},isSimple:function(){var t=new Gi(this);return t.isSimple()},isWithinDistance:function(t,e){var n=this.getEnvelopeInternal().distance(t.getEnvelopeInternal());return n>e?!1:hr.isWithinDistance(this,t,e)},distance:function(t){return hr.distance(this,t)},isEquivalentClass:function(t){return this.getClass()===t.getClass()}});var Ao="1.1.2 (248dab8)";t.version=Ao,t.algorithm=co,t.densify=fo,t.dissolve=go,t.geom=lo,t.index=mo,t.io=Io,t.noding=No,t.operation=Oo,t.precision=_o,t.simplify=Mo,t.triangulate=Do});

},{}],12:[function(require,module,exports){
'use strict';
(function (factory, window) {
    /*globals define, module, require*/

    // define an AMD module that relies on 'leaflet'
    if (typeof define === 'function' && define.amd) {
        define(['leaflet'], factory);


    // define a Common JS module that relies on 'leaflet'
    } else if (typeof exports === 'object') {
        module.exports = factory(require('leaflet'));
    }

    // attach your plugin to the global 'L' variable
    if(typeof window !== 'undefined' && window.L){
        factory(window.L);
    }

}(function (L) {
    L.Editable = L.Evented.extend({

        statics: {
            FORWARD: 1,
            BACKWARD: -1
        },

        options: {
            zIndex: 1000,
            polygonClass: L.Polygon,
            polylineClass: L.Polyline,
            markerClass: L.Marker,
            rectangleClass: L.Rectangle,
            circleClass: L.Circle,
            drawingCSSClass: 'leaflet-editable-drawing',
            drawingCursor: 'crosshair'
        },

        initialize: function (map, options) {
            L.setOptions(this, options);
            this._lastZIndex = this.options.zIndex;
            this.map = map;
            this.editLayer = this.createEditLayer();
            this.featuresLayer = this.createFeaturesLayer();
            this.forwardLineGuide = this.createLineGuide();
            this.backwardLineGuide = this.createLineGuide();
        },

        fireAndForward: function (type, e) {
            e = e || {};
            e.editTools = this;
            this.fire(type, e);
            this.map.fire(type, e);
        },

        createLineGuide: function () {
            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);
            return L.polyline([], options);
        },

        createVertexIcon: function (options) {
            return L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);
        },

        createEditLayer: function () {
            return this.options.editLayer || new L.LayerGroup().addTo(this.map);
        },

        createFeaturesLayer: function () {
            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);
        },

        moveForwardLineGuide: function (latlng) {
            if (this.forwardLineGuide._latlngs.length) {
                this.forwardLineGuide._latlngs[1] = latlng;
                this.forwardLineGuide._bounds.extend(latlng);
                this.forwardLineGuide.redraw();
            }
        },

        moveBackwardLineGuide: function (latlng) {
            if (this.backwardLineGuide._latlngs.length) {
                this.backwardLineGuide._latlngs[1] = latlng;
                this.backwardLineGuide._bounds.extend(latlng);
                this.backwardLineGuide.redraw();
            }
        },

        anchorForwardLineGuide: function (latlng) {
            this.forwardLineGuide._latlngs[0] = latlng;
            this.forwardLineGuide._bounds.extend(latlng);
            this.forwardLineGuide.redraw();
        },

        anchorBackwardLineGuide: function (latlng) {
            this.backwardLineGuide._latlngs[0] = latlng;
            this.backwardLineGuide._bounds.extend(latlng);
            this.backwardLineGuide.redraw();
        },

        attachForwardLineGuide: function () {
            this.editLayer.addLayer(this.forwardLineGuide);
        },

        attachBackwardLineGuide: function () {
            this.editLayer.addLayer(this.backwardLineGuide);
        },

        detachForwardLineGuide: function () {
            this.forwardLineGuide.setLatLngs([]);
            this.editLayer.removeLayer(this.forwardLineGuide);
        },

        detachBackwardLineGuide: function () {
            this.backwardLineGuide.setLatLngs([]);
            this.editLayer.removeLayer(this.backwardLineGuide);
        },

        blockEvents: function () {
            // Hack: force map not to listen to other layers events while drawing.
            if (!this._oldTargets) {
                this._oldTargets = this.map._targets;
                this.map._targets = {};
            }
        },

        unblockEvents: function () {
            if (this._oldTargets) {
                // Reset, but keep targets created while drawing.
                this.map._targets = L.extend(this.map._targets, this._oldTargets);
                delete this._oldTargets;
            }
        },

        registerForDrawing: function (editor) {
            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);
            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);
            this.blockEvents();
            this._drawingEditor = editor;
            this.map.on('mousedown', this.onMousedown, this);
            this.map.on('mouseup', this.onMouseup, this);
            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);
            this.defaultMapCursor = this.map._container.style.cursor;
            this.map._container.style.cursor = this.options.drawingCursor;
        },

        unregisterForDrawing: function (editor) {
            this.unblockEvents();
            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);
            this.map._container.style.cursor = this.defaultMapCursor;
            editor = editor || this._drawingEditor;
            if (!editor) return;
            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);
            this.map.off('mousedown', this.onMousedown, this);
            this.map.off('mouseup', this.onMouseup, this);
            if (editor !== this._drawingEditor) return;
            delete this._drawingEditor;
            if (editor._drawing) editor.cancelDrawing();
        },

        onMousedown: function (e) {
            this._mouseDown = e;
            this._drawingEditor.onDrawingMouseDown(e);
        },

        onMouseup: function (e) {
            if (this._mouseDown) {
                var origin = L.point(this._mouseDown.originalEvent.clientX, this._mouseDown.originalEvent.clientY);
                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);
                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);
                else this._drawingEditor.onDrawingMouseUp(e);
            }
            this._mouseDown = null;
        },

        drawing: function () {
            return this._drawingEditor && this._drawingEditor.drawing();
        },

        stopDrawing: function () {
            this.unregisterForDrawing();
        },

        commitDrawing: function (e) {
            if (!this._drawingEditor) return;
            this._drawingEditor.commitDrawing(e);
        },

        connectCreatedToMap: function (layer) {
            return this.featuresLayer.addLayer(layer);
        },

        startPolyline: function (latlng, options) {
            var line = this.createPolyline([], options);
            line.enableEdit(this.map).newShape(latlng);
            return line;
        },

        startPolygon: function (latlng, options) {
            var polygon = this.createPolygon([], options);
            polygon.enableEdit(this.map).newShape(latlng);
            return polygon;
        },

        startMarker: function (latlng, options) {
            latlng = latlng || this.map.getCenter().clone();
            var marker = this.createMarker(latlng, options);
            marker.enableEdit(this.map).startDrawing();
            return marker;
        },

        startRectangle: function(latlng, options) {
            var corner = latlng || L.latLng([0, 0]);
            var bounds = new L.LatLngBounds(corner, corner);
            var rectangle = this.createRectangle(bounds, options);
            rectangle.enableEdit(this.map).startDrawing();
            return rectangle;
        },

        startCircle: function (latlng, options) {
            latlng = latlng || this.map.getCenter().clone();
            var circle = this.createCircle(latlng, options);
            circle.enableEdit(this.map).startDrawing();
            return circle;
        },

        startHole: function (editor, latlng) {
            editor.newHole(latlng);
        },

        createLayer: function (klass, latlngs, options) {
            options = L.Util.extend({editOptions: {editTools: this}}, options);
            var layer = new klass(latlngs, options);
            this.fireAndForward('editable:created', {layer: layer});
            return layer;
        },

        createPolyline: function (latlngs, options) {
            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);
        },

        createPolygon: function (latlngs, options) {
            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);
        },

        createMarker: function (latlng, options) {
            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);
        },

        createRectangle: function (bounds, options) {
            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);
        },

        createCircle: function (latlng, options) {
            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);
        }

    });

    L.extend(L.Editable, {

        makeCancellable: function (e) {
            e.cancel = function () {
                e._cancelled = true;
            };
        }

    });

    L.Map.mergeOptions({
        editToolsClass: L.Editable
    });

    L.Map.addInitHook(function () {

        this.whenReady(function () {
            if (this.options.editable) {
                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);
            }
        });

    });

    L.Editable.VertexIcon = L.DivIcon.extend({

        options: {
            iconSize: new L.Point(8, 8)
        }

    });

    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({

        options: {
            iconSize: new L.Point(20, 20)
        }

    });


    L.Editable.VertexMarker = L.Marker.extend({

        options: {
            draggable: true,
            className: 'leaflet-div-icon leaflet-vertex-icon'
        },

        initialize: function (latlng, latlngs, editor, options) {
            // We don't use this._latlng, because on drag Leaflet replace it while
            // we want to keep reference.
            this.latlng = latlng;
            this.latlngs = latlngs;
            this.editor = editor;
            L.Marker.prototype.initialize.call(this, latlng, options);
            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});
            this.latlng.__vertex = this;
            this.editor.editLayer.addLayer(this);
            this.setZIndexOffset(editor.tools._lastZIndex + 1);
        },

        onAdd: function (map) {
            L.Marker.prototype.onAdd.call(this, map);
            this.on('drag', this.onDrag);
            this.on('dragstart', this.onDragStart);
            this.on('dragend', this.onDragEnd);
            this.on('mouseup', this.onMouseup);
            this.on('click', this.onClick);
            this.on('contextmenu', this.onContextMenu);
            this.on('mousedown touchstart', this.onMouseDown);
            this.addMiddleMarkers();
        },

        onRemove: function (map) {
            if (this.middleMarker) this.middleMarker.delete();
            delete this.latlng.__vertex;
            this.off('drag', this.onDrag);
            this.off('dragstart', this.onDragStart);
            this.off('dragend', this.onDragEnd);
            this.off('mouseup', this.onMouseup);
            this.off('click', this.onClick);
            this.off('contextmenu', this.onContextMenu);
            this.off('mousedown touchstart', this.onMouseDown);
            L.Marker.prototype.onRemove.call(this, map);
        },

        onDrag: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerDrag(e);
            var iconPos = L.DomUtil.getPosition(this._icon),
                latlng = this._map.layerPointToLatLng(iconPos);
            this.latlng.update(latlng);
            this._latlng = this.latlng;  // Push back to Leaflet our reference.
            this.editor.refresh();
            if (this.middleMarker) {
                this.middleMarker.updateLatLng();
            }
            var next = this.getNext();
            if (next && next.middleMarker) {
                next.middleMarker.updateLatLng();
            }
        },

        onDragStart: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerDragStart(e);
        },

        onDragEnd: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerDragEnd(e);
        },

        onClick: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerClick(e);
        },

        onMouseup: function (e) {
            L.DomEvent.stop(e);
            e.vertex = this;
            this.editor.map.fire('mouseup', e);
        },

        onContextMenu: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerContextMenu(e);
        },

        onMouseDown: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerMouseDown(e);
        },

        delete: function () {
            var next = this.getNext();  // Compute before changing latlng
            this.latlngs.splice(this.getIndex(), 1);
            this.editor.editLayer.removeLayer(this);
            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});
            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);
            if (next) next.resetMiddleMarker();
            this.editor.refresh();
        },

        getIndex: function () {
            return this.latlngs.indexOf(this.latlng);
        },

        getLastIndex: function () {
            return this.latlngs.length - 1;
        },

        getPrevious: function () {
            if (this.latlngs.length < 2) return;
            var index = this.getIndex(),
                previousIndex = index - 1;
            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();
            var previous = this.latlngs[previousIndex];
            if (previous) return previous.__vertex;
        },

        getNext: function () {
            if (this.latlngs.length < 2) return;
            var index = this.getIndex(),
                nextIndex = index + 1;
            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;
            var next = this.latlngs[nextIndex];
            if (next) return next.__vertex;
        },

        addMiddleMarker: function (previous) {
            if (!this.editor.hasMiddleMarkers()) return;
            previous = previous || this.getPrevious();
            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);
        },

        addMiddleMarkers: function () {
            if (!this.editor.hasMiddleMarkers()) return;
            var previous = this.getPrevious();
            if (previous) {
                this.addMiddleMarker(previous);
            }
            var next = this.getNext();
            if (next) {
                next.resetMiddleMarker();
            }
        },

        resetMiddleMarker: function () {
            if (this.middleMarker) this.middleMarker.delete();
            this.addMiddleMarker();
        },

        split: function () {
            if (!this.editor.splitShape) return;  // Only for PolylineEditor
            this.editor.splitShape(this.latlngs, this.getIndex());
        },

        continue: function () {
            if (!this.editor.continueBackward) return;  // Only for PolylineEditor
            var index = this.getIndex();
            if (index === 0) this.editor.continueBackward(this.latlngs);
            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);
        }

    });

    L.Editable.mergeOptions({
        vertexMarkerClass: L.Editable.VertexMarker
    });

    L.Editable.MiddleMarker = L.Marker.extend({

        options: {
            opacity: 0.5,
            className: 'leaflet-div-icon leaflet-middle-icon',
            draggable: true
        },

        initialize: function (left, right, latlngs, editor, options) {
            this.left = left;
            this.right = right;
            this.editor = editor;
            this.latlngs = latlngs;
            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);
            this._opacity = this.options.opacity;
            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});
            this.editor.editLayer.addLayer(this);
            this.setVisibility();
        },

        setVisibility: function () {
            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),
                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),
                size = L.point(this.options.icon.options.iconSize);
            if (leftPoint.distanceTo(rightPoint) < size.x * 3) {
                this.hide();
            } else {
                this.show();
            }
        },

        show: function () {
            this.setOpacity(this._opacity);
        },

        hide: function () {
            this.setOpacity(0);
        },

        updateLatLng: function () {
            this.setLatLng(this.computeLatLng());
            this.setVisibility();
        },

        computeLatLng: function () {
            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),
                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),
                y = (leftPoint.y + rightPoint.y) / 2,
                x = (leftPoint.x + rightPoint.x) / 2;
            return this.editor.map.containerPointToLatLng([x, y]);
        },

        onAdd: function (map) {
            L.Marker.prototype.onAdd.call(this, map);
            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);
            map.on('zoomend', this.setVisibility, this);
        },

        onRemove: function (map) {
            delete this.right.middleMarker;
            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);
            map.off('zoomend', this.setVisibility, this);
            L.Marker.prototype.onRemove.call(this, map);
        },

        onMouseDown: function (e) {
            var iconPos = L.DomUtil.getPosition(this._icon),
                latlng = this.editor.map.layerPointToLatLng(iconPos);
            e = {
                originalEvent: e,
                latlng: latlng
            };
            if (this.options.opacity === 0) return;
            L.Editable.makeCancellable(e);
            this.editor.onMiddleMarkerMouseDown(e);
            if (e._cancelled) return;
            this.latlngs.splice(this.index(), 0, e.latlng);
            this.editor.refresh();
            var icon = this._icon;
            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);
            /* Hack to workaround browser not firing touchend when element is no more on DOM */
            var parent = marker._icon.parentNode;
            parent.removeChild(marker._icon);
            marker._icon = icon;
            parent.appendChild(marker._icon);
            marker._initIcon();
            marker._initInteraction();
            marker.setOpacity(1);
            /* End hack */
            // Transfer ongoing dragging to real marker
            L.Draggable._dragging = false;
            marker.dragging._draggable._onDown(e.originalEvent);
            this.delete();
        },

        delete: function () {
            this.editor.editLayer.removeLayer(this);
        },

        index: function () {
            return this.latlngs.indexOf(this.right.latlng);
        }

    });

    L.Editable.mergeOptions({
        middleMarkerClass: L.Editable.MiddleMarker
    });

    L.Editable.BaseEditor = L.Class.extend({

        initialize: function (map, feature, options) {
            L.setOptions(this, options);
            this.map = map;
            this.feature = feature;
            this.feature.editor = this;
            this.editLayer = new L.LayerGroup();
            this.tools = this.options.editTools || map.editTools;
        },

        enable: function () {
            if (this._enabled) return this;
            if (this.isConnected()) this.tools.editLayer.addLayer(this.editLayer);
            this.onEnable();
            this._enabled = true;
            this.feature.on('remove', this.disable, this);
            return this;
        },

        disable: function () {
            this.feature.off('remove', this.disable, this);
            this.editLayer.clearLayers();
            this.tools.editLayer.removeLayer(this.editLayer);
            this.onDisable();
            delete this._enabled;
            if (this._drawing) this.cancelDrawing();
            return this;
        },

        drawing: function () {
            return !!this._drawing;
        },

        hasMiddleMarkers: function () {
            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;
        },

        fireAndForward: function (type, e) {
            e = e || {};
            e.layer = this.feature;
            this.feature.fire(type, e);
            this.tools.fireAndForward(type, e);
        },

        onEnable: function () {
            this.fireAndForward('editable:enable');
        },

        onDisable: function () {
            this.fireAndForward('editable:disable');
        },

        onEditing: function () {
            this.fireAndForward('editable:editing');
        },

        onStartDrawing: function () {
            this.fireAndForward('editable:drawing:start');
        },

        onEndDrawing: function () {
            this.fireAndForward('editable:drawing:end');
        },

        onCancelDrawing: function () {
            this.fireAndForward('editable:drawing:cancel');
        },

        onCommitDrawing: function (e) {
            this.fireAndForward('editable:drawing:commit', e);
        },

        onDrawingMouseDown: function (e) {
            this.fireAndForward('editable:drawing:mousedown', e);
        },

        onDrawingMouseUp: function (e) {
            this.fireAndForward('editable:drawing:mouseup', e);
        },

        startDrawing: function () {
            if (!this._drawing) this._drawing = L.Editable.FORWARD;
            this.tools.registerForDrawing(this);
            this.onStartDrawing();
        },

        commitDrawing: function (e) {
            this.onCommitDrawing(e);
            this.endDrawing();
        },

        cancelDrawing: function () {
            this.onCancelDrawing();
            this.endDrawing();
        },

        endDrawing: function () {
            this._drawing = false;
            this.tools.unregisterForDrawing(this);
            this.onEndDrawing();
        },

        onDrawingClick: function (e) {
            if (!this.drawing) return;
            L.Editable.makeCancellable(e);
            this.fireAndForward('editable:drawing:click', e);
            if (e._cancelled) return;
            if (!this.isConnected()) this.connect(e);
            this.processDrawingClick(e);
        },

        isConnected: function () {
            return this.map.hasLayer(this.feature);
        },

        connect: function (e) {
            this.tools.connectCreatedToMap(this.feature);
            this.tools.editLayer.addLayer(this.editLayer);
        },

        onMove: function (e) {
            this.fireAndForward('editable:drawing:move', e);
        },

        onDrawingMouseMove: function (e) {
            this.onMove(e);
        }

    });

    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({

        enable: function () {
            if (this._enabled) return this;
            L.Editable.BaseEditor.prototype.enable.call(this);
            if (this.isConnected()) this.enableDragging();
            else this.feature.on('add', this.enableDragging, this);
            this.feature.on('dragstart', this.onEditing, this);
            this.feature.on('drag', this.onMove, this);
            return this;
        },

        disable: function () {
            L.Editable.BaseEditor.prototype.disable.call(this);
            if (this.feature.dragging) this.feature.dragging.disable();
            this.feature.off('dragstart', this.onEditing, this);
            this.feature.off('drag', this.onMove, this);
            return this;
        },

        enableDragging: function () {
            this.feature.dragging.enable();
        },

        onDrawingMouseMove: function (e) {
            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
            if (this._drawing) this.feature.setLatLng(e.latlng);
        },

        processDrawingClick: function (e) {
            this.fireAndForward('editable:drawing:clicked', e);
            this.commitDrawing(e);
        },

        connect: function (e) {
            // On touch, the latlng has not been updated because there is
            // no mousemove.
            if (e) this.feature._latlng = e.latlng;
            L.Editable.BaseEditor.prototype.connect.call(this, e);
        }

    });

    L.Editable.PathEditor = L.Editable.BaseEditor.extend({

        CLOSED: false,
        MIN_VERTEX: 2,

        enable: function () {
            if (this._enabled) return this;
            L.Editable.BaseEditor.prototype.enable.call(this);
            if (this.feature) {
                this.initVertexMarkers();
            }
            return this;
        },

        disable: function () {
            return L.Editable.BaseEditor.prototype.disable.call(this);
        },

        initVertexMarkers: function (latlngs) {
            latlngs = latlngs || this.getLatLngs();
            if (L.Polyline._flat(latlngs)) this.addVertexMarkers(latlngs);
            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);
        },

        getLatLngs: function () {
            return this.feature.getLatLngs();
        },

        reset: function () {
            this.editLayer.clearLayers();
            this.initVertexMarkers();
        },

        addVertexMarker: function (latlng, latlngs) {
            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);
        },

        addVertexMarkers: function (latlngs) {
            for (var i = 0; i < latlngs.length; i++) {
                this.addVertexMarker(latlngs[i], latlngs);
            }
        },

        refreshVertexMarkers: function (latlngs) {
            latlngs = latlngs || this.getDefaultLatLngs();
            for (var i = 0; i < latlngs.length; i++) {
                latlngs[i].__vertex.update();
            }
        },

        addMiddleMarker: function (left, right, latlngs) {
            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);
        },

        onVertexMarkerClick: function (e) {
            L.Editable.makeCancellable(e);
            this.fireAndForward('editable:vertex:click', e);
            if (e._cancelled) return;
            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;
            var index = e.vertex.getIndex(), commit;
            if (e.originalEvent.ctrlKey) {
                this.onVertexMarkerCtrlClick(e);
            } else if (e.originalEvent.altKey) {
                this.onVertexMarkerAltClick(e);
            } else if (e.originalEvent.shiftKey) {
                this.onVertexMarkerShiftClick(e);
            } else if (e.originalEvent.metaKey) {
                this.onVertexMarkerMetaKeyClick(e);
            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {
                if (index >= this.MIN_VERTEX - 1) commit = true;
            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {
                commit = true;
            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {
                commit = true;  // Allow to close on first point also for polygons
            } else {
                this.onVertexRawMarkerClick(e);
            }
            this.fireAndForward('editable:vertex:clicked', e);
            if (commit) this.commitDrawing(e);
        },

        onVertexRawMarkerClick: function (e) {
            this.fireAndForward('editable:vertex:rawclick', e);
            if (e._cancelled) return;
            if (!this.vertexCanBeDeleted(e.vertex)) return;
            e.vertex.delete();
        },

        vertexCanBeDeleted: function (vertex) {
            return vertex.latlngs.length > this.MIN_VERTEX;
        },

        onVertexDeleted: function (e) {
            this.fireAndForward('editable:vertex:deleted', e);
        },

        onVertexMarkerCtrlClick: function (e) {
            this.fireAndForward('editable:vertex:ctrlclick', e);
        },

        onVertexMarkerShiftClick: function (e) {
            this.fireAndForward('editable:vertex:shiftclick', e);
        },

        onVertexMarkerMetaKeyClick: function (e) {
            this.fireAndForward('editable:vertex:metakeyclick', e);
        },

        onVertexMarkerAltClick: function (e) {
            this.fireAndForward('editable:vertex:altclick', e);
        },

        onVertexMarkerContextMenu: function (e) {
            this.fireAndForward('editable:vertex:contextmenu', e);
        },

        onVertexMarkerMouseDown: function (e) {
            this.fireAndForward('editable:vertex:mousedown', e);
        },

        onMiddleMarkerMouseDown: function (e) {
            this.fireAndForward('editable:middlemarker:mousedown', e);
        },

        onVertexMarkerDrag: function (e) {
            this.onMove(e);
            if (this.feature._bounds) this.extendBounds(e);
            this.fireAndForward('editable:vertex:drag', e);
        },

        onVertexMarkerDragStart: function (e) {
            this.fireAndForward('editable:vertex:dragstart', e);
        },

        onVertexMarkerDragEnd: function (e) {
            this.fireAndForward('editable:vertex:dragend', e);
        },

        setDrawnLatLngs: function (latlngs) {
            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();
        },

        startDrawing: function () {
            if (!this._drawnLatLngs) this.setDrawnLatLngs();
            L.Editable.BaseEditor.prototype.startDrawing.call(this);
        },

        startDrawingForward: function () {
            this.startDrawing();
            this.tools.attachForwardLineGuide();
        },

        endDrawing: function () {
            this.tools.detachForwardLineGuide();
            this.tools.detachBackwardLineGuide();
            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);
            L.Editable.BaseEditor.prototype.endDrawing.call(this);
            delete this._drawnLatLngs;
        },

        addLatLng: function (latlng) {
            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);
            else this._drawnLatLngs.unshift(latlng);
            this.feature._bounds.extend(latlng);
            this.addVertexMarker(latlng, this._drawnLatLngs);
            this.refresh();
        },

        newPointForward: function (latlng) {
            this.addLatLng(latlng);
            this.tools.anchorForwardLineGuide(latlng);
            if (!this.tools.backwardLineGuide._latlngs[0]) {
                this.tools.anchorBackwardLineGuide(latlng);
            }
        },

        newPointBackward: function (latlng) {
            this.addLatLng(latlng);
            this.tools.anchorBackwardLineGuide(latlng);
        },

        push: function (latlng) {
            if (!latlng) return console.error('L.Editable.PathEditor.push expect a vaild latlng as parameter');
            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);
            else this.newPointBackward(latlng);
        },

        removeLatLng: function (latlng) {
            latlng.__vertex.delete();
            this.refresh();
        },

        pop: function () {
            if (this._drawnLatLngs.length <= 1) return;
            var latlng;
            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];
            else latlng = this._drawnLatLngs[0];
            this.removeLatLng(latlng);
            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);
            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);
            return latlng;
        },

        processDrawingClick: function (e) {
            if (e.vertex && e.vertex.editor === this) return;
            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);
            else this.newPointBackward(e.latlng);
            this.fireAndForward('editable:drawing:clicked', e);
        },

        onDrawingMouseMove: function (e) {
            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
            if (this._drawing) {
                this.tools.moveForwardLineGuide(e.latlng);
                this.tools.moveBackwardLineGuide(e.latlng);
            }
        },

        refresh: function () {
            this.feature.redraw();
            this.onEditing();
        },

        newShape: function (latlng) {
            var shape = this.addNewEmptyShape();
            if (!shape) return;
            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline
            this.startDrawingForward();
            this.fireAndForward('editable:shape:new', {shape: shape});
            if (latlng) this.newPointForward(latlng);
        },

        deleteShape: function (shape, latlngs) {
            var e = {shape: shape};
            L.Editable.makeCancellable(e);
            this.fireAndForward('editable:shape:delete', e);
            if (e._cancelled) return;
            shape = this._deleteShape(shape, latlngs);
            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.
            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.
            this.refresh();
            this.reset();
            this.fireAndForward('editable:shape:deleted', {shape: shape});
            return shape;
        },

        _deleteShape: function (shape, latlngs) {
            latlngs = latlngs || this.getLatLngs();
            if (!latlngs.length) return;
            var self = this,
                inplaceDelete = function (latlngs, shape) {
                    // Called when deleting a flat latlngs
                    shape = latlngs.splice(0, Number.MAX_VALUE);
                    return shape;
                },
                spliceDelete = function (latlngs, shape) {
                    // Called when removing a latlngs inside an array
                    latlngs.splice(latlngs.indexOf(shape), 1);
                    if (!latlngs.length) self._deleteShape(latlngs);
                    return shape;
                };
            if (latlngs === shape) return inplaceDelete(latlngs, shape);
            for (var i = 0; i < latlngs.length; i++) {
                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);
                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);
            }
        },

        deleteShapeAt: function (latlng) {
            var shape = this.feature.shapeAt(latlng);
            if (shape) return this.deleteShape(shape);
        },

        appendShape: function (shape) {
            this.insertShape(shape);
        },

        prependShape: function (shape) {
            this.insertShape(shape, 0);
        },

        insertShape: function (shape, index) {
            this.ensureMulti();
            shape = this.formatShape(shape);
            if (typeof index === 'undefined') index = this.feature._latlngs.length;
            this.feature._latlngs.splice(index, 0, shape);
            this.feature.redraw();
            if (this._enabled) this.reset();
        },

        extendBounds: function (e) {
            this.feature._bounds.extend(e.vertex.latlng);
        }

    });

    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({

        startDrawingBackward: function (latlngs) {
            this._drawing = L.Editable.BACKWARD;
            this.startDrawing(latlngs);
            this.tools.attachBackwardLineGuide();
        },

        continueBackward: function (latlngs) {
            if (this.drawing()) return;
            latlngs = latlngs || this.getDefaultLatLngs();
            this.setDrawnLatLngs(latlngs);
            this.tools.anchorBackwardLineGuide(latlngs[0]);
            this.startDrawingBackward();
        },

        continueForward: function (latlngs) {
            if (this.drawing()) return;
            latlngs = latlngs || this.getDefaultLatLngs();
            this.setDrawnLatLngs(latlngs);
            this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);
            this.startDrawingForward();
        },

        getDefaultLatLngs: function (latlngs) {
            latlngs = latlngs || this.feature._latlngs;
            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;
            else return this.getDefaultLatLngs(latlngs[0]);
        },

        ensureMulti: function () {
            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs)) {
                this.feature._latlngs = [this.feature._latlngs];
            }
        },

        addNewEmptyShape: function () {
            if (this.feature._latlngs.length) {
                var shape = [];
                this.appendShape(shape);
                return shape;
            } else {
                return this.feature._latlngs;
            }
        },

        formatShape: function (shape) {
            if (L.Polyline._flat(shape)) return shape;
            else if (shape[0]) return this.formatShape(shape[0]);
        },

        splitShape: function (shape, index) {
            if (!index || index >= shape.length - 1) return;
            this.ensureMulti();
            var shapeIndex = this.feature._latlngs.indexOf(shape);
            if (shapeIndex === -1) return;
            var first = shape.slice(0, index + 1),
                second = shape.slice(index);
            // We deal with reference, we don't want twice the same latlng around.
            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);
            this.feature._latlngs.splice(shapeIndex, 1, first, second);
            this.refresh();
            this.reset();
        }

    });

    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({

        CLOSED: true,
        MIN_VERTEX: 3,

        startDrawingForward: function () {
            L.Editable.PathEditor.prototype.startDrawingForward.call(this);
            this.tools.attachBackwardLineGuide();
        },

        addNewEmptyHole: function (latlng) {
            this.ensureNotFlat();
            var latlngs = this.feature.shapeAt(latlng);
            if (!latlngs) return;
            var holes = [];
            latlngs.push(holes);
            return holes;
        },

        newHole: function (latlng) {
            var holes = this.addNewEmptyHole(latlng);
            if (!holes) return;
            this.setDrawnLatLngs(holes);
            this.startDrawingForward();
            if (latlng) this.newPointForward(latlng);
        },

        addNewEmptyShape: function () {
            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {
                var shape = [];
                this.appendShape(shape);
                return shape;
            } else {
                return this.feature._latlngs;
            }
        },

        ensureMulti: function () {
            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs[0])) {
                this.feature._latlngs = [this.feature._latlngs];
            }
        },

        ensureNotFlat: function () {
            if (!this.feature._latlngs.length || L.Polyline._flat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];
        },

        vertexCanBeDeleted: function (vertex) {
            var parent = this.feature.parentShape(vertex.latlngs),
                idx = L.Util.indexOf(parent, vertex.latlngs);
            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.
            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);
        },

        getDefaultLatLngs: function () {
            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);
            return this.feature._latlngs[0];
        },

        formatShape: function (shape) {
            // [[1, 2], [3, 4]] => must be nested
            // [] => must be nested
            // [[]] => is already nested
            if (L.Polyline._flat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];
            else return shape;
        }

    });

    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({

        CLOSED: true,
        MIN_VERTEX: 4,

        options: {
            skipMiddleMarkers: true
        },

        extendBounds: function (e) {
            var index = e.vertex.getIndex(),
                oppositeIndex = (index + 2) % 4,
                opposite = e.vertex.latlngs[oppositeIndex],
                bounds = new L.LatLngBounds(e.latlng, opposite);
            this.updateBounds(bounds);
            this.refreshVertexMarkers();
        },

        onDrawingMouseDown: function (e) {
            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);
            this.connect();
            var latlngs = this.getDefaultLatLngs();
            // L.Polygon._convertLatLngs removes last latlng if it equals first point,
            // which is the case here as all latlngs are [0, 0]
            if (latlngs.length === 3) latlngs.push(e.latlng);
            var bounds = new L.LatLngBounds(e.latlng, e.latlng);
            this.updateBounds(bounds);
            this.refresh();
            this.reset();
            this.commitDrawing(e);
            // Stop dragging map.
            this.map.dragging._draggable._onUp(e.originalEvent);
            // Now transfer ongoing drag action to the bottom right corner.
            // Should we refine which corne will handle the drag according to
            // drag direction?
            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);
        },

        getDefaultLatLngs: function (latlngs) {
            return latlngs || this.feature._latlngs[0];
        },

        updateBounds: function (bounds) {
            this.feature._bounds = bounds;
            var latlngs = this.getDefaultLatLngs(),
                newLatlngs = this.feature._boundsToLatLngs(bounds);
            // Keep references.
            for (var i = 0; i < latlngs.length; i++) {
                latlngs[i].update(newLatlngs[i]);
            };
        }

    });

    L.Editable.CircleEditor = L.Editable.PathEditor.extend({

        MIN_VERTEX: 2,

        options: {
            skipMiddleMarkers: true
        },

        initialize: function (map, feature, options) {
            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);
            this._resizeLatLng = this.computeResizeLatLng();
        },

        computeResizeLatLng: function () {
            // While circle is not added to the map, _radius is not set.
            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),
                point = this.map.project(this.feature._latlng);
            return this.map.unproject([point.x + delta, point.y - delta]);
        },

        updateResizeLatLng: function () {
            this._resizeLatLng.update(this.computeResizeLatLng());
            this._resizeLatLng.__vertex.update();
        },

        getLatLngs: function () {
            return [this.feature._latlng, this._resizeLatLng];
        },

        getDefaultLatLngs: function () {
            return this.getLatLngs();
        },

        onVertexMarkerDrag: function (e) {
            if (e.vertex.getIndex() === 1) this.resize(e);
            else this.updateResizeLatLng(e);
            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);
        },

        resize: function (e) {
            var radius = this.feature._latlng.distanceTo(e.latlng)
            this.feature.setRadius(radius);
        },

        onDrawingMouseDown: function (e) {
            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);
            this._resizeLatLng.update(e.latlng);
            this.feature._latlng.update(e.latlng);
            this.connect();
            this.commitDrawing(e);
            // Stop dragging map.
            this.map.dragging._draggable._onUp(e.originalEvent);
            // Now transfer ongoing drag action to the radius handler.
            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);
        },

        onDrawingMouseMove: function (e) {
            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
            this.feature._latlng.update(e.latlng);
            this.feature._latlng.__vertex.update();
        }

    });

    var EditableMixin = {

        createEditor: function (map) {
            map = map || this._map;
            var Klass = this.options.editorClass || this.getEditorClass(map);
            return new Klass(map, this, this.options.editOptions);
        },

        enableEdit: function (map) {
            if (!this.editor) this.createEditor(map);
            return this.editor.enable();
        },

        editEnabled: function () {
            return this.editor && this.editor._enabled;
        },

        disableEdit: function () {
            if (this.editor) {
                this.editor.disable();
                delete this.editor;
            }
        },

        toggleEdit: function () {
            if (this.editEnabled()) {
                this.disableEdit();
            } else {
                this.enableEdit();
            }
        },

        _onEditableAdd: function () {
            if (this.editor) this.enableEdit();
        }

    };

    L.Polyline.include(EditableMixin);
    L.Polygon.include(EditableMixin);
    L.Marker.include(EditableMixin);
    L.Rectangle.include(EditableMixin);
    L.Circle.include(EditableMixin);

    L.Polyline.include({

        getEditorClass: function (map) {
            return (map && map.options.polylineEditorClass) ? map.options.polylineEditorClass : L.Editable.PolylineEditor;
        },

        shapeAt: function (latlng, latlngs) {
            // We can have those cases:
            // - latlngs are just a flat array of latlngs, use this
            // - latlngs is an array of arrays of latlngs, loop over
            var shape = null;
            latlngs = latlngs || this._latlngs;
            if (!latlngs.length) return shape;
            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;
            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];
            return shape;
        },

        isInLatLngs: function (l, latlngs) {
            if (!latlngs) return false;
            var i, k, len, part = [], p,
                w = this._clickTolerance();
            this._projectLatlngs(latlngs, part, this._pxBounds);
            part = part[0];
            p = this._map.latLngToLayerPoint(l);

            if (!this._pxBounds.contains(p)) { return false; }
            for (i = 1, len = part.length, k = 0; i < len; k = i++) {

                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {
                    return true;
                }
            }
            return false;
        }

    });

    L.Polygon.include({

        getEditorClass: function (map) {
            return (map && map.options.polygonEditorClass) ? map.options.polygonEditorClass : L.Editable.PolygonEditor;
        },

        shapeAt: function (latlng, latlngs) {
            // We can have those cases:
            // - latlngs are just a flat array of latlngs, use this
            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first
            // - latlngs is an array of arrays of arrays, this is a multi, loop over
            var shape = null;
            latlngs = latlngs || this._latlngs;
            if (!latlngs.length) return shape;
            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;
            else if (L.Polyline._flat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;
            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];
            return shape;
        },

        isInLatLngs: function (l, latlngs) {
            var inside = false, l1, l2, j, k, len2;

            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {
                l1 = latlngs[j];
                l2 = latlngs[k];

                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&
                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {
                    inside = !inside;
                }
            }

            return inside;
        },

        parentShape: function (shape, latlngs) {
            latlngs = latlngs || this._latlngs;
            if (!latlngs) return;
            var idx = L.Util.indexOf(latlngs, shape);
            if (idx !== -1) return latlngs;
            for (var i = 0; i < latlngs.length; i++) {
                idx = L.Util.indexOf(latlngs[i], shape);
                if (idx !== -1) return latlngs[i];
            }
        }

    });

    L.Marker.include({

        getEditorClass: function (map) {
            return (map && map.options.markerEditorClass) ? map.options.markerEditorClass : L.Editable.MarkerEditor;
        }

    });

    L.Rectangle.include({

        getEditorClass: function (map) {
            return (map && map.options.rectangleEditorClass) ? map.options.rectangleEditorClass : L.Editable.RectangleEditor;
        }

    });

    L.Circle.include({

        getEditorClass: function (map) {
            return (map && map.options.circleEditorClass) ? map.options.circleEditorClass : L.Editable.CircleEditor;
        }

    });

    var keepEditable = function () {
        // Make sure you can remove/readd an editable layer.
        this.on('add', this._onEditableAdd);
    };
    L.Marker.addInitHook(keepEditable);
    L.Polyline.addInitHook(keepEditable);

    L.LatLng.prototype.update = function (latlng) {
        this.lat = latlng.lat;
        this.lng = latlng.lng;
    }

}, window));

},{"leaflet":13}],13:[function(require,module,exports){
/*
 Leaflet 1.0.0-rc.2, a JS library for interactive maps. http://leafletjs.com
 (c) 2010-2015 Vladimir Agafonkin, (c) 2010-2011 CloudMade
*/
(function (window, document, undefined) {
var L = {
	version: "1.0.0-rc.2"
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed
if (typeof window !== 'undefined') {
	expose();
}



/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

L.Util = {

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	extend: function (dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// @function bind(fn: Function, â€¦): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assiging it one if it doesn't have it.
	stamp: function (obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
		/*eslint-enable */
	},

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	lastId: 0,

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.bind` shortcut.
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	falseFn: function () { return false; },

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values â€” they will be evaluated passing `data` as an argument.
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_\-]+) *\}/g,

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	indexOf: function (array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	},

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	L.Util.requestAnimFrame = function (fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context));
		}
	};

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;




// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

L.Class = function () {};

L.Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
L.Class.include = function (props) {
	L.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};



/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */


L.Evented = L.Class.extend({

	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = {
				listeners: {},
				count: 0
			};
			this._events[type] = typeListeners;
		}

		var contextId = context && context !== this && L.stamp(context),
		    newListener = {fn: fn, ctx: context};

		if (!contextId) {
			contextId = 'no_context';
			newListener.ctx = undefined;
		}

		// fn array for context
		var listeners = typeListeners.listeners[contextId];
		if (!listeners) {
			listeners = [];
			typeListeners.listeners[contextId] = listeners;
		}

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn) {
				return;
			}
		}

		listeners.push(newListener);
		typeListeners.count++;
	},

	_off: function (type, fn, context) {
		var typeListeners,
		    contextId,
		    listeners,
		    i,
		    len;

		if (!this._events) { return; }

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			typeListeners = this._events[type];
			if (typeListeners) {
				for (contextId in typeListeners.listeners) {
					listeners = typeListeners.listeners[contextId];
					for (i = 0, len = listeners.length; i < len; i++) {
						listeners[i].fn = L.Util.falseFn;
					}
				}
				// clear all listeners for a type if function isn't specified
				delete this._events[type];
			}
			return;
		}

		typeListeners = this._events[type];
		if (!typeListeners) {
			return;
		}

		contextId = context && context !== this && L.stamp(context);
		if (!contextId) {
			contextId = 'no_context';
		}

		listeners = typeListeners.listeners[contextId];
		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = L.Util.falseFn;
					typeListeners.count--;

					if (len > 1) {
						if (!this._isFiring) {
							listeners.splice(i, 1);
						} else {
							/* copy array in case events are being fired */
							typeListeners.listeners[contextId] = listeners.slice();
							typeListeners.listeners[contextId].splice(i, 1);
						}
					} else {
						delete typeListeners.listeners[contextId];
					}

					return;
				}
				if (listeners.length === 0) {
					delete typeListeners.listeners[contextId];
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object â€” the first argument of the listener function will contain its
	// properties. The event might can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this});

		if (this._events) {
			var typeListeners = this._events[type];

			if (typeListeners) {
				this._isFiring = true;

				// each context
				for (var contextId in typeListeners.listeners) {
					var listeners = typeListeners.listeners[contextId];

					// each fn in context
					for (var i = 0, len = listeners.length; i < len; i++) {
						var l = listeners[i];
						l.fn.call(l.ctx || this, event);
					}
				}

				this._isFiring = false;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var typeListeners = this._events && this._events[type];
		if (typeListeners && typeListeners.count) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(â€¦): this
	// Behaves as [`on(â€¦)`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually

// @method addEventListener(â€¦): this
// Alias to [`on(â€¦)`](#evented-on)
proto.addEventListener = proto.on;

// @method removeEventListener(â€¦): this
// Alias to [`off(â€¦)`](#evented-off)

// @method clearAllEventListeners(â€¦): this
// Alias to [`off()`](#evented-off)
proto.removeEventListener = proto.clearAllEventListeners = proto.off;

// @method addOneTimeEventListener(â€¦): this
// Alias to [`once(â€¦)`](#evented-once)
proto.addOneTimeEventListener = proto.once;

// @method fireEvent(â€¦): this
// Alias to [`fire(â€¦)`](#evented-fire)
proto.fireEvent = proto.fire;

// @method hasEventListeners(â€¦): Boolean
// Alias to [`listens(â€¦)`](#evented-listens)
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};



/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,
	    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

	    win = navigator.platform.indexOf('Win') === 0,

	    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
	    pointer = window.PointerEvent || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera12 = 'OTransition' in doc.style;


	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {

		// @property ie: Boolean
		// `true` for all Internet Explorer versions (not Edge).
		ie: ie,

		// @property ielt9: Boolean
		// `true` for Internet Explorer versions less than 9.
		ielt9: ie && !document.addEventListener,

		// @property edge: Boolean
		// `true` for the Edge web browser.
		edge: 'msLaunchUri' in navigator && !('documentMode' in document),

		// @property webkit: Boolean
		// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
		webkit: webkit,

		// @property gecko: Boolean
		// `true` for gecko-based browsers like Firefox.
		gecko: gecko,

		// @property android: Boolean
		// `true` for any browser running on an Android platform.
		android: ua.indexOf('android') !== -1,

		// @property android23: Boolean
		// `true` for browsers running on Android 2 or Android 3.
		android23: android23,

		// @property chrome: Boolean
		// `true` for the Chrome browser.
		chrome: chrome,

		// @property safari: Boolean
		// `true` for the Safari browser.
		safari: !chrome && ua.indexOf('safari') !== -1,


		// @property win: Boolean
		// `true` when the browser is running in a Windows platform
		win: win,


		// @property ie3d: Boolean
		// `true` for all Internet Explorer versions supporting CSS transforms.
		ie3d: ie3d,

		// @property webkit3d: Boolean
		// `true` for webkit-based browsers supporting CSS transforms.
		webkit3d: webkit3d,

		// @property gecko3d: Boolean
		// `true` for gecko-based browsers supporting CSS transforms.
		gecko3d: gecko3d,

		// @property opera12: Boolean
		// `true` for the Opera browser supporting CSS transforms (version 12 or later).
		opera12: opera12,

		// @property any3d: Boolean
		// `true` for all browsers supporting CSS transforms.
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


		// @property mobile: Boolean
		// `true` for all browsers running in a mobile device.
		mobile: mobile,

		// @property mobileWebkit: Boolean
		// `true` for all webkit-based browsers in a mobile device.
		mobileWebkit: mobile && webkit,

		// @property mobileWebkit3d: Boolean
		// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
		mobileWebkit3d: mobile && webkit3d,

		// @property mobileOpera: Boolean
		// `true` for the Opera browser in a mobile device.
		mobileOpera: mobile && window.opera,

		// @property mobileGecko: Boolean
		// `true` for gecko-based browsers running in a mobile device.
		mobileGecko: mobile && gecko,


		// @property touch: Boolean
		// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
		touch: !!touch,

		// @property msPointer: Boolean
		// `true` for browsers implementing the Microsoft touch events model (notably IE10).
		msPointer: !!msPointer,

		// @property pointer: Boolean
		// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
		pointer: !!pointer,


		// @property retina: Boolean
		// `true` for browsers on a high-resolution "retina" screen.
		retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
	};

}());



/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

L.Point = function (x, y, round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(L.point(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new L.Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new L.Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new L.Point(x.x, x.y);
	}
	return new L.Point(x, y, round);
};



/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

L.Bounds = function (a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = L.point(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new L.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(topLeft: Point, bottomRight: Point)
// Creates a Bounds object from two coordinates (usually top-left and bottom-right corners).
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the points it contains
L.bounds = function (a, b) {
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};



/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = new L.Transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts real `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts real `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};



/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

L.DomUtil = {

	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	empty: function (el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	},

	// @function toFront(el: HTMLElement)
	// Makes `el` the last children of its parent, so it renders in front of the other children.
	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	// @function toBack(el: HTMLElement)
	// Makes `el` the first children of its parent, so it renders back from the other children.
	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {
			L.DomUtil._setOpacityIE(el, value);
		}
	},

	_setOpacityIE: function (el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	},

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0);

		el.style[L.DomUtil.TRANSFORM] =
			(L.Browser.ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	},

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

		/*eslint-disable */
		el._leaflet_pos = point;
		/*eslint-enable */

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new L.Point(0, 0);
	}
};


(function () {
	// prefix style property names

	// @property TRANSFORM: String
	// Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transform style name.
	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	L.DomUtil.preventOutline = function (element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element || !element.style) { return; }
		L.DomUtil.restoreOutline();
		this._outlineElement = element;
		this._outlineStyle = element.style.outline;
		element.style.outline = 'none';
		L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
	};

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	L.DomUtil.restoreOutline = function () {
		if (!this._outlineElement) { return; }
		this._outlineElement.style.outline = this._outlineStyle;
		delete this._outlineElement;
		delete this._outlineStyle;
		L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
})();



/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return L.latLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new L.LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

L.latLng = function (a, b, c) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new L.LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b, c);
};



/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var southWest = L.latLng(40.712, -74.227),
 * northEast = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(southWest, northEast);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
	equals: function (bounds) {
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(southWest: LatLng, northEast: LatLng)
// Creates a `LatLngBounds` object by defining south-west and north-east corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
L.latLngBounds = function (a, b) {
	if (a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};



/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection â€” the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:3395` and `Simple` CRS.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};



/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection â€” the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

L.Projection.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};



/*
 * @class CRS
 * @aka L.CRS
 * Abstract class that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

L.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level correspondingto a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng1: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude coordinate axis
	// wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean = false
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return L.latLng(lat, lng, alt);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});



/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) +
		        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});



/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API â€” it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

L.Map = L.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: L.CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = undefined
		// Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
		minZoom: undefined,

		// @option maxZoom: Number = undefined
		// Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back when he tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom) {
		// replaced by animation-powered implementation in Map.PanAnimation.js
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), zoom);
		return this;
	},

	// @method setZoom(zoom: Number, options: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && (this.getZoom() > this.options.maxZoom)) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so â€”
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so â€”
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},


	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		for (var i in this._layers) {
			this._layers[i].remove();
		}

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a children of `container`, or
	// as a children of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);
		padding = L.point(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;

		var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.zoom(scale * crs.scale(fromZoom));
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return L.DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeteadly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeteadly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		L.Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove) {
		if (!L.DomEvent) { return; }

		this._targets = {};
		this._targets[L.stamp(this._container)] = this;

		var onOff = remove ? 'off' : 'on';

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: Event
		// Fired when the user presses a key from the keyboard while the map is focused.
		L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}

		if (L.Browser.any3d && this.options.transform3DLimit) {
			this[onOff]('moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[L.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && L.DomEvent._isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

		if (type === 'mousedown') {
			// prevents outline when clicking on keyboard-focusable element
			L.DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = L.Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			L.DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target instanceof L.Marker;
			data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = L.bounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
L.map = function (id, options) {
	return new L.Map(id, options);
};




/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


L.Layer = L.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',
		nonBubblingEvents: []  // Array of events that should not be bubbled to DOM parents (like the map)
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map): this
	 * Adds the layer to the given map
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[L.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[L.stamp(targetEl)];
		return this;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	}
});



/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection â€” more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});



/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


L.GridLayer = L.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = depends
		// If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
		updateWhenIdle: L.Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "Â© Mapbox".
		attribution: null,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level that tiles will be loaded at. By default the entire map.
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level that tiles will be loaded at.
		maxZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		options = L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	// @method getContainer: String
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof L.Point ? s : new L.Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (L.Browser.ielt9) { return; }

		L.DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			L.DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) { willPrune = true; }
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
			} else {
				L.DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			L.Util.falseFn(level.el.offsetWidth);
		}

		this._level = level;

		return level;
	},

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			L.DomUtil.remove(this._levels[z].el);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new L.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new L.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = Math.round(zoom);
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(level.el, translate, scale);
		} else {
			L.DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = map.getZoom();

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new L.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if its the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),

		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),

		    nw = map.wrapLatLng(map.unproject(nwPoint, coords.z)),
		    se = map.wrapLatLng(map.unproject(sePoint, coords.z));

		return new L.LatLngBounds(nw, se);
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new L.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		L.DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		L.DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
		}

		L.DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			L.DomUtil.setOpacity(tile.el, 0);
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

		// @event tileload: TileEvent
		// Fired when a tile loads.
		this.fire('tileload', {
			tile: tile.el,
			coords: coords
		});

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (L.Browser.ielt9 || !this._map._fadeAnimated) {
				L.Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(L.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new L.Point(
			this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new L.Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
L.gridLayer = function (options) {
	return new L.GridLayer(options);
};



/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` â€” zoom level, `{x}` and `{y}` â€” tile coordinates. `{r}` can be used to add @2x to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


L.TileLayer = L.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// Minimum zoom number.
		minZoom: 0,

		// @option maxZoom: Number = 18
		// Maximum zoom number.
		maxZoom: 18,

		// @option maxNativeZoom: Number = null
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: null,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
		L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: L.Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return L.Util.template(this._url, L.extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (L.Browser.ielt9) {
			setTimeout(L.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	getTileSize: function () {
		var map = this._map,
		    tileSize = L.GridLayer.prototype.getTileSize.call(this),
		    zoom = this._tileZoom + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom;

		// increase tile size when overscaling
		return zoomN !== null && zoom > zoomN ?
				tileSize.divideBy(map.getZoomScale(zoomN, zoom)).round() :
				tileSize;
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._tileZoom;

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom !== null ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;

				if (!tile.complete) {
					tile.src = L.Util.emptyImageUrl;
					L.DomUtil.remove(tile);
				}
			}
		}
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};



/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data Â© 2012 IEM Nexrad"
 * });
 * ```
 */

L.TileLayer.WMS = L.TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);

		return url +
			L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};



/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

L.ImageOverlay = L.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option attribution: String = null
		// An optional string containing HTML to be shown on the `Attribution control`
		attribution: null,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			L.DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	setBounds: function (bounds) {
		this._bounds = bounds;

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	getBounds: function () {
		return this._bounds;
	},

	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);

		L.DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};



/*
 * @class Icon
 * @aka L.Icon
 * @inherits Layer
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

L.Icon = L.Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = null
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	initialize: function (options) {
		L.setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = L.point(sizeOption),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
L.icon = function (options) {
	return new L.Icon(options);
};



/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + (L.Browser.retina && name === 'icon' ? '-2x' : '') + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src || '';

		if (src.match(leafletRe)) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());



/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

L.Marker = L.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. Set to new `L.Icon.Default()` by default.
		icon: new L.Icon.Default(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// FIXME: shadowPane is no longer a valid option
		nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		L.DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (L.Handler.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new L.Handler.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};



/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

L.DivIcon = L.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = L.point(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
L.divIcon = function (options) {
	return new L.DivIcon(options);
};



/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
L.Map.mergeOptions({
	closePopupOnClick: true
});

// @namespace DivOverlay
L.DivOverlay = L.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option zoomAnimation: Boolean = true
		// Whether to animate the popup on zoom. Disable it if you have
		// problems with Flash content inside popups.
		zoomAnimation: true,

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && this.options.zoomAnimation;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});



/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
L.Popup = L.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when user clicks the map (set globally by
		// the Map's [closePopupOnClick](#map-closepopuponclick) option).
		autoClose: true
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			this._source.on('preclick', L.DomEvent.stopPropagation);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			this._source.off('preclick', L.DomEvent.stopPropagation);
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'));

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		L.DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._zoomAnimated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return L.point(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
L.popup = function (options, source) {
	return new L.Popup(options, source);
};


// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof L.Popup)) {
			popup = new L.Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});



/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
L.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return this._popup.isOpen();
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		L.DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof L.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});



/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor || [0, 0];
	}
});



/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [6, -6], because the tooltip
 *   tip is 6px width and height. Remember to change this value if you override
 *   the tip in CSS.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
L.Tooltip = L.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(6, -6)
		// The offset of the tooltip position. Update it if you customize the
		// tooltip tip in CSS.
		offset: [6, -6],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = L.DomUtil.create('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_updatePosition: function () {
		var map = this._map,
		    pos = map.latLngToLayerPoint(this._latlng),
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(L.point(-tooltipWidth / 2, -tooltipHeight + offset.y + anchor.y));
		} else if (direction === 'bottom') {
			pos = pos.subtract(L.point(tooltipWidth / 2, offset.y));
		} else if (direction === 'center') {
			pos = pos.subtract(L.point(tooltipWidth / 2, tooltipHeight / 2 - anchor.y));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add([offset.x + anchor.x, anchor.y - tooltipHeight / 2]);
		} else {
			direction = 'left';
			pos = pos.subtract(L.point(offset.x + tooltipWidth + anchor.x, tooltipHeight / 2 - anchor.y));
		}

		L.DomUtil.removeClass(container, 'leaflet-tooltip-right');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-left');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-top');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		L.DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		L.DomUtil.setPosition(container, pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), offset;
		if (this.options.offset) {
			offset = L.point(this.options.offset);
			pos = pos.add(offset);
		}
		L.DomUtil.setPosition(this._container, pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return L.point(this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
L.tooltip = function (options, source) {
	return new L.Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof L.Tooltip)) {
			tooltip = new L.Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});



/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
L.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof L.Tooltip) {
			L.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = L.tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent) { this.openTooltip(); }

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove) {
		if (!remove && this._tooltipHandlersAdded) { return; }
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (L.Browser.touch) {
				events.click = this._openTooltip;
			}
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive) {
				L.DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});



/*
 * Tooltip extension to L.Marker, adding tooltip-related methods.
 */

L.Marker.include({
	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});



/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, â€¦): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});


// @factory L.layerGroup(layers: Layer[])
// Create a layer group, optionally given an initial set of layers.
L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};



/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that also has mouse events (propagated from members of the group) and a shared bindPopup method.
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a group!'); })
 * 	.addTo(map);
 * ```
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};



/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 */

L.Renderer = L.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = L.DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			L.DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);
	},

	_update: function () {
		// update pixel bounds of renderer container (for positioning/sizing/clipping later)
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});


L.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});



/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

L.Path = L.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	getEvents: function () {
		return {
			zoomend: this._project,
			moveend: this._update,
			viewreset: this._reset
		};
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in children classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});



/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	pointToSegmentDistance:  function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},


	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	clipSegment: function (a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = this._getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, round);
	},

	_getBitCode: function (p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};



/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[-122.68, 45.51],
 * 	[-122.43, 37.77],
 * 	[-118.2, 34.04]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[-122.68, 45.51],
 * 	 [-122.43, 37.77],
 * 	 [-118.2, 34.04]],
 * 	[[-73.91, 40.78],
 * 	 [-87.62, 41.83],
 * 	 [-96.72, 32.76]]
 * ];
 * ```
 */

L.Polyline = L.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = L.latLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = L.Polyline._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new L.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};

L.Polyline._flat = function (latlngs) {
	// true if it's a flat array of latlngs; false if nested
	return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};



/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

L.PolyUtil = {};

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
L.PolyUtil.clipPolygon = function (points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};



/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one â€” it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *   [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *     [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 *   ],
 *   [ // second polygon
 *     [[-109.05, 37],[-109.03, 41],[-102.05, 41],[-102.04, 37],[-109.05, 38]]
 *   ]
 * ];
 * ```
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		L.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (L.Polyline._flat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};



/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};



/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

L.CircleMarker = L.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};



/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], 200).addTo(map);
 * ```
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = L.extend({}, legacyOptions, {radius: options});
		}
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
L.circle = function (latlng, options, legacyOptions) {
	return new L.Circle(latlng, options, legacyOptions);
};



/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg();
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.SVG = L.Renderer.extend({

	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = L.SVG.create('g');
		this._container.appendChild(this._rootGroup);
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			L.DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		L.DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	}
});


// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:
L.extend(L.SVG, {
	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	create: function (name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	},

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
		    i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

// @namespace Browser; @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);


// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};



/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// @namespace Browser; @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._container);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._container);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}



/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas();
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.Canvas = L.Renderer.extend({

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		this._layers = this._layers || {};

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
			.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		this._drawnLayers = {};

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: L.Util.falseFn,

	_removePath: function (layer) {
		layer._removed = true;
		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		this._redrawBounds = layer._pxBounds;
		this._draw(true);
		layer._project();
		layer._update();
		this._draw();
		this._redrawBounds = null;
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		var padding = (layer.options.weight || 0) + 1;
		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
		this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));

		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_redraw: function () {
		this._redrawRequest = null;

		this._draw(true); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_draw: function (clear) {
		this._clear = clear;
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
			this._ctx.clip();
		}

		for (var id in this._layers) {
			layer = this._layers[id];
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
			if (clear && layer._removed) {
				delete layer._removed;
				delete this._layers[id];
			}
		}
		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		if (ctx.setLineDash) {
			ctx.setLineDash(layer.options && layer.options._dashArray || []);
		}

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var clear = this._clear,
		    options = layer.options;

		ctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';

		if (options.fill) {
			ctx.globalAlpha = clear ? 1 : options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			ctx.globalAlpha = clear ? 1 : options.opacity;

			// if clearing shape, do it with the previously drawn line width
			layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;

			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layers = [], layer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				L.DomEvent._fakeStop(e);
				layers.push(layer);
			}
		}
		if (layers.length)  {
			this._fireEvent(layers, e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseOut(e, point);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e, point) {
		var layer = this._hoveredLayer;
		if (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var id, layer;

		for (id in this._drawnLayers) {
			layer = this._drawnLayers[id];
			if (layer.options.interactive && layer._containsPoint(point)) {
				L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([layer], e, 'mouseover');
				this._hoveredLayer = layer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	// TODO _bringToFront & _bringToBack, pretty tricky

	_bringToFront: L.Util.falseFn,
	_bringToBack: L.Util.falseFn
});

// @namespace Browser; @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @namespace Canvas
// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};



/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJson(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

L.GeoJSON = L.FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to show a feature or not.
	 * The default is to show all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @function addData( <GeoJSON> data ): Layer
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @function resetStyle( <Path> layer ): Layer
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = L.Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @function setStyle( <Function> style ): Layer
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:
L.extend(L.GeoJSON, {
	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	// @function latLngToCoords(latlng: LatLng): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	asFeature: function (geojson) {
		if (geojson.type === 'Feature') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
L.Polyline.prototype.toGeoJSON = function () {
	var multi = !L.Polyline._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
L.Polygon.prototype.toGeoJSON = function () {
	var holes = !L.Polyline._flat(this._latlngs),
	    multi = holes && !L.Polyline._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


// @namespace LayerGroup
L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `GeometryCollection`).
	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
L.geoJSON = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};
// Backward compatibility.
L.geoJson = L.geoJSON;



/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.



var eventsKey = '_leaflet_events';

L.DomEvent = {

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function. If no function is specified,
	// it will remove all the listeners of that particular DOM event from the element.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.addPointerListener(obj, type, handler, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (L.DomEvent._isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel', L.DomEvent.stopPropagation);
	},

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	// @function stop(ev): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` or to the whole page if not specified.
	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	_wheelPxFactor: (L.Browser.win && L.Browser.chrome) ? 2 :
	                L.Browser.gecko ? window.devicePixelRatio :
	                1,

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	getWheelDelta: function (e) {
		return (L.Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / L.DomEvent._wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_isExternalTarget: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		handler(e);
	}
};

// @function addListener(â€¦): this
// Alias to [`L.DomEvent.on`](#domevent-on)
L.DomEvent.addListener = L.DomEvent.on;

// @function removeListener(â€¦): this
// Alias to [`L.DomEvent.off`](#domevent-off)
L.DomEvent.removeListener = L.DomEvent.off;



/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

L.Draggable = L.Evented.extend({

	options: {
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline: Boolean)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches) || !this._enabled) { return; }
		L.Draggable._dragging = true;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			L.DomUtil.preventOutline(this._element);
		}

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);

		L.DomEvent
			.on(document, L.Draggable.MOVE[e.type], this._onMove, this)
			.on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		L.DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
				.off(document, L.Draggable.MOVE[i], this._onMove, this)
				.off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		L.Draggable._dragging = false;
	}
});



/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});



/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !L.Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/secondÂ².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		L.DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-grab');
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDown: function () {
		this._map._stop();
	},

	_onDragStart: function () {
		var map = this._map;

		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = L.latLngBounds(this._map.options.maxBounds);

			this._offsetLimit = L.bounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);



/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

L.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);



/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);



/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				count = L.DomEvent._pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd() {
			if (doubleTap && !touch.cancelBubble) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;
		obj[pre + 'dblclick' + id] = handler;

		obj.addEventListener(touchstart, onTouchStart, false);
		obj.addEventListener(touchend, onTouchEnd, false);

		// On some platforms (notably, chrome on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		if (!L.Browser.edge) {
			obj.addEventListener('dblclick', handler, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    touchstart = obj[pre + this._touchstart + id],
		    touchend = obj[pre + this._touchend + id],
		    dblclick = obj[pre + 'dblclick' + id];

		obj.removeEventListener(this._touchstart, touchstart, false);
		obj.removeEventListener(this._touchend, touchend, false);
		if (!L.Browser.edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}
});



/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
	TAG_WHITE_LIST: ['INPUT', 'SELECT', 'OPTION'],

	_pointers: {},
	_pointersCount: 0,

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (this.TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					L.DomEvent.preventDefault(e);
				} else {
					return;
				}
			}

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!this._pointerDocListener) {
			var pointerUp = L.bind(this._globalPointerUp, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
			document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
			document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
			document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

			this._pointerDocListener = true;
		}
	},

	_globalPointerDown: function (e) {
		this._pointers[e.pointerId] = e;
		this._pointersCount++;
	},

	_globalPointerMove: function (e) {
		if (this._pointers[e.pointerId]) {
			this._pointers[e.pointerId] = e;
		}
	},

	_globalPointerUp: function (e) {
		delete this._pointers[e.pointerId];
		this._pointersCount--;
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});



/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: L.Browser.touch && !L.Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;


		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);

		var moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);

		L.DomEvent.preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when snapZoom is off, so snapZoom becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.snapZoom);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);



/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}



/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_resetState: function () {
		this._moved = false;
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		this._resetState();

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		setTimeout(L.bind(this._resetState, this), 0);

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);



/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
L.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = L.point(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27) {
			map.closePopup();

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);



/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch).
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});



/*
 * @class Control
 * @aka L.Control
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});



/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

L.Control.Zoom = L.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '-'
		// The text set on the 'zoom out' button.
		zoomOutText: '-',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		L.DomEvent
		    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
		    .on(link, 'click', L.DomEvent.stop)
		    .on(link, 'click', fn, this)
		    .on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

L.Control.Attribution = L.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		if (L.DomEvent) {
			L.DomEvent.disableClickPropagation(this._container);
		}

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new L.Control.Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};



/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

L.Control.Scale = L.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
L.control.scale = function (options) {
	return new L.Control.Scale(options);
};



/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control.html)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */


L.Control.Layers = L.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		return this._container;
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(L.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		L.DomEvent.disableClickPropagation(container);
		if (!L.Browser.touch) {
			L.DomEvent.disableScrollPropagation(container);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}

			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this.expand, this);
			} else {
				L.DomEvent.on(link, 'focus', this.expand, this);
			}

			// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this.collapse, this);
			// TODO keyboard accessibility
		} else {
			this.expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return this; }

		L.DomUtil.empty(this._baseLayersList);
		L.DomUtil.empty(this._overlaysList);

		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(L.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				addedLayers.push(layer);

			} else if (!input.checked && hasLayer) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			this._map.removeLayer(removedLayers[i]);
		}
		for (i = 0; i < addedLayers.length; i++) {
			this._map.addLayer(addedLayers[i]);
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};



/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

L.PosAnimation = L.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		L.DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});



/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});



/*
 * Extends L.Map to handle zoom animations.
 */

// @namespace Map
// @section Animation Options
L.Map.mergeOptions({
	// @option zoomAnimation: Boolean = true
	// Whether the map zoom animation is enabled. By default it's enabled
	// in all browsers that support CSS3 Transitions except Android.
	zoomAnimation: true,

	// @option zoomAnimationThreshold: Number = 4
	// Won't animate zoom if the zoom difference exceeds this value.
	zoomAnimationThreshold: 4
});

var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;

if (zoomAnimated) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {

			this._createAnimProxy();

			L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!zoomAnimated ? {} : {

	_createAnimProxy: function () {

		var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = L.DomUtil.TRANSFORM,
			    transform = proxy.style[prop];

			L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    ._moveStart(true)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		L.Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});



// @namespace Map
// @section Methods for modifying map state
L.Map.include({

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/Pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !L.Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = L.latLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = L.Util.requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	}
});



/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

// @namespace Map

L.Map.include({
	// @section Geolocation methods
	_defaultLocateOptions: {
		timeout: 10000,
		watch: false
		// setView: false
		// maxZoom: <Number>
		// maximumAge: 0
		// enableHighAccuracy: false
	},

	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
		    onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	}
});



}(window, document));

},{}],14:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('emitter');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only verison of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pushEncodedKeyValuePair(pairs, key, obj[key]);
    }
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (Array.isArray(val)) {
    return val.forEach(function(v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  } else if (isObject(val)) {
    for(var subkey in val) {
      pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
    }
    return;
  }
  pairs.push(encodeURIComponent(key)
    + '=' + encodeURIComponent(val));
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */),
        key = parts.shift(),
        val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this._setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this._parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype._setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype._setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (res.status < 200 || res.status >= 300) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
        new_err.original = err;
        new_err.response = res;
        new_err.status = res.status;
      }
    } catch(e) {
      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype._timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */

Request.prototype._appendQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self._timeoutError();
      if (self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = 'download';
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  this._appendQueryString();

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn){
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":15,"./request":17,"./request-base":16,"emitter":10}],15:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],16:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

exports.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){
      self.end(function(err, res){
        if (err) innerReject(err); else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
}

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
exports.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

exports.withCredentials = function(){
  // This is browser-only functionality. Node side is no-op.
  this._withCredentials = true;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

exports.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

exports.toJSON = function(){
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

exports._isHost = function _isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

exports.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || this._isHost(data)) return this;

  // default to json
  if (!type) this.type('json');
  return this;
};

},{"./is-object":15}],17:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],18:[function(require,module,exports){
'use strict';

module.exports = TinyQueue;

function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (data) for (var i = Math.floor(this.length / 2); i >= 0; i--) this._down(i);
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

TinyQueue.prototype = {

    push: function (item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    },

    pop: function () {
        var top = this.data[0];
        this.data[0] = this.data[this.length - 1];
        this.length--;
        this.data.pop();
        this._down(0);
        return top;
    },

    peek: function () {
        return this.data[0];
    },

    _up: function (pos) {
        var data = this.data,
            compare = this.compare;

        while (pos > 0) {
            var parent = Math.floor((pos - 1) / 2);
            if (compare(data[pos], data[parent]) < 0) {
                swap(data, parent, pos);
                pos = parent;

            } else break;
        }
    },

    _down: function (pos) {
        var data = this.data,
            compare = this.compare,
            len = this.length;

        while (true) {
            var left = 2 * pos + 1,
                right = left + 1,
                min = pos;

            if (left < len && compare(data[left], data[min]) < 0) min = left;
            if (right < len && compare(data[right], data[min]) < 0) min = right;

            if (min === pos) return;

            swap(data, min, pos);
            pos = min;
        }
    }
};

function swap(data, i, j) {
    var tmp = data[i];
    data[i] = data[j];
    data[j] = tmp;
}

},{}],19:[function(require,module,exports){
var signedArea = require('./signed_area');

/**
 * @param  {SweepEvent} e1
 * @param  {SweepEvent} e2
 * @return {Number}
 */
module.exports = function sweepEventsComp(e1, e2) {
  var p1 = e1.point;
  var p2 = e2.point;

  // Different x-coordinate
  if (p1[0] > p2[0]) return 1;
  if (p1[0] < p2[0]) return -1;

  // Different points, but same x-coordinate
  // Event with lower y-coordinate is processed first
  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;

  return specialCases(e1, e2, p1, p2);
};


function specialCases(e1, e2, p1, p2) {
  // Same coordinates, but one is a left endpoint and the other is
  // a right endpoint. The right endpoint is processed first
  if (e1.left !== e2.left)
    return e1.left ? 1 : -1;

  // Same coordinates, both events
  // are left endpoints or right endpoints.
  // not collinear
  if (signedArea (p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {
    // the event associate to the bottom segment is processed first
    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;
  }
  return (!e1.isSubject && e2.isSubject) ? 1 : -1;
  //return e1.isSubject ? -1 : 1;
}
},{"./signed_area":25}],20:[function(require,module,exports){
var signedArea    = require('./signed_area');
var compareEvents = require('./compare_events');
var equals        = require('./equals');


/**
 * @param  {SweepEvent} le1
 * @param  {SweepEvent} le2
 * @return {Number}
 */
module.exports = function compareSegments(le1, le2) {
  if (le1 === le2) return 0;

  // Segments are not collinear
  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||
    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {

    // If they share their left endpoint use the right endpoint to sort
    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;

    // Different left endpoint: use the left endpoint to sort
    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;

    // has the line segment associated to e1 been inserted
    // into S after the line segment associated to e2 ?
    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;

    // The line segment associated to e2 has been inserted
    // into S after the line segment associated to e1
    return le1.isBelow(le2.point) ? -1 : 1;
  }

  // Segments are collinear
  if (le1.isSubject !== le2.isSubject) return (le1.isSubject && !le2.isSubject) ? 1 : -1;

  // Just a consistent criterion is used
  if (equals(le1.point, le2.point)) return 0;

  return compareEvents(le1, le2) === 1 ? 1 : -1;
};

},{"./compare_events":19,"./equals":22,"./signed_area":25}],21:[function(require,module,exports){
module.exports = { 
  NORMAL:               0, 
  NON_CONTRIBUTING:     1, 
  SAME_TRANSITION:      2, 
  DIFFERENT_TRANSITION: 3
};

},{}],22:[function(require,module,exports){
module.exports = function equals(p1, p2) {
  return p1[0] === p2[0] && p1[1] === p2[1];
};
},{}],23:[function(require,module,exports){
var INTERSECTION    = 0;
var UNION           = 1;
var DIFFERENCE      = 2;
var XOR             = 3;

var EMPTY           = [];

var edgeType        = require('./edge_type');

var Queue           = require('tinyqueue');
var Tree            = require('bintrees').RBTree;
var SweepEvent      = require('./sweep_event');

var compareEvents   = require('./compare_events');
var compareSegments = require('./compare_segments');
var intersection    = require('./segment_intersection');
var equals          = require('./equals');

var max = Math.max;
var min = Math.min;

/**
 * @param  {<Array.<Number>} s1
 * @param  {<Array.<Number>} s2
 * @param  {Boolean}         isSubject
 * @param  {Queue}           eventQueue
 * @param  {Array.<Number>}  bbox
 */
function processSegment(s1, s2, isSubject, eventQueue, bbox) {
  // Possible degenerate condition.
  if (equals(s1, s2)) return;

  var e1 = new SweepEvent(s1, false, undefined, isSubject);
  var e2 = new SweepEvent(s2, false, e1,        isSubject);
  e1.otherEvent = e2;

  if (compareEvents(e1, e2) > 0) {
    e2.left = true;
  } else {
    e1.left = true;
  }

  bbox[0] = min(bbox[0], s1[0]);
  bbox[1] = min(bbox[1], s1[1]);
  bbox[2] = max(bbox[2], s1[0]);
  bbox[3] = max(bbox[3], s1[1]);

  // Pushing it so the queue is sorted from left to right,
  // with object on the left having the highest priority.
  eventQueue.push(e1);
  eventQueue.push(e2);
}


function processPolygon(polygon, isSubject, queue, bbox) {
  var i, len;
  if (typeof polygon[0][0] === 'number') {
    for (i = 0, len = polygon.length - 1; i < len; i++) {
      processSegment(polygon[i], polygon[i + 1], isSubject, queue, bbox);
    }
  } else {
    for (i = 0, len = polygon.length; i < len; i++) {
      processPolygon(polygon[i], isSubject, queue, bbox);
    }
  }
}


function fillQueue(subject, clipping, sbbox, cbbox) {
  var eventQueue = new Queue(null, compareEvents);

  processPolygon(subject,  true,  eventQueue, sbbox);
  processPolygon(clipping, false, eventQueue, cbbox);

  return eventQueue;
}


function computeFields(event, prev, sweepLine, operation) {
  // compute inOut and otherInOut fields
  if (prev === null) {
    event.inOut      = false;
    event.otherInOut = true;

  // previous line segment in sweepline belongs to the same polygon
  } else if (event.isSubject === prev.isSubject) {
    event.inOut      = !prev.inOut;
    event.otherInOut = prev.otherInOut;

  // previous line segment in sweepline belongs to the clipping polygon
  } else {
    event.inOut      = !prev.otherInOut;
    event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;
  }

  // compute prevInResult field
  if (prev) {
    event.prevInResult = (!inResult(prev, operation) || prev.isVertical()) ?
       prev.prevInResult : prev;
  }
  // check if the line segment belongs to the Boolean operation
  event.inResult = inResult(event, operation);
}


function inResult(event, operation) {
  switch (event.type) {
    case edgeType.NORMAL:
      switch (operation) {
        case INTERSECTION:
          return !event.otherInOut;
        case UNION:
          return event.otherInOut;
        case DIFFERENCE:
          return (event.isSubject && event.otherInOut) ||
                 (!event.isSubject && !event.otherInOut);
        case XOR:
          return true;
      }
    case edgeType.SAME_TRANSITION:
      return operation === INTERSECTION || operation === UNION;
    case edgeType.DIFFERENT_TRANSITION:
      return operation === DIFFERENCE;
    case edgeType.NON_CONTRIBUTING:
      return false;
  }
  return false;
}


/**
 * @param  {SweepEvent} se1
 * @param  {SweepEvent} se2
 * @param  {Queue}      queue
 * @return {Number}
 */
function possibleIntersection(se1, se2, queue) {
  // that disallows self-intersecting polygons,
  // did cost us half a day, so I'll leave it
  // out of respect
  // if (se1.isSubject === se2.isSubject) return;

  var inter = intersection(
    se1.point, se1.otherEvent.point,
    se2.point, se2.otherEvent.point
  );

  var nintersections = inter ? inter.length : 0;
  if (nintersections === 0) return 0; // no intersection

  // the line segments intersect at an endpoint of both line segments
  if ((nintersections === 1) &&
      (equals(se1.point, se2.point) ||
       equals(se1.otherEvent.point, se2.otherEvent.point))) {
    return 0;
  }

  if (nintersections === 2 && se1.isSubject === se2.isSubject) {
    console.warn(se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);
    throw new Error('Edges of the same polygon overlap');
  }

  // The line segments associated to se1 and se2 intersect
  if (nintersections === 1) {

    // if the intersection point is not an endpoint of se1
    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {
      divideSegment(se1, inter[0], queue);
    }

    // if the intersection point is not an endpoint of se2
    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {
      divideSegment(se2, inter[0], queue);
    }
    return 1;
  }

  // The line segments associated to se1 and se2 overlap
  var events        = [];
  var leftCoincide  = false;
  var rightCoincide = false;

  if (equals(se1.point, se2.point)) {
    leftCoincide = true; // linked
  } else if (compareEvents(se1, se2) === 1) {
    events.push(se2, se1);
  } else {
    events.push(se1, se2);
  }

  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {
    rightCoincide = true;
  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {
    events.push(se2.otherEvent, se1.otherEvent);
  } else {
    events.push(se1.otherEvent, se2.otherEvent);
  }

  if ((leftCoincide && rightCoincide) || leftCoincide) {
    // both line segments are equal or share the left endpoint
    se1.type = edgeType.NON_CONTRIBUTING;
    se2.type = (se1.inOut === se2.inOut) ?
      edgeType.SAME_TRANSITION :
      edgeType.DIFFERENT_TRANSITION;

    if (leftCoincide && !rightCoincide) {
      divideSegment(events[2].otherEvent, events[1].point, queue);
    }
    return 2;
  }

  // the line segments share the right endpoint
  if (rightCoincide) {
    divideSegment(events[0], events[1].point, queue);
    return 3;
  }

  // no line segment includes totally the other one
  if (events[0] !== events[3].otherEvent) {
    divideSegment(events[0], events[1].point, queue);
    divideSegment(events[1], events[2].point, queue);
    return 3;
  }

  // one line segment includes the other one
  divideSegment(events[0], events[1].point, queue);
  divideSegment(events[3].otherEvent, events[2].point, queue);

  return 3;
}


/**
 * @param  {SweepEvent} se
 * @param  {Array.<Number>} p
 * @param  {Queue} queue
 * @return {Queue}
 */
function divideSegment(se, p, queue)  {
  var r = new SweepEvent(p, false, se,            se.isSubject);
  var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);

  // avoid a rounding error. The left event would be processed after the right event
  if (compareEvents(l, se.otherEvent) > 0) {
    se.otherEvent.left = true;
    l.left = false;
  }

  // avoid a rounding error. The left event would be processed after the right event
  // if (compareEvents(se, r) > 0) {}

  se.otherEvent.otherEvent = l;
  se.otherEvent = r;

  queue.push(l);
  queue.push(r);

  return queue;
}


/* eslint-disable no-unused-vars, no-debugger */
function iteratorEquals(it1, it2) {
  return it1._cursor === it2._cursor;
}


function _renderSweepLine(sweepLine, pos, event) {
  var map = window.map;
  if (!map) return;
  if (window.sws) window.sws.forEach(function(p) {
    map.removeLayer(p);
  });
  window.sws = [];
  sweepLine.each(function(e) {
    var poly = L.polyline([e.point.slice().reverse(), e.otherEvent.point.slice().reverse()], { color: 'green' }).addTo(map);
    window.sws.push(poly);
  });

  if (window.vt) map.removeLayer(window.vt);
  var v = pos.slice();
  var b = map.getBounds();
  window.vt = L.polyline([[b.getNorth(), v[0]], [b.getSouth(), v[0]]], {color: 'green', weight: 1}).addTo(map);

  if (window.ps) map.removeLayer(window.ps);
  window.ps = L.polyline([event.point.slice().reverse(), event.otherEvent.point.slice().reverse()], {color: 'black', weight: 9, opacity: 0.4}).addTo(map);
  debugger;
}
/* eslint-enable no-unused-vars, no-debugger */


function subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation) {
  var sortedEvents = [];
  var prev, next;

  var sweepLine = new Tree(compareSegments);
  var sortedEvents = [];

  var rightbound = min(sbbox[2], cbbox[2]);

  var prev, next;

  while (eventQueue.length) {
    var event = eventQueue.pop();
    sortedEvents.push(event);

    // optimization by bboxes for intersection and difference goes here
    if ((operation === INTERSECTION && event.point[0] > rightbound) ||
        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {
      break;
    }

    if (event.left) {
      sweepLine.insert(event);
      // _renderSweepLine(sweepLine, event.point, event);

      next = sweepLine.findIter(event);
      prev = sweepLine.findIter(event);
      event.iterator = sweepLine.findIter(event);

      if (prev.data() !== sweepLine.min()) {
        prev.prev();
      } else {
        prev = sweepLine.findIter(sweepLine.max());
        prev.next();
      }
      next.next();

      computeFields(event, prev.data(), sweepLine, operation);

      if (next.data()) {
        if (possibleIntersection(event, next.data(), eventQueue) === 2) {
          computeFields(event, prev.data(), sweepLine, operation);
          computeFields(event, next.data(), sweepLine, operation);
        }
      }

      if (prev.data()) {
        if (possibleIntersection(prev.data(), event, eventQueue) === 2) {
          var prevprev = sweepLine.findIter(prev.data());
          if (prevprev.data() !== sweepLine.min()) {
            prevprev.prev();
          } else {
            prevprev = sweepLine.findIter(sweepLine.max());
            prevprev.next();
          }
          computeFields(prev.data(), prevprev.data(), sweepLine, operation);
          computeFields(event, prev.data(), sweepLine, operation);
        }
      }
    } else {
      event = event.otherEvent;
      next = sweepLine.findIter(event);
      prev = sweepLine.findIter(event);

      // _renderSweepLine(sweepLine, event.otherEvent.point, event);

      if (!(prev && next)) continue;

      if (prev.data() !== sweepLine.min()) {
        prev.prev();
      } else {
        prev = sweepLine.findIter(sweepLine.max());
        prev.next();
      }
      next.next();
      sweepLine.remove(event);

      //_renderSweepLine(sweepLine, event.otherEvent.point, event);

      if (next.data() && prev.data()) {
        possibleIntersection(prev.data(), next.data(), eventQueue);
      }
    }
  }
  return sortedEvents;
}


function swap (arr, i, n) {
  var temp = arr[i];
  arr[i] = arr[n];
  arr[n] = temp;
}


function changeOrientation(contour) {
  return contour.reverse();
}


function isArray (arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
}


function addHole(contour, idx) {
  if (!isArray(contour[0][0])) {
    contour = [contour];
  }
  contour[idx] = [];
  return contour;
}


function connectEdges(sortedEvents) {
  // copy the events in the result polygon to resultEvents array
  var resultEvents = [];
  var event, i, len;

  for (i = 0, len = sortedEvents.length; i < len; i++) {
    event = sortedEvents[i];
    if ((event.left && event.inResult) ||
      (!event.left && event.otherEvent.otherEvent.inResult)) {
      resultEvents.push(event);
      resultEvents.push(event.otherEvent);
    }
  }

  // Due to overlapping edges the resultEvents array can be not wholly sorted
  var sorted = false;
  while (!sorted) {
    sorted = true;
    for (i = 0, len = resultEvents.length; i < len; i++) {
      if ((i + 1) < len &&
        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {
        swap(resultEvents, i, i + 1);
        sorted = false;
      }
    }
  }

  for (i = 0, len = resultEvents.length; i < len; i++) {
    resultEvents[i].pos = i;
    if (!resultEvents[i].left) {
      var temp = resultEvents[i].pos;
      resultEvents[i].pos = resultEvents[i].otherEvent.pos;
      resultEvents[i].otherEvent.pos = temp;
    }
  }

  // "false"-filled array
  var processed = Array(resultEvents.length);
  var result = [];

  var depth  = [];
  var holeOf = [];
  var isHole = {};

  for (i = 0, len = resultEvents.length; i < len; i++) {
    if (processed[i]) continue;

    var contour = [];
    result.push(contour);

    var contourId = result.length - 1;
    depth.push(0);
    holeOf.push(-1);


    if (resultEvents[i].prevInResult) {
      var lowerContourId = resultEvents[i].prevInResult.contourId;
      if (!resultEvents[i].prevInResult.resultInOut) {
        addHole(result[lowerContourId], contourId);
        holeOf[contourId] = lowerContourId;
        depth[contourId]  = depth[lowerContourId] + 1;
        isHole[contourId] = true;
      } else if (isHole[lowerContourId]) {
        addHole(result[holeOf[lowerContourId]], contourId);
        holeOf[contourId] = holeOf[lowerContourId];
        depth[contourId]  = depth[lowerContourId];
        isHole[contourId] = true;
      }
    }

    var pos = i;
    var initial = resultEvents[i].point;
    contour.push(initial);

    try {
    while (!equals(resultEvents[pos].otherEvent.point, initial)) {
      processed[pos] = true;

      if (resultEvents[pos].left) {
        resultEvents[pos].resultInOut = false;
        resultEvents[pos].contourId   = contourId;
      } else {
        resultEvents[pos].otherEvent.resultInOut = true;
        resultEvents[pos].otherEvent.contourId   = contourId;
      }

      pos = resultEvents[pos].pos;
      processed[pos] = true;

      contour.push(resultEvents[pos].point);
      pos = nextPos(pos, resultEvents, processed);
    }

    processed[pos] = processed[resultEvents[pos].pos] = true;
    resultEvents[pos].otherEvent.resultInOut = true;
    resultEvents[pos].otherEvent.contourId   = contourId;

    } catch (e) {
      console.log(pos || 0, resultEvents, resultEvents.length, e);
    }

    // depth is even
    /* eslint-disable no-bitwise */
    if (depth[contourId] & 1) {
      changeOrientation(contour);
    }
    /* eslint-enable no-bitwise */
  }

  return result;
}


/**
 * @param  {Number} pos
 * @param  {Array.<SweepEvent>} resultEvents
 * @param  {Array.<Boolean>}    processed
 * @return {Number}
 */
function nextPos(pos, resultEvents, processed) {
  var newPos = pos + 1;
  while (newPos < resultEvents.length
    && equals(resultEvents[newPos].point, resultEvents[pos].point)) {
    if (!processed[newPos]) {
      return newPos;
    } else {
      newPos = newPos + 1;
    }
  }

  newPos = pos - 1;

  while (processed[newPos]) {
    newPos = newPos - 1;
  }
  return newPos;
}


function trivialOperation(subject, clipping, operation) {
  var result = null;
  if (subject.length * clipping.length === 0) {
    if (operation === INTERSECTION) {
      result = EMPTY;
    } else if (operation === DIFFERENCE) {
      result = subject;
    } else if (operation === UNION || operation === XOR) {
      result = (subject.length === 0) ? clipping : subject;
    }
  }
  return result;
}


function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {
  var result = null;
  if (sbbox[0] > cbbox[2] ||
      cbbox[0] > sbbox[2] ||
      sbbox[1] > cbbox[3] ||
      cbbox[1] > sbbox[3]) {
    if (operation === INTERSECTION) {
      result = EMPTY;
    } else if (operation === DIFFERENCE) {
      result = subject;
    } else if (operation === UNION || operation === XOR) {
      result = subject.concat(clipping);
    }
  }
  return result;
}


function boolean(subject, clipping, operation) {
  var trivial = trivialOperation(subject, clipping, operation);
  if (trivial) {
    return trivial === EMPTY ? null : trivial;
  }
  var sbbox = [Infinity, Infinity, -Infinity, -Infinity];
  var cbbox = [Infinity, Infinity, -Infinity, -Infinity];

  var eventQueue = fillQueue(subject, clipping, sbbox, cbbox);

  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);
  if (trivial) {
    return trivial === EMPTY ? null : trivial;
  }
  var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);
  return connectEdges(sortedEvents);
}


module.exports = boolean;


module.exports.union = function(subject, clipping) {
  return boolean(subject, clipping, UNION);
};


module.exports.diff = function(subject, clipping) {
  return boolean(subject, clipping, DIFFERENCE);
};


module.exports.xor = function(subject, clipping) {
  return boolean(subject, clipping, XOR);
};


module.exports.intersection = function(subject, clipping) {
  return boolean(subject, clipping, INTERSECTION);
};


/**
 * @enum {Number}
 */
module.exports.operations = {
  INTERSECTION: INTERSECTION,
  DIFFERENCE:   DIFFERENCE,
  UNION:        UNION,
  XOR:          XOR
};


// for testing
module.exports.fillQueue            = fillQueue;
module.exports.computeFields        = computeFields;
module.exports.subdivideSegments    = subdivideSegments;
module.exports.divideSegment        = divideSegment;
module.exports.possibleIntersection = possibleIntersection;

},{"./compare_events":19,"./compare_segments":20,"./edge_type":21,"./equals":22,"./segment_intersection":24,"./sweep_event":26,"bintrees":6,"tinyqueue":18}],24:[function(require,module,exports){
var EPSILON = 1e-9;

/**
 * Finds the magnitude of the cross product of two vectors (if we pretend
 * they're in three dimensions)
 *
 * @param {Object} a First vector
 * @param {Object} b Second vector
 * @private
 * @returns {Number} The magnitude of the cross product
 */
function krossProduct(a, b) {
  return a[0] * b[1] - a[1] * b[0];
}

/**
 * Finds the dot product of two vectors.
 *
 * @param {Object} a First vector
 * @param {Object} b Second vector
 * @private
 * @returns {Number} The dot product
 */
function dotProduct(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Finds the intersection (if any) between two line segments a and b, given the
 * line segments' end points a1, a2 and b1, b2.
 *
 * This algorithm is based on Schneider and Eberly.
 * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf
 * Page 244.
 *
 * @param {Array.<Number>} a1 point of first line
 * @param {Array.<Number>} a2 point of first line
 * @param {Array.<Number>} b1 point of second line
 * @param {Array.<Number>} b2 point of second line
 * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints
 *                                         (meaning connected segments) as
 *                                         intersections
 * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of
 * intersection. If they overlap, the two end points of the overlapping segment.
 * Otherwise, null.
 */
module.exports = function(a1, a2, b1, b2, noEndpointTouch) {
  // The algorithm expects our lines in the form P + sd, where P is a point,
  // s is on the interval [0, 1], and d is a vector.
  // We are passed two points. P can be the first point of each pair. The
  // vector, then, could be thought of as the distance (in x and y components)
  // from the first point to the second point.
  // So first, let's make our vectors:
  var va = [a2[0] - a1[0], a2[1] - a1[1]];
  var vb = [b2[0] - b1[0], b2[1] - b1[1]];
  // We also define a function to convert back to regular point form:

  /* eslint-disable arrow-body-style */

  function toPoint(p, s, d) {
    return [
      p[0] + s * d[0],
      p[1] + s * d[1]
    ];
  }

  /* eslint-enable arrow-body-style */

  // The rest is pretty much a straight port of the algorithm.
  var e = [b1[0] - a1[0], b1[1] - a1[1]];
  var kross = krossProduct(va, vb);
  var sqrKross = kross * kross;
  var sqrLenA = dotProduct(va, va);
  var sqrLenB = dotProduct(vb, vb);

  // Check for line intersection. This works because of the properties of the
  // cross product -- specifically, two vectors are parallel if and only if the
  // cross product is the 0 vector. The full calculation involves relative error
  // to account for possible very small line segments. See Schneider & Eberly
  // for details.
  if (sqrKross > EPSILON * sqrLenA * sqrLenB) {
    // If they're not parallel, then (because these are line segments) they
    // still might not actually intersect. This code checks that the
    // intersection point of the lines is actually on both line segments.
    var s = krossProduct(e, vb) / kross;
    if (s < 0 || s > 1) {
      // not on line segment a
      return null;
    }
    var t = krossProduct(e, va) / kross;
    if (t < 0 || t > 1) {
      // not on line segment b
      return null;
    }
    return noEndpointTouch ? null : [toPoint(a1, s, va)];
  }

  // If we've reached this point, then the lines are either parallel or the
  // same, but the segments could overlap partially or fully, or not at all.
  // So we need to find the overlap, if any. To do that, we can use e, which is
  // the (vector) difference between the two initial points. If this is parallel
  // with the line itself, then the two lines are the same line, and there will
  // be overlap.
  var sqrLenE = dotProduct(e, e);
  kross = krossProduct(e, va);
  sqrKross = kross * kross;

  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {
    // Lines are just parallel, not the same. No overlap.
    return null;
  }

  var sa = dotProduct(va, e) / sqrLenA;
  var sb = sa + dotProduct(va, vb) / sqrLenA;
  var smin = Math.min(sa, sb);
  var smax = Math.max(sa, sb);

  // this is, essentially, the FindIntersection acting on floats from
  // Schneider & Eberly, just inlined into this function.
  if (smin <= 1 && smax >= 0) {

    // overlap on an end point
    if (smin === 1) {
      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];
    }

    if (smax === 0) {
      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];
    }

    if (noEndpointTouch && smin === 0 && smax === 1) return null;

    // There's overlap on a segment -- two points of intersection. Return both.
    return [
      toPoint(a1, smin > 0 ? smin : 0, va),
      toPoint(a1, smax < 1 ? smax : 1, va),
    ];
  }

  return null;
};

},{}],25:[function(require,module,exports){
/**
 * Signed area of the triangle (p0, p1, p2)
 * @param  {Array.<Number>} p0
 * @param  {Array.<Number>} p1
 * @param  {Array.<Number>} p2
 * @return {Number}
 */
module.exports = function signedArea(p0, p1, p2) {
  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);
};

},{}],26:[function(require,module,exports){
var signedArea = require('./signed_area');
var EdgeType   = require('./edge_type');


/**
 * Sweepline event
 *
 * @param {Array.<Number>}  point
 * @param {Boolean}         left
 * @param {SweepEvent=}     otherEvent
 * @param {Boolean}         isSubject
 * @param {Number}          edgeType
 */
function SweepEvent(point, left, otherEvent, isSubject, edgeType) {

  /**
   * Is left endpoint?
   * @type {Boolean}
   */
  this.left = left;

  /**
   * @type {Array.<Number>}
   */
  this.point = point;

  /**
   * Other edge reference
   * @type {SweepEvent}
   */
  this.otherEvent = otherEvent;

  /**
   * Belongs to source or clipping polygon
   * @type {Boolean}
   */
  this.isSubject = isSubject;

  /**
   * Edge contribution type
   * @type {Number}
   */
  this.type = edgeType || EdgeType.NORMAL;


  /**
   * In-out transition for the sweepline crossing polygon
   * @type {Boolean}
   */
  this.inOut = false;


  /**
   * @type {Boolean}
   */
  this.otherInOut = false;

  /**
   * Previous event in result?
   * @type {SweepEvent}
   */
  this.prevInResult = null;

  /**
   * Does event belong to result?
   * @type {Boolean}
   */
  this.inResult = false;


  // connection step

  /**
   * @type {Boolean}
   */
  this.resultInOut = false;
}


SweepEvent.prototype = {

  /**
   * @param  {Array.<Number>}  p
   * @return {Boolean}
   */
  isBelow: function(p) {
    return this.left ?
      signedArea (this.point, this.otherEvent.point, p) > 0 :
      signedArea (this.otherEvent.point, this.point, p) > 0;
  },


  /**
   * @param  {Array.<Number>}  p
   * @return {Boolean}
   */
  isAbove: function(p) {
    return !this.isBelow(p);
  },


  /**
   * @return {Boolean}
   */
  isVertical: function() {
    return this.point[0] === this.otherEvent.point[0];
  }
};

module.exports = SweepEvent;

},{"./edge_type":21,"./signed_area":25}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vL2pzL2Jvb2xlYW5vcGNvbnRyb2wuanMiLCJkZW1vL2pzL2Nvb3JkaW5hdGVzLmpzIiwiZGVtby9qcy9pbmRleC5qcyIsImRlbW8vanMvcG9seWdvbmNvbnRyb2wuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW50cmVlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW50cmVlcy9saWIvYmludHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9iaW50cmVlcy9saWIvcmJ0cmVlLmpzIiwibm9kZV9tb2R1bGVzL2JpbnRyZWVzL2xpYi90cmVlYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3RzL2Rpc3QvanN0cy5taW4uanMiLCJub2RlX21vZHVsZXMvbGVhZmxldC1lZGl0YWJsZS9zcmMvTGVhZmxldC5FZGl0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy90aW55cXVldWUvaW5kZXguanMiLCJzcmMvY29tcGFyZV9ldmVudHMuanMiLCJzcmMvY29tcGFyZV9zZWdtZW50cy5qcyIsInNyYy9lZGdlX3R5cGUuanMiLCJzcmMvZXF1YWxzLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3NlZ21lbnRfaW50ZXJzZWN0aW9uLmpzIiwic3JjL3NpZ25lZF9hcmVhLmpzIiwic3JjL3N3ZWVwX2V2ZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdzWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzk4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiTC5Cb29sZWFuQ29udHJvbCA9IEwuQ29udHJvbC5leHRlbmQoe1xuICBvcHRpb25zOiB7XG4gICAgcG9zaXRpb246ICd0b3ByaWdodCdcbiAgfSxcblxuICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWJhcicpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kID0gJyNmZmZmZmYnO1xuICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBbXG4gICAgICAnPGZvcm0+JyxcbiAgICAgICAgJzx1bCBzdHlsZT1cImxpc3Qtc3R5bGU6bm9uZTsgcGFkZGluZy1sZWZ0OiAwXCI+JyxcbiAgICAgICAgICAnPGxpPicsJzxsYWJlbD4nLCAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJvcFwiIHZhbHVlPVwiMFwiIGNoZWNrZWQgLz4nLCAgJyBJbnRlcnNlY3Rpb24nLCAnPC9sYWJlbD4nLCAnPC9saT4nLFxuICAgICAgICAgICc8bGk+JywnPGxhYmVsPicsICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cIm9wXCIgdmFsdWU9XCIxXCIgLz4nLCAgJyBVbmlvbicsICc8L2xhYmVsPicsICc8L2xpPicsXG4gICAgICAgICAgJzxsaT4nLCc8bGFiZWw+JywgJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwib3BcIiB2YWx1ZT1cIjJcIiAvPicsICAnIERpZmZlcmVuY2UnLCAnPC9sYWJlbD4nLCAnPC9saT4nLFxuICAgICAgICAgICc8bGk+JywnPGxhYmVsPicsICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cIm9wXCIgdmFsdWU9XCIzXCIgLz4nLCAgJyBYb3InLCAnPC9sYWJlbD4nLCAnPC9saT4nLFxuICAgICAgICAnPC91bD4nLFxuICAgICAgICAnPGlucHV0IHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIlJ1blwiPicsICc8aW5wdXQgbmFtZT1cImNsZWFyXCIgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwiQ2xlYXIgbGF5ZXJzXCI+JyxcbiAgICAgICc8L2Zvcm0+J10uam9pbignJyk7XG4gICAgdmFyIGZvcm0gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignZm9ybScpO1xuICAgIEwuRG9tRXZlbnRcbiAgICAgIC5vbihmb3JtLCAnc3VibWl0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBMLkRvbUV2ZW50LnN0b3AoZXZ0KTtcbiAgICAgICAgdmFyIHJhZGlvcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgICAgICAgIGZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1yYWRpb10nKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYWRpb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocmFkaW9zW2ldLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jYWxsYmFjayhwYXJzZUludChyYWRpb3NbaV0udmFsdWUpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcylcbiAgICAgIC5vbihmb3JtWydjbGVhciddLCAnY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgTC5Eb21FdmVudC5zdG9wKGV2dCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jbGVhcigpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICBMLkRvbUV2ZW50XG4gICAgICAuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKVxuICAgICAgLmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIH1cblxufSk7IiwiTC5Db29yZGluYXRlcyA9IEwuQ29udHJvbC5leHRlbmQoe1xuICBvcHRpb25zOiB7XG4gICAgcG9zaXRpb246ICdib3R0b21yaWdodCdcbiAgfSxcblxuICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtYmFyJyk7XG4gICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSAnI2ZmZmZmZic7XG4gICAgbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgfSxcblxuICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwicGFkZGluZzogNXB4XCI+JyArXG4gICAgICBlLmxhdGxuZy5sbmcgKyAnLCAnICsgZS5sYXRsbmcubGF0ICsgJzwvc3Bhbj4nO1xuICB9XG5cbn0pOyIsInZhciBMID0gcmVxdWlyZSgnbGVhZmxldCcpO1xudmFyIExlYWZsZXRFZGl0YWJsZSA9IHJlcXVpcmUoJ2xlYWZsZXQtZWRpdGFibGUnKTtcbnJlcXVpcmUoJy4vY29vcmRpbmF0ZXMnKTtcbnJlcXVpcmUoJy4vcG9seWdvbmNvbnRyb2wnKTtcbnJlcXVpcmUoJy4vYm9vbGVhbm9wY29udHJvbCcpO1xudmFyIG1hcnRpbmV6ID0gcmVxdWlyZSgnLi4vLi4vJyk7XG52YXIgeGhyID0gcmVxdWlyZSgnc3VwZXJhZ2VudCcpO1xuLy8gdmFyIHR1cmYgPSByZXF1aXJlKCd0dXJmJyk7XG52YXIganN0cyA9IHdpbmRvdy5qc3RzID0gcmVxdWlyZSgnanN0cycpO1xuXG52YXIgbW9kZSA9IC9nZW8vLnRlc3Qod2luZG93LmxvY2F0aW9uLmhhc2gpID8gJ2dlbycgOiAnb3J0aG9nb25hbCc7XG5cbmNvbnNvbGUubG9nKG1vZGUpO1xuXG52YXIgcGF0aCA9ICcuLi90ZXN0L2ZpeHR1cmVzLyc7XG52YXIgZmlsZSA9IG1vZGUgPT09ICdnZW8nID8gJ2FzaWEuanNvbicgOiAnaG9yc2VzaG9lLmpzb24nO1xuXG5cblxudmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuZGl2LmlkID0gJ2ltYWdlLW1hcCc7XG5kaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4vLyBjcmVhdGUgdGhlIHNsaXBweSBtYXBcbnZhciBtYXAgPSB3aW5kb3cubWFwID0gTC5tYXAoJ2ltYWdlLW1hcCcsIHtcbiAgbWluWm9vbTogMSxcbiAgbWF4Wm9vbTogMjAsXG4gIGNlbnRlcjogWzAsIDBdLFxuICB6b29tOiAxLFxuICBjcnM6IG1vZGUgPT09ICdnZW8nID8gTC5DUlMuRVBTRzQzMjYgOiBMLkNSUy5TaW1wbGUsXG4gIGVkaXRhYmxlOiB0cnVlXG59KTtcblxubWFwLmFkZENvbnRyb2wobmV3IEwuTmV3UG9seWdvbkNvbnRyb2woe1xuICBjYWxsYmFjazogbWFwLmVkaXRUb29scy5zdGFydFBvbHlnb25cbn0pKTtcbm1hcC5hZGRDb250cm9sKG5ldyBMLkNvb3JkaW5hdGVzKCkpO1xubWFwLmFkZENvbnRyb2wobmV3IEwuQm9vbGVhbkNvbnRyb2woe1xuICBjYWxsYmFjazogcnVuLFxuICBjbGVhcjogY2xlYXJcbn0pKTtcblxudmFyIGRyYXduSXRlbXMgPSB3aW5kb3cuZHJhd25JdGVtcyA9IEwuZ2VvSnNvbigpLmFkZFRvKG1hcCk7XG5cbmZ1bmN0aW9uIGxvYWREYXRhKHBhdGgpIHtcbiAgY29uc29sZS5sb2cocGF0aCk7XG4gIC8vIHZhciB0d29fdHJpYW5nbGVzID0gcmVxdWlyZSgnLi4vLi4vdGVzdC9maXh0dXJlcy90d29fc2hhcGVzLmpzb24nKTtcbiAgLy8gdmFyIG9uZUluc2lkZSA9IHJlcXVpcmUoJy4uLy4uL3Rlc3QvZml4dHVyZXMvb25lX2luc2lkZS5qc29uJyk7XG4gIC8vIHZhciB0d29Qb2ludGVkVHJpYW5nbGVzID0gcmVxdWlyZSgnLi4vLi4vdGVzdC9maXh0dXJlcy90d29fcG9pbnRlZF90cmlhbmdsZXMuanNvbicpO1xuICAvLyB2YXIgc2VsZkludGVyc2VjdGluZyA9IHJlcXVpcmUoJy4uLy4uL3Rlc3QvZml4dHVyZXMvc2VsZl9pbnRlcnNlY3RpbmcuanNvbicpO1xuICAvLyB2YXIgaG9sZXMgPSByZXF1aXJlKCcuLi8uLi90ZXN0L2ZpeHR1cmVzL2hvbGVfaG9sZS5qc29uJyk7XG4gIC8vdmFyIGRhdGEgPSAgcmVxdWlyZSgnLi4vLi4vdGVzdC9maXh0dXJlcy9pbmRvbmVzaWEuanNvbicpO1xuICB4aHJcbiAgICAuZ2V0KHBhdGgpXG4gICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgIC5lbmQoZnVuY3Rpb24oZSwgcikge1xuICAgICAgaWYgKCFlKSB7XG4gICAgICAgIGRyYXduSXRlbXMuYWRkRGF0YShyLmJvZHkpO1xuICAgICAgICBtYXAuZml0Qm91bmRzKGRyYXduSXRlbXMuZ2V0Qm91bmRzKCkucGFkKDAuMDUpLCB7IGFuaW1hdGU6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgZHJhd25JdGVtcy5jbGVhckxheWVycygpO1xuICByZXN1bHRzLmNsZWFyTGF5ZXJzKCk7XG59XG5cbnZhciByZWFkZXIgPSBuZXcganN0cy5pby5HZW9KU09OUmVhZGVyKCk7XG52YXIgd3JpdGVyID0gbmV3IGpzdHMuaW8uR2VvSlNPTldyaXRlcigpO1xuXG5cbmZ1bmN0aW9uIHJ1biAob3ApIHtcbiAgdmFyIGxheWVycyA9IGRyYXduSXRlbXMuZ2V0TGF5ZXJzKCk7XG4gIGlmIChsYXllcnMubGVuZ3RoIDwgMikgcmV0dXJuO1xuICB2YXIgc3ViamVjdCA9IGxheWVyc1swXS50b0dlb0pTT04oKTtcbiAgdmFyIGNsaXBwaW5nID0gbGF5ZXJzWzFdLnRvR2VvSlNPTigpO1xuXG4gIGNvbnNvbGUubG9nKCdpbnB1dCcsIHN1YmplY3QsIGNsaXBwaW5nLCBvcCk7XG5cbiAgc3ViamVjdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3ViamVjdCkpO1xuICBjbGlwcGluZyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2xpcHBpbmcpKTtcblxuXG4gIGNvbnNvbGUudGltZSgnbWFydGluZXonKTtcbiAgdmFyIHJlc3VsdCA9IG1hcnRpbmV6KHN1YmplY3QuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIGNsaXBwaW5nLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBvcCk7XG4gIGNvbnNvbGUudGltZUVuZCgnbWFydGluZXonKTtcblxuICBjb25zb2xlLnRpbWUoJ2pzdHMnKTtcbiAgdmFyIHMgPSByZWFkZXIucmVhZChzdWJqZWN0KTtcbiAgdmFyIGMgPSByZWFkZXIucmVhZChjbGlwcGluZyk7XG4gIHZhciByZXMgPSB3cml0ZXIud3JpdGUocy5nZW9tZXRyeS5pbnRlcnNlY3Rpb24oYy5nZW9tZXRyeSkpO1xuXG4gIGNvbnNvbGUudGltZUVuZCgnanN0cycpO1xuXG4gIC8vY29uc29sZS5sb2coJ3Jlc3VsdCcsIHJlc3VsdCwgcmVzKTtcblxuICByZXN1bHRzLmNsZWFyTGF5ZXJzKCk7XG4gIHJlc3VsdHMuYWRkRGF0YSh7XG4gICAgJ3R5cGUnOiAnRmVhdHVyZScsXG4gICAgJ2dlb21ldHJ5Jzoge1xuICAgICAgJ3R5cGUnOiAnUG9seWdvbicsXG4gICAgICAnY29vcmRpbmF0ZXMnOiByZXN1bHRcbiAgICB9XG4gIH0pO1xufVxuXG4vL2RyYXduSXRlbXMuYWRkRGF0YShvbmVJbnNpZGUpO1xuLy9kcmF3bkl0ZW1zLmFkZERhdGEodHdvUG9pbnRlZFRyaWFuZ2xlcyk7XG4vL2RyYXduSXRlbXMuYWRkRGF0YShzZWxmSW50ZXJzZWN0aW5nKTtcbi8vZHJhd25JdGVtcy5hZGREYXRhKGhvbGVzKTtcbi8vZHJhd25JdGVtcy5hZGREYXRhKGRhdGEpO1xuXG5tYXAub24oJ2VkaXRhYmxlOmNyZWF0ZWQnLCBmdW5jdGlvbihldnQpIHtcbiAgZHJhd25JdGVtcy5hZGRMYXllcihldnQubGF5ZXIpO1xuICBldnQubGF5ZXIub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgIGlmICgoZS5vcmlnaW5hbEV2ZW50LmN0cmxLZXkgfHwgZS5vcmlnaW5hbEV2ZW50Lm1ldGFLZXkpICYmIHRoaXMuZWRpdEVuYWJsZWQoKSkge1xuICAgICAgdGhpcy5lZGl0b3IubmV3SG9sZShlLmxhdGxuZyk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgcmVzdWx0cyA9IHdpbmRvdy5yZXN1bHRzID0gTC5nZW9Kc29uKG51bGwsIHtcbiAgc3R5bGU6IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgd2VpZ2h0OiAxXG4gICAgfTtcbiAgfVxufSkuYWRkVG8obWFwKTtcblxubG9hZERhdGEocGF0aCArIGZpbGUpO1xuIiwiTC5FZGl0Q29udHJvbCA9IEwuQ29udHJvbC5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxuICAgIGNhbGxiYWNrOiBudWxsLFxuICAgIGtpbmQ6ICcnLFxuICAgIGh0bWw6ICcnXG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICB2YXIgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbCBsZWFmbGV0LWJhcicpLFxuICAgICAgICBsaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsICcnLCBjb250YWluZXIpO1xuXG4gICAgbGluay5ocmVmID0gJyMnO1xuICAgIGxpbmsudGl0bGUgPSAnQ3JlYXRlIGEgbmV3ICcgKyB0aGlzLm9wdGlvbnMua2luZDtcbiAgICBsaW5rLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5odG1sO1xuICAgIEwuRG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wKVxuICAgICAgICAgICAgICAub24obGluaywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5MQVlFUiA9IHRoaXMub3B0aW9ucy5jYWxsYmFjay5jYWxsKG1hcC5lZGl0VG9vbHMpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxufSk7XG5cbkwuTmV3UG9seWdvbkNvbnRyb2wgPSBMLkVkaXRDb250cm9sLmV4dGVuZCh7XG4gIG9wdGlvbnM6IHtcbiAgICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxuICAgIGtpbmQ6ICdwb2x5Z29uJyxcbiAgICBodG1sOiAn4pawJ1xuICB9XG59KTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL2luZGV4Jyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBSQlRyZWU6IHJlcXVpcmUoJy4vbGliL3JidHJlZScpLFxuICAgIEJpblRyZWU6IHJlcXVpcmUoJy4vbGliL2JpbnRyZWUnKVxufTtcbiIsIlxudmFyIFRyZWVCYXNlID0gcmVxdWlyZSgnLi90cmVlYmFzZScpO1xuXG5mdW5jdGlvbiBOb2RlKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubGVmdCA9IG51bGw7XG4gICAgdGhpcy5yaWdodCA9IG51bGw7XG59XG5cbk5vZGUucHJvdG90eXBlLmdldF9jaGlsZCA9IGZ1bmN0aW9uKGRpcikge1xuICAgIHJldHVybiBkaXIgPyB0aGlzLnJpZ2h0IDogdGhpcy5sZWZ0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0X2NoaWxkID0gZnVuY3Rpb24oZGlyLCB2YWwpIHtcbiAgICBpZihkaXIpIHtcbiAgICAgICAgdGhpcy5yaWdodCA9IHZhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHZhbDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBCaW5UcmVlKGNvbXBhcmF0b3IpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICB0aGlzLnNpemUgPSAwO1xufVxuXG5CaW5UcmVlLnByb3RvdHlwZSA9IG5ldyBUcmVlQmFzZSgpO1xuXG4vLyByZXR1cm5zIHRydWUgaWYgaW5zZXJ0ZWQsIGZhbHNlIGlmIGR1cGxpY2F0ZVxuQmluVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmKHRoaXMuX3Jvb3QgPT09IG51bGwpIHtcbiAgICAgICAgLy8gZW1wdHkgdHJlZVxuICAgICAgICB0aGlzLl9yb290ID0gbmV3IE5vZGUoZGF0YSk7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZGlyID0gMDtcblxuICAgIC8vIHNldHVwXG4gICAgdmFyIHAgPSBudWxsOyAvLyBwYXJlbnRcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG5cbiAgICAvLyBzZWFyY2ggZG93blxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgaWYobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IG5ldyBub2RlIGF0IHRoZSBib3R0b21cbiAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgIHAuc2V0X2NoaWxkKGRpciwgbm9kZSk7XG4gICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgaWYgZm91bmRcbiAgICAgICAgaWYodGhpcy5fY29tcGFyYXRvcihub2RlLmRhdGEsIGRhdGEpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkaXIgPSB0aGlzLl9jb21wYXJhdG9yKG5vZGUuZGF0YSwgZGF0YSkgPCAwO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBoZWxwZXJzXG4gICAgICAgIHAgPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5nZXRfY2hpbGQoZGlyKTtcbiAgICB9XG59O1xuXG4vLyByZXR1cm5zIHRydWUgaWYgcmVtb3ZlZCwgZmFsc2UgaWYgbm90IGZvdW5kXG5CaW5UcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYodGhpcy5fcm9vdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGhlYWQgPSBuZXcgTm9kZSh1bmRlZmluZWQpOyAvLyBmYWtlIHRyZWUgcm9vdFxuICAgIHZhciBub2RlID0gaGVhZDtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgcCA9IG51bGw7IC8vIHBhcmVudFxuICAgIHZhciBmb3VuZCA9IG51bGw7IC8vIGZvdW5kIGl0ZW1cbiAgICB2YXIgZGlyID0gMTtcblxuICAgIHdoaWxlKG5vZGUuZ2V0X2NoaWxkKGRpcikgIT09IG51bGwpIHtcbiAgICAgICAgcCA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmdldF9jaGlsZChkaXIpO1xuICAgICAgICB2YXIgY21wID0gdGhpcy5fY29tcGFyYXRvcihkYXRhLCBub2RlLmRhdGEpO1xuICAgICAgICBkaXIgPSBjbXAgPiAwO1xuXG4gICAgICAgIGlmKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgZm91bmQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQgIT09IG51bGwpIHtcbiAgICAgICAgZm91bmQuZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgcC5zZXRfY2hpbGQocC5yaWdodCA9PT0gbm9kZSwgbm9kZS5nZXRfY2hpbGQobm9kZS5sZWZ0ID09PSBudWxsKSk7XG5cbiAgICAgICAgdGhpcy5fcm9vdCA9IGhlYWQucmlnaHQ7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpblRyZWU7XG5cbiIsIlxudmFyIFRyZWVCYXNlID0gcmVxdWlyZSgnLi90cmVlYmFzZScpO1xuXG5mdW5jdGlvbiBOb2RlKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubGVmdCA9IG51bGw7XG4gICAgdGhpcy5yaWdodCA9IG51bGw7XG4gICAgdGhpcy5yZWQgPSB0cnVlO1xufVxuXG5Ob2RlLnByb3RvdHlwZS5nZXRfY2hpbGQgPSBmdW5jdGlvbihkaXIpIHtcbiAgICByZXR1cm4gZGlyID8gdGhpcy5yaWdodCA6IHRoaXMubGVmdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldF9jaGlsZCA9IGZ1bmN0aW9uKGRpciwgdmFsKSB7XG4gICAgaWYoZGlyKSB7XG4gICAgICAgIHRoaXMucmlnaHQgPSB2YWw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB2YWw7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gUkJUcmVlKGNvbXBhcmF0b3IpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICB0aGlzLnNpemUgPSAwO1xufVxuXG5SQlRyZWUucHJvdG90eXBlID0gbmV3IFRyZWVCYXNlKCk7XG5cbi8vIHJldHVybnMgdHJ1ZSBpZiBpbnNlcnRlZCwgZmFsc2UgaWYgZHVwbGljYXRlXG5SQlRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgICBpZih0aGlzLl9yb290ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGVtcHR5IHRyZWVcbiAgICAgICAgdGhpcy5fcm9vdCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBoZWFkID0gbmV3IE5vZGUodW5kZWZpbmVkKTsgLy8gZmFrZSB0cmVlIHJvb3RcblxuICAgICAgICB2YXIgZGlyID0gMDtcbiAgICAgICAgdmFyIGxhc3QgPSAwO1xuXG4gICAgICAgIC8vIHNldHVwXG4gICAgICAgIHZhciBncCA9IG51bGw7IC8vIGdyYW5kcGFyZW50XG4gICAgICAgIHZhciBnZ3AgPSBoZWFkOyAvLyBncmFuZC1ncmFuZC1wYXJlbnRcbiAgICAgICAgdmFyIHAgPSBudWxsOyAvLyBwYXJlbnRcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9yb290O1xuICAgICAgICBnZ3AucmlnaHQgPSB0aGlzLl9yb290O1xuXG4gICAgICAgIC8vIHNlYXJjaCBkb3duXG4gICAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgICAgIGlmKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgbmV3IG5vZGUgYXQgdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgICAgICBwLnNldF9jaGlsZChkaXIsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGlzX3JlZChub2RlLmxlZnQpICYmIGlzX3JlZChub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbG9yIGZsaXBcbiAgICAgICAgICAgICAgICBub2RlLnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0LnJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUucmlnaHQucmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpeCByZWQgdmlvbGF0aW9uXG4gICAgICAgICAgICBpZihpc19yZWQobm9kZSkgJiYgaXNfcmVkKHApKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcjIgPSBnZ3AucmlnaHQgPT09IGdwO1xuXG4gICAgICAgICAgICAgICAgaWYobm9kZSA9PT0gcC5nZXRfY2hpbGQobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2dwLnNldF9jaGlsZChkaXIyLCBzaW5nbGVfcm90YXRlKGdwLCAhbGFzdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2dwLnNldF9jaGlsZChkaXIyLCBkb3VibGVfcm90YXRlKGdwLCAhbGFzdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmF0b3Iobm9kZS5kYXRhLCBkYXRhKTtcblxuICAgICAgICAgICAgLy8gc3RvcCBpZiBmb3VuZFxuICAgICAgICAgICAgaWYoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3QgPSBkaXI7XG4gICAgICAgICAgICBkaXIgPSBjbXAgPCAwO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgaGVscGVyc1xuICAgICAgICAgICAgaWYoZ3AgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZ3AgPSBncDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwID0gcDtcbiAgICAgICAgICAgIHAgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0X2NoaWxkKGRpcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgcm9vdFxuICAgICAgICB0aGlzLl9yb290ID0gaGVhZC5yaWdodDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHJvb3QgYmxhY2tcbiAgICB0aGlzLl9yb290LnJlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8vIHJldHVybnMgdHJ1ZSBpZiByZW1vdmVkLCBmYWxzZSBpZiBub3QgZm91bmRcblJCVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmKHRoaXMuX3Jvb3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBoZWFkID0gbmV3IE5vZGUodW5kZWZpbmVkKTsgLy8gZmFrZSB0cmVlIHJvb3RcbiAgICB2YXIgbm9kZSA9IGhlYWQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHAgPSBudWxsOyAvLyBwYXJlbnRcbiAgICB2YXIgZ3AgPSBudWxsOyAvLyBncmFuZCBwYXJlbnRcbiAgICB2YXIgZm91bmQgPSBudWxsOyAvLyBmb3VuZCBpdGVtXG4gICAgdmFyIGRpciA9IDE7XG5cbiAgICB3aGlsZShub2RlLmdldF9jaGlsZChkaXIpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBsYXN0ID0gZGlyO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBoZWxwZXJzXG4gICAgICAgIGdwID0gcDtcbiAgICAgICAgcCA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmdldF9jaGlsZChkaXIpO1xuXG4gICAgICAgIHZhciBjbXAgPSB0aGlzLl9jb21wYXJhdG9yKGRhdGEsIG5vZGUuZGF0YSk7XG5cbiAgICAgICAgZGlyID0gY21wID4gMDtcblxuICAgICAgICAvLyBzYXZlIGZvdW5kIG5vZGVcbiAgICAgICAgaWYoY21wID09PSAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdXNoIHRoZSByZWQgbm9kZSBkb3duXG4gICAgICAgIGlmKCFpc19yZWQobm9kZSkgJiYgIWlzX3JlZChub2RlLmdldF9jaGlsZChkaXIpKSkge1xuICAgICAgICAgICAgaWYoaXNfcmVkKG5vZGUuZ2V0X2NoaWxkKCFkaXIpKSkge1xuICAgICAgICAgICAgICAgIHZhciBzciA9IHNpbmdsZV9yb3RhdGUobm9kZSwgZGlyKTtcbiAgICAgICAgICAgICAgICBwLnNldF9jaGlsZChsYXN0LCBzcik7XG4gICAgICAgICAgICAgICAgcCA9IHNyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighaXNfcmVkKG5vZGUuZ2V0X2NoaWxkKCFkaXIpKSkge1xuICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gcC5nZXRfY2hpbGQoIWxhc3QpO1xuICAgICAgICAgICAgICAgIGlmKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWlzX3JlZChzaWJsaW5nLmdldF9jaGlsZCghbGFzdCkpICYmICFpc19yZWQoc2libGluZy5nZXRfY2hpbGQobGFzdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xvciBmbGlwXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcjIgPSBncC5yaWdodCA9PT0gcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNfcmVkKHNpYmxpbmcuZ2V0X2NoaWxkKGxhc3QpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdwLnNldF9jaGlsZChkaXIyLCBkb3VibGVfcm90YXRlKHAsIGxhc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNfcmVkKHNpYmxpbmcuZ2V0X2NoaWxkKCFsYXN0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncC5zZXRfY2hpbGQoZGlyMiwgc2luZ2xlX3JvdGF0ZShwLCBsYXN0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBjb3JyZWN0IGNvbG9yaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3BjID0gZ3AuZ2V0X2NoaWxkKGRpcjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3BjLnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBncGMubGVmdC5yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdwYy5yaWdodC5yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgYW5kIHJlbW92ZSBpZiBmb3VuZFxuICAgIGlmKGZvdW5kICE9PSBudWxsKSB7XG4gICAgICAgIGZvdW5kLmRhdGEgPSBub2RlLmRhdGE7XG4gICAgICAgIHAuc2V0X2NoaWxkKHAucmlnaHQgPT09IG5vZGUsIG5vZGUuZ2V0X2NoaWxkKG5vZGUubGVmdCA9PT0gbnVsbCkpO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgcm9vdCBhbmQgbWFrZSBpdCBibGFja1xuICAgIHRoaXMuX3Jvb3QgPSBoZWFkLnJpZ2h0O1xuICAgIGlmKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcm9vdC5yZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmQgIT09IG51bGw7XG59O1xuXG5mdW5jdGlvbiBpc19yZWQobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSBudWxsICYmIG5vZGUucmVkO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVfcm90YXRlKHJvb3QsIGRpcikge1xuICAgIHZhciBzYXZlID0gcm9vdC5nZXRfY2hpbGQoIWRpcik7XG5cbiAgICByb290LnNldF9jaGlsZCghZGlyLCBzYXZlLmdldF9jaGlsZChkaXIpKTtcbiAgICBzYXZlLnNldF9jaGlsZChkaXIsIHJvb3QpO1xuXG4gICAgcm9vdC5yZWQgPSB0cnVlO1xuICAgIHNhdmUucmVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gc2F2ZTtcbn1cblxuZnVuY3Rpb24gZG91YmxlX3JvdGF0ZShyb290LCBkaXIpIHtcbiAgICByb290LnNldF9jaGlsZCghZGlyLCBzaW5nbGVfcm90YXRlKHJvb3QuZ2V0X2NoaWxkKCFkaXIpLCAhZGlyKSk7XG4gICAgcmV0dXJuIHNpbmdsZV9yb3RhdGUocm9vdCwgZGlyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSQlRyZWU7XG4iLCJcbmZ1bmN0aW9uIFRyZWVCYXNlKCkge31cblxuLy8gcmVtb3ZlcyBhbGwgbm9kZXMgZnJvbSB0aGUgdHJlZVxuVHJlZUJhc2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gMDtcbn07XG5cbi8vIHJldHVybnMgbm9kZSBkYXRhIGlmIGZvdW5kLCBudWxsIG90aGVyd2lzZVxuVHJlZUJhc2UucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuX3Jvb3Q7XG5cbiAgICB3aGlsZShyZXMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLl9jb21wYXJhdG9yKGRhdGEsIHJlcy5kYXRhKTtcbiAgICAgICAgaWYoYyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcmVzLmdldF9jaGlsZChjID4gMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIHJldHVybnMgaXRlcmF0b3IgdG8gbm9kZSBpZiBmb3VuZCwgbnVsbCBvdGhlcndpc2VcblRyZWVCYXNlLnByb3RvdHlwZS5maW5kSXRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgaXRlciA9IHRoaXMuaXRlcmF0b3IoKTtcblxuICAgIHdoaWxlKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuX2NvbXBhcmF0b3IoZGF0YSwgcmVzLmRhdGEpO1xuICAgICAgICBpZihjID09PSAwKSB7XG4gICAgICAgICAgICBpdGVyLl9jdXJzb3IgPSByZXM7XG4gICAgICAgICAgICByZXR1cm4gaXRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXIuX2FuY2VzdG9ycy5wdXNoKHJlcyk7XG4gICAgICAgICAgICByZXMgPSByZXMuZ2V0X2NoaWxkKGMgPiAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuLy8gUmV0dXJucyBhbiBpdGVyYXRvciB0byB0aGUgdHJlZSBub2RlIGF0IG9yIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpdGVtXG5UcmVlQmFzZS5wcm90b3R5cGUubG93ZXJCb3VuZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB2YXIgY3VyID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgaXRlciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICB2YXIgY21wID0gdGhpcy5fY29tcGFyYXRvcjtcblxuICAgIHdoaWxlKGN1ciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgYyA9IGNtcChpdGVtLCBjdXIuZGF0YSk7XG4gICAgICAgIGlmKGMgPT09IDApIHtcbiAgICAgICAgICAgIGl0ZXIuX2N1cnNvciA9IGN1cjtcbiAgICAgICAgICAgIHJldHVybiBpdGVyO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXIuX2FuY2VzdG9ycy5wdXNoKGN1cik7XG4gICAgICAgIGN1ciA9IGN1ci5nZXRfY2hpbGQoYyA+IDApO1xuICAgIH1cblxuICAgIGZvcih2YXIgaT1pdGVyLl9hbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY3VyID0gaXRlci5fYW5jZXN0b3JzW2ldO1xuICAgICAgICBpZihjbXAoaXRlbSwgY3VyLmRhdGEpIDwgMCkge1xuICAgICAgICAgICAgaXRlci5fY3Vyc29yID0gY3VyO1xuICAgICAgICAgICAgaXRlci5fYW5jZXN0b3JzLmxlbmd0aCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGl0ZXIuX2FuY2VzdG9ycy5sZW5ndGggPSAwO1xuICAgIHJldHVybiBpdGVyO1xufTtcblxuLy8gUmV0dXJucyBhbiBpdGVyYXRvciB0byB0aGUgdHJlZSBub2RlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpdGVtXG5UcmVlQmFzZS5wcm90b3R5cGUudXBwZXJCb3VuZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB2YXIgaXRlciA9IHRoaXMubG93ZXJCb3VuZChpdGVtKTtcbiAgICB2YXIgY21wID0gdGhpcy5fY29tcGFyYXRvcjtcblxuICAgIHdoaWxlKGl0ZXIuZGF0YSgpICE9PSBudWxsICYmIGNtcChpdGVyLmRhdGEoKSwgaXRlbSkgPT09IDApIHtcbiAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXI7XG59O1xuXG4vLyByZXR1cm5zIG51bGwgaWYgdHJlZSBpcyBlbXB0eVxuVHJlZUJhc2UucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXMgPSB0aGlzLl9yb290O1xuICAgIGlmKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZShyZXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICByZXMgPSByZXMubGVmdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLmRhdGE7XG59O1xuXG4vLyByZXR1cm5zIG51bGwgaWYgdHJlZSBpcyBlbXB0eVxuVHJlZUJhc2UucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXMgPSB0aGlzLl9yb290O1xuICAgIGlmKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZShyZXMucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgcmVzID0gcmVzLnJpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiByZXMuZGF0YTtcbn07XG5cbi8vIHJldHVybnMgYSBudWxsIGl0ZXJhdG9yXG4vLyBjYWxsIG5leHQoKSBvciBwcmV2KCkgdG8gcG9pbnQgdG8gYW4gZWxlbWVudFxuVHJlZUJhc2UucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzKTtcbn07XG5cbi8vIGNhbGxzIGNiIG9uIGVhY2ggbm9kZSdzIGRhdGEsIGluIG9yZGVyXG5UcmVlQmFzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgdmFyIGl0PXRoaXMuaXRlcmF0b3IoKSwgZGF0YTtcbiAgICB3aGlsZSgoZGF0YSA9IGl0Lm5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgY2IoZGF0YSk7XG4gICAgfVxufTtcblxuLy8gY2FsbHMgY2Igb24gZWFjaCBub2RlJ3MgZGF0YSwgaW4gcmV2ZXJzZSBvcmRlclxuVHJlZUJhc2UucHJvdG90eXBlLnJlYWNoID0gZnVuY3Rpb24oY2IpIHtcbiAgICB2YXIgaXQ9dGhpcy5pdGVyYXRvcigpLCBkYXRhO1xuICAgIHdoaWxlKChkYXRhID0gaXQucHJldigpKSAhPT0gbnVsbCkge1xuICAgICAgICBjYihkYXRhKTtcbiAgICB9XG59O1xuXG5cbmZ1bmN0aW9uIEl0ZXJhdG9yKHRyZWUpIHtcbiAgICB0aGlzLl90cmVlID0gdHJlZTtcbiAgICB0aGlzLl9hbmNlc3RvcnMgPSBbXTtcbiAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJzb3IgIT09IG51bGwgPyB0aGlzLl9jdXJzb3IuZGF0YSA6IG51bGw7XG59O1xuXG4vLyBpZiBudWxsLWl0ZXJhdG9yLCByZXR1cm5zIGZpcnN0IG5vZGVcbi8vIG90aGVyd2lzZSwgcmV0dXJucyBuZXh0IG5vZGVcbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5fY3Vyc29yID09PSBudWxsKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5fdHJlZS5fcm9vdDtcbiAgICAgICAgaWYocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbWluTm9kZShyb290KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYodGhpcy5fY3Vyc29yLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBncmVhdGVyIG5vZGUgaW4gc3VidHJlZSwgZ28gdXAgdG8gcGFyZW50XG4gICAgICAgICAgICAvLyBpZiBjb21pbmcgZnJvbSBhIHJpZ2h0IGNoaWxkLCBjb250aW51ZSB1cCB0aGUgc3RhY2tcbiAgICAgICAgICAgIHZhciBzYXZlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHNhdmUgPSB0aGlzLl9jdXJzb3I7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fYW5jZXN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB0aGlzLl9hbmNlc3RvcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlKHRoaXMuX2N1cnNvci5yaWdodCA9PT0gc2F2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIG5leHQgbm9kZSBmcm9tIHRoZSBzdWJ0cmVlXG4gICAgICAgICAgICB0aGlzLl9hbmNlc3RvcnMucHVzaCh0aGlzLl9jdXJzb3IpO1xuICAgICAgICAgICAgdGhpcy5fbWluTm9kZSh0aGlzLl9jdXJzb3IucmlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jdXJzb3IgIT09IG51bGwgPyB0aGlzLl9jdXJzb3IuZGF0YSA6IG51bGw7XG59O1xuXG4vLyBpZiBudWxsLWl0ZXJhdG9yLCByZXR1cm5zIGxhc3Qgbm9kZVxuLy8gb3RoZXJ3aXNlLCByZXR1cm5zIHByZXZpb3VzIG5vZGVcbkl0ZXJhdG9yLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5fY3Vyc29yID09PSBudWxsKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5fdHJlZS5fcm9vdDtcbiAgICAgICAgaWYocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbWF4Tm9kZShyb290KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYodGhpcy5fY3Vyc29yLmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzYXZlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHNhdmUgPSB0aGlzLl9jdXJzb3I7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fYW5jZXN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB0aGlzLl9hbmNlc3RvcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlKHRoaXMuX2N1cnNvci5sZWZ0ID09PSBzYXZlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2VzdG9ycy5wdXNoKHRoaXMuX2N1cnNvcik7XG4gICAgICAgICAgICB0aGlzLl9tYXhOb2RlKHRoaXMuX2N1cnNvci5sZWZ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3Vyc29yICE9PSBudWxsID8gdGhpcy5fY3Vyc29yLmRhdGEgOiBudWxsO1xufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLl9taW5Ob2RlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgICB3aGlsZShzdGFydC5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2FuY2VzdG9ycy5wdXNoKHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5sZWZ0O1xuICAgIH1cbiAgICB0aGlzLl9jdXJzb3IgPSBzdGFydDtcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5fbWF4Tm9kZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgd2hpbGUoc3RhcnQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fYW5jZXN0b3JzLnB1c2goc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHN0YXJ0LnJpZ2h0O1xuICAgIH1cbiAgICB0aGlzLl9jdXJzb3IgPSBzdGFydDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZUJhc2U7XG5cbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIi8vIEpTVFMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzXG4vLyBMaWNlbnNlczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FREx2MS50eHRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FUEx2MS50eHRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9MSUNFTlNFX0VTNl9DT0xMRUNUSU9OUy50eHRcbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUodC5qc3RzPXQuanN0c3x8e30pfSh0aGlzLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUodCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKX1mdW5jdGlvbiBuKCl7fWZ1bmN0aW9uIGkoKXt9ZnVuY3Rpb24gcigpe31mdW5jdGlvbiBzKCl7fWZ1bmN0aW9uIG8oKXt9ZnVuY3Rpb24gYSgpe31mdW5jdGlvbiB1KCl7fWZ1bmN0aW9uIGwodCl7dGhpcy5tZXNzYWdlPXR9ZnVuY3Rpb24gaCh0LGUpe3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXR9ZnVuY3Rpb24gYygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWwuY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07bC5jYWxsKHRoaXMsdCl9fWZ1bmN0aW9uIGYoKXt9ZnVuY3Rpb24gZygpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMuej1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWcuY2FsbCh0aGlzLDAsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2cuY2FsbCh0aGlzLHQueCx0LnksdC56KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07Zy5jYWxsKHRoaXMsZSxuLGcuTlVMTF9PUkRJTkFURSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMueD1pLHRoaXMueT1yLHRoaXMuej1zfX1mdW5jdGlvbiBkKCl7aWYodGhpcy5kaW1lbnNpb25zVG9UZXN0PTIsMD09PWFyZ3VtZW50cy5sZW5ndGgpZC5jYWxsKHRoaXMsMik7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKDIhPT10JiYzIT09dCl0aHJvdyBuZXcgaShcIm9ubHkgMiBvciAzIGRpbWVuc2lvbnMgbWF5IGJlIHNwZWNpZmllZFwiKTt0aGlzLmRpbWVuc2lvbnNUb1Rlc3Q9dH19ZnVuY3Rpb24gcCgpe31mdW5jdGlvbiB2KCl7fWZ1bmN0aW9uIG0odCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24geSgpe31mdW5jdGlvbiB4KHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIEUodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gSSgpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1mdW5jdGlvbiBOKCl7aWYoSS5hcHBseSh0aGlzKSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZW5zdXJlQ2FwYWNpdHkodC5sZW5ndGgpLHRoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmVuc3VyZUNhcGFjaXR5KGUubGVuZ3RoKSx0aGlzLmFkZChlLG4pfX1mdW5jdGlvbiBDKCl7aWYodGhpcy5taW54PW51bGwsdGhpcy5tYXh4PW51bGwsdGhpcy5taW55PW51bGwsdGhpcy5tYXh5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQueCx0LngsdC55LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmluaXQoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQobi54LGkueCxuLnksaS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM107dGhpcy5pbml0KHIscyxvLGEpfX1mdW5jdGlvbiBTKCl7fWZ1bmN0aW9uIHcoKXtTLmNhbGwodGhpcyxcIlByb2plY3RpdmUgcG9pbnQgbm90IHJlcHJlc2VudGFibGUgb24gdGhlIENhcnRlc2lhbiBwbGFuZS5cIil9ZnVuY3Rpb24gTCgpe31mdW5jdGlvbiBSKHQsZSl7cmV0dXJuIHQuaW50ZXJmYWNlc18mJnQuaW50ZXJmYWNlc18oKS5pbmRleE9mKGUpPi0xfWZ1bmN0aW9uIFQoKXt9ZnVuY3Rpb24gUCh0KXt0aGlzLnN0cj10fWZ1bmN0aW9uIGIodCl7dGhpcy52YWx1ZT10fWZ1bmN0aW9uIE8oKXt9ZnVuY3Rpb24gXygpe2lmKHRoaXMuaGk9MCx0aGlzLmxvPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmluaXQoZSl9ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgbj1hcmd1bWVudHNbMF07Xy5jYWxsKHRoaXMsXy5wYXJzZShuKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQoaSxyKX19ZnVuY3Rpb24gTSgpe31mdW5jdGlvbiBEKCl7fWZ1bmN0aW9uIEEoKXt9ZnVuY3Rpb24gRigpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMudz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMueD0wLHRoaXMueT0wLHRoaXMudz0xO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy53PTF9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMueD1lLHRoaXMueT1uLHRoaXMudz0xfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEYpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTt0aGlzLng9aS55KnIudy1yLnkqaS53LHRoaXMueT1yLngqaS53LWkueCpyLncsdGhpcy53PWkueCpyLnktci54KmkueX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV07dGhpcy54PXMueS1vLnksdGhpcy55PW8ueC1zLngsdGhpcy53PXMueCpvLnktby54KnMueX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdLGw9YXJndW1lbnRzWzJdO3RoaXMueD1hLHRoaXMueT11LHRoaXMudz1sfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBoPWFyZ3VtZW50c1swXSxjPWFyZ3VtZW50c1sxXSxmPWFyZ3VtZW50c1syXSxkPWFyZ3VtZW50c1szXSxwPWgueS1jLnksdj1jLngtaC54LG09aC54KmMueS1jLngqaC55LHk9Zi55LWQueSx4PWQueC1mLngsRT1mLngqZC55LWQueCpmLnk7dGhpcy54PXYqRS14Km0sdGhpcy55PXkqbS1wKkUsdGhpcy53PXAqeC15KnZ9fWZ1bmN0aW9uIEcoKXt9ZnVuY3Rpb24gcSgpe31mdW5jdGlvbiBCKCl7dGhpcy5lbnZlbG9wZT1udWxsLHRoaXMuZmFjdG9yeT1udWxsLHRoaXMuU1JJRD1udWxsLHRoaXMudXNlckRhdGE9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXQsdGhpcy5TUklEPXQuZ2V0U1JJRCgpfWZ1bmN0aW9uIHooKXt9ZnVuY3Rpb24gVigpe31mdW5jdGlvbiBrKCl7fWZ1bmN0aW9uIFkoKXt9ZnVuY3Rpb24gVSgpe31mdW5jdGlvbiBYKCl7fWZ1bmN0aW9uIEgoKXt9ZnVuY3Rpb24gVygpe31mdW5jdGlvbiBqKCl7fWZ1bmN0aW9uIEsoKXt9ZnVuY3Rpb24gWigpe31mdW5jdGlvbiBRKCl7fWZ1bmN0aW9uIEooKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9ZnVuY3Rpb24gJCh0KXtyZXR1cm4gbnVsbD09dD8kczp0LmNvbG9yfWZ1bmN0aW9uIHR0KHQpe3JldHVybiBudWxsPT10P251bGw6dC5wYXJlbnR9ZnVuY3Rpb24gZXQodCxlKXtudWxsIT09dCYmKHQuY29sb3I9ZSl9ZnVuY3Rpb24gbnQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LmxlZnR9ZnVuY3Rpb24gaXQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnJpZ2h0fWZ1bmN0aW9uIHJ0KCl7dGhpcy5yb290Xz1udWxsLHRoaXMuc2l6ZV89MH1mdW5jdGlvbiBzdCgpe31mdW5jdGlvbiBvdCgpe31mdW5jdGlvbiBhdCgpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1mdW5jdGlvbiB1dCgpe31mdW5jdGlvbiBsdCgpe31mdW5jdGlvbiBodCgpe31mdW5jdGlvbiBjdCgpe31mdW5jdGlvbiBmdCgpe3RoaXMuZ2VvbWV0cmllcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihCLmNhbGwodGhpcyxlKSxudWxsPT09dCYmKHQ9W10pLEIuaGFzTnVsbEVsZW1lbnRzKHQpKXRocm93IG5ldyBpKFwiZ2VvbWV0cmllcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7dGhpcy5nZW9tZXRyaWVzPXR9ZnVuY3Rpb24gZ3QoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZnQuY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gZHQoKXtpZih0aGlzLmdlb209bnVsbCx0aGlzLmdlb21GYWN0PW51bGwsdGhpcy5iblJ1bGU9bnVsbCx0aGlzLmVuZHBvaW50TWFwPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtkdC5jYWxsKHRoaXMsdCxWLk1PRDJfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuZ2VvbT1lLHRoaXMuZ2VvbUZhY3Q9ZS5nZXRGYWN0b3J5KCksdGhpcy5iblJ1bGU9bn19ZnVuY3Rpb24gcHQoKXt0aGlzLmNvdW50PW51bGx9ZnVuY3Rpb24gdnQoKXt9ZnVuY3Rpb24gbXQoKXt9ZnVuY3Rpb24geXQoKXt9ZnVuY3Rpb24geHQoKXt9ZnVuY3Rpb24gRXQoKXt9ZnVuY3Rpb24gSXQoKXt9ZnVuY3Rpb24gTnQoKXt9ZnVuY3Rpb24gQ3QoKXt9ZnVuY3Rpb24gU3QoKXt0aGlzLnBvaW50cz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtCLmNhbGwodGhpcyxlKSx0aGlzLmluaXQodCl9ZnVuY3Rpb24gd3QoKXt9ZnVuY3Rpb24gTHQoKXt0aGlzLmNvb3JkaW5hdGVzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0IuY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX1mdW5jdGlvbiBSdCgpe31mdW5jdGlvbiBUdCgpe3RoaXMuc2hlbGw9bnVsbCx0aGlzLmhvbGVzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKEIuY2FsbCh0aGlzLG4pLG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKCkpLG51bGw9PT1lJiYoZT1bXSksQi5oYXNOdWxsRWxlbWVudHMoZSkpdGhyb3cgbmV3IGkoXCJob2xlcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7aWYodC5pc0VtcHR5KCkmJkIuaGFzTm9uRW1wdHlFbGVtZW50cyhlKSl0aHJvdyBuZXcgaShcInNoZWxsIGlzIGVtcHR5IGJ1dCBob2xlcyBhcmUgbm90XCIpO3RoaXMuc2hlbGw9dCx0aGlzLmhvbGVzPWV9ZnVuY3Rpb24gUHQoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZnQuY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gYnQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgaWUpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtidC5jYWxsKHRoaXMsZS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpLGUpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sRCkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgaWUpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtTdC5jYWxsKHRoaXMsbixpKSx0aGlzLnZhbGlkYXRlQ29uc3RydWN0aW9uKCl9fWZ1bmN0aW9uIE90KCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Z0LmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIF90KCl7aWYodGhpcy5mYWN0b3J5PW51bGwsdGhpcy5pc1VzZXJEYXRhQ29waWVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXR9fWZ1bmN0aW9uIE10KCl7fWZ1bmN0aW9uIER0KCl7fWZ1bmN0aW9uIEF0KCl7fWZ1bmN0aW9uIEZ0KCl7fWZ1bmN0aW9uIEd0KCl7aWYodGhpcy5kaW1lbnNpb249Myx0aGlzLmNvb3JkaW5hdGVzPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtHdC5jYWxsKHRoaXMsdCwzKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7Zm9yKHZhciBuPTA7ZT5uO24rKyl0aGlzLmNvb3JkaW5hdGVzW25dPW5ldyBnfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpZihudWxsPT09aSlyZXR1cm4gdGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO3RoaXMuZGltZW5zaW9uPWkuZ2V0RGltZW5zaW9uKCksdGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkoaS5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKHZhciBuPTA7bjx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtuKyspdGhpcy5jb29yZGluYXRlc1tuXT1pLmdldENvb3JkaW5hdGVDb3B5KG4pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdO3RoaXMuY29vcmRpbmF0ZXM9cix0aGlzLmRpbWVuc2lvbj1zLG51bGw9PT1yJiYodGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdO3RoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KG8pLmZpbGwobnVsbCksdGhpcy5kaW1lbnNpb249YTtmb3IodmFyIG49MDtvPm47bisrKXRoaXMuY29vcmRpbmF0ZXNbbl09bmV3IGd9fWZ1bmN0aW9uIHF0KCl7fWZ1bmN0aW9uIEJ0KHQsZSl7cmV0dXJuIHQ9PT1lfHx0IT09dCYmZSE9PWV9ZnVuY3Rpb24genQodCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiB0aGlzJiZ0aGlzLmNvbnN0cnVjdG9yPT09bj8odGhpcy5fa2V5cz1bXSx0aGlzLl92YWx1ZXM9W10sdGhpcy5faXRwPVtdLHRoaXMub2JqZWN0T25seT1lLHZvaWQodCYmVnQuY2FsbCh0aGlzLHQpKSk6bmV3IG4odCl9cmV0dXJuIGV8fGlvKHQsXCJzaXplXCIse2dldDpKdH0pLHQuY29uc3RydWN0b3I9bixuLnByb3RvdHlwZT10LG59ZnVuY3Rpb24gVnQodCl7dGhpcy5hZGQ/dC5mb3JFYWNoKHRoaXMuYWRkLHRoaXMpOnQuZm9yRWFjaChmdW5jdGlvbih0KXt0aGlzLnNldCh0WzBdLHRbMV0pfSx0aGlzKX1mdW5jdGlvbiBrdCh0KXtyZXR1cm4gdGhpcy5oYXModCkmJih0aGlzLl9rZXlzLnNwbGljZShubywxKSx0aGlzLl92YWx1ZXMuc3BsaWNlKG5vLDEpLHRoaXMuX2l0cC5mb3JFYWNoKGZ1bmN0aW9uKHQpe25vPHRbMF0mJnRbMF0tLX0pKSxubz4tMX1mdW5jdGlvbiBZdCh0KXtyZXR1cm4gdGhpcy5oYXModCk/dGhpcy5fdmFsdWVzW25vXTp2b2lkIDB9ZnVuY3Rpb24gVXQodCxlKXtpZih0aGlzLm9iamVjdE9ubHkmJmUhPT1PYmplY3QoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdmFsdWUgdXNlZCBhcyB3ZWFrIGNvbGxlY3Rpb24ga2V5XCIpO2lmKGUhPT1lfHwwPT09ZSlmb3Iobm89dC5sZW5ndGg7bm8tLSYmIUJ0KHRbbm9dLGUpOyk7ZWxzZSBubz10LmluZGV4T2YoZSk7cmV0dXJuIG5vPi0xfWZ1bmN0aW9uIFh0KHQpe3JldHVybiBVdC5jYWxsKHRoaXMsdGhpcy5fa2V5cyx0KX1mdW5jdGlvbiBIdCh0LGUpe3JldHVybiB0aGlzLmhhcyh0KT90aGlzLl92YWx1ZXNbbm9dPWU6dGhpcy5fdmFsdWVzW3RoaXMuX2tleXMucHVzaCh0KS0xXT1lLHRoaXN9ZnVuY3Rpb24gV3QoKXsodGhpcy5fa2V5c3x8MCkubGVuZ3RoPXRoaXMuX3ZhbHVlcy5sZW5ndGg9MH1mdW5jdGlvbiBqdCgpe3JldHVybiBRdCh0aGlzLl9pdHAsdGhpcy5fa2V5cyl9ZnVuY3Rpb24gS3QoKXtyZXR1cm4gUXQodGhpcy5faXRwLHRoaXMuX3ZhbHVlcyl9ZnVuY3Rpb24gWnQoKXtyZXR1cm4gUXQodGhpcy5faXRwLHRoaXMuX2tleXMsdGhpcy5fdmFsdWVzKX1mdW5jdGlvbiBRdCh0LGUsbil7dmFyIGk9WzBdLHI9ITE7cmV0dXJuIHQucHVzaChpKSx7bmV4dDpmdW5jdGlvbigpe3ZhciBzLG89aVswXTtyZXR1cm4hciYmbzxlLmxlbmd0aD8ocz1uP1tlW29dLG5bb11dOmVbb10saVswXSsrKToocj0hMCx0LnNwbGljZSh0LmluZGV4T2YoaSksMSkpLHtkb25lOnIsdmFsdWU6c319fX1mdW5jdGlvbiBKdCgpe3JldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RofWZ1bmN0aW9uICR0KHQsZSl7Zm9yKHZhciBuPXRoaXMuZW50cmllcygpOzspe3ZhciBpPW4ubmV4dCgpO2lmKGkuZG9uZSlicmVhazt0LmNhbGwoZSxpLnZhbHVlWzFdLGkudmFsdWVbMF0sdGhpcyl9fWZ1bmN0aW9uIHRlKCl7dGhpcy5tYXBfPW5ldyBzb31mdW5jdGlvbiBlZSgpe2lmKHRoaXMubW9kZWxUeXBlPW51bGwsdGhpcy5zY2FsZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMubW9kZWxUeXBlPWVlLkZMT0FUSU5HO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBuZSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubW9kZWxUeXBlPXQsdD09PWVlLkZJWEVEJiZ0aGlzLnNldFNjYWxlKDEpfWVsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMubW9kZWxUeXBlPWVlLkZJWEVELHRoaXMuc2V0U2NhbGUoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXt2YXIgbj1hcmd1bWVudHNbMF07dGhpcy5tb2RlbFR5cGU9bi5tb2RlbFR5cGUsdGhpcy5zY2FsZT1uLnNjYWxlfX1mdW5jdGlvbiBuZSgpe3RoaXMubmFtZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5hbWU9dCxuZS5uYW1lVG9UeXBlTWFwLnB1dCh0LHRoaXMpfWZ1bmN0aW9uIGllKCl7aWYodGhpcy5wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1udWxsLHRoaXMuU1JJRD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWllLmNhbGwodGhpcyxuZXcgZWUsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sRykpe3ZhciB0PWFyZ3VtZW50c1swXTtpZS5jYWxsKHRoaXMsbmV3IGVlLDAsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXt2YXIgZT1hcmd1bWVudHNbMF07aWUuY2FsbCh0aGlzLGUsMCxpZS5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2llLmNhbGwodGhpcyxuLGksaWUuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMucHJlY2lzaW9uTW9kZWw9cix0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9byx0aGlzLlNSSUQ9c319ZnVuY3Rpb24gcmUodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllfWZ1bmN0aW9uIHNlKHQpe3RoaXMucGFyc2VyPW5ldyByZSh0KX1mdW5jdGlvbiBvZSgpe3RoaXMucmVzdWx0PW51bGwsdGhpcy5pbnB1dExpbmVzPUFycmF5KDIpLmZpbGwoKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkoMil9KSx0aGlzLmludFB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuaW50TGluZUluZGV4PW51bGwsdGhpcy5faXNQcm9wZXI9bnVsbCx0aGlzLnBhPW51bGwsdGhpcy5wYj1udWxsLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmludFB0WzBdPW5ldyBnLHRoaXMuaW50UHRbMV09bmV3IGcsdGhpcy5wYT10aGlzLmludFB0WzBdLHRoaXMucGI9dGhpcy5pbnRQdFsxXSx0aGlzLnJlc3VsdD0wfWZ1bmN0aW9uIGFlKCl7b2UuYXBwbHkodGhpcyl9ZnVuY3Rpb24gdWUoKXt9ZnVuY3Rpb24gbGUoKXt0aGlzLnA9bnVsbCx0aGlzLmNyb3NzaW5nQ291bnQ9MCx0aGlzLmlzUG9pbnRPblNlZ21lbnQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucD10fWZ1bmN0aW9uIGhlKCl7fWZ1bmN0aW9uIGNlKCl7aWYodGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCljZS5jYWxsKHRoaXMsbmV3IGcsbmV3IGcpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtjZS5jYWxsKHRoaXMsdC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wMD1lLHRoaXMucDE9bn1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbz1hcmd1bWVudHNbM107Y2UuY2FsbCh0aGlzLG5ldyBnKGksciksbmV3IGcocyxvKSl9fWZ1bmN0aW9uIGZlKCl7aWYodGhpcy5tYXRyaXg9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLm1hdHJpeD1BcnJheSgzKS5maWxsKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5KDMpfSksdGhpcy5zZXRBbGwobHQuRkFMU0UpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO2ZlLmNhbGwodGhpcyksdGhpcy5zZXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZlKXt2YXIgZT1hcmd1bWVudHNbMF07ZmUuY2FsbCh0aGlzKSx0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXT1lLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSx0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXT1lLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSx0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXT1lLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSx0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXT1lLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSx0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXT1lLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSx0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXT1lLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXSx0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXT1lLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSx0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkJPVU5EQVJZXT1lLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkJPVU5EQVJZXSx0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkVYVEVSSU9SXT1lLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkVYVEVSSU9SXX19ZnVuY3Rpb24gZ2UoKXt0aGlzLmFyZWFCYXNlUHQ9bnVsbCx0aGlzLnRyaWFuZ2xlQ2VudDM9bmV3IGcsdGhpcy5hcmVhc3VtMj0wLHRoaXMuY2czPW5ldyBnLHRoaXMubGluZUNlbnRTdW09bmV3IGcsdGhpcy50b3RhbExlbmd0aD0wLHRoaXMucHRDb3VudD0wLHRoaXMucHRDZW50U3VtPW5ldyBnO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFyZWFCYXNlUHQ9bnVsbCx0aGlzLmFkZCh0KX1mdW5jdGlvbiBkZSh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBwZSgpe3RoaXMuYXJyYXlfPVtdfWZ1bmN0aW9uIHZlKCl7dGhpcy50cmVlU2V0PW5ldyBhdCx0aGlzLmxpc3Q9bmV3IEl9ZnVuY3Rpb24gbWUoKXtpZih0aGlzLmdlb21GYWN0b3J5PW51bGwsdGhpcy5pbnB1dFB0cz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07bWUuY2FsbCh0aGlzLG1lLmV4dHJhY3RDb29yZGluYXRlcyh0KSx0LmdldEZhY3RvcnkoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuaW5wdXRQdHM9dmUuZmlsdGVyQ29vcmRpbmF0ZXMoZSksdGhpcy5nZW9tRmFjdG9yeT1ufX1mdW5jdGlvbiB5ZSgpe3RoaXMub3JpZ2luPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMub3JpZ2luPXR9ZnVuY3Rpb24geGUoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZmFjdG9yeT1udWxsLHRoaXMucHJ1bmVFbXB0eUdlb21ldHJ5PSEwLHRoaXMucHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlPSEwLHRoaXMucHJlc2VydmVDb2xsZWN0aW9ucz0hMSx0aGlzLnByZXNlcnZlVHlwZT0hMX1mdW5jdGlvbiBFZSgpe2lmKHRoaXMuc25hcFRvbGVyYW5jZT0wLHRoaXMuc3JjUHRzPW51bGwsdGhpcy5zZWc9bmV3IGNlLHRoaXMuYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9ITEsdGhpcy5faXNDbG9zZWQ9ITEsYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0VlLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGVzKCksZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5zcmNQdHM9bix0aGlzLl9pc0Nsb3NlZD1FZS5pc0Nsb3NlZChuKSx0aGlzLnNuYXBUb2xlcmFuY2U9aX19ZnVuY3Rpb24gSWUoKXt0aGlzLnNyY0dlb209bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zcmNHZW9tPXR9ZnVuY3Rpb24gTmUoKXtpZih4ZS5hcHBseSh0aGlzKSx0aGlzLnNuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLnNuYXBQdHM9bnVsbCx0aGlzLmlzU2VsZlNuYXA9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNuYXBUb2xlcmFuY2U9dCx0aGlzLnNuYXBQdHM9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5zbmFwVG9sZXJhbmNlPW4sdGhpcy5zbmFwUHRzPWksdGhpcy5pc1NlbGZTbmFwPXJ9fWZ1bmN0aW9uIENlKCl7dGhpcy5pc0ZpcnN0PSEwLHRoaXMuY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9NTMsdGhpcy5jb21tb25CaXRzPTAsdGhpcy5jb21tb25TaWduRXhwPW51bGx9ZnVuY3Rpb24gU2UoKXt0aGlzLmNvbW1vbkNvb3JkPW51bGwsdGhpcy5jY0ZpbHRlcj1uZXcgd2V9ZnVuY3Rpb24gd2UoKXt0aGlzLmNvbW1vbkJpdHNYPW5ldyBDZSx0aGlzLmNvbW1vbkJpdHNZPW5ldyBDZX1mdW5jdGlvbiBMZSgpe3RoaXMudHJhbnM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy50cmFucz10fWZ1bmN0aW9uIFJlKCl7dGhpcy5wYXJlbnQ9bnVsbCx0aGlzLmF0U3RhcnQ9bnVsbCx0aGlzLm1heD1udWxsLHRoaXMuaW5kZXg9bnVsbCx0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBhcmVudD10LHRoaXMuYXRTdGFydD0hMCx0aGlzLmluZGV4PTAsdGhpcy5tYXg9dC5nZXROdW1HZW9tZXRyaWVzKCl9ZnVuY3Rpb24gVGUoKXtpZih0aGlzLmJvdW5kYXJ5UnVsZT1WLk9HQ19TRlNfQk9VTkRBUllfUlVMRSx0aGlzLmlzSW49bnVsbCx0aGlzLm51bUJvdW5kYXJpZXM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXRocm93IG5ldyBpKFwiUnVsZSBtdXN0IGJlIG5vbi1udWxsXCIpO3RoaXMuYm91bmRhcnlSdWxlPXR9fWZ1bmN0aW9uIFBlKCl7fWZ1bmN0aW9uIGJlKCl7fWZ1bmN0aW9uIE9lKCl7dGhpcy5wdHM9bnVsbCx0aGlzLmRhdGE9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wdHM9dCx0aGlzLmRhdGE9ZX1mdW5jdGlvbiBfZSgpe31mdW5jdGlvbiBNZSgpe3RoaXMuYm91bmRzPW51bGwsdGhpcy5pdGVtPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYm91bmRzPXQsdGhpcy5pdGVtPWV9ZnVuY3Rpb24gRGUoKXt0aGlzLl9zaXplPW51bGwsdGhpcy5pdGVtcz1udWxsLHRoaXMuX3NpemU9MCx0aGlzLml0ZW1zPW5ldyBJLHRoaXMuaXRlbXMuYWRkKG51bGwpfWZ1bmN0aW9uIEFlKCl7fWZ1bmN0aW9uIEZlKCl7fWZ1bmN0aW9uIEdlKCl7aWYodGhpcy5jaGlsZEJvdW5kYWJsZXM9bmV3IEksdGhpcy5ib3VuZHM9bnVsbCx0aGlzLmxldmVsPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxldmVsPXR9fWZ1bmN0aW9uIHFlKCl7dGhpcy5ib3VuZGFibGUxPW51bGwsdGhpcy5ib3VuZGFibGUyPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLml0ZW1EaXN0YW5jZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmJvdW5kYWJsZTE9dCx0aGlzLmJvdW5kYWJsZTI9ZSx0aGlzLml0ZW1EaXN0YW5jZT1uLHRoaXMuX2Rpc3RhbmNlPXRoaXMuZGlzdGFuY2UoKX1mdW5jdGlvbiBCZSgpe2lmKHRoaXMucm9vdD1udWxsLHRoaXMuYnVpbHQ9ITEsdGhpcy5pdGVtQm91bmRhYmxlcz1uZXcgSSx0aGlzLm5vZGVDYXBhY2l0eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKUJlLmNhbGwodGhpcyxCZS5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtmLmlzVHJ1ZSh0PjEsXCJOb2RlIGNhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksdGhpcy5ub2RlQ2FwYWNpdHk9dH19ZnVuY3Rpb24gemUoKXt9ZnVuY3Rpb24gVmUoKXt9ZnVuY3Rpb24ga2UoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClrZS5jYWxsKHRoaXMsa2UuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07QmUuY2FsbCh0aGlzLHQpfX1mdW5jdGlvbiBZZSgpe3ZhciB0PWFyZ3VtZW50c1swXTtHZS5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24gVWUoKXt9ZnVuY3Rpb24gWGUoKXt0aGlzLnNlZ1N0cmluZz1udWxsLHRoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuc2VnbWVudE9jdGFudD1udWxsLHRoaXMuX2lzSW50ZXJpb3I9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dGhpcy5zZWdTdHJpbmc9dCx0aGlzLmNvb3JkPW5ldyBnKGUpLHRoaXMuc2VnbWVudEluZGV4PW4sdGhpcy5zZWdtZW50T2N0YW50PWksdGhpcy5faXNJbnRlcmlvcj0hZS5lcXVhbHMyRCh0LmdldENvb3JkaW5hdGUobikpfWZ1bmN0aW9uIEhlKCl7dGhpcy5ub2RlTWFwPW5ldyBydCx0aGlzLmVkZ2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lZGdlPXR9ZnVuY3Rpb24gV2UoKXt0aGlzLm5vZGVMaXN0PW51bGwsdGhpcy5lZGdlPW51bGwsdGhpcy5ub2RlSXQ9bnVsbCx0aGlzLmN1cnJOb2RlPW51bGwsdGhpcy5uZXh0Tm9kZT1udWxsLHRoaXMuY3VyclNlZ0luZGV4PTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUxpc3Q9dCx0aGlzLmVkZ2U9dC5nZXRFZGdlKCksdGhpcy5ub2RlSXQ9dC5pdGVyYXRvcigpLHRoaXMucmVhZE5leHROb2RlKCl9ZnVuY3Rpb24gamUoKXt9ZnVuY3Rpb24gS2UoKXt0aGlzLm5vZGVMaXN0PW5ldyBIZSh0aGlzKSx0aGlzLnB0cz1udWxsLHRoaXMuZGF0YT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz10LHRoaXMuZGF0YT1lfWZ1bmN0aW9uIFplKCl7dGhpcy50ZW1wRW52MT1uZXcgQyx0aGlzLnRlbXBFbnYyPW5ldyBDLHRoaXMub3ZlcmxhcFNlZzE9bmV3IGNlLHRoaXMub3ZlcmxhcFNlZzI9bmV3IGNlfWZ1bmN0aW9uIFFlKCl7dGhpcy5wdHM9bnVsbCx0aGlzLnN0YXJ0PW51bGwsdGhpcy5lbmQ9bnVsbCx0aGlzLmVudj1udWxsLHRoaXMuY29udGV4dD1udWxsLHRoaXMuaWQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dGhpcy5wdHM9dCx0aGlzLnN0YXJ0PWUsdGhpcy5lbmQ9bix0aGlzLmNvbnRleHQ9aX1mdW5jdGlvbiBKZSgpe31mdW5jdGlvbiAkZSgpe31mdW5jdGlvbiB0bigpe31mdW5jdGlvbiBlbigpe2lmKHRoaXMuc2VnSW50PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0KX19ZnVuY3Rpb24gbm4oKXtpZih0aGlzLm1vbm9DaGFpbnM9bmV3IEksdGhpcy5pbmRleD1uZXcga2UsdGhpcy5pZENvdW50ZXI9MCx0aGlzLm5vZGVkU2VnU3RyaW5ncz1udWxsLHRoaXMubk92ZXJsYXBzPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtlbi5jYWxsKHRoaXMsdCl9fWZ1bmN0aW9uIHJuKCl7WmUuYXBwbHkodGhpcyksdGhpcy5zaT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNpPXR9ZnVuY3Rpb24gc24oKXtpZih0aGlzLnB0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07bC5jYWxsKHRoaXMsc24ubXNnV2l0aENvb3JkKGUsbikpLHRoaXMucHQ9bmV3IGcobil9fWZ1bmN0aW9uIG9uKCl7fWZ1bmN0aW9uIGFuKCl7dGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLmlzQ2hlY2tFbmRTZWdtZW50c09ubHk9ITEsdGhpcy5saT1udWxsLHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb249bnVsbCx0aGlzLmludFNlZ21lbnRzPW51bGwsdGhpcy5pbnRlcnNlY3Rpb25zPW5ldyBJLHRoaXMuaW50ZXJzZWN0aW9uQ291bnQ9MCx0aGlzLmtlZXBJbnRlcnNlY3Rpb25zPSEwO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpPXQsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbj1udWxsfWZ1bmN0aW9uIHVuKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5zZWdTdHJpbmdzPW51bGwsdGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLnNlZ0ludD1udWxsLHRoaXMuX2lzVmFsaWQ9ITA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2VnU3RyaW5ncz10fWZ1bmN0aW9uIGxuKCl7dGhpcy5udj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm52PW5ldyB1bihsbi50b1NlZ21lbnRTdHJpbmdzKHQpKX1mdW5jdGlvbiBobigpe3RoaXMubWFwT3A9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tYXBPcD10fWZ1bmN0aW9uIGNuKCl7fWZ1bmN0aW9uIGZuKCl7aWYodGhpcy5sb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQubGVuZ3RoKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCgxKSx0aGlzLmxvY2F0aW9uW2NuLk9OXT1lfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmbil7dmFyIG49YXJndW1lbnRzWzBdO2lmKHRoaXMuaW5pdChuLmxvY2F0aW9uLmxlbmd0aCksbnVsbCE9PW4pZm9yKHZhciBpPTA7aTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtpKyspdGhpcy5sb2NhdGlvbltpXT1uLmxvY2F0aW9uW2ldfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5pbml0KDMpLHRoaXMubG9jYXRpb25bY24uT05dPXIsdGhpcy5sb2NhdGlvbltjbi5MRUZUXT1zLHRoaXMubG9jYXRpb25bY24uUklHSFRdPW99fWZ1bmN0aW9uIGduKCl7aWYodGhpcy5lbHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBmbih0KSx0aGlzLmVsdFsxXT1uZXcgZm4odCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGduKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IGZuKGUuZWx0WzBdKSx0aGlzLmVsdFsxXT1uZXcgZm4oZS5lbHRbMV0pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5lbHRbMF09bmV3IGZuKEwuTk9ORSksdGhpcy5lbHRbMV09bmV3IGZuKEwuTk9ORSksdGhpcy5lbHRbbl0uc2V0TG9jYXRpb24oaSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMuZWx0WzBdPW5ldyBmbihyLHMsbyksdGhpcy5lbHRbMV09bmV3IGZuKHIscyxvKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV0sbD1hcmd1bWVudHNbMl0saD1hcmd1bWVudHNbM107dGhpcy5lbHRbMF09bmV3IGZuKEwuTk9ORSxMLk5PTkUsTC5OT05FKSx0aGlzLmVsdFsxXT1uZXcgZm4oTC5OT05FLEwuTk9ORSxMLk5PTkUpLHRoaXMuZWx0W2FdLnNldExvY2F0aW9ucyh1LGwsaCl9fWZ1bmN0aW9uIGRuKCl7dGhpcy5zdGFydERlPW51bGwsdGhpcy5tYXhOb2RlRGVncmVlPS0xLHRoaXMuZWRnZXM9bmV3IEksdGhpcy5wdHM9bmV3IEksdGhpcy5sYWJlbD1uZXcgZ24oTC5OT05FKSx0aGlzLnJpbmc9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLnNoZWxsPW51bGwsdGhpcy5ob2xlcz1uZXcgSSx0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21ldHJ5RmFjdG9yeT1lLHRoaXMuY29tcHV0ZVBvaW50cyh0KSx0aGlzLmNvbXB1dGVSaW5nKCl9ZnVuY3Rpb24gcG4oKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZG4uY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gdm4oKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZG4uY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gbW4oKXtpZih0aGlzLmxhYmVsPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc0NvdmVyZWQ9ITEsdGhpcy5faXNDb3ZlcmVkU2V0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGFiZWw9dH19ZnVuY3Rpb24geW4oKXttbi5hcHBseSh0aGlzKSx0aGlzLmNvb3JkPW51bGwsdGhpcy5lZGdlcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmNvb3JkPXQsdGhpcy5lZGdlcz1lLHRoaXMubGFiZWw9bmV3IGduKDAsTC5OT05FKX1mdW5jdGlvbiB4bigpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5ub2RlRmFjdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVGYWN0PXR9ZnVuY3Rpb24gRW4oKXtpZih0aGlzLmVkZ2U9bnVsbCx0aGlzLmxhYmVsPW51bGwsdGhpcy5ub2RlPW51bGwsdGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLmR4PW51bGwsdGhpcy5keT1udWxsLHRoaXMucXVhZHJhbnQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWFyZ3VtZW50c1syXTtFbi5jYWxsKHRoaXMsZSxuLGksbnVsbCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9YXJndW1lbnRzWzNdO0VuLmNhbGwodGhpcyxyKSx0aGlzLmluaXQocyxvKSx0aGlzLmxhYmVsPWF9fWZ1bmN0aW9uIEluKCl7dGhpcy5faXNGb3J3YXJkPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5zeW09bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLm5leHRNaW49bnVsbCx0aGlzLmVkZ2VSaW5nPW51bGwsdGhpcy5taW5FZGdlUmluZz1udWxsLHRoaXMuZGVwdGg9WzAsLTk5OSwtOTk5XTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoRW4uY2FsbCh0aGlzLHQpLHRoaXMuX2lzRm9yd2FyZD1lLGUpdGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZSgwKSx0LmdldENvb3JkaW5hdGUoMSkpO2Vsc2V7dmFyIG49dC5nZXROdW1Qb2ludHMoKS0xO3RoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUobiksdC5nZXRDb29yZGluYXRlKG4tMSkpfXRoaXMuY29tcHV0ZURpcmVjdGVkTGFiZWwoKX1mdW5jdGlvbiBObigpe31mdW5jdGlvbiBDbigpe2lmKHRoaXMuZWRnZXM9bmV3IEksdGhpcy5ub2Rlcz1udWxsLHRoaXMuZWRnZUVuZExpc3Q9bmV3IEksMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5ub2Rlcz1uZXcgeG4obmV3IE5uKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ub2Rlcz1uZXcgeG4odCl9fWZ1bmN0aW9uIFNuKCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLnNoZWxsTGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dH1mdW5jdGlvbiB3bigpe3RoaXMub3A9bnVsbCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMucHRMb2NhdG9yPW51bGwsdGhpcy5saW5lRWRnZXNMaXN0PW5ldyBJLHRoaXMucmVzdWx0TGluZUxpc3Q9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMub3A9dCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1lLHRoaXMucHRMb2NhdG9yPW59ZnVuY3Rpb24gTG4oKXt0aGlzLm9wPW51bGwsdGhpcy5nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLnJlc3VsdFBvaW50TGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdO3RoaXMub3A9dCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1lfWZ1bmN0aW9uIFJuKCl7fWZ1bmN0aW9uIFRuKCl7dGhpcy5nZW9tPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbT10fWZ1bmN0aW9uIFBuKCl7dGhpcy5lZGdlTWFwPW5ldyBydCx0aGlzLmVkZ2VMaXN0PW51bGwsdGhpcy5wdEluQXJlYUxvY2F0aW9uPVtMLk5PTkUsTC5OT05FXX1mdW5jdGlvbiBibigpe1BuLmFwcGx5KHRoaXMpLHRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0PW51bGwsdGhpcy5sYWJlbD1udWxsLHRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HPTEsdGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HPTJ9ZnVuY3Rpb24gT24oKXtObi5hcHBseSh0aGlzKX1mdW5jdGlvbiBfbigpe3RoaXMubWNlPW51bGwsdGhpcy5jaGFpbkluZGV4PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubWNlPXQsdGhpcy5jaGFpbkluZGV4PWV9ZnVuY3Rpb24gTW4oKXtpZih0aGlzLmxhYmVsPW51bGwsdGhpcy54VmFsdWU9bnVsbCx0aGlzLmV2ZW50VHlwZT1udWxsLHRoaXMuaW5zZXJ0RXZlbnQ9bnVsbCx0aGlzLmRlbGV0ZUV2ZW50SW5kZXg9bnVsbCx0aGlzLm9iaj1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5ldmVudFR5cGU9TW4uREVMRVRFLHRoaXMueFZhbHVlPXQsdGhpcy5pbnNlcnRFdmVudD1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmV2ZW50VHlwZT1Nbi5JTlNFUlQsdGhpcy5sYWJlbD1uLHRoaXMueFZhbHVlPWksdGhpcy5vYmo9cn19ZnVuY3Rpb24gRG4oKXt9ZnVuY3Rpb24gQW4oKXt0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5oYXNQcm9wZXI9ITEsdGhpcy5oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5saT1udWxsLHRoaXMuaW5jbHVkZVByb3Blcj1udWxsLHRoaXMucmVjb3JkSXNvbGF0ZWQ9bnVsbCx0aGlzLmlzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMubnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtVGVzdHM9MCx0aGlzLmJkeU5vZGVzPW51bGwsdGhpcy5faXNEb25lPSExLHRoaXMuaXNEb25lV2hlblByb3BlckludD0hMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5saT10LHRoaXMuaW5jbHVkZVByb3Blcj1lLHRoaXMucmVjb3JkSXNvbGF0ZWQ9bn1mdW5jdGlvbiBGbigpe0RuLmFwcGx5KHRoaXMpLHRoaXMuZXZlbnRzPW5ldyBJLHRoaXMubk92ZXJsYXBzPW51bGx9ZnVuY3Rpb24gR24oKXt0aGlzLm1pbj1yLlBPU0lUSVZFX0lORklOSVRZLHRoaXMubWF4PXIuTkVHQVRJVkVfSU5GSU5JVFl9ZnVuY3Rpb24gcW4oKXt9ZnVuY3Rpb24gQm4oKXtHbi5hcHBseSh0aGlzKSx0aGlzLml0ZW09bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5taW49dCx0aGlzLm1heD1lLHRoaXMuaXRlbT1ufWZ1bmN0aW9uIHpuKCl7R24uYXBwbHkodGhpcyksdGhpcy5ub2RlMT1udWxsLHRoaXMubm9kZTI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5ub2RlMT10LHRoaXMubm9kZTI9ZSx0aGlzLmJ1aWxkRXh0ZW50KHRoaXMubm9kZTEsdGhpcy5ub2RlMil9ZnVuY3Rpb24gVm4oKXt0aGlzLmxlYXZlcz1uZXcgSSx0aGlzLnJvb3Q9bnVsbCx0aGlzLmxldmVsPTB9ZnVuY3Rpb24ga24oKXtpZih0aGlzLmxpbmVzPW51bGwsdGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZz0hMSwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGluZXM9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5saW5lcz1lLHRoaXMuaXNGb3JjZWRUb0xpbmVTdHJpbmc9bn19ZnVuY3Rpb24gWW4oKXt0aGlzLml0ZW1zPW5ldyBJfWZ1bmN0aW9uIFVuKCl7dGhpcy5pbmRleD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTtpZighUih0LFJ0KSl0aHJvdyBuZXcgaShcIkFyZ3VtZW50IG11c3QgYmUgUG9seWdvbmFsXCIpO3RoaXMuaW5kZXg9bmV3IEhuKHQpfWZ1bmN0aW9uIFhuKCl7dGhpcy5jb3VudGVyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY291bnRlcj10fWZ1bmN0aW9uIEhuKCl7dGhpcy5pbmRleD1uZXcgVm47dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1mdW5jdGlvbiBXbigpe3RoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuZGlzdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmNvb3JkPW5ldyBnKHQpLHRoaXMuc2VnbWVudEluZGV4PWUsdGhpcy5kaXN0PW59ZnVuY3Rpb24gam4oKXt0aGlzLm5vZGVNYXA9bmV3IHJ0LHRoaXMuZWRnZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmVkZ2U9dH1mdW5jdGlvbiBLbigpe31mdW5jdGlvbiBabigpe3RoaXMuZT1udWxsLHRoaXMucHRzPW51bGwsdGhpcy5zdGFydEluZGV4PW51bGwsdGhpcy5lbnYxPW5ldyBDLHRoaXMuZW52Mj1uZXcgQzt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lPXQsdGhpcy5wdHM9dC5nZXRDb29yZGluYXRlcygpO3ZhciBlPW5ldyBLbjt0aGlzLnN0YXJ0SW5kZXg9ZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyh0aGlzLnB0cyl9ZnVuY3Rpb24gUW4oKXt0aGlzLmRlcHRoPUFycmF5KDIpLmZpbGwoKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkoMyl9KTtmb3IodmFyIHQ9MDsyPnQ7dCsrKWZvcih2YXIgZT0wOzM+ZTtlKyspdGhpcy5kZXB0aFt0XVtlXT1Rbi5OVUxMX1ZBTFVFfWZ1bmN0aW9uIEpuKCl7aWYobW4uYXBwbHkodGhpcyksdGhpcy5wdHM9bnVsbCx0aGlzLmVudj1udWxsLHRoaXMuZWlMaXN0PW5ldyBqbih0aGlzKSx0aGlzLm5hbWU9bnVsbCx0aGlzLm1jZT1udWxsLHRoaXMuX2lzSXNvbGF0ZWQ9ITAsdGhpcy5kZXB0aD1uZXcgUW4sdGhpcy5kZXB0aERlbHRhPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtKbi5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wdHM9ZSx0aGlzLmxhYmVsPW59fWZ1bmN0aW9uICRuKCl7aWYoQ24uYXBwbHkodGhpcyksdGhpcy5wYXJlbnRHZW9tPW51bGwsdGhpcy5saW5lRWRnZU1hcD1uZXcgdGUsdGhpcy5ib3VuZGFyeU5vZGVSdWxlPW51bGwsdGhpcy51c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSEwLHRoaXMuYXJnSW5kZXg9bnVsbCx0aGlzLmJvdW5kYXJ5Tm9kZXM9bnVsbCx0aGlzLl9oYXNUb29GZXdQb2ludHM9ITEsdGhpcy5pbnZhbGlkUG9pbnQ9bnVsbCx0aGlzLmFyZWFQdExvY2F0b3I9bnVsbCx0aGlzLnB0TG9jYXRvcj1uZXcgVGUsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTskbi5jYWxsKHRoaXMsdCxlLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5hcmdJbmRleD1uLHRoaXMucGFyZW50R2VvbT1pLHRoaXMuYm91bmRhcnlOb2RlUnVsZT1yLG51bGwhPT1pJiZ0aGlzLmFkZChpKX19ZnVuY3Rpb24gdGkoKXtpZih0aGlzLmxpPW5ldyBhZSx0aGlzLnJlc3VsdFByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5hcmc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLmFyZz1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSx0aGlzLmFyZ1swXT1uZXcgJG4oMCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGkuY2FsbCh0aGlzLGUsbixWLk9HQ19TRlNfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO2kuZ2V0UHJlY2lzaW9uTW9kZWwoKS5jb21wYXJlVG8oci5nZXRQcmVjaXNpb25Nb2RlbCgpKT49MD90aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGkuZ2V0UHJlY2lzaW9uTW9kZWwoKSk6dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihyLmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuYXJnPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuYXJnWzBdPW5ldyAkbigwLGkscyksdGhpcy5hcmdbMV09bmV3ICRuKDEscixzKX19ZnVuY3Rpb24gZWkoKXt0aGlzLnB0cz1udWxsLHRoaXMuX29yaWVudGF0aW9uPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPXQsdGhpcy5fb3JpZW50YXRpb249ZWkub3JpZW50YXRpb24odCl9ZnVuY3Rpb24gbmkoKXt0aGlzLmVkZ2VzPW5ldyBJLHRoaXMub2NhTWFwPW5ldyBydH1mdW5jdGlvbiBpaSgpe3RoaXMucHRMb2NhdG9yPW5ldyBUZSx0aGlzLmdlb21GYWN0PW51bGwsdGhpcy5yZXN1bHRHZW9tPW51bGwsdGhpcy5ncmFwaD1udWxsLHRoaXMuZWRnZUxpc3Q9bmV3IG5pLHRoaXMucmVzdWx0UG9seUxpc3Q9bmV3IEksdGhpcy5yZXN1bHRMaW5lTGlzdD1uZXcgSSx0aGlzLnJlc3VsdFBvaW50TGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGkuY2FsbCh0aGlzLHQsZSksdGhpcy5ncmFwaD1uZXcgQ24obmV3IE9uKSx0aGlzLmdlb21GYWN0PXQuZ2V0RmFjdG9yeSgpfWZ1bmN0aW9uIHJpKCl7dGhpcy5nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuY2JyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZ2VvbVswXT10LHRoaXMuZ2VvbVsxXT1lLHRoaXMuY29tcHV0ZVNuYXBUb2xlcmFuY2UoKX1mdW5jdGlvbiBzaSgpe3RoaXMuZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5nZW9tWzBdPXQsdGhpcy5nZW9tWzFdPWV9ZnVuY3Rpb24gb2koKXt0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmludGVyaW9yUG9pbnQ9bnVsbCx0aGlzLm1heFdpZHRoPTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0aGlzLmFkZCh0KX1mdW5jdGlvbiBhaSgpe3RoaXMucG9seT1udWxsLHRoaXMuY2VudHJlWT1udWxsLHRoaXMuaGlZPXIuTUFYX1ZBTFVFLHRoaXMubG9ZPS1yLk1BWF9WQUxVRTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wb2x5PXQsdGhpcy5oaVk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWF4WSgpLHRoaXMubG9ZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1pblkoKSx0aGlzLmNlbnRyZVk9b2kuYXZnKHRoaXMubG9ZLHRoaXMuaGlZKX1mdW5jdGlvbiB1aSgpe3RoaXMuY2VudHJvaWQ9bnVsbCx0aGlzLm1pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuaW50ZXJpb3JQb2ludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNlbnRyb2lkPXQuZ2V0Q2VudHJvaWQoKS5nZXRDb29yZGluYXRlKCksdGhpcy5hZGRJbnRlcmlvcih0KSxudWxsPT09dGhpcy5pbnRlcmlvclBvaW50JiZ0aGlzLmFkZEVuZHBvaW50cyh0KX1mdW5jdGlvbiBsaSgpe3RoaXMuY2VudHJvaWQ9bnVsbCx0aGlzLm1pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuaW50ZXJpb3JQb2ludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNlbnRyb2lkPXQuZ2V0Q2VudHJvaWQoKS5nZXRDb29yZGluYXRlKCksdGhpcy5hZGQodCl9ZnVuY3Rpb24gaGkoKXt9ZnVuY3Rpb24gY2koKXt0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMucDI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5wMD10LHRoaXMucDE9ZSx0aGlzLnAyPW59ZnVuY3Rpb24gZmkoKXt0aGlzLmlucHV0PW51bGwsdGhpcy5leHRyZW1hbFB0cz1udWxsLHRoaXMuY2VudHJlPW51bGwsdGhpcy5yYWRpdXM9MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dD10fWZ1bmN0aW9uIGdpKCl7aWYodGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmlzQ29udmV4PW51bGwsdGhpcy5jb252ZXhIdWxsUHRzPW51bGwsdGhpcy5taW5CYXNlU2VnPW5ldyBjZSx0aGlzLm1pbldpZHRoUHQ9bnVsbCx0aGlzLm1pblB0SW5kZXg9bnVsbCx0aGlzLm1pbldpZHRoPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtnaS5jYWxsKHRoaXMsdCwhMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuaW5wdXRHZW9tPWUsdGhpcy5pc0NvbnZleD1ufX1mdW5jdGlvbiBkaSgpe3RoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0R2VvbT10fWZ1bmN0aW9uIHBpKCl7eGUuYXBwbHkodGhpcyksdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9ZnVuY3Rpb24gdmkoKXt0aGlzLl9vcmlnPW51bGwsdGhpcy5fc3ltPW51bGwsdGhpcy5fbmV4dD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLl9vcmlnPXR9ZnVuY3Rpb24gbWkoKXt0aGlzLl9pc01hcmtlZD0hMTt2YXIgdD1hcmd1bWVudHNbMF07dmkuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIHlpKCl7dGhpcy52ZXJ0ZXhNYXA9bmV3IHRlfWZ1bmN0aW9uIHhpKCl7dGhpcy5faXNTdGFydD0hMTt2YXIgdD1hcmd1bWVudHNbMF07bWkuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIEVpKCl7eWkuYXBwbHkodGhpcyl9ZnVuY3Rpb24gSWkoKXt0aGlzLnJlc3VsdD1udWxsLHRoaXMuZmFjdG9yeT1udWxsLHRoaXMuZ3JhcGg9bnVsbCx0aGlzLmxpbmVzPW5ldyBJLHRoaXMubm9kZUVkZ2VTdGFjaz1uZXcgcGUsdGhpcy5yaW5nU3RhcnRFZGdlPW51bGwsdGhpcy5ncmFwaD1uZXcgRWl9ZnVuY3Rpb24gTmkoKXt0aGlzLml0ZW1zPW5ldyBJLHRoaXMuc3Vibm9kZT1uZXcgQXJyYXkoNCkuZmlsbChudWxsKX1mdW5jdGlvbiBDaSgpe31mdW5jdGlvbiBTaSh0LGUpe3ZhciBuLGkscixzLG89ezMyOntkOjEyNyxjOjEyOCxiOjAsYTowfSw2NDp7ZDozMjc1MixjOjAsYjowLGE6MH19LGE9ezMyOjgsNjQ6MTF9W3RdO2lmKHN8fChuPTA+ZXx8MD4xL2UsaXNGaW5pdGUoZSl8fChzPW9bdF0sbiYmKHMuZCs9MTw8dC80LTEpLGk9TWF0aC5wb3coMixhKS0xLHI9MCkpLCFzKXtmb3IoaT17MzI6MTI3LDY0OjEwMjN9W3RdLHI9TWF0aC5hYnMoZSk7cj49MjspaSsrLHIvPTI7Zm9yKDsxPnImJmk+MDspaS0tLHIqPTI7MD49aSYmKHIvPTIpLDMyPT09dCYmaT4yNTQmJihzPXtkOm4/MjU1OjEyNyxjOjEyOCxiOjAsYTowfSxpPU1hdGgucG93KDIsYSktMSxyPTApfXJldHVybiBpfWZ1bmN0aW9uIHdpKCl7dGhpcy5wdD1uZXcgZyx0aGlzLmxldmVsPTAsdGhpcy5lbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfWZ1bmN0aW9uIExpKCl7TmkuYXBwbHkodGhpcyksdGhpcy5lbnY9bnVsbCx0aGlzLmNlbnRyZXg9bnVsbCx0aGlzLmNlbnRyZXk9bnVsbCx0aGlzLmxldmVsPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZW52PXQsdGhpcy5sZXZlbD1lLHRoaXMuY2VudHJleD0odC5nZXRNaW5YKCkrdC5nZXRNYXhYKCkpLzIsdGhpcy5jZW50cmV5PSh0LmdldE1pblkoKSt0LmdldE1heFkoKSkvMn1mdW5jdGlvbiBSaSgpe31mdW5jdGlvbiBUaSgpe05pLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIFBpKCl7dGhpcy5yb290PW51bGwsdGhpcy5taW5FeHRlbnQ9MSx0aGlzLnJvb3Q9bmV3IFRpfWZ1bmN0aW9uIGJpKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZX1mdW5jdGlvbiBPaSh0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgaWUsdGhpcy5wcmVjaXNpb25Nb2RlbD10aGlzLmdlb21ldHJ5RmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpLHRoaXMucGFyc2VyPW5ldyBiaSh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9ZnVuY3Rpb24gX2koKXt0aGlzLnBhcnNlcj1uZXcgYmkodGhpcy5nZW9tZXRyeUZhY3RvcnkpfWZ1bmN0aW9uIE1pKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZSx0aGlzLnByZWNpc2lvbk1vZGVsPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCksdGhpcy5wYXJzZXI9bmV3IHJlKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX1mdW5jdGlvbiBEaSh0KXtyZXR1cm5bdC54LHQueV19ZnVuY3Rpb24gQWkodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllfWZ1bmN0aW9uIEZpKCl7aWYodGhpcy5ub2Rlcj1udWxsLHRoaXMuc2NhbGVGYWN0b3I9bnVsbCx0aGlzLm9mZnNldFg9bnVsbCx0aGlzLm9mZnNldFk9bnVsbCx0aGlzLmlzU2NhbGVkPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07RmkuY2FsbCh0aGlzLHQsZSwwLDApfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdO3RoaXMubm9kZXI9bix0aGlzLnNjYWxlRmFjdG9yPWksdGhpcy5pc1NjYWxlZD0hdGhpcy5pc0ludGVnZXJQcmVjaXNpb24oKX19ZnVuY3Rpb24gR2koKXtpZih0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuaXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSEwLHRoaXMubm9uU2ltcGxlTG9jYXRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuaW5wdXRHZW9tPWUsdGhpcy5pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9IW4uaXNJbkJvdW5kYXJ5KDIpfX1mdW5jdGlvbiBxaSgpe3RoaXMucHQ9bnVsbCx0aGlzLmlzQ2xvc2VkPW51bGwsdGhpcy5kZWdyZWU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wdD10LHRoaXMuaXNDbG9zZWQ9ITEsdGhpcy5kZWdyZWU9MH1mdW5jdGlvbiBCaSgpe2lmKHRoaXMucXVhZHJhbnRTZWdtZW50cz1CaS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTLHRoaXMuZW5kQ2FwU3R5bGU9QmkuQ0FQX1JPVU5ELHRoaXMuam9pblN0eWxlPUJpLkpPSU5fUk9VTkQsdGhpcy5taXRyZUxpbWl0PUJpLkRFRkFVTFRfTUlUUkVfTElNSVQsdGhpcy5faXNTaW5nbGVTaWRlZD0hMSx0aGlzLnNpbXBsaWZ5RmFjdG9yPUJpLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHMoZSksdGhpcy5zZXRFbmRDYXBTdHlsZShuKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbz1hcmd1bWVudHNbM107dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKGkpLHRoaXMuc2V0RW5kQ2FwU3R5bGUociksdGhpcy5zZXRKb2luU3R5bGUocyksdGhpcy5zZXRNaXRyZUxpbWl0KG8pfX1mdW5jdGlvbiB6aSgpe3RoaXMubWluSW5kZXg9LTEsdGhpcy5taW5Db29yZD1udWxsLHRoaXMubWluRGU9bnVsbCx0aGlzLm9yaWVudGVkRGU9bnVsbH1mdW5jdGlvbiBWaSgpe3RoaXMuYXJyYXlfPVtdfWZ1bmN0aW9uIGtpKCl7dGhpcy5maW5kZXI9bnVsbCx0aGlzLmRpckVkZ2VMaXN0PW5ldyBJLHRoaXMubm9kZXM9bmV3IEksdGhpcy5yaWdodE1vc3RDb29yZD1udWxsLHRoaXMuZW52PW51bGwsdGhpcy5maW5kZXI9bmV3IHppfWZ1bmN0aW9uIFlpKCl7dGhpcy5pbnB1dExpbmU9bnVsbCxcbnRoaXMuZGlzdGFuY2VUb2w9bnVsbCx0aGlzLmlzRGVsZXRlZD1udWxsLHRoaXMuYW5nbGVPcmllbnRhdGlvbj1oZS5DT1VOVEVSQ0xPQ0tXSVNFO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0TGluZT10fWZ1bmN0aW9uIFVpKCl7dGhpcy5wdExpc3Q9bnVsbCx0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5taW5pbWltVmVydGV4RGlzdGFuY2U9MCx0aGlzLnB0TGlzdD1uZXcgSX1mdW5jdGlvbiBYaSgpe3RoaXMubWF4Q3VydmVTZWdtZW50RXJyb3I9MCx0aGlzLmZpbGxldEFuZ2xlUXVhbnR1bT1udWxsLHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj0xLHRoaXMuc2VnTGlzdD1udWxsLHRoaXMuZGlzdGFuY2U9MCx0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5idWZQYXJhbXM9bnVsbCx0aGlzLmxpPW51bGwsdGhpcy5zMD1udWxsLHRoaXMuczE9bnVsbCx0aGlzLnMyPW51bGwsdGhpcy5zZWcwPW5ldyBjZSx0aGlzLnNlZzE9bmV3IGNlLHRoaXMub2Zmc2V0MD1uZXcgY2UsdGhpcy5vZmZzZXQxPW5ldyBjZSx0aGlzLnNpZGU9MCx0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITE7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMucHJlY2lzaW9uTW9kZWw9dCx0aGlzLmJ1ZlBhcmFtcz1lLHRoaXMubGk9bmV3IGFlLHRoaXMuZmlsbGV0QW5nbGVRdWFudHVtPU1hdGguUEkvMi9lLmdldFF1YWRyYW50U2VnbWVudHMoKSxlLmdldFF1YWRyYW50U2VnbWVudHMoKT49OCYmZS5nZXRKb2luU3R5bGUoKT09PUJpLkpPSU5fUk9VTkQmJih0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3I9WGkuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1IpLHRoaXMuaW5pdChuKX1mdW5jdGlvbiBIaSgpe3RoaXMuZGlzdGFuY2U9MCx0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5idWZQYXJhbXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wcmVjaXNpb25Nb2RlbD10LHRoaXMuYnVmUGFyYW1zPWV9ZnVuY3Rpb24gV2koKXt0aGlzLnN1YmdyYXBocz1udWxsLHRoaXMuc2VnPW5ldyBjZSx0aGlzLmNnYT1uZXcgaGU7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc3ViZ3JhcGhzPXR9ZnVuY3Rpb24gamkoKXt0aGlzLnVwd2FyZFNlZz1udWxsLHRoaXMubGVmdERlcHRoPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMudXB3YXJkU2VnPW5ldyBjZSh0KSx0aGlzLmxlZnREZXB0aD1lfWZ1bmN0aW9uIEtpKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmRpc3RhbmNlPW51bGwsdGhpcy5jdXJ2ZUJ1aWxkZXI9bnVsbCx0aGlzLmN1cnZlTGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5pbnB1dEdlb209dCx0aGlzLmRpc3RhbmNlPWUsdGhpcy5jdXJ2ZUJ1aWxkZXI9bn1mdW5jdGlvbiBaaSgpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLmhhc1Byb3Blcj0hMSx0aGlzLmhhc1Byb3BlckludGVyaW9yPSExLHRoaXMuaGFzSW50ZXJpb3I9ITEsdGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMubGk9bnVsbCx0aGlzLmlzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMubnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpPXR9ZnVuY3Rpb24gUWkoKXt0aGlzLmJ1ZlBhcmFtcz1udWxsLHRoaXMud29ya2luZ1ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy53b3JraW5nTm9kZXI9bnVsbCx0aGlzLmdlb21GYWN0PW51bGwsdGhpcy5ncmFwaD1udWxsLHRoaXMuZWRnZUxpc3Q9bmV3IG5pO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmJ1ZlBhcmFtcz10fWZ1bmN0aW9uIEppKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5zZWdTdHJpbmdzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2VnU3RyaW5ncz10fWZ1bmN0aW9uICRpKCl7dGhpcy5saT1udWxsLHRoaXMucHQ9bnVsbCx0aGlzLm9yaWdpbmFsUHQ9bnVsbCx0aGlzLnB0U2NhbGVkPW51bGwsdGhpcy5wMFNjYWxlZD1udWxsLHRoaXMucDFTY2FsZWQ9bnVsbCx0aGlzLnNjYWxlRmFjdG9yPW51bGwsdGhpcy5taW54PW51bGwsdGhpcy5tYXh4PW51bGwsdGhpcy5taW55PW51bGwsdGhpcy5tYXh5PW51bGwsdGhpcy5jb3JuZXI9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5zYWZlRW52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMub3JpZ2luYWxQdD10LHRoaXMucHQ9dCx0aGlzLnNjYWxlRmFjdG9yPWUsdGhpcy5saT1uLDA+PWUpdGhyb3cgbmV3IGkoXCJTY2FsZSBmYWN0b3IgbXVzdCBiZSBub24temVyb1wiKTsxIT09ZSYmKHRoaXMucHQ9bmV3IGcodGhpcy5zY2FsZSh0LngpLHRoaXMuc2NhbGUodC55KSksdGhpcy5wMFNjYWxlZD1uZXcgZyx0aGlzLnAxU2NhbGVkPW5ldyBnKSx0aGlzLmluaXRDb3JuZXJzKHRoaXMucHQpfWZ1bmN0aW9uIHRyKCl7dGhpcy50ZW1wRW52MT1uZXcgQyx0aGlzLnNlbGVjdGVkU2VnbWVudD1uZXcgY2V9ZnVuY3Rpb24gZXIoKXt0aGlzLmluZGV4PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5kZXg9dH1mdW5jdGlvbiBucigpe3RyLmFwcGx5KHRoaXMpLHRoaXMuaG90UGl4ZWw9bnVsbCx0aGlzLnBhcmVudEVkZ2U9bnVsbCx0aGlzLmhvdFBpeGVsVmVydGV4SW5kZXg9bnVsbCx0aGlzLl9pc05vZGVBZGRlZD0hMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5ob3RQaXhlbD10LHRoaXMucGFyZW50RWRnZT1lLHRoaXMuaG90UGl4ZWxWZXJ0ZXhJbmRleD1ufWZ1bmN0aW9uIGlyKCl7dGhpcy5saT1udWxsLHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGk9dCx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ucz1uZXcgSX1mdW5jdGlvbiBycigpe3RoaXMucG09bnVsbCx0aGlzLmxpPW51bGwsdGhpcy5zY2FsZUZhY3Rvcj1udWxsLHRoaXMubm9kZXI9bnVsbCx0aGlzLnBvaW50U25hcHBlcj1udWxsLHRoaXMubm9kZWRTZWdTdHJpbmdzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucG09dCx0aGlzLmxpPW5ldyBhZSx0aGlzLmxpLnNldFByZWNpc2lvbk1vZGVsKHQpLHRoaXMuc2NhbGVGYWN0b3I9dC5nZXRTY2FsZSgpfWZ1bmN0aW9uIHNyKCl7aWYodGhpcy5hcmdHZW9tPW51bGwsdGhpcy5kaXN0YW5jZT1udWxsLHRoaXMuYnVmUGFyYW1zPW5ldyBCaSx0aGlzLnJlc3VsdEdlb21ldHJ5PW51bGwsdGhpcy5zYXZlRXhjZXB0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFyZ0dlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5hcmdHZW9tPWUsdGhpcy5idWZQYXJhbXM9bn19ZnVuY3Rpb24gb3IoKXt0aGlzLmNvbXBzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY29tcHM9dH1mdW5jdGlvbiBhcigpe2lmKHRoaXMuY29tcG9uZW50PW51bGwsdGhpcy5zZWdJbmRleD1udWxsLHRoaXMucHQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyLmNhbGwodGhpcyx0LGFyLklOU0lERV9BUkVBLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmNvbXBvbmVudD1uLHRoaXMuc2VnSW5kZXg9aSx0aGlzLnB0PXJ9fWZ1bmN0aW9uIHVyKCl7dGhpcy5wdHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9dH1mdW5jdGlvbiBscigpe3RoaXMubG9jYXRpb25zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubG9jYXRpb25zPXR9ZnVuY3Rpb24gaHIoKXtpZih0aGlzLmdlb209bnVsbCx0aGlzLnRlcm1pbmF0ZURpc3RhbmNlPTAsdGhpcy5wdExvY2F0b3I9bmV3IFRlLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbj1udWxsLHRoaXMubWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtoci5jYWxsKHRoaXMsdCxlLDApfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLmdlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5nZW9tWzBdPW4sdGhpcy5nZW9tWzFdPWksdGhpcy50ZXJtaW5hdGVEaXN0YW5jZT1zfX1mdW5jdGlvbiBjcigpe3RoaXMuZmFjdG9yeT1udWxsLHRoaXMuZGlyZWN0ZWRFZGdlcz1uZXcgSSx0aGlzLmNvb3JkaW5hdGVzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fWZ1bmN0aW9uIGZyKCl7dGhpcy5faXNNYXJrZWQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuZGF0YT1udWxsfWZ1bmN0aW9uIGdyKCl7ZnIuYXBwbHkodGhpcyksdGhpcy5wYXJlbnRFZGdlPW51bGwsdGhpcy5mcm9tPW51bGwsdGhpcy50bz1udWxsLHRoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5zeW09bnVsbCx0aGlzLmVkZ2VEaXJlY3Rpb249bnVsbCx0aGlzLnF1YWRyYW50PW51bGwsdGhpcy5hbmdsZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0aGlzLmZyb209dCx0aGlzLnRvPWUsdGhpcy5lZGdlRGlyZWN0aW9uPWksdGhpcy5wMD10LmdldENvb3JkaW5hdGUoKSx0aGlzLnAxPW47dmFyIHI9dGhpcy5wMS54LXRoaXMucDAueCxzPXRoaXMucDEueS10aGlzLnAwLnk7dGhpcy5xdWFkcmFudD1KZS5xdWFkcmFudChyLHMpLHRoaXMuYW5nbGU9TWF0aC5hdGFuMihzLHIpfWZ1bmN0aW9uIGRyKCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO2dyLmNhbGwodGhpcyx0LGUsbixpKX1mdW5jdGlvbiBwcigpe2lmKGZyLmFwcGx5KHRoaXMpLHRoaXMuZGlyRWRnZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXREaXJlY3RlZEVkZ2VzKHQsZSl9fWZ1bmN0aW9uIHZyKCl7dGhpcy5vdXRFZGdlcz1uZXcgSSx0aGlzLnNvcnRlZD0hMX1mdW5jdGlvbiBtcigpe2lmKGZyLmFwcGx5KHRoaXMpLHRoaXMucHQ9bnVsbCx0aGlzLmRlU3Rhcj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07bXIuY2FsbCh0aGlzLHQsbmV3IHZyKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wdD1lLHRoaXMuZGVTdGFyPW59fWZ1bmN0aW9uIHlyKCl7cHIuYXBwbHkodGhpcyksdGhpcy5saW5lPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGluZT10fWZ1bmN0aW9uIHhyKCl7dGhpcy5ub2RlTWFwPW5ldyBydH1mdW5jdGlvbiBFcigpe3RoaXMuZWRnZXM9bmV3IEosdGhpcy5kaXJFZGdlcz1uZXcgSix0aGlzLm5vZGVNYXA9bmV3IHhyfWZ1bmN0aW9uIElyKCl7RXIuYXBwbHkodGhpcyl9ZnVuY3Rpb24gTnIoKXt0aGlzLmdyYXBoPW5ldyBJcix0aGlzLm1lcmdlZExpbmVTdHJpbmdzPW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5lZGdlU3RyaW5ncz1udWxsfWZ1bmN0aW9uIENyKCl7dGhpcy5lZGdlUmluZz1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMubGFiZWw9LTE7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO2dyLmNhbGwodGhpcyx0LGUsbixpKX1mdW5jdGlvbiBTcigpe3ByLmFwcGx5KHRoaXMpLHRoaXMubGluZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpbmU9dH1mdW5jdGlvbiB3cigpe3RoaXMuZmFjdG9yeT1udWxsLHRoaXMuZGVMaXN0PW5ldyBJLHRoaXMubG93ZXN0RWRnZT1udWxsLHRoaXMucmluZz1udWxsLHRoaXMucmluZ1B0cz1udWxsLHRoaXMuaG9sZXM9bnVsbCx0aGlzLnNoZWxsPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5faXNQcm9jZXNzZWQ9ITEsdGhpcy5faXNJbmNsdWRlZFNldD0hMSx0aGlzLl9pc0luY2x1ZGVkPSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dH1mdW5jdGlvbiBMcigpe31mdW5jdGlvbiBScigpe0VyLmFwcGx5KHRoaXMpLHRoaXMuZmFjdG9yeT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dH1mdW5jdGlvbiBUcigpe2lmKHRoaXMubGluZVN0cmluZ0FkZGVyPW5ldyBQcih0aGlzKSx0aGlzLmdyYXBoPW51bGwsdGhpcy5kYW5nbGVzPW5ldyBJLHRoaXMuY3V0RWRnZXM9bmV3IEksdGhpcy5pbnZhbGlkUmluZ0xpbmVzPW5ldyBJLHRoaXMuaG9sZUxpc3Q9bnVsbCx0aGlzLnNoZWxsTGlzdD1udWxsLHRoaXMucG9seUxpc3Q9bnVsbCx0aGlzLmlzQ2hlY2tpbmdSaW5nc1ZhbGlkPSEwLHRoaXMuZXh0cmFjdE9ubHlQb2x5Z29uYWw9bnVsbCx0aGlzLmdlb21GYWN0b3J5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpVHIuY2FsbCh0aGlzLCExKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0T25seVBvbHlnb25hbD10fX1mdW5jdGlvbiBQcigpe3RoaXMucD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnA9dH1mdW5jdGlvbiBicigpe31mdW5jdGlvbiBPcigpe2lmKHRoaXMuZWRnZUVuZHM9bmV3IEksMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtPci5jYWxsKHRoaXMsbnVsbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT0oYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSk7RW4uY2FsbCh0aGlzLGUuZ2V0RWRnZSgpLGUuZ2V0Q29vcmRpbmF0ZSgpLGUuZ2V0RGlyZWN0ZWRDb29yZGluYXRlKCksbmV3IGduKGUuZ2V0TGFiZWwoKSkpLHRoaXMuaW5zZXJ0KGUpfX1mdW5jdGlvbiBfcigpe1BuLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIE1yKCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3luLmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIERyKCl7Tm4uYXBwbHkodGhpcyl9ZnVuY3Rpb24gQXIoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLnB0TG9jYXRvcj1uZXcgVGUsdGhpcy5hcmc9bnVsbCx0aGlzLm5vZGVzPW5ldyB4bihuZXcgRHIpLHRoaXMuaW09bnVsbCx0aGlzLmlzb2xhdGVkRWRnZXM9bmV3IEksdGhpcy5pbnZhbGlkUG9pbnQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hcmc9dH1mdW5jdGlvbiBGcigpe3RoaXMucmVjdEVudj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9ZnVuY3Rpb24gR3IoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLnJlY3RFbnY9bnVsbCx0aGlzLmRpYWdVcDA9bnVsbCx0aGlzLmRpYWdVcDE9bnVsbCx0aGlzLmRpYWdEb3duMD1udWxsLHRoaXMuZGlhZ0Rvd24xPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdEVudj10LHRoaXMuZGlhZ1VwMD1uZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksdGhpcy5kaWFnVXAxPW5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSx0aGlzLmRpYWdEb3duMD1uZXcgZyh0LmdldE1pblgoKSx0LmdldE1heFkoKSksdGhpcy5kaWFnRG93bjE9bmV3IGcodC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpfWZ1bmN0aW9uIHFyKCl7dGhpcy5faXNEb25lPSExfWZ1bmN0aW9uIEJyKCl7dGhpcy5yZWN0YW5nbGU9bnVsbCx0aGlzLnJlY3RFbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0YW5nbGU9dCx0aGlzLnJlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9ZnVuY3Rpb24genIoKXtxci5hcHBseSh0aGlzKSx0aGlzLnJlY3RFbnY9bnVsbCx0aGlzLl9pbnRlcnNlY3RzPSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RFbnY9dH1mdW5jdGlvbiBWcigpe3FyLmFwcGx5KHRoaXMpLHRoaXMucmVjdFNlcT1udWxsLHRoaXMucmVjdEVudj1udWxsLHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdFNlcT10LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHRoaXMucmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1mdW5jdGlvbiBrcigpe3FyLmFwcGx5KHRoaXMpLHRoaXMucmVjdEVudj1udWxsLHRoaXMucmVjdEludGVyc2VjdG9yPW51bGwsdGhpcy5oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5wMD1uZXcgZyx0aGlzLnAxPW5ldyBnO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCksdGhpcy5yZWN0SW50ZXJzZWN0b3I9bmV3IEdyKHRoaXMucmVjdEVudil9ZnVuY3Rpb24gWXIoKXtpZih0aGlzLl9yZWxhdGU9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RpLmNhbGwodGhpcyx0LGUpLHRoaXMuX3JlbGF0ZT1uZXcgQXIodGhpcy5hcmcpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aS5jYWxsKHRoaXMsbixpLHIpLHRoaXMuX3JlbGF0ZT1uZXcgQXIodGhpcy5hcmcpfX1mdW5jdGlvbiBVcigpe3RoaXMuZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLnNraXBFbXB0eT0hMSx0aGlzLmlucHV0R2VvbXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tRmFjdG9yeT1Vci5leHRyYWN0RmFjdG9yeSh0KSx0aGlzLmlucHV0R2VvbXM9dH1mdW5jdGlvbiBYcigpe3RoaXMucG9pbnRHZW9tPW51bGwsdGhpcy5vdGhlckdlb209bnVsbCx0aGlzLmdlb21GYWN0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucG9pbnRHZW9tPXQsdGhpcy5vdGhlckdlb209ZSx0aGlzLmdlb21GYWN0PWUuZ2V0RmFjdG9yeSgpfWZ1bmN0aW9uIEhyKCl7dGhpcy5zb3J0SW5kZXg9LTEsdGhpcy5jb21wcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNvcnRJbmRleD10LHRoaXMuY29tcHM9ZX1mdW5jdGlvbiBXcigpe3RoaXMuaW5wdXRQb2x5cz1udWxsLHRoaXMuZ2VvbUZhY3Rvcnk9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dFBvbHlzPXQsbnVsbD09PXRoaXMuaW5wdXRQb2x5cyYmKHRoaXMuaW5wdXRQb2x5cz1uZXcgSSl9ZnVuY3Rpb24ganIoKXtpZih0aGlzLnBvbHlnb25zPW5ldyBJLHRoaXMubGluZXM9bmV3IEksdGhpcy5wb2ludHM9bmV3IEksdGhpcy5nZW9tRmFjdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdChlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuZ2VvbUZhY3Q9aSx0aGlzLmV4dHJhY3Qobil9fWZ1bmN0aW9uIEtyKCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9bmV3IGllLHRoaXMuZ2VvbUdyYXBoPW51bGwsdGhpcy5kaXNjb25uZWN0ZWRSaW5nY29vcmQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tR3JhcGg9dH1mdW5jdGlvbiBacigpe3RoaXMuaXRlbXM9bmV3IEksdGhpcy5zdWJub2RlPVtudWxsLG51bGxdfWZ1bmN0aW9uIFFyKCl7aWYodGhpcy5taW49bnVsbCx0aGlzLm1heD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMubWluPTAsdGhpcy5tYXg9MDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQubWluLHQubWF4KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbml0KGUsbil9fWZ1bmN0aW9uIEpyKCl7dGhpcy5wdD0wLHRoaXMubGV2ZWw9MCx0aGlzLmludGVydmFsPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY29tcHV0ZUtleSh0KX1mdW5jdGlvbiAkcigpe1pyLmFwcGx5KHRoaXMpLHRoaXMuaW50ZXJ2YWw9bnVsbCx0aGlzLmNlbnRyZT1udWxsLHRoaXMubGV2ZWw9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbnRlcnZhbD10LHRoaXMubGV2ZWw9ZSx0aGlzLmNlbnRyZT0odC5nZXRNaW4oKSt0LmdldE1heCgpKS8yfWZ1bmN0aW9uIHRzKCl7WnIuYXBwbHkodGhpcyl9ZnVuY3Rpb24gZXMoKXt0aGlzLnJvb3Q9bnVsbCx0aGlzLm1pbkV4dGVudD0xLHRoaXMucm9vdD1uZXcgdHN9ZnVuY3Rpb24gbnMoKXt9ZnVuY3Rpb24gaXMoKXt0aGlzLnJpbmc9bnVsbCx0aGlzLnRyZWU9bnVsbCx0aGlzLmNyb3NzaW5ncz0wLHRoaXMuaW50ZXJ2YWw9bmV3IFFyO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJpbmc9dCx0aGlzLmJ1aWxkSW5kZXgoKX1mdW5jdGlvbiBycygpe3RyLmFwcGx5KHRoaXMpLHRoaXMubWNwPW51bGwsdGhpcy5wPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubWNwPXQsdGhpcy5wPWV9ZnVuY3Rpb24gc3MoKXt0aGlzLm5vZGVzPW5ldyB4bihuZXcgRHIpfWZ1bmN0aW9uIG9zKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5nZW9tR3JhcGg9bnVsbCx0aGlzLm5vZGVHcmFwaD1uZXcgc3MsdGhpcy5pbnZhbGlkUG9pbnQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tR3JhcGg9dH1mdW5jdGlvbiBhcygpe3RoaXMuZ3JhcGg9bnVsbCx0aGlzLnJpbmdzPW5ldyBJLHRoaXMudG90YWxFbnY9bmV3IEMsdGhpcy5pbmRleD1udWxsLHRoaXMubmVzdGVkUHQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ncmFwaD10fWZ1bmN0aW9uIHVzKCl7aWYodGhpcy5lcnJvclR5cGU9bnVsbCx0aGlzLnB0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt1cy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5lcnJvclR5cGU9ZSxudWxsIT09biYmKHRoaXMucHQ9bi5jb3B5KCkpfX1mdW5jdGlvbiBscygpe3RoaXMucGFyZW50R2VvbWV0cnk9bnVsbCx0aGlzLmlzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9ITEsdGhpcy52YWxpZEVycj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBhcmVudEdlb21ldHJ5PXR9ZnVuY3Rpb24gaHMoKXtfdC5Db29yZGluYXRlT3BlcmF0aW9uLmFwcGx5KHRoaXMpLHRoaXMudGFyZ2V0UE09bnVsbCx0aGlzLnJlbW92ZUNvbGxhcHNlZD0hMDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy50YXJnZXRQTT10LHRoaXMucmVtb3ZlQ29sbGFwc2VkPWV9ZnVuY3Rpb24gY3MoKXt0aGlzLnRhcmdldFBNPW51bGwsdGhpcy5yZW1vdmVDb2xsYXBzZWQ9ITAsdGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbD0hMSx0aGlzLmlzUG9pbnR3aXNlPSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRhcmdldFBNPXR9ZnVuY3Rpb24gZnMoKXt0aGlzLnB0cz1udWxsLHRoaXMudXNlUHQ9bnVsbCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5zZWc9bmV3IGNlO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnB0cz10fWZ1bmN0aW9uIGdzKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZnVuY3Rpb24gZHMoKXt4ZS5hcHBseSh0aGlzKSx0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT0hMCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5PXQsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1lfWZ1bmN0aW9uIHBzKCl7aWYodGhpcy5wYXJlbnQ9bnVsbCx0aGlzLmluZGV4PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtwcy5jYWxsKHRoaXMsdCxlLG51bGwsLTEpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtjZS5jYWxsKHRoaXMsbixpKSx0aGlzLnBhcmVudD1yLHRoaXMuaW5kZXg9c319ZnVuY3Rpb24gdnMoKXtpZih0aGlzLnBhcmVudExpbmU9bnVsbCx0aGlzLnNlZ3M9bnVsbCx0aGlzLnJlc3VsdFNlZ3M9bmV3IEksdGhpcy5taW5pbXVtU2l6ZT1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dnMuY2FsbCh0aGlzLHQsMil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucGFyZW50TGluZT1lLHRoaXMubWluaW11bVNpemU9bix0aGlzLmluaXQoKX19ZnVuY3Rpb24gbXMoKXt0aGlzLmluZGV4PW5ldyBQaX1mdW5jdGlvbiB5cygpe3RoaXMucXVlcnlTZWc9bnVsbCx0aGlzLml0ZW1zPW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnF1ZXJ5U2VnPXR9ZnVuY3Rpb24geHMoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLmlucHV0SW5kZXg9bmV3IG1zLHRoaXMub3V0cHV0SW5kZXg9bmV3IG1zLHRoaXMubGluZT1udWxsLHRoaXMubGluZVB0cz1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9MDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbnB1dEluZGV4PXQsdGhpcy5vdXRwdXRJbmRleD1lfWZ1bmN0aW9uIEVzKCl7dGhpcy5pbnB1dEluZGV4PW5ldyBtcyx0aGlzLm91dHB1dEluZGV4PW5ldyBtcyx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPTB9ZnVuY3Rpb24gSXMoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMubGluZVNpbXBsaWZpZXI9bmV3IEVzLHRoaXMubGluZXN0cmluZ01hcD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0R2VvbT10fWZ1bmN0aW9uIE5zKCl7eGUuYXBwbHkodGhpcyksdGhpcy5saW5lc3RyaW5nTWFwPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGluZXN0cmluZ01hcD10fWZ1bmN0aW9uIENzKCl7dGhpcy50cHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy50cHM9dH1mdW5jdGlvbiBTcygpe3RoaXMuc2VnPW51bGwsdGhpcy5zZWdMZW49bnVsbCx0aGlzLnNwbGl0UHQ9bnVsbCx0aGlzLm1pbmltdW1MZW49MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZWc9dCx0aGlzLnNlZ0xlbj10LmdldExlbmd0aCgpfWZ1bmN0aW9uIHdzKCl7fWZ1bmN0aW9uIExzKCl7fWZ1bmN0aW9uIFJzKCl7fWZ1bmN0aW9uIFRzKCl7aWYodGhpcy5wPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnA9bmV3IGcodCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucD1uZXcgZyhlLG4pfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLnA9bmV3IGcoaSxyLHMpfX1mdW5jdGlvbiBQcygpe3RoaXMuX2lzT25Db25zdHJhaW50PW51bGwsdGhpcy5jb25zdHJhaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO1RzLmNhbGwodGhpcyx0KX1mdW5jdGlvbiBicygpe3RoaXMuX3JvdD1udWxsLHRoaXMudmVydGV4PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5kYXRhPW51bGx9ZnVuY3Rpb24gT3MoKXt0aGlzLnN1YmRpdj1udWxsLHRoaXMuaXNVc2luZ1RvbGVyYW5jZT0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zdWJkaXY9dCx0aGlzLmlzVXNpbmdUb2xlcmFuY2U9dC5nZXRUb2xlcmFuY2UoKT4wfWZ1bmN0aW9uIF9zKCl7fWZ1bmN0aW9uIE1zKCl7dGhpcy5zdWJkaXY9bnVsbCx0aGlzLmxhc3RFZGdlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc3ViZGl2PXQsdGhpcy5pbml0KCl9ZnVuY3Rpb24gRHMoKXtpZih0aGlzLnNlZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07bC5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgZT1hcmd1bWVudHNbMF07bC5jYWxsKHRoaXMsXCJMb2NhdGUgZmFpbGVkIHRvIGNvbnZlcmdlIChhdCBlZGdlOiBcIitlK1wiKS4gIFBvc3NpYmxlIGNhdXNlcyBpbmNsdWRlIGludmFsaWQgU3ViZGl2aXNpb24gdG9wb2xvZ3kgb3IgdmVyeSBjbG9zZSBzaXRlc1wiKSx0aGlzLnNlZz1uZXcgY2UoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtsLmNhbGwodGhpcyxEcy5tc2dXaXRoU3BhdGlhbChuLGkpKSx0aGlzLnNlZz1uZXcgY2UoaSl9fWZ1bmN0aW9uIEFzKCl7fWZ1bmN0aW9uIEZzKCl7dGhpcy52aXNpdGVkS2V5PTAsdGhpcy5xdWFkRWRnZXM9bmV3IEksdGhpcy5zdGFydGluZ0VkZ2U9bnVsbCx0aGlzLnRvbGVyYW5jZT1udWxsLHRoaXMuZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5mcmFtZVZlcnRleD1uZXcgQXJyYXkoMykuZmlsbChudWxsKSx0aGlzLmZyYW1lRW52PW51bGwsdGhpcy5sb2NhdG9yPW51bGwsdGhpcy5zZWc9bmV3IGNlLHRoaXMudHJpRWRnZXM9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMudG9sZXJhbmNlPWUsdGhpcy5lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9ZS9Gcy5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1IsdGhpcy5jcmVhdGVGcmFtZSh0KSx0aGlzLnN0YXJ0aW5nRWRnZT10aGlzLmluaXRTdWJkaXYoKSx0aGlzLmxvY2F0b3I9bmV3IE1zKHRoaXMpfWZ1bmN0aW9uIEdzKCl7fWZ1bmN0aW9uIHFzKCl7dGhpcy50cmlMaXN0PW5ldyBJfWZ1bmN0aW9uIEJzKCl7dGhpcy50cmlMaXN0PW5ldyBJfWZ1bmN0aW9uIHpzKCl7dGhpcy5jb29yZExpc3Q9bmV3IE4sdGhpcy50cmlDb29yZHM9bmV3IEl9ZnVuY3Rpb24gVnMoKXtpZih0aGlzLmxzPW51bGwsdGhpcy5kYXRhPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmxzPW5ldyBjZSh0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmxzPW5ldyBjZShuLGkpLHRoaXMuZGF0YT1yfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPWFyZ3VtZW50c1syXSx1PWFyZ3VtZW50c1szXSxsPWFyZ3VtZW50c1s0XSxoPWFyZ3VtZW50c1s1XTtWcy5jYWxsKHRoaXMsbmV3IGcocyxvLGEpLG5ldyBnKHUsbCxoKSl9ZWxzZSBpZig3PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGM9YXJndW1lbnRzWzBdLGY9YXJndW1lbnRzWzFdLGQ9YXJndW1lbnRzWzJdLHA9YXJndW1lbnRzWzNdLHY9YXJndW1lbnRzWzRdLG09YXJndW1lbnRzWzVdLHk9YXJndW1lbnRzWzZdO1ZzLmNhbGwodGhpcyxuZXcgZyhjLGYsZCksbmV3IGcocCx2LG0pLHkpfX1mdW5jdGlvbiBrcygpe31mdW5jdGlvbiBZcygpe2lmKHRoaXMucD1udWxsLHRoaXMuZGF0YT1udWxsLHRoaXMubGVmdD1udWxsLHRoaXMucmlnaHQ9bnVsbCx0aGlzLmNvdW50PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnA9bmV3IGcodCksdGhpcy5sZWZ0PW51bGwsdGhpcy5yaWdodD1udWxsLHRoaXMuY291bnQ9MSx0aGlzLmRhdGE9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5wPW5ldyBnKG4saSksdGhpcy5sZWZ0PW51bGwsdGhpcy5yaWdodD1udWxsLHRoaXMuY291bnQ9MSx0aGlzLmRhdGE9cn19ZnVuY3Rpb24gVXMoKXtpZih0aGlzLnJvb3Q9bnVsbCx0aGlzLm51bWJlck9mTm9kZXM9bnVsbCx0aGlzLnRvbGVyYW5jZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKVVzLmNhbGwodGhpcywwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy50b2xlcmFuY2U9dH19ZnVuY3Rpb24gWHMoKXt0aGlzLnRvbGVyYW5jZT1udWxsLHRoaXMubWF0Y2hOb2RlPW51bGwsdGhpcy5tYXRjaERpc3Q9MCx0aGlzLnA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wPXQsdGhpcy50b2xlcmFuY2U9ZX1mdW5jdGlvbiBIcygpe3RoaXMuaW5pdGlhbFZlcnRpY2VzPW51bGwsdGhpcy5zZWdWZXJ0aWNlcz1udWxsLHRoaXMuc2VnbWVudHM9bmV3IEksdGhpcy5zdWJkaXY9bnVsbCx0aGlzLmluY0RlbD1udWxsLHRoaXMuY29udmV4SHVsbD1udWxsLHRoaXMuc3BsaXRGaW5kZXI9bmV3IExzLHRoaXMua2R0PW51bGwsdGhpcy52ZXJ0ZXhGYWN0b3J5PW51bGwsdGhpcy5jb21wdXRlQXJlYUVudj1udWxsLHRoaXMuc3BsaXRQdD1udWxsLHRoaXMudG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdGlhbFZlcnRpY2VzPW5ldyBJKHQpLHRoaXMudG9sZXJhbmNlPWUsdGhpcy5rZHQ9bmV3IFVzKGUpfWZ1bmN0aW9uIFdzKCl7dGhpcy5zaXRlQ29vcmRzPW51bGwsdGhpcy50b2xlcmFuY2U9MCx0aGlzLnN1YmRpdj1udWxsfWZ1bmN0aW9uIGpzKCl7dGhpcy5zaXRlQ29vcmRzPW51bGwsdGhpcy5jb25zdHJhaW50TGluZXM9bnVsbCx0aGlzLnRvbGVyYW5jZT0wLHRoaXMuc3ViZGl2PW51bGwsdGhpcy5jb25zdHJhaW50VmVydGV4TWFwPW5ldyBydH1mdW5jdGlvbiBLcygpe3RoaXMuc2l0ZUNvb3Jkcz1udWxsLHRoaXMudG9sZXJhbmNlPTAsdGhpcy5zdWJkaXY9bnVsbCx0aGlzLmNsaXBFbnY9bnVsbCx0aGlzLmRpYWdyYW1FbnY9bnVsbH1mdW5jdGlvbiBacygpe31BcnJheS5wcm90b3R5cGUuZmlsbHx8KEFycmF5LnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1PYmplY3QodGhpcyksbj1wYXJzZUludChlLmxlbmd0aCwxMCksaT1hcmd1bWVudHNbMV0scj1wYXJzZUludChpLDEwKXx8MCxzPTA+cj9NYXRoLm1heChuK3IsMCk6TWF0aC5taW4ocixuKSxvPWFyZ3VtZW50c1syXSxhPXZvaWQgMD09PW8/bjpwYXJzZUludChvLDEwKXx8MCx1PTA+YT9NYXRoLm1heChuK2EsMCk6TWF0aC5taW4oYSxuKTt1PnM7cysrKWVbc109dDtyZXR1cm4gZX0pLE51bWJlci5pc0Zpbml0ZT1OdW1iZXIuaXNGaW5pdGV8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KX0sTnVtYmVyLmlzSW50ZWdlcj1OdW1iZXIuaXNJbnRlZ2VyfHxmdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmaXNGaW5pdGUodCkmJk1hdGguZmxvb3IodCk9PT10fSxOdW1iZXIucGFyc2VGbG9hdD1OdW1iZXIucGFyc2VGbG9hdHx8cGFyc2VGbG9hdCxOdW1iZXIuaXNOYU49TnVtYmVyLmlzTmFOfHxmdW5jdGlvbih0KXtyZXR1cm4gdCE9PXR9LE1hdGgudHJ1bmM9TWF0aC50cnVuY3x8ZnVuY3Rpb24odCl7cmV0dXJuIDA+dD9NYXRoLmNlaWwodCk6TWF0aC5mbG9vcih0KX0sZShuLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KSxuLmVxdWFsc1dpdGhUb2xlcmFuY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBNYXRoLmFicyh0LWUpPD1ufSxyLmlzTmFOPWZ1bmN0aW9uKHQpe3JldHVybiBOdW1iZXIuaXNOYU4odCl9LHIuZG91YmxlVG9Mb25nQml0cz1mdW5jdGlvbih0KXtyZXR1cm4gdH0sci5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxyLmlzSW5maW5pdGU9ZnVuY3Rpb24odCl7cmV0dXJuIU51bWJlci5pc0Zpbml0ZSh0KX0sci5NQVhfVkFMVUU9TnVtYmVyLk1BWF9WQUxVRSxoKGMsbCksZShjLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY319KSxlKGYucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmfX0pLGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmU9ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmLnNob3VsZE5ldmVyUmVhY2hIZXJlKG51bGwpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aHJvdyBuZXcgYyhcIlNob3VsZCBuZXZlciByZWFjaCBoZXJlXCIrKG51bGwhPT10P1wiOiBcIit0OlwiXCIpKX19LGYuaXNUcnVlPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtmLmlzVHJ1ZSh0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtpZighZSl0aHJvdyBudWxsPT09bj9uZXcgYzpuZXcgYyhuKX19LGYuZXF1YWxzPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmLmVxdWFscyh0LGUsbnVsbCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO2lmKCFpLmVxdWFscyhuKSl0aHJvdyBuZXcgYyhcIkV4cGVjdGVkIFwiK24rXCIgYnV0IGVuY291bnRlcmVkIFwiK2krKG51bGwhPT1yP1wiOiBcIityOlwiXCIpKX19LGUoZy5wcm90b3R5cGUse3NldE9yZGluYXRlOmZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQpe2Nhc2UgZy5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgZy5ZOnRoaXMueT1lO2JyZWFrO2Nhc2UgZy5aOnRoaXMuej1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IGkoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19LGVxdWFsczJEOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy54IT09dC54PyExOnRoaXMueT09PXQueX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiBuLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy54LGUueCxpKT8hIW4uZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnksZS55LGkpOiExfX0sZ2V0T3JkaW5hdGU6ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UgZy5YOnJldHVybiB0aGlzLng7Y2FzZSBnLlk6cmV0dXJuIHRoaXMueTtjYXNlIGcuWjpyZXR1cm4gdGhpcy56fXRocm93IG5ldyBpKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9LGVxdWFsczNEOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueSYmKHRoaXMuej09PXQuenx8ci5pc05hTih0aGlzLnopJiZyLmlzTmFOKHQueikpfSxlcXVhbHM6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBnP3RoaXMuZXF1YWxzMkQodCk6ITF9LGVxdWFsSW5aOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnosdC56LGUpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy54PGUueD8tMTp0aGlzLng+ZS54PzE6dGhpcy55PGUueT8tMTp0aGlzLnk+ZS55PzE6MH0sY2xvbmU6ZnVuY3Rpb24oKXt0cnl7dmFyIHQ9bnVsbDtyZXR1cm4gdH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJ0aGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGlzIGNsYXNzIGlzIENsb25lYWJsZVwiKSxudWxsO3Rocm93IHR9ZmluYWxseXt9fSxjb3B5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKHRoaXMpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLnorXCIpXCJ9LGRpc3RhbmNlM0Q6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy54LXQueCxuPXRoaXMueS10LnksaT10aGlzLnotdC56O3JldHVybiBNYXRoLnNxcnQoZSplK24qbitpKmkpfSxkaXN0YW5jZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLngtdC54LG49dGhpcy55LXQueTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfSxoYXNoQ29kZTpmdW5jdGlvbigpe3ZhciB0PTE3O3JldHVybiB0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLngpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMueSl9LHNldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10Lnp9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3Msbyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ319KSxnLmhhc2hDb2RlPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXIuZG91YmxlVG9Mb25nQml0cyh0KTtyZXR1cm4gTWF0aC50cnVuYyhlXmU+Pj4zMil9fSxlKGQucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWUscj1kLmNvbXBhcmUobi54LGkueCk7aWYoMCE9PXIpcmV0dXJuIHI7dmFyIHM9ZC5jb21wYXJlKG4ueSxpLnkpO2lmKDAhPT1zKXJldHVybiBzO2lmKHRoaXMuZGltZW5zaW9uc1RvVGVzdDw9MilyZXR1cm4gMDt2YXIgbz1kLmNvbXBhcmUobi56LGkueik7cmV0dXJuIG99LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkfX0pLGQuY29tcGFyZT1mdW5jdGlvbih0LGUpe3JldHVybiBlPnQ/LTE6dD5lPzE6ci5pc05hTih0KT9yLmlzTmFOKGUpPzA6LTE6ci5pc05hTihlKT8xOjB9LGcuRGltZW5zaW9uYWxDb21wYXJhdG9yPWQsZy5zZXJpYWxWZXJzaW9uVUlEPTB4NWNiZjJjMjM1YzdlNTgwMCxnLk5VTExfT1JESU5BVEU9ci5OYU4sZy5YPTAsZy5ZPTEsZy5aPTIscC5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe30scC5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe30scC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe30sbS5wcm90b3R5cGU9bmV3IEVycm9yLG0ucHJvdG90eXBlLm5hbWU9XCJJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXCIseS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh2LnByb3RvdHlwZSkseS5wcm90b3R5cGUuY29uc3RydWN0b3I9eSx5LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt9LHkucHJvdG90eXBlLnNldD1mdW5jdGlvbigpe30seS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe30seC5wcm90b3R5cGU9bmV3IEVycm9yLHgucHJvdG90eXBlLm5hbWU9XCJOb1N1Y2hFbGVtZW50RXhjZXB0aW9uXCIsRS5wcm90b3R5cGU9bmV3IEVycm9yLEUucHJvdG90eXBlLm5hbWU9XCJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRcIixJLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHkucHJvdG90eXBlKSxJLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1JLEkucHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5PWZ1bmN0aW9uKCl7fSxJLnByb3RvdHlwZS5pbnRlcmZhY2VzXz1mdW5jdGlvbigpe3JldHVyblt5LHZdfSxJLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksITB9LEkucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5hcnJheV89W119LEkucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LEkucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuYXJyYXlfW3RdO3JldHVybiB0aGlzLmFycmF5X1t0XT1lLG59LEkucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBRcyh0aGlzKX0sSS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKDA+dHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IG07cmV0dXJuIHRoaXMuYXJyYXlfW3RdfSxJLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LEkucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxJLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LEkucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9ITEsbj0wLGk9dGhpcy5hcnJheV8ubGVuZ3RoO2k+bjtuKyspaWYodGhpcy5hcnJheV9bbl09PT10KXt0aGlzLmFycmF5Xy5zcGxpY2UobiwxKSxlPSEwO2JyZWFrfXJldHVybiBlfTt2YXIgUXM9ZnVuY3Rpb24odCl7dGhpcy5hcnJheUxpc3RfPXQsdGhpcy5wb3NpdGlvbl89MH07UXMucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvc2l0aW9uXz09PXRoaXMuYXJyYXlMaXN0Xy5zaXplKCkpdGhyb3cgbmV3IHg7cmV0dXJuIHRoaXMuYXJyYXlMaXN0Xy5nZXQodGhpcy5wb3NpdGlvbl8rKyl9LFFzLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25fPHRoaXMuYXJyYXlMaXN0Xy5zaXplKCl9LFFzLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlMaXN0Xy5zZXQodGhpcy5wb3NpdGlvbl8tMSx0KX0sUXMucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBFfSxoKE4sSSksZShOLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXQodCl9LGFkZEFsbDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ITEsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXRoaXMuYWRkKGkubmV4dCgpLGUpLG49ITA7cmV0dXJuIG59cmV0dXJuIEkucHJvdG90eXBlLmFkZEFsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGNsb25lOmZ1bmN0aW9uIHQoKXtmb3IodmFyIHQ9SS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKSxlPTA7ZTx0aGlzLnNpemUoKTtlKyspdC5hZGQoZSx0aGlzLmdldChlKS5jb3B5KCkpO3JldHVybiB0fSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvQXJyYXkoTi5jb29yZEFycmF5VHlwZSl9LGFkZDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07SS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcyx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZChlLG4sITApLCEwfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTtpZighciYmdGhpcy5zaXplKCk+PTEpe3ZhciBzPXRoaXMuZ2V0KHRoaXMuc2l6ZSgpLTEpO2lmKHMuZXF1YWxzMkQoaSkpcmV0dXJuIG51bGx9SS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcyxpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZChvLGEpLCEwfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB1PWFyZ3VtZW50c1swXSxsPWFyZ3VtZW50c1sxXSxoPWFyZ3VtZW50c1syXTtpZihoKWZvcih2YXIgYz0wO2M8dS5sZW5ndGg7YysrKXRoaXMuYWRkKHVbY10sbCk7ZWxzZSBmb3IodmFyIGM9dS5sZW5ndGgtMTtjPj0wO2MtLSl0aGlzLmFkZCh1W2NdLGwpO3JldHVybiEwfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7dmFyIGY9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdO2lmKCFwKXt2YXIgdj10aGlzLnNpemUoKTtpZih2PjApe2lmKGY+MCl7dmFyIG09dGhpcy5nZXQoZi0xKTtpZihtLmVxdWFsczJEKGQpKXJldHVybiBudWxsfWlmKHY+Zil7dmFyIHk9dGhpcy5nZXQoZik7aWYoeS5lcXVhbHMyRChkKSlyZXR1cm4gbnVsbH19fUkucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsZixkKX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHg9YXJndW1lbnRzWzBdLEU9YXJndW1lbnRzWzFdLE49YXJndW1lbnRzWzJdLEM9YXJndW1lbnRzWzNdLFM9MTtOPkMmJihTPS0xKTtmb3IodmFyIGM9TjtjIT09QztjKz1TKXRoaXMuYWRkKHhbY10sRSk7cmV0dXJuITB9fSxjbG9zZVJpbmc6ZnVuY3Rpb24oKXt0aGlzLnNpemUoKT4wJiZ0aGlzLmFkZChuZXcgZyh0aGlzLmdldCgwKSksITEpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOfX0pLE4uY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCksZShDLnByb3RvdHlwZSx7Z2V0QXJlYTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFdpZHRoKCkqdGhpcy5nZXRIZWlnaHQoKX0sZXF1YWxzOmZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEMpKXJldHVybiExO3ZhciBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKTp0aGlzLm1heHg9PT1lLmdldE1heFgoKSYmdGhpcy5tYXh5PT09ZS5nZXRNYXhZKCkmJnRoaXMubWlueD09PWUuZ2V0TWluWCgpJiZ0aGlzLm1pbnk9PT1lLmdldE1pblkoKX0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNOdWxsKCl8fHQuaXNOdWxsKCl8fCF0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIG5ldyBDO3ZhciBlPXRoaXMubWlueD50Lm1pbng/dGhpcy5taW54OnQubWlueCxuPXRoaXMubWlueT50Lm1pbnk/dGhpcy5taW55OnQubWlueSxpPXRoaXMubWF4eDx0Lm1heHg/dGhpcy5tYXh4OnQubWF4eCxyPXRoaXMubWF4eTx0Lm1heHk/dGhpcy5tYXh5OnQubWF4eTtyZXR1cm4gbmV3IEMoZSxpLG4scil9LGlzTnVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heHg8dGhpcy5taW54fSxnZXRNYXhYOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4eH0sY292ZXJzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0LngsdC55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc051bGwoKXx8ZS5pc051bGwoKT8hMTplLmdldE1pblgoKT49dGhpcy5taW54JiZlLmdldE1heFgoKTw9dGhpcy5tYXh4JiZlLmdldE1pblkoKT49dGhpcy5taW55JiZlLmdldE1heFkoKTw9dGhpcy5tYXh5fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNOdWxsKCk/ITE6bj49dGhpcy5taW54JiZuPD10aGlzLm1heHgmJmk+PXRoaXMubWlueSYmaTw9dGhpcy5tYXh5fX0saW50ZXJzZWN0czpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc051bGwoKXx8dC5pc051bGwoKT8hMTohKHQubWlueD50aGlzLm1heHh8fHQubWF4eDx0aGlzLm1pbnh8fHQubWlueT50aGlzLm1heHl8fHQubWF4eTx0aGlzLm1pbnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmludGVyc2VjdHMoZS54LGUueSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc051bGwoKT8hMTohKG4+dGhpcy5tYXh4fHxuPHRoaXMubWlueHx8aT50aGlzLm1heHl8fGk8dGhpcy5taW55KX19LGdldE1pblk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW55fSxnZXRNaW5YOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWlueH0sZXhwYW5kVG9JbmNsdWRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZXhwYW5kVG9JbmNsdWRlKHQueCx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07aWYoZS5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLmlzTnVsbCgpPyh0aGlzLm1pbng9ZS5nZXRNaW5YKCksdGhpcy5tYXh4PWUuZ2V0TWF4WCgpLHRoaXMubWlueT1lLmdldE1pblkoKSx0aGlzLm1heHk9ZS5nZXRNYXhZKCkpOihlLm1pbng8dGhpcy5taW54JiYodGhpcy5taW54PWUubWlueCksZS5tYXh4PnRoaXMubWF4eCYmKHRoaXMubWF4eD1lLm1heHgpLGUubWlueTx0aGlzLm1pbnkmJih0aGlzLm1pbnk9ZS5taW55KSxlLm1heHk+dGhpcy5tYXh5JiYodGhpcy5tYXh5PWUubWF4eSkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5pc051bGwoKT8odGhpcy5taW54PW4sdGhpcy5tYXh4PW4sdGhpcy5taW55PWksdGhpcy5tYXh5PWkpOihuPHRoaXMubWlueCYmKHRoaXMubWlueD1uKSxuPnRoaXMubWF4eCYmKHRoaXMubWF4eD1uKSxpPHRoaXMubWlueSYmKHRoaXMubWlueT1pKSxpPnRoaXMubWF4eSYmKHRoaXMubWF4eT1pKSl9fSxtaW5FeHRlbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO3ZhciB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIGU+dD90OmV9LGdldFdpZHRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLm1heHgtdGhpcy5taW54fSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpPzA6LTE6ZS5pc051bGwoKT8xOnRoaXMubWlueDxlLm1pbng/LTE6dGhpcy5taW54PmUubWlueD8xOnRoaXMubWlueTxlLm1pbnk/LTE6dGhpcy5taW55PmUubWlueT8xOnRoaXMubWF4eDxlLm1heHg/LTE6dGhpcy5tYXh4PmUubWF4eD8xOnRoaXMubWF4eTxlLm1heHk/LTE6dGhpcy5tYXh5PmUubWF4eT8xOjB9LHRyYW5zbGF0ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6dm9pZCB0aGlzLmluaXQodGhpcy5nZXRNaW5YKCkrdCx0aGlzLmdldE1heFgoKSt0LHRoaXMuZ2V0TWluWSgpK2UsdGhpcy5nZXRNYXhZKCkrZSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJFbnZbXCIrdGhpcy5taW54K1wiIDogXCIrdGhpcy5tYXh4K1wiLCBcIit0aGlzLm1pbnkrXCIgOiBcIit0aGlzLm1heHkrXCJdXCJ9LHNldFRvTnVsbDpmdW5jdGlvbigpe3RoaXMubWlueD0wLHRoaXMubWF4eD0tMSx0aGlzLm1pbnk9MCx0aGlzLm1heHk9LTF9LGdldEhlaWdodDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTnVsbCgpPzA6dGhpcy5tYXh5LXRoaXMubWlueX0sbWF4RXh0ZW50OmZ1bmN0aW9uKCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDt2YXIgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiB0PmU/dDplfSxleHBhbmRCeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRCeSh0LHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtpZih0aGlzLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMubWlueC09ZSx0aGlzLm1heHgrPWUsdGhpcy5taW55LT1uLHRoaXMubWF4eSs9biwodGhpcy5taW54PnRoaXMubWF4eHx8dGhpcy5taW55PnRoaXMubWF4eSkmJnRoaXMuc2V0VG9OdWxsKCl9fSxjb250YWluczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY292ZXJzKG4saSl9fSxjZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc051bGwoKT9udWxsOm5ldyBnKCh0aGlzLmdldE1pblgoKSt0aGlzLmdldE1heFgoKSkvMiwodGhpcy5nZXRNaW5ZKCkrdGhpcy5nZXRNYXhZKCkpLzIpfSxpbml0OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb051bGwoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMubWlueD1lLm1pbngsdGhpcy5tYXh4PWUubWF4eCx0aGlzLm1pbnk9ZS5taW55LHRoaXMubWF4eT1lLm1heHl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQobi54LGkueCxuLnksaS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM107cz5yPyh0aGlzLm1pbng9cix0aGlzLm1heHg9cyk6KHRoaXMubWlueD1zLHRoaXMubWF4eD1yKSxhPm8/KHRoaXMubWlueT1vLHRoaXMubWF4eT1hKToodGhpcy5taW55PWEsdGhpcy5tYXh5PW8pfX0sZ2V0TWF4WTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heHl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gMDt2YXIgZT0wO3RoaXMubWF4eDx0Lm1pbng/ZT10Lm1pbngtdGhpcy5tYXh4OnRoaXMubWlueD50Lm1heHgmJihlPXRoaXMubWlueC10Lm1heHgpO3ZhciBuPTA7cmV0dXJuIHRoaXMubWF4eTx0Lm1pbnk/bj10Lm1pbnktdGhpcy5tYXh5OnRoaXMubWlueT50Lm1heHkmJihuPXRoaXMubWlueS10Lm1heHkpLDA9PT1lP246MD09PW4/ZTpNYXRoLnNxcnQoZSplK24qbil9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9MTc7cmV0dXJuIHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMubWlueCksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5tYXh4KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLm1pbnkpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMubWF4eSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3MsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEN9fSksQy5pbnRlcnNlY3RzPWZ1bmN0aW9uKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbi54Pj0odC54PGUueD90Lng6ZS54KSYmbi54PD0odC54PmUueD90Lng6ZS54KSYmbi55Pj0odC55PGUueT90Lnk6ZS55KSYmbi55PD0odC55PmUueT90Lnk6ZS55KX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdLGE9TWF0aC5taW4ocy54LG8ueCksdT1NYXRoLm1heChzLngsby54KSxsPU1hdGgubWluKGkueCxyLngpLGg9TWF0aC5tYXgoaS54LHIueCk7cmV0dXJuIGw+dT8hMTphPmg/ITE6KGE9TWF0aC5taW4ocy55LG8ueSksdT1NYXRoLm1heChzLnksby55KSxsPU1hdGgubWluKGkueSxyLnkpLGg9TWF0aC5tYXgoaS55LHIueSksbD51PyExOiEoYT5oKSl9fSxDLnNlcmlhbFZlcnNpb25VSUQ9MHg1MTg0NWNkNTUyMTg5ODAwLGgodyxTKSxlKHcucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3fX0pLGUoTC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEx9fSksTC50b0xvY2F0aW9uU3ltYm9sPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIEwuRVhURVJJT1I6cmV0dXJuXCJlXCI7Y2FzZSBMLkJPVU5EQVJZOnJldHVyblwiYlwiO2Nhc2UgTC5JTlRFUklPUjpyZXR1cm5cImlcIjtjYXNlIEwuTk9ORTpyZXR1cm5cIi1cIn10aHJvdyBuZXcgaShcIlVua25vd24gbG9jYXRpb24gdmFsdWU6IFwiK3QpfSxMLklOVEVSSU9SPTAsTC5CT1VOREFSWT0xLEwuRVhURVJJT1I9MixMLk5PTkU9LTEsZShULnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVH19KSxULmxvZzEwPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGgubG9nKHQpO3JldHVybiByLmlzSW5maW5pdGUoZSk/ZTpyLmlzTmFOKGUpP2U6ZS9ULkxPR18xMH0sVC5taW49ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dDtyZXR1cm4gcj5lJiYocj1lKSxyPm4mJihyPW4pLHI+aSYmKHI9aSkscn0sVC5jbGFtcD1mdW5jdGlvbigpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gZT50P2U6dD5uP246dH1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07cmV0dXJuIHI+aT9yOmk+cz9zOml9fSxULndyYXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD50P2UtIC10JWU6dCVlfSxULm1heD1mdW5jdGlvbigpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT10O3JldHVybiBlPmkmJihpPWUpLG4+aSYmKGk9biksaX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9YXJndW1lbnRzWzNdLGk9cjtyZXR1cm4gcz5pJiYoaT1zKSxvPmkmJihpPW8pLGE+aSYmKGk9YSksaX19LFQuYXZlcmFnZT1mdW5jdGlvbih0LGUpe1xucmV0dXJuKHQrZSkvMn0sVC5MT0dfMTA9TWF0aC5sb2coMTApLFAucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbih0KXt0aGlzLnN0cis9dH0sUC5wcm90b3R5cGUuc2V0Q2hhckF0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3RyLnN1YnN0cigwLHQpK2UrdGhpcy5zdHIuc3Vic3RyKHQrMSl9LFAucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0cn0sYi5wcm90b3R5cGUuaW50VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sYi5wcm90b3R5cGUuY29tcGFyZVRvPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnZhbHVlPHQ/LTE6dGhpcy52YWx1ZT50PzE6MH0sYi5pc05hTj1mdW5jdGlvbih0KXtyZXR1cm4gTnVtYmVyLmlzTmFOKHQpfSxPLmlzV2hpdGVzcGFjZT1mdW5jdGlvbih0KXtyZXR1cm4gMzI+PXQmJnQ+PTB8fDEyNz09dH0sTy50b1VwcGVyQ2FzZT1mdW5jdGlvbih0KXtyZXR1cm4gdC50b1VwcGVyQ2FzZSgpfSxlKF8ucHJvdG90eXBlLHtsZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaTx0LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbzw9dC5sb30sZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5hYnMoKSxpPV8ubWFnbml0dWRlKG4uaGkpLHI9Xy5URU4ucG93KGkpO249bi5kaXZpZGUociksbi5ndChfLlRFTik/KG49bi5kaXZpZGUoXy5URU4pLGkrPTEpOm4ubHQoXy5PTkUpJiYobj1uLm11bHRpcGx5KF8uVEVOKSxpLT0xKTtmb3IodmFyIHM9aSsxLG89bmV3IFAsYT1fLk1BWF9QUklOVF9ESUdJVFMtMSx1PTA7YT49dTt1Kyspe3QmJnU9PT1zJiZvLmFwcGVuZChcIi5cIik7dmFyIGw9TWF0aC50cnVuYyhuLmhpKTtpZigwPmwpYnJlYWs7dmFyIGg9ITEsYz0wO2w+OT8oaD0hMCxjPVwiOVwiKTpjPVwiMFwiK2wsby5hcHBlbmQoYyksbj1uLnN1YnRyYWN0KF8udmFsdWVPZihsKSkubXVsdGlwbHkoXy5URU4pLGgmJm4uc2VsZkFkZChfLlRFTik7dmFyIGY9ITAsZz1fLm1hZ25pdHVkZShuLmhpKTtpZigwPmcmJk1hdGguYWJzKGcpPj1hLXUmJihmPSExKSwhZilicmVha31yZXR1cm4gZVswXT1pLG8udG9TdHJpbmcoKX0sc3FyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubXVsdGlwbHkodGhpcyl9LGRvdWJsZVZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGkrdGhpcy5sb30sc3VidHJhY3Q6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQodC5uZWdhdGUoKSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCgtZSl9fSxlcXVhbHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmhpPT09dC5oaSYmdGhpcy5sbz09PXQubG99fSxpc1plcm86ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuaGkmJjA9PT10aGlzLmxvfSxzZWxmU3VidHJhY3Q6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC10LmhpLC10LmxvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtZSwwKX19LGdldFNwZWNpYWxOdW1iZXJTdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1plcm8oKT9cIjAuMFwiOnRoaXMuaXNOYU4oKT9cIk5hTiBcIjpudWxsfSxtaW46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGUodCk/dGhpczp0fSxzZWxmRGl2aWRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUodC5oaSx0LmxvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZShlLDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1udWxsLHM9bnVsbCxvPW51bGwsYT1udWxsLHU9bnVsbCxsPW51bGwsaD1udWxsLGM9bnVsbDtyZXR1cm4gdT10aGlzLmhpL24sbD1fLlNQTElUKnUscj1sLXUsYz1fLlNQTElUKm4scj1sLXIscz11LXIsbz1jLW4saD11Km4sbz1jLW8sYT1uLW8sYz1yKm8taCtyKmErcypvK3MqYSxsPSh0aGlzLmhpLWgtYyt0aGlzLmxvLXUqaSkvbixjPXUrbCx0aGlzLmhpPWMsdGhpcy5sbz11LWMrbCx0aGlzfX0sZHVtcDpmdW5jdGlvbigpe3JldHVyblwiREQ8XCIrdGhpcy5oaStcIiwgXCIrdGhpcy5sbytcIj5cIn0sZGl2aWRlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1udWxsLG49bnVsbCxpPW51bGwscz1udWxsLG89bnVsbCxhPW51bGwsdT1udWxsLGw9bnVsbDtvPXRoaXMuaGkvdC5oaSxhPV8uU1BMSVQqbyxlPWEtbyxsPV8uU1BMSVQqdC5oaSxlPWEtZSxuPW8tZSxpPWwtdC5oaSx1PW8qdC5oaSxpPWwtaSxzPXQuaGktaSxsPWUqaS11K2UqcytuKmkrbipzLGE9KHRoaXMuaGktdS1sK3RoaXMubG8tbyp0LmxvKS90LmhpLGw9bythO3ZhciBoPWwsYz1vLWwrYTtyZXR1cm4gbmV3IF8oaCxjKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZj1hcmd1bWVudHNbMF07cmV0dXJuIHIuaXNOYU4oZik/Xy5jcmVhdGVOYU4oKTpfLmNvcHkodGhpcykuc2VsZkRpdmlkZShmLDApfX0sZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGk+dC5oaXx8dGhpcy5oaT09PXQuaGkmJnRoaXMubG8+PXQubG99LHBvdzpmdW5jdGlvbih0KXtpZigwPT09dClyZXR1cm4gXy52YWx1ZU9mKDEpO3ZhciBlPW5ldyBfKHRoaXMpLG49Xy52YWx1ZU9mKDEpLGk9TWF0aC5hYnModCk7aWYoaT4xKWZvcig7aT4wOylpJTI9PT0xJiZuLnNlbGZNdWx0aXBseShlKSxpLz0yLGk+MCYmKGU9ZS5zcXIoKSk7ZWxzZSBuPWU7cmV0dXJuIDA+dD9uLnJlY2lwcm9jYWwoKTpufSxjZWlsOmZ1bmN0aW9uKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBfLk5hTjt2YXIgdD1NYXRoLmNlaWwodGhpcy5oaSksZT0wO3JldHVybiB0PT09dGhpcy5oaSYmKGU9TWF0aC5jZWlsKHRoaXMubG8pKSxuZXcgXyh0LGUpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5oaTxlLmhpPy0xOnRoaXMuaGk+ZS5oaT8xOnRoaXMubG88ZS5sbz8tMTp0aGlzLmxvPmUubG8/MTowfSxyaW50OmZ1bmN0aW9uKCl7aWYodGhpcy5pc05hTigpKXJldHVybiB0aGlzO3ZhciB0PXRoaXMuYWRkKC41KTtyZXR1cm4gdC5mbG9vcigpfSxzZXRWYWx1ZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQodCksdGhpc31pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdChlKSx0aGlzfX0sbWF4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlKHQpP3RoaXM6dH0sc3FydDpmdW5jdGlvbigpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIF8udmFsdWVPZigwKTtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gXy5OYU47dmFyIHQ9MS9NYXRoLnNxcnQodGhpcy5oaSksZT10aGlzLmhpKnQsbj1fLnZhbHVlT2YoZSksaT10aGlzLnN1YnRyYWN0KG4uc3FyKCkpLHI9aS5oaSooLjUqdCk7cmV0dXJuIG4uYWRkKHIpfSxzZWxmQWRkOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZBZGQodC5oaSx0LmxvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1udWxsLGk9bnVsbCxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGw7cmV0dXJuIHI9dGhpcy5oaStlLG89ci10aGlzLmhpLHM9ci1vLHM9ZS1vKyh0aGlzLmhpLXMpLGE9cyt0aGlzLmxvLG49cithLGk9YSsoci1uKSx0aGlzLmhpPW4raSx0aGlzLmxvPWkrKG4tdGhpcy5oaSksdGhpc319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdLG49bnVsbCxpPW51bGwsaD1udWxsLGM9bnVsbCxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGw7cj10aGlzLmhpK3UsaD10aGlzLmxvK2wsbz1yLXRoaXMuaGksYT1oLXRoaXMubG8scz1yLW8sYz1oLWEscz11LW8rKHRoaXMuaGktcyksYz1sLWErKHRoaXMubG8tYyksbz1zK2gsbj1yK28saT1vKyhyLW4pLG89YytpO3ZhciBmPW4rbyxnPW8rKG4tZik7cmV0dXJuIHRoaXMuaGk9Zix0aGlzLmxvPWcsdGhpc319LHNlbGZNdWx0aXBseTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodC5oaSx0LmxvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KGUsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGwsdT1udWxsLGw9bnVsbDt1PV8uU1BMSVQqdGhpcy5oaSxyPXUtdGhpcy5oaSxsPV8uU1BMSVQqbixyPXUtcixzPXRoaXMuaGktcixvPWwtbix1PXRoaXMuaGkqbixvPWwtbyxhPW4tbyxsPXIqby11K3IqYStzKm8rcyphKyh0aGlzLmhpKmkrdGhpcy5sbypuKTt2YXIgaD11K2w7cj11LWg7dmFyIGM9bCtyO3JldHVybiB0aGlzLmhpPWgsdGhpcy5sbz1jLHRoaXN9fSxzZWxmU3FyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHRoaXMpfSxmbG9vcjpmdW5jdGlvbigpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gXy5OYU47dmFyIHQ9TWF0aC5mbG9vcih0aGlzLmhpKSxlPTA7cmV0dXJuIHQ9PT10aGlzLmhpJiYoZT1NYXRoLmZsb29yKHRoaXMubG8pKSxuZXcgXyh0LGUpfSxuZWdhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6bmV3IF8oLXRoaXMuaGksLXRoaXMubG8pfSxjbG9uZTpmdW5jdGlvbigpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIG51bGw7dGhyb3cgdH1maW5hbGx5e319LG11bHRpcGx5OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuaXNOYU4oKT9fLmNyZWF0ZU5hTigpOl8uY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKGUpP18uY3JlYXRlTmFOKCk6Xy5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseShlLDApfX0saXNOYU46ZnVuY3Rpb24oKXtyZXR1cm4gci5pc05hTih0aGlzLmhpKX0saW50VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC50cnVuYyh0aGlzLmhpKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1fLm1hZ25pdHVkZSh0aGlzLmhpKTtyZXR1cm4gdD49LTMmJjIwPj10P3RoaXMudG9TdGFuZGFyZE5vdGF0aW9uKCk6dGhpcy50b1NjaU5vdGF0aW9uKCl9LHRvU3RhbmRhcmROb3RhdGlvbjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O3ZhciBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITAsZSksaT1lWzBdKzEscj1uO2lmKFwiLlwiPT09bi5jaGFyQXQoMCkpcj1cIjBcIituO2Vsc2UgaWYoMD5pKXI9XCIwLlwiK18uc3RyaW5nT2ZDaGFyKFwiMFwiLC1pKStuO2Vsc2UgaWYoLTE9PT1uLmluZGV4T2YoXCIuXCIpKXt2YXIgcz1pLW4ubGVuZ3RoLG89Xy5zdHJpbmdPZkNoYXIoXCIwXCIscyk7cj1uK28rXCIuMFwifXJldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIityOnJ9LHJlY2lwcm9jYWw6ZnVuY3Rpb24oKXt2YXIgdD1udWxsLGU9bnVsbCxuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyPTEvdGhpcy5oaSxzPV8uU1BMSVQqcix0PXMtcixhPV8uU1BMSVQqdGhpcy5oaSx0PXMtdCxlPXItdCxuPWEtdGhpcy5oaSxvPXIqdGhpcy5oaSxuPWEtbixpPXRoaXMuaGktbixhPXQqbi1vK3QqaStlKm4rZSppLHM9KDEtby1hLXIqdGhpcy5sbykvdGhpcy5oaTt2YXIgdT1yK3MsbD1yLXUrcztyZXR1cm4gbmV3IF8odSxsKX0sdG9TY2lOb3RhdGlvbjpmdW5jdGlvbigpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIF8uU0NJX05PVF9aRVJPO3ZhciB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O3ZhciBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITEsZSksaT1fLlNDSV9OT1RfRVhQT05FTlRfQ0hBUitlWzBdO2lmKFwiMFwiPT09bi5jaGFyQXQoMCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkZvdW5kIGxlYWRpbmcgemVybzogXCIrbik7dmFyIHI9XCJcIjtuLmxlbmd0aD4xJiYocj1uLnN1YnN0cmluZygxKSk7dmFyIHM9bi5jaGFyQXQoMCkrXCIuXCIrcjtyZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIrcytpOnMraX0sYWJzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9fLk5hTjp0aGlzLmlzTmVnYXRpdmUoKT90aGlzLm5lZ2F0ZSgpOm5ldyBfKHRoaXMpfSxpc1Bvc2l0aXZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk+MHx8MD09PXRoaXMuaGkmJnRoaXMubG8+MH0sbHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGk8dC5oaXx8dGhpcy5oaT09PXQuaGkmJnRoaXMubG88dC5sb30sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIF8uY29weSh0aGlzKS5zZWxmQWRkKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gXy5jb3B5KHRoaXMpLnNlbGZBZGQoZSl9fSxpbml0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmhpPXQsdGhpcy5sbz0wfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5oaT1lLmhpLHRoaXMubG89ZS5sb319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaGk9bix0aGlzLmxvPWl9fSxndDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaT50LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbz50LmxvfSxpc05lZ2F0aXZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk8MHx8MD09PXRoaXMuaGkmJnRoaXMubG88MH0sdHJ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc05hTigpP18uTmFOOnRoaXMuaXNQb3NpdGl2ZSgpP3RoaXMuZmxvb3IoKTp0aGlzLmNlaWwoKX0sc2lnbnVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk+MD8xOnRoaXMuaGk8MD8tMTp0aGlzLmxvPjA/MTp0aGlzLmxvPDA/LTE6MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdSxzLG9dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBffX0pLF8uc3FyPWZ1bmN0aW9uKHQpe3JldHVybiBfLnZhbHVlT2YodCkuc2VsZk11bHRpcGx5KHQpfSxfLnZhbHVlT2Y9ZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIF8ucGFyc2UodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgXyhlKX19LF8uc3FydD1mdW5jdGlvbih0KXtyZXR1cm4gXy52YWx1ZU9mKHQpLnNxcnQoKX0sXy5wYXJzZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXQubGVuZ3RoO08uaXNXaGl0ZXNwYWNlKHQuY2hhckF0KGUpKTspZSsrO3ZhciBpPSExO2lmKG4+ZSl7dmFyIHI9dC5jaGFyQXQoZSk7XCItXCIhPT1yJiZcIitcIiE9PXJ8fChlKyssXCItXCI9PT1yJiYoaT0hMCkpfWZvcih2YXIgcz1uZXcgXyxvPTAsYT0wLHU9MDs7KXtpZihlPj1uKWJyZWFrO3ZhciBsPXQuY2hhckF0KGUpO2lmKGUrKyxPLmlzRGlnaXQobCkpe3ZhciBoPWwtXCIwXCI7cy5zZWxmTXVsdGlwbHkoXy5URU4pLHMuc2VsZkFkZChoKSxvKyt9ZWxzZXtpZihcIi5cIiE9PWwpe2lmKFwiZVwiPT09bHx8XCJFXCI9PT1sKXt2YXIgYz10LnN1YnN0cmluZyhlKTt0cnl7dT1iLnBhcnNlSW50KGMpfWNhdGNoKGUpe3Rocm93IGUgaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb24/bmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIkludmFsaWQgZXhwb25lbnQgXCIrYytcIiBpbiBzdHJpbmcgXCIrdCk6ZX1maW5hbGx5e31icmVha310aHJvdyBuZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK2wrXCInIGF0IHBvc2l0aW9uIFwiK2UrXCIgaW4gc3RyaW5nIFwiK3QpfWE9b319dmFyIGY9cyxnPW8tYS11O2lmKDA9PT1nKWY9cztlbHNlIGlmKGc+MCl7dmFyIGQ9Xy5URU4ucG93KGcpO2Y9cy5kaXZpZGUoZCl9ZWxzZSBpZigwPmcpe3ZhciBkPV8uVEVOLnBvdygtZyk7Zj1zLm11bHRpcGx5KGQpfXJldHVybiBpP2YubmVnYXRlKCk6Zn0sXy5jcmVhdGVOYU49ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IF8oci5OYU4sci5OYU4pfSxfLmNvcHk9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBfKHQpfSxfLm1hZ25pdHVkZT1mdW5jdGlvbih0KXt2YXIgZT1NYXRoLmFicyh0KSxuPU1hdGgubG9nKGUpL01hdGgubG9nKDEwKSxpPU1hdGgudHJ1bmMoTWF0aC5mbG9vcihuKSkscj1NYXRoLnBvdygxMCxpKTtyZXR1cm4gZT49MTAqciYmKGkrPTEpLGl9LF8uc3RyaW5nT2ZDaGFyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBQLGk9MDtlPmk7aSsrKW4uYXBwZW5kKHQpO3JldHVybiBuLnRvU3RyaW5nKCl9LF8uUEk9bmV3IF8oMy4xNDE1OTI2NTM1ODk3OTMsMS4yMjQ2NDY3OTkxNDczNTMyZS0xNiksXy5UV09fUEk9bmV3IF8oNi4yODMxODUzMDcxNzk1ODYsMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiksXy5QSV8yPW5ldyBfKDEuNTcwNzk2MzI2Nzk0ODk2Niw2LjEyMzIzMzk5NTczNjc2NmUtMTcpLF8uRT1uZXcgXygyLjcxODI4MTgyODQ1OTA0NSwxLjQ0NTY0Njg5MTcyOTI1MDJlLTE2KSxfLk5hTj1uZXcgXyhyLk5hTixyLk5hTiksXy5FUFM9MS4yMzI1OTUxNjQ0MDc4M2UtMzIsXy5TUExJVD0xMzQyMTc3MjksXy5NQVhfUFJJTlRfRElHSVRTPTMyLF8uVEVOPV8udmFsdWVPZigxMCksXy5PTkU9Xy52YWx1ZU9mKDEpLF8uU0NJX05PVF9FWFBPTkVOVF9DSEFSPVwiRVwiLF8uU0NJX05PVF9aRVJPPVwiMC4wRTBcIixlKE0ucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNfX0pLE0ub3JpZW50YXRpb25JbmRleD1mdW5jdGlvbih0LGUsbil7dmFyIGk9TS5vcmllbnRhdGlvbkluZGV4RmlsdGVyKHQsZSxuKTtpZigxPj1pKXJldHVybiBpO3ZhciByPV8udmFsdWVPZihlLngpLnNlbGZBZGQoLXQueCkscz1fLnZhbHVlT2YoZS55KS5zZWxmQWRkKC10LnkpLG89Xy52YWx1ZU9mKG4ueCkuc2VsZkFkZCgtZS54KSxhPV8udmFsdWVPZihuLnkpLnNlbGZBZGQoLWUueSk7cmV0dXJuIHIuc2VsZk11bHRpcGx5KGEpLnNlbGZTdWJ0cmFjdChzLnNlbGZNdWx0aXBseShvKSkuc2lnbnVtKCl9LE0uc2lnbk9mRGV0MngyPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQubXVsdGlwbHkoaSkuc2VsZlN1YnRyYWN0KGUubXVsdGlwbHkobikpO3JldHVybiByLnNpZ251bSgpfSxNLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1fLnZhbHVlT2YoaS55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkpLHM9Xy52YWx1ZU9mKGkueCkuc2VsZlN1YnRyYWN0KG4ueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxvPXIuc3VidHJhY3QocyksYT1fLnZhbHVlT2YoaS54KS5zZWxmU3VidHJhY3Qobi54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLHU9Xy52YWx1ZU9mKGkueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxsPWEuc3VidHJhY3QodSksaD1sLnNlbGZEaXZpZGUobykuZG91YmxlVmFsdWUoKSxjPV8udmFsdWVPZih0LngpLnNlbGZBZGQoXy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KGgpKS5kb3VibGVWYWx1ZSgpLGY9Xy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChuLnkpKSxkPV8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qobi54KSkscD1mLnN1YnRyYWN0KGQpLHY9cC5zZWxmRGl2aWRlKG8pLmRvdWJsZVZhbHVlKCksbT1fLnZhbHVlT2Yobi55KS5zZWxmQWRkKF8udmFsdWVPZihpLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseSh2KSkuZG91YmxlVmFsdWUoKTtyZXR1cm4gbmV3IGcoYyxtKX0sTS5vcmllbnRhdGlvbkluZGV4RmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1udWxsLHI9KHQueC1uLngpKihlLnktbi55KSxzPSh0Lnktbi55KSooZS54LW4ueCksbz1yLXM7aWYocj4wKXtpZigwPj1zKXJldHVybiBNLnNpZ251bShvKTtpPXIrc31lbHNle2lmKCEoMD5yKSlyZXR1cm4gTS5zaWdudW0obyk7aWYocz49MClyZXR1cm4gTS5zaWdudW0obyk7aT0tci1zfXZhciBhPU0uRFBfU0FGRV9FUFNJTE9OKmk7cmV0dXJuIG8+PWF8fC1vPj1hP00uc2lnbnVtKG8pOjJ9LE0uc2lnbnVtPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/MTowPnQ/LTE6MH0sTS5EUF9TQUZFX0VQU0lMT049MWUtMTUsZShELnByb3RvdHlwZSx7c2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlLG4pe30sc2l6ZTpmdW5jdGlvbigpe30sZ2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlKXt9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxnZXRDb29yZGluYXRlQ29weTpmdW5jdGlvbih0KXt9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe30sZ2V0WDpmdW5jdGlvbih0KXt9LGNsb25lOmZ1bmN0aW9uKCl7fSxleHBhbmRFbnZlbG9wZTpmdW5jdGlvbih0KXt9LGNvcHk6ZnVuY3Rpb24oKXt9LGdldFk6ZnVuY3Rpb24odCl7fSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIER9fSksRC5YPTAsRC5ZPTEsRC5aPTIsRC5NPTMsQS5hcnJheWNvcHk9ZnVuY3Rpb24odCxlLG4saSxyKXtmb3IodmFyIHM9MCxvPWU7ZStyPm87bysrKW5baStzXT10W29dLHMrK30sQS5nZXRQcm9wZXJ0eT1mdW5jdGlvbih0KXtyZXR1cm57XCJsaW5lLnNlcGFyYXRvclwiOlwiXFxuXCJ9W3RdfSxlKEYucHJvdG90eXBlLHtnZXRZOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy55L3RoaXMudztpZihyLmlzTmFOKHQpfHxyLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IHc7cmV0dXJuIHR9LGdldFg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLngvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdztyZXR1cm4gdH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBnO3JldHVybiB0Lng9dGhpcy5nZXRYKCksdC55PXRoaXMuZ2V0WSgpLHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZ9fSksRi5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlLG4saSl7dmFyIHM9dC55LWUueSxvPWUueC10LngsYT10LngqZS55LWUueCp0LnksdT1uLnktaS55LGw9aS54LW4ueCxoPW4ueCppLnktaS54Km4ueSxjPW8qaC1sKmEsZj11KmEtcypoLGQ9cypsLXUqbyxwPWMvZCx2PWYvZDtpZihyLmlzTmFOKHApfHxyLmlzSW5maW5pdGUocCl8fHIuaXNOYU4odil8fHIuaXNJbmZpbml0ZSh2KSl0aHJvdyBuZXcgdztyZXR1cm4gbmV3IGcocCx2KX0sZShHLnByb3RvdHlwZSx7Y3JlYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2FyZ3VtZW50c1swXX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLEQpKXthcmd1bWVudHNbMF19fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHfX0pLGUocS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHF9fSksZShCLnByb3RvdHlwZSx7aXNHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTn0sZ2V0RmFjdG9yeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZhY3Rvcnl9LGdldEdlb21ldHJ5TjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpc30sZ2V0QXJlYTpmdW5jdGlvbigpe3JldHVybiAwfSxpc1JlY3RhbmdsZTpmdW5jdGlvbigpe3JldHVybiExfSxlcXVhbHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG51bGw9PT10PyExOnRoaXMuZXF1YWxzVG9wbyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCl7dmFyIGU9YXJndW1lbnRzWzBdO2lmKCEoZSBpbnN0YW5jZW9mIEIpKXJldHVybiExO3ZhciBuPWU7cmV0dXJuIHRoaXMuZXF1YWxzRXhhY3Qobil9fX0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXM9PT10fHx0aGlzLmVxdWFsc0V4YWN0KHQsMCl9LGdlb21ldHJ5Q2hhbmdlZDpmdW5jdGlvbigpe3RoaXMuYXBwbHkoQi5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIpfSxnZW9tZXRyeUNoYW5nZWRBY3Rpb246ZnVuY3Rpb24oKXt0aGlzLmVudmVsb3BlPW51bGx9LGVxdWFsc05vcm06ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PT10PyExOnRoaXMubm9ybSgpLmVxdWFsc0V4YWN0KHQubm9ybSgpKX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LGdldE51bUdlb21ldHJpZXM6ZnVuY3Rpb24oKXtyZXR1cm4gMX0sY29tcGFyZVRvOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQ7cmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkhPT1lLmdldFNvcnRJbmRleCgpP3RoaXMuZ2V0U29ydEluZGV4KCktZS5nZXRTb3J0SW5kZXgoKTp0aGlzLmlzRW1wdHkoKSYmZS5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTplLmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1uO3JldHVybiB0aGlzLmdldFNvcnRJbmRleCgpIT09ZS5nZXRTb3J0SW5kZXgoKT90aGlzLmdldFNvcnRJbmRleCgpLWUuZ2V0U29ydEluZGV4KCk6dGhpcy5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6ZS5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhuLGkpfX0sZ2V0VXNlckRhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51c2VyRGF0YX0sZ2V0U1JJRDpmdW5jdGlvbigpe3JldHVybiB0aGlzLlNSSUR9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkpfSxjaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtpZih0LmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OKXRocm93IG5ldyBpKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpfSxlcXVhbDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIDA9PT1uP3QuZXF1YWxzKGUpOnQuZGlzdGFuY2UoZSk8PW59LG5vcm06ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvcHkoKTtyZXR1cm4gdC5ub3JtYWxpemUoKSx0fSxnZXRQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX0sZ2V0RW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5lbnZlbG9wZSYmKHRoaXMuZW52ZWxvcGU9dGhpcy5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpKSxuZXcgQyh0aGlzLmVudmVsb3BlKX0sc2V0U1JJRDpmdW5jdGlvbih0KXt0aGlzLlNSSUQ9dH0sc2V0VXNlckRhdGE6ZnVuY3Rpb24odCl7dGhpcy51c2VyRGF0YT10fSxjb21wYXJlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaXRlcmF0b3IoKSxpPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKSYmaS5oYXNOZXh0KCk7KXt2YXIgcj1uLm5leHQoKSxzPWkubmV4dCgpLG89ci5jb21wYXJlVG8ocyk7aWYoMCE9PW8pcmV0dXJuIG99cmV0dXJuIG4uaGFzTmV4dCgpPzE6aS5oYXNOZXh0KCk/LTE6MH0saGFzaENvZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuaGFzaENvZGUoKX0saXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTnx8dGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX01VTFRJUE9JTlR8fHRoaXMuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkd8fHRoaXMuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9NVUxUSVBPTFlHT059LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW28scyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQn19KSxCLmhhc05vbkVtcHR5RWxlbWVudHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIXRbZV0uaXNFbXB0eSgpKXJldHVybiEwO3JldHVybiExfSxCLmhhc051bGxFbGVtZW50cz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKylpZihudWxsPT09dFtlXSlyZXR1cm4hMDtyZXR1cm4hMX0sQi5zZXJpYWxWZXJzaW9uVUlEPTB4Nzk5ZWE0NjUyMjg1NGMwMCxCLlNPUlRJTkRFWF9QT0lOVD0wLEIuU09SVElOREVYX01VTFRJUE9JTlQ9MSxCLlNPUlRJTkRFWF9MSU5FU1RSSU5HPTIsQi5TT1JUSU5ERVhfTElORUFSUklORz0zLEIuU09SVElOREVYX01VTFRJTElORVNUUklORz00LEIuU09SVElOREVYX1BPTFlHT049NSxCLlNPUlRJTkRFWF9NVUxUSVBPTFlHT049NixCLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT049NyxCLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcj17aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGZpbHRlcjpmdW5jdGlvbih0KXt0Lmdlb21ldHJ5Q2hhbmdlZEFjdGlvbigpfX0sZSh6LnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gen19KSxlKFYucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWfX0pLGUoay5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtyZXR1cm4gdCUyPT09MX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bVl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGt9fSksZShZLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0PjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZfX0pLGUoVS5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtyZXR1cm4gdD4xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltWXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVX19KSxlKFgucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7cmV0dXJuIDE9PT10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltWXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWH19KSxWLk1vZDJCb3VuZGFyeU5vZGVSdWxlPWssVi5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9WSxWLk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPVUsVi5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPVgsVi5NT0QyX0JPVU5EQVJZX1JVTEU9bmV3IGssVi5FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBZLFYuTVVMVElWQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgVSxWLk1PTk9WQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgWCxWLk9HQ19TRlNfQk9VTkRBUllfUlVMRT1WLk1PRDJfQk9VTkRBUllfUlVMRSxlKEgucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIfX0pLEguaXNSaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aDw0PyExOiEhdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX0sSC5wdE5vdEluTGlzdD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2lmKEguaW5kZXhPZihpLGUpPDApcmV0dXJuIGl9cmV0dXJuIG51bGx9LEguc2Nyb2xsPWZ1bmN0aW9uKHQsZSl7dmFyIG49SC5pbmRleE9mKGUsdCk7aWYoMD5uKXJldHVybiBudWxsO3ZhciBpPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtBLmFycmF5Y29weSh0LG4saSwwLHQubGVuZ3RoLW4pLEEuYXJyYXljb3B5KHQsMCxpLHQubGVuZ3RoLW4sbiksQS5hcnJheWNvcHkoaSwwLHQsMCx0Lmxlbmd0aCl9LEguZXF1YWxzPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT09dHx8bnVsbD09PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZVtuXSkpcmV0dXJuITE7cmV0dXJuITB9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtpZihpPT09cilyZXR1cm4hMDtpZihudWxsPT09aXx8bnVsbD09PXIpcmV0dXJuITE7aWYoaS5sZW5ndGghPT1yLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIG49MDtuPGkubGVuZ3RoO24rKylpZigwIT09cy5jb21wYXJlKGlbbl0scltuXSkpcmV0dXJuITE7cmV0dXJuITB9fSxILmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgTixpPTA7aTx0Lmxlbmd0aDtpKyspZS5pbnRlcnNlY3RzKHRbaV0pJiZuLmFkZCh0W2ldLCEwKTtyZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfSxILmhhc1JlcGVhdGVkUG9pbnRzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZS0xXS5lcXVhbHModFtlXSkpcmV0dXJuITA7cmV0dXJuITF9LEgucmVtb3ZlUmVwZWF0ZWRQb2ludHM9ZnVuY3Rpb24odCl7aWYoIUguaGFzUmVwZWF0ZWRQb2ludHModCkpcmV0dXJuIHQ7dmFyIGU9bmV3IE4odCwhMSk7cmV0dXJuIGUudG9Db29yZGluYXRlQXJyYXkoKX0sSC5yZXZlcnNlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aC0xLG49TWF0aC50cnVuYyhlLzIpLGk9MDtuPj1pO2krKyl7dmFyIHI9dFtpXTt0W2ldPXRbZS1pXSx0W2UtaV09cn19LEgucmVtb3ZlTnVsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDtuKyspbnVsbCE9PXRbbl0mJmUrKzt2YXIgaT1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtpZigwPT09ZSlyZXR1cm4gaTtmb3IodmFyIHI9MCxuPTA7bjx0Lmxlbmd0aDtuKyspbnVsbCE9PXRbbl0mJihpW3IrK109dFtuXSk7cmV0dXJuIGl9LEguY29weURlZXA9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKSxuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT1uZXcgZyh0W25dKTtyZXR1cm4gZX1pZig1PT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdLGE9YXJndW1lbnRzWzRdLG49MDthPm47bisrKXNbbytuXT1uZXcgZyhpW3Irbl0pfSxILmlzRXF1YWxSZXZlcnNlZD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dLHI9ZVt0Lmxlbmd0aC1uLTFdO2lmKDAhPT1pLmNvbXBhcmVUbyhyKSlyZXR1cm4hMX1yZXR1cm4hMH0sSC5lbnZlbG9wZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEMsbj0wO248dC5sZW5ndGg7bisrKWUuZXhwYW5kVG9JbmNsdWRlKHRbbl0pO3JldHVybiBlfSxILnRvQ29vcmRpbmF0ZUFycmF5PWZ1bmN0aW9uKHQpe3JldHVybiB0LnRvQXJyYXkoSC5jb29yZEFycmF5VHlwZSl9LEguYXRMZWFzdE5Db29yZGluYXRlc09yTm90aGluZz1mdW5jdGlvbih0LGUpe3JldHVybiBlLmxlbmd0aD49dD9lOltdfSxILmluZGV4T2Y9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKylpZih0LmVxdWFscyhlW25dKSlyZXR1cm4gbjtyZXR1cm4tMX0sSC5pbmNyZWFzaW5nRGlyZWN0aW9uPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8TWF0aC50cnVuYyh0Lmxlbmd0aC8yKTtlKyspe3ZhciBuPXQubGVuZ3RoLTEtZSxpPXRbZV0uY29tcGFyZVRvKHRbbl0pO2lmKDAhPT1pKXJldHVybiBpfXJldHVybiAxfSxILmNvbXBhcmU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoJiZuPGUubGVuZ3RoOyl7dmFyIGk9dFtuXS5jb21wYXJlVG8oZVtuXSk7aWYoMCE9PWkpcmV0dXJuIGk7bisrfXJldHVybiBuPGUubGVuZ3RoPy0xOm48dC5sZW5ndGg/MTowfSxILm1pbkNvb3JkaW5hdGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj0wO248dC5sZW5ndGg7bisrKShudWxsPT09ZXx8ZS5jb21wYXJlVG8odFtuXSk+MCkmJihlPXRbbl0pO3JldHVybiBlfSxILmV4dHJhY3Q9ZnVuY3Rpb24odCxlLG4pe2U9VC5jbGFtcChlLDAsdC5sZW5ndGgpLG49VC5jbGFtcChuLC0xLHQubGVuZ3RoKTt2YXIgaT1uLWUrMTswPm4mJihpPTApLGU+PXQubGVuZ3RoJiYoaT0wKSxlPm4mJihpPTApO3ZhciByPW5ldyBBcnJheShpKS5maWxsKG51bGwpO2lmKDA9PT1pKXJldHVybiByO2Zvcih2YXIgcz0wLG89ZTtuPj1vO28rKylyW3MrK109dFtvXTtyZXR1cm4gcn0sZShXLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO3JldHVybiBILmNvbXBhcmUobixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFd9fSksZShqLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO2lmKG4ubGVuZ3RoPGkubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPmkubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDt2YXIgcj1ILmNvbXBhcmUobixpKSxzPUguaXNFcXVhbFJldmVyc2VkKG4saSk7cmV0dXJuIHM/MDpyfSxPTERjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWU7aWYobi5sZW5ndGg8aS5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+aS5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2Zvcih2YXIgcj1ILmluY3JlYXNpbmdEaXJlY3Rpb24obikscz1ILmluY3JlYXNpbmdEaXJlY3Rpb24oaSksbz1yPjA/MDpuLmxlbmd0aC0xLGE9cz4wPzA6bi5sZW5ndGgtMSx1PTA7dTxuLmxlbmd0aDt1Kyspe3ZhciBsPW5bb10uY29tcGFyZVRvKGlbYV0pO2lmKDAhPT1sKXJldHVybiBsO28rPXIsYSs9c31yZXR1cm4gMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGp9fSksSC5Gb3J3YXJkQ29tcGFyYXRvcj1XLEguQmlkaXJlY3Rpb25hbENvbXBhcmF0b3I9aixILmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLEsucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe30sSy5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7fSxaLnByb3RvdHlwZT1uZXcgSyxRLnByb3RvdHlwZT1uZXcgdixRLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbigpe30sSi5wcm90b3R5cGU9bmV3IFEsSi5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl7dmFyIGk9dGhpcy5hcnJheV9bZV07aWYoaT09PXQpcmV0dXJuITB9cmV0dXJuITF9LEoucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb250YWlucyh0KT8hMToodGhpcy5hcnJheV8ucHVzaCh0KSwhMCl9LEoucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LEoucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgamF2YXNjcmlwdC51dGlsLk9wZXJhdGlvbk5vdFN1cHBvcnRlZH0sSi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LEoucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sSi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxKLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgSnModGhpcyl9O3ZhciBKcz1mdW5jdGlvbih0KXt0aGlzLmhhc2hTZXRfPXQsdGhpcy5wb3NpdGlvbl89MH07SnMucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvc2l0aW9uXz09PXRoaXMuaGFzaFNldF8uc2l6ZSgpKXRocm93IG5ldyB4O3JldHVybiB0aGlzLmhhc2hTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXX0sSnMucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy5oYXNoU2V0Xy5zaXplKCl9LEpzLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRX07dmFyICRzPTAsdG89MTtydC5wcm90b3R5cGU9bmV3IFoscnQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5yb290XztudWxsIT09ZTspe3ZhciBuPXQuY29tcGFyZVRvKGUua2V5KTtpZigwPm4pZT1lLmxlZnQ7ZWxzZXtpZighKG4+MCkpcmV0dXJuIGUudmFsdWU7ZT1lLnJpZ2h0fX1yZXR1cm4gbnVsbH0scnQucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe2lmKG51bGw9PT10aGlzLnJvb3RfKXJldHVybiB0aGlzLnJvb3RfPXtrZXk6dCx2YWx1ZTplLGxlZnQ6bnVsbCxyaWdodDpudWxsLHBhcmVudDpudWxsLGNvbG9yOiRzLGdldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmtleX19LHRoaXMuc2l6ZV89MSxudWxsO3ZhciBuLGkscj10aGlzLnJvb3RfO2RvIGlmKG49cixpPXQuY29tcGFyZVRvKHIua2V5KSwwPmkpcj1yLmxlZnQ7ZWxzZXtpZighKGk+MCkpe3ZhciBzPXIudmFsdWU7cmV0dXJuIHIudmFsdWU9ZSxzfXI9ci5yaWdodH13aGlsZShudWxsIT09cik7dmFyIG89e2tleTp0LGxlZnQ6bnVsbCxyaWdodDpudWxsLHZhbHVlOmUscGFyZW50Om4sY29sb3I6JHMsZ2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5fX07cmV0dXJuIDA+aT9uLmxlZnQ9bzpuLnJpZ2h0PW8sdGhpcy5maXhBZnRlckluc2VydGlvbihvKSx0aGlzLnNpemVfKyssbnVsbH0scnQucHJvdG90eXBlLmZpeEFmdGVySW5zZXJ0aW9uPWZ1bmN0aW9uKHQpe2Zvcih0LmNvbG9yPXRvO251bGwhPXQmJnQhPXRoaXMucm9vdF8mJnQucGFyZW50LmNvbG9yPT10bzspaWYodHQodCk9PW50KHR0KHR0KHQpKSkpe3ZhciBlPWl0KHR0KHR0KHQpKSk7JChlKT09dG8/KGV0KHR0KHQpLCRzKSxldChlLCRzKSxldCh0dCh0dCh0KSksdG8pLHQ9dHQodHQodCkpKToodD09aXQodHQodCkpJiYodD10dCh0KSx0aGlzLnJvdGF0ZUxlZnQodCkpLGV0KHR0KHQpLCRzKSxldCh0dCh0dCh0KSksdG8pLHRoaXMucm90YXRlUmlnaHQodHQodHQodCkpKSl9ZWxzZXt2YXIgZT1udCh0dCh0dCh0KSkpOyQoZSk9PXRvPyhldCh0dCh0KSwkcyksZXQoZSwkcyksZXQodHQodHQodCkpLHRvKSx0PXR0KHR0KHQpKSk6KHQ9PW50KHR0KHQpKSYmKHQ9dHQodCksdGhpcy5yb3RhdGVSaWdodCh0KSksZXQodHQodCksJHMpLGV0KHR0KHR0KHQpKSx0byksdGhpcy5yb3RhdGVMZWZ0KHR0KHR0KHQpKSkpfXRoaXMucm9vdF8uY29sb3I9JHN9LHJ0LnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSSxlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlLnZhbHVlKTtudWxsIT09KGU9cnQuc3VjY2Vzc29yKGUpKTspdC5hZGQoZS52YWx1ZSk7cmV0dXJuIHR9LHJ0LnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe3ZhciB0PW5ldyBKLGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUpO251bGwhPT0oZT1ydC5zdWNjZXNzb3IoZSkpOyl0LmFkZChlKTtyZXR1cm4gdH0scnQucHJvdG90eXBlLnJvdGF0ZUxlZnQ9ZnVuY3Rpb24odCl7aWYobnVsbCE9dCl7dmFyIGU9dC5yaWdodDt0LnJpZ2h0PWUubGVmdCxudWxsIT1lLmxlZnQmJihlLmxlZnQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5sZWZ0PT10P3QucGFyZW50LmxlZnQ9ZTp0LnBhcmVudC5yaWdodD1lLGUubGVmdD10LHQucGFyZW50PWV9fSxydC5wcm90b3R5cGUucm90YXRlUmlnaHQ9ZnVuY3Rpb24odCl7aWYobnVsbCE9dCl7dmFyIGU9dC5sZWZ0O3QubGVmdD1lLnJpZ2h0LG51bGwhPWUucmlnaHQmJihlLnJpZ2h0LnBhcmVudD10KSxlLnBhcmVudD10LnBhcmVudCxudWxsPT10LnBhcmVudD90aGlzLnJvb3RfPWU6dC5wYXJlbnQucmlnaHQ9PXQ/dC5wYXJlbnQucmlnaHQ9ZTp0LnBhcmVudC5sZWZ0PWUsZS5yaWdodD10LHQucGFyZW50PWV9fSxydC5wcm90b3R5cGUuZ2V0Rmlyc3RFbnRyeT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucm9vdF87aWYobnVsbCE9dClmb3IoO251bGwhPXQubGVmdDspdD10LmxlZnQ7cmV0dXJuIHR9LHJ0LnN1Y2Nlc3Nvcj1mdW5jdGlvbih0KXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtpZihudWxsIT09dC5yaWdodCl7Zm9yKHZhciBlPXQucmlnaHQ7bnVsbCE9PWUubGVmdDspZT1lLmxlZnQ7cmV0dXJuIGV9Zm9yKHZhciBlPXQucGFyZW50LG49dDtudWxsIT09ZSYmbj09PWUucmlnaHQ7KW49ZSxlPWUucGFyZW50O3JldHVybiBlfSxydC5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVffSxlKHN0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gc3R9fSksb3QucHJvdG90eXBlPW5ldyBRLGF0LnByb3RvdHlwZT1uZXcgb3QsYXQucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspe3ZhciBpPXRoaXMuYXJyYXlfW2VdO2lmKDA9PT1pLmNvbXBhcmVUbyh0KSlyZXR1cm4hMH1yZXR1cm4hMX0sYXQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtpZih0aGlzLmNvbnRhaW5zKHQpKXJldHVybiExO2Zvcih2YXIgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspe3ZhciBpPXRoaXMuYXJyYXlfW2VdO2lmKDE9PT1pLmNvbXBhcmVUbyh0KSlyZXR1cm4gdGhpcy5hcnJheV8uc3BsaWNlKGUsMCx0KSwhMH1yZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSwhMH0sYXQucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LGF0LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEV9LGF0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sYXQucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sYXQucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sYXQucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBlbyh0aGlzKX07dmFyIGVvPWZ1bmN0aW9uKHQpe3RoaXMudHJlZVNldF89dCx0aGlzLnBvc2l0aW9uXz0wfTtlby5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy50cmVlU2V0Xy5zaXplKCkpdGhyb3cgbmV3IHg7cmV0dXJuIHRoaXMudHJlZVNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdfSxlby5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLnRyZWVTZXRfLnNpemUoKX0sZW8ucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBFfSx1dC5zb3J0PWZ1bmN0aW9uKCl7dmFyIHQsZSxuLGkscj1hcmd1bWVudHNbMF07aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSl9LHZvaWQgci5zb3J0KGkpO2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKW49YXJndW1lbnRzWzFdLGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbi5jb21wYXJlKHQsZSl9LHIuc29ydChpKTtlbHNle2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtlPXIuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSksZS5zb3J0KCk7dmFyIHM9ci5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KGUsci5zbGljZShhcmd1bWVudHNbMl0sci5sZW5ndGgpKTtmb3Ioci5zcGxpY2UoMCxyLmxlbmd0aCksdD0wO3Q8cy5sZW5ndGg7dCsrKXIucHVzaChzW3RdKTtyZXR1cm59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihlPXIuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSksbj1hcmd1bWVudHNbM10saT1mdW5jdGlvbih0LGUpe3JldHVybiBuLmNvbXBhcmUodCxlKX0sZS5zb3J0KGkpLHM9ci5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KGUsci5zbGljZShhcmd1bWVudHNbMl0sci5sZW5ndGgpKSxyLnNwbGljZSgwLHIubGVuZ3RoKSx0PTA7dDxzLmxlbmd0aDt0Kyspci5wdXNoKHNbdF0pO3JldHVybn19fSx1dC5hc0xpc3Q9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49MCxpPXQubGVuZ3RoO2k+bjtuKyspZS5hZGQodFtuXSk7cmV0dXJuIGV9LGUobHQucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsdH19KSxsdC50b0RpbWVuc2lvblN5bWJvbD1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSBsdC5GQUxTRTpyZXR1cm4gbHQuU1lNX0ZBTFNFO2Nhc2UgbHQuVFJVRTpyZXR1cm4gbHQuU1lNX1RSVUU7Y2FzZSBsdC5ET05UQ0FSRTpyZXR1cm4gbHQuU1lNX0RPTlRDQVJFO2Nhc2UgbHQuUDpyZXR1cm4gbHQuU1lNX1A7Y2FzZSBsdC5MOnJldHVybiBsdC5TWU1fTDtjYXNlIGx0LkE6cmV0dXJuIGx0LlNZTV9BfXRocm93IG5ldyBpKFwiVW5rbm93biBkaW1lbnNpb24gdmFsdWU6IFwiK3QpfSxsdC50b0RpbWVuc2lvblZhbHVlPWZ1bmN0aW9uKHQpe3N3aXRjaChPLnRvVXBwZXJDYXNlKHQpKXtjYXNlIGx0LlNZTV9GQUxTRTpyZXR1cm4gbHQuRkFMU0U7Y2FzZSBsdC5TWU1fVFJVRTpyZXR1cm4gbHQuVFJVRTtjYXNlIGx0LlNZTV9ET05UQ0FSRTpyZXR1cm4gbHQuRE9OVENBUkU7Y2FzZSBsdC5TWU1fUDpyZXR1cm4gbHQuUDtjYXNlIGx0LlNZTV9MOnJldHVybiBsdC5MO2Nhc2UgbHQuU1lNX0E6cmV0dXJuIGx0LkF9dGhyb3cgbmV3IGkoXCJVbmtub3duIGRpbWVuc2lvbiBzeW1ib2w6IFwiK3QpfSxsdC5QPTAsbHQuTD0xLGx0LkE9MixsdC5GQUxTRT0tMSxsdC5UUlVFPS0yLGx0LkRPTlRDQVJFPS0zLGx0LlNZTV9GQUxTRT1cIkZcIixsdC5TWU1fVFJVRT1cIlRcIixsdC5TWU1fRE9OVENBUkU9XCIqXCIsbHQuU1lNX1A9XCIwXCIsbHQuU1lNX0w9XCIxXCIsbHQuU1lNX0E9XCIyXCIsZShodC5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGh0fX0pLGUoY3QucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCxlKXt9LGlzRG9uZTpmdW5jdGlvbigpe30saXNHZW9tZXRyeUNoYW5nZWQ6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGN0fX0pLGgoZnQsQiksZShmdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBDLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuZ2VvbWV0cmllc1tlXS5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiB0fSxnZXRHZW9tZXRyeU46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cmllc1t0XX0sZ2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTn0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCksZT0tMSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKylmb3IodmFyIGk9dGhpcy5nZW9tZXRyaWVzW25dLmdldENvb3JkaW5hdGVzKCkscj0wO3I8aS5sZW5ndGg7cisrKWUrKyx0W2VdPWlbcl07cmV0dXJuIHR9LGdldEFyZWE6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmdlb21ldHJpZXNbZV0uZ2V0QXJlYSgpO3JldHVybiB0fSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7dmFyIG49dDtpZih0aGlzLmdlb21ldHJpZXMubGVuZ3RoIT09bi5nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGk9MDtpPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7aSsrKWlmKCF0aGlzLmdlb21ldHJpZXNbaV0uZXF1YWxzRXhhY3Qobi5nZW9tZXRyaWVzW2ldLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBCLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDt0KyspdGhpcy5nZW9tZXRyaWVzW3RdLm5vcm1hbGl6ZSgpO3V0LnNvcnQodGhpcy5nZW9tZXRyaWVzKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2VvbWV0cmllc1swXS5nZXRDb29yZGluYXRlKCl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWx0LkZBTFNFLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLmdlb21ldHJpZXNbZV0uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSk7cmV0dXJuIHR9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe2Zvcih2YXIgdD1sdC5GQUxTRSxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5nZW9tZXRyaWVzW2VdLmdldERpbWVuc2lvbigpKTtyZXR1cm4gdH0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5nZW9tZXRyaWVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmdlb21ldHJpZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9LGdldE51bUdlb21ldHJpZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW9tZXRyaWVzLmxlbmd0aH0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksbj0wO248dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZVtuXT10aGlzLmdlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9LGNvbXBhcmVUb1NhbWVDbGFzczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgYXQodXQuYXNMaXN0KHRoaXMuZ2VvbWV0cmllcykpLG49bmV3IGF0KHV0LmFzTGlzdCh0Lmdlb21ldHJpZXMpKTtyZXR1cm4gdGhpcy5jb21wYXJlKGUsbil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1pLG89dGhpcy5nZXROdW1HZW9tZXRyaWVzKCksYT1zLmdldE51bUdlb21ldHJpZXMoKSx1PTA7bz51JiZhPnU7KXt2YXIgbD10aGlzLmdldEdlb21ldHJ5Tih1KSxoPXMuZ2V0R2VvbWV0cnlOKHUpLGM9bC5jb21wYXJlVG9TYW1lQ2xhc3MoaCxyKTtpZigwIT09YylyZXR1cm4gYzt1Kyt9cmV0dXJuIG8+dT8xOmE+dT8tMTowfX0sYXBwbHk6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx6KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseSh0KTtlbHNlIGlmKFIoYXJndW1lbnRzWzBdLGN0KSl7dmFyIG49YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLmdlb21ldHJpZXMubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aCYmKHRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseShuKSwhbi5pc0RvbmUoKSk7ZSsrKTtuLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpLmZpbHRlcih0aGlzKTtmb3IodmFyIGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseShpKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgcj1hcmd1bWVudHNbMF07ci5maWx0ZXIodGhpcyk7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLmdlb21ldHJpZXNbZV0uYXBwbHkocil9fSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSxudWxsfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7dC5nZW9tZXRyaWVzPW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdC5nZW9tZXRyaWVzW2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jbG9uZSgpO3JldHVybiB0fSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIkdlb21ldHJ5Q29sbGVjdGlvblwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBmdCh0LHRoaXMuZmFjdG9yeSl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLmdlb21ldHJpZXNbdF0uaXNFbXB0eSgpKXJldHVybiExO3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmdH19KSxmdC5zZXJpYWxWZXJzaW9uVUlEPS0weDRmMDdiY2IxZjg1N2Q4MDAsaChndCxmdCksZShndC5wcm90b3R5cGUse2dldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkd9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KT9mdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSk6ITF9cmV0dXJuIGZ0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT9sdC5GQUxTRTowfSxpc0Nsb3NlZDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiExO2Zvcih2YXIgdD0wO3Q8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuZ2VvbWV0cmllc1t0XS5pc0Nsb3NlZCgpKXJldHVybiExO3JldHVybiEwfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMX0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksbj0wO248dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZVt0LTEtbl09dGhpcy5nZW9tZXRyaWVzW25dLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiBuZXcgZHQodGhpcykuZ2V0Qm91bmRhcnkoKX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJNdWx0aUxpbmVTdHJpbmdcIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKSxlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLmdlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgZ3QodCx0aGlzLmZhY3RvcnkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe1xucmV0dXJuW3N0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ3R9fSksZ3Quc2VyaWFsVmVyc2lvblVJRD0weDcxNTVkMmFiNGFmYTgwMDAsZShkdC5wcm90b3R5cGUse2JvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7dmFyIGU9dGhpcy5jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyh0KTtyZXR1cm4gMT09PWUubGVuZ3RoP3RoaXMuZ2VvbUZhY3QuY3JlYXRlUG9pbnQoZVswXSk6dGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhlKX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW9tIGluc3RhbmNlb2YgU3Q/dGhpcy5ib3VuZGFyeUxpbmVTdHJpbmcodGhpcy5nZW9tKTp0aGlzLmdlb20gaW5zdGFuY2VvZiBndD90aGlzLmJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nKHRoaXMuZ2VvbSk6dGhpcy5nZW9tLmdldEJvdW5kYXJ5KCl9LGJvdW5kYXJ5TGluZVN0cmluZzpmdW5jdGlvbih0KXtpZih0aGlzLmdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpO2lmKHQuaXNDbG9zZWQoKSl7dmFyIGU9dGhpcy5iblJ1bGUuaXNJbkJvdW5kYXJ5KDIpO3JldHVybiBlP3QuZ2V0U3RhcnRQb2ludCgpOnRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfXJldHVybiB0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoW3QuZ2V0U3RhcnRQb2ludCgpLHQuZ2V0RW5kUG9pbnQoKV0pfSxnZXRFbXB0eU11bHRpUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9LGNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBJO3RoaXMuZW5kcG9pbnRNYXA9bmV3IHJ0O2Zvcih2YXIgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10LmdldEdlb21ldHJ5TihuKTswIT09aS5nZXROdW1Qb2ludHMoKSYmKHRoaXMuYWRkRW5kcG9pbnQoaS5nZXRDb29yZGluYXRlTigwKSksdGhpcy5hZGRFbmRwb2ludChpLmdldENvb3JkaW5hdGVOKGkuZ2V0TnVtUG9pbnRzKCktMSkpKX1mb3IodmFyIHI9dGhpcy5lbmRwb2ludE1hcC5lbnRyeVNldCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXMuZ2V0VmFsdWUoKSxhPW8uY291bnQ7dGhpcy5iblJ1bGUuaXNJbkJvdW5kYXJ5KGEpJiZlLmFkZChzLmdldEtleSgpKX1yZXR1cm4gSC50b0Nvb3JkaW5hdGVBcnJheShlKX0sYWRkRW5kcG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lbmRwb2ludE1hcC5nZXQodCk7bnVsbD09PWUmJihlPW5ldyBwdCx0aGlzLmVuZHBvaW50TWFwLnB1dCh0LGUpKSxlLmNvdW50Kyt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGR0fX0pLGR0LmdldEJvdW5kYXJ5PWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBkdCh0KTtyZXR1cm4gZS5nZXRCb3VuZGFyeSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1uZXcgZHQobixpKTtyZXR1cm4gZS5nZXRCb3VuZGFyeSgpfX0sZShwdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHB0fX0pLGUoTnQucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOdH19KSxOdC5jaGFycz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgQXJyYXkoZSkuZmlsbChudWxsKSxpPTA7ZT5pO2krKyluW2ldPXQ7cmV0dXJuIG5ldyBTdHJpbmcobil9LE50LmdldFN0YWNrVHJhY2U9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IHh0LG49bmV3IHZ0KGUpO3JldHVybiB0LnByaW50U3RhY2tUcmFjZShuKSxlLnRvU3RyaW5nKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1cIlwiLG89bmV3IG10KE50LmdldFN0YWNrVHJhY2UoaSkpLGE9bmV3IEl0KG8pLHU9MDtyPnU7dSsrKXRyeXtzKz1hLnJlYWRMaW5lKCkrTnQuTkVXTElORX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBFdCkpdGhyb3cgdDtmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9ZmluYWxseXt9cmV0dXJuIHN9fSxOdC5zcGxpdD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLmxlbmd0aCxpPW5ldyBJLHI9XCJcIit0LHM9ci5pbmRleE9mKGUpO3M+PTA7KXt2YXIgbz1yLnN1YnN0cmluZygwLHMpO2kuYWRkKG8pLHI9ci5zdWJzdHJpbmcocytuKSxzPXIuaW5kZXhPZihlKX1yLmxlbmd0aD4wJiZpLmFkZChyKTtmb3IodmFyIGE9bmV3IEFycmF5KGkuc2l6ZSgpKS5maWxsKG51bGwpLHU9MDt1PGEubGVuZ3RoO3UrKylhW3VdPWkuZ2V0KHUpO3JldHVybiBhfSxOdC50b1N0cmluZz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIE50LlNJTVBMRV9PUkRJTkFURV9GT1JNQVQuZm9ybWF0KHQpfX0sTnQuc3BhY2VzPWZ1bmN0aW9uKHQpe3JldHVybiBOdC5jaGFycyhcIiBcIix0KX0sTnQuTkVXTElORT1BLmdldFByb3BlcnR5KFwibGluZS5zZXBhcmF0b3JcIiksTnQuU0lNUExFX09SRElOQVRFX0ZPUk1BVD1uZXcgeXQoXCIwLiNcIiksZShDdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEN0fX0pLEN0LmNvcHlDb29yZD1mdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHI9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxuLmdldERpbWVuc2lvbigpKSxzPTA7cj5zO3MrKyluLnNldE9yZGluYXRlKGkscyx0LmdldE9yZGluYXRlKGUscykpfSxDdC5pc1Jpbmc9ZnVuY3Rpb24odCl7dmFyIGU9dC5zaXplKCk7cmV0dXJuIDA9PT1lPyEwOjM+PWU/ITE6dC5nZXRPcmRpbmF0ZSgwLEQuWCk9PT10LmdldE9yZGluYXRlKGUtMSxELlgpJiZ0LmdldE9yZGluYXRlKDAsRC5ZKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEQuWSl9LEN0LmlzRXF1YWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10LnNpemUoKSxpPWUuc2l6ZSgpO2lmKG4hPT1pKXJldHVybiExO2Zvcih2YXIgcz1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpLG89MDtuPm87bysrKWZvcih2YXIgYT0wO3M+YTthKyspe3ZhciB1PXQuZ2V0T3JkaW5hdGUobyxhKSxsPWUuZ2V0T3JkaW5hdGUobyxhKTtpZighKHQuZ2V0T3JkaW5hdGUobyxhKT09PWUuZ2V0T3JkaW5hdGUobyxhKXx8ci5pc05hTih1KSYmci5pc05hTihsKSkpcmV0dXJuITF9cmV0dXJuITB9LEN0LmV4dGVuZD1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxyPWUuc2l6ZSgpO2lmKEN0LmNvcHkoZSwwLGksMCxyKSxyPjApZm9yKHZhciBzPXI7bj5zO3MrKylDdC5jb3B5KGUsci0xLGkscywxKTtyZXR1cm4gaX0sQ3QucmV2ZXJzZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zaXplKCktMSxuPU1hdGgudHJ1bmMoZS8yKSxpPTA7bj49aTtpKyspQ3Quc3dhcCh0LGksZS1pKX0sQ3Quc3dhcD1mdW5jdGlvbih0LGUsbil7aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKHZhciBpPTA7aTx0LmdldERpbWVuc2lvbigpO2krKyl7dmFyIHI9dC5nZXRPcmRpbmF0ZShlLGkpO3Quc2V0T3JkaW5hdGUoZSxpLHQuZ2V0T3JkaW5hdGUobixpKSksdC5zZXRPcmRpbmF0ZShuLGkscil9fSxDdC5jb3B5PWZ1bmN0aW9uKHQsZSxuLGkscil7Zm9yKHZhciBzPTA7cj5zO3MrKylDdC5jb3B5Q29vcmQodCxlK3MsbixpK3MpfSxDdC50b1N0cmluZz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10LnNpemUoKTtpZigwPT09ZSlyZXR1cm5cIigpXCI7dmFyIG49dC5nZXREaW1lbnNpb24oKSxpPW5ldyBQO2kuYXBwZW5kKFwiKFwiKTtmb3IodmFyIHI9MDtlPnI7cisrKXtyPjAmJmkuYXBwZW5kKFwiIFwiKTtmb3IodmFyIHM9MDtuPnM7cysrKXM+MCYmaS5hcHBlbmQoXCIsXCIpLGkuYXBwZW5kKE50LnRvU3RyaW5nKHQuZ2V0T3JkaW5hdGUocixzKSkpfXJldHVybiBpLmFwcGVuZChcIilcIiksaS50b1N0cmluZygpfX0sQ3QuZW5zdXJlVmFsaWRSaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zaXplKCk7aWYoMD09PW4pcmV0dXJuIGU7aWYoMz49bilyZXR1cm4gQ3QuY3JlYXRlQ2xvc2VkUmluZyh0LGUsNCk7dmFyIGk9ZS5nZXRPcmRpbmF0ZSgwLEQuWCk9PT1lLmdldE9yZGluYXRlKG4tMSxELlgpJiZlLmdldE9yZGluYXRlKDAsRC5ZKT09PWUuZ2V0T3JkaW5hdGUobi0xLEQuWSk7cmV0dXJuIGk/ZTpDdC5jcmVhdGVDbG9zZWRSaW5nKHQsZSxuKzEpfSxDdC5jcmVhdGVDbG9zZWRSaW5nPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLHI9ZS5zaXplKCk7Q3QuY29weShlLDAsaSwwLHIpO2Zvcih2YXIgcz1yO24+cztzKyspQ3QuY29weShlLDAsaSxzLDEpO3JldHVybiBpfSxoKFN0LEIpLGUoU3QucHJvdG90eXBlLHtjb21wdXRlRW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9uZXcgQzp0aGlzLnBvaW50cy5leHBhbmRFbnZlbG9wZShuZXcgQyl9LGlzUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCkmJnRoaXMuaXNTaW1wbGUoKX0sZ2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX0xJTkVTVFJJTkd9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnRzLnRvQ29vcmRpbmF0ZUFycmF5KCl9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10O2lmKHRoaXMucG9pbnRzLnNpemUoKSE9PW4ucG9pbnRzLnNpemUoKSlyZXR1cm4hMTtmb3IodmFyIGk9MDtpPHRoaXMucG9pbnRzLnNpemUoKTtpKyspaWYoIXRoaXMuZXF1YWwodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSxuLnBvaW50cy5nZXRDb29yZGluYXRlKGkpLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBCLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8TWF0aC50cnVuYyh0aGlzLnBvaW50cy5zaXplKCkvMik7dCsrKXt2YXIgZT10aGlzLnBvaW50cy5zaXplKCktMS10O2lmKCF0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpLmVxdWFscyh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpKSlyZXR1cm4gdGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5jb21wYXJlVG8odGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSk+MCYmQ3QucmV2ZXJzZSh0aGlzLnBvaW50cyksbnVsbH19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKDApfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/bHQuRkFMU0U6MH0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/ITE6dGhpcy5nZXRDb29yZGluYXRlTigwKS5lcXVhbHMyRCh0aGlzLmdldENvb3JkaW5hdGVOKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSkpfSxnZXRFbmRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2V0UG9pbnROKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSl9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gaGUuY29tcHV0ZUxlbmd0aCh0aGlzLnBvaW50cyl9LGdldE51bVBvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvaW50cy5zaXplKCl9LHJldmVyc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvaW50cy5jb3B5KCk7Q3QucmV2ZXJzZSh0KTt2YXIgZT10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQpO3JldHVybiBlfSxjb21wYXJlVG9TYW1lQ2xhc3M6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQsbj0wLGk9MDtuPHRoaXMucG9pbnRzLnNpemUoKSYmaTxlLnBvaW50cy5zaXplKCk7KXt2YXIgcj10aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKG4pLmNvbXBhcmVUbyhlLnBvaW50cy5nZXRDb29yZGluYXRlKGkpKTtpZigwIT09cilyZXR1cm4gcjtuKyssaSsrfXJldHVybiBuPHRoaXMucG9pbnRzLnNpemUoKT8xOmk8ZS5wb2ludHMuc2l6ZSgpPy0xOjB9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxlPXM7cmV0dXJuIG8uY29tcGFyZSh0aGlzLnBvaW50cyxlLnBvaW50cyl9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5wb2ludHMuc2l6ZSgpO2UrKyl0LmZpbHRlcih0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpKTtlbHNlIGlmKFIoYXJndW1lbnRzWzBdLGN0KSl7dmFyIG49YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLnBvaW50cy5zaXplKCkpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTx0aGlzLnBvaW50cy5zaXplKCkmJihuLmZpbHRlcih0aGlzLnBvaW50cyxlKSwhbi5pc0RvbmUoKSk7ZSsrKTtuLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpLmZpbHRlcih0aGlzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgcj1hcmd1bWVudHNbMF07ci5maWx0ZXIodGhpcyl9fSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiBuZXcgZHQodGhpcykuZ2V0Qm91bmRhcnkoKX0saXNFcXVpdmFsZW50Q2xhc3M6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBTdH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1CLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0LnBvaW50cz10aGlzLnBvaW50cy5jbG9uZSgpLHR9LGdldENvb3JkaW5hdGVOOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIkxpbmVTdHJpbmdcIn0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgU3QodGhpcy5wb2ludHMuY29weSgpLHRoaXMuZmFjdG9yeSl9LGdldENvb3JkaW5hdGVTZXF1ZW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvaW50c30saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5wb2ludHMuc2l6ZSgpfSxpbml0OmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksMT09PXQuc2l6ZSgpKXRocm93IG5ldyBpKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVTdHJpbmcgKGZvdW5kIFwiK3Quc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDIpXCIpO3RoaXMucG9pbnRzPXR9LGlzQ29vcmRpbmF0ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMucG9pbnRzLnNpemUoKTtlKyspaWYodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKS5lcXVhbHModCkpcmV0dXJuITA7cmV0dXJuITF9LGdldFN0YXJ0UG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50TigwKX0sZ2V0UG9pbnROOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTdH19KSxTdC5zZXJpYWxWZXJzaW9uVUlEPTB4MmIyYjUxYmE0MzVjOGUwMCxlKHd0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd3R9fSksaChMdCxCKSxlKEx0LnByb3RvdHlwZSx7Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbmV3IEM7dmFyIHQ9bmV3IEM7cmV0dXJuIHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY29vcmRpbmF0ZXMuZ2V0WCgwKSx0aGlzLmNvb3JkaW5hdGVzLmdldFkoMCkpLHR9LGdldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9QT0lOVH0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/W106W3RoaXMuZ2V0Q29vcmRpbmF0ZSgpXX0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpP3RoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKT8hMDp0aGlzLmlzRW1wdHkoKSE9PXQuaXNFbXB0eSgpPyExOnRoaXMuZXF1YWwodC5nZXRDb29yZGluYXRlKCksdGhpcy5nZXRDb29yZGluYXRlKCksZSk6ITF9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLmNvb3JkaW5hdGVzLnNpemUoKT90aGlzLmNvb3JkaW5hdGVzLmdldENvb3JkaW5hdGUoMCk6bnVsbH0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAwfSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoxfSxyZXZlcnNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29weSgpfSxnZXRYOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJnZXRYIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueH0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQ7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyhlLmdldENvb3JkaW5hdGUoKSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW47cmV0dXJuIGkuY29tcGFyZSh0aGlzLmNvb3JkaW5hdGVzLGUuY29vcmRpbmF0ZXMpfX0sYXBwbHk6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx6KSl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGN0KSl7dmFyIGU9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO2UuZmlsdGVyKHRoaXMuY29vcmRpbmF0ZXMsMCksZS5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0saHQpKXt2YXIgbj1hcmd1bWVudHNbMF07bi5maWx0ZXIodGhpcyl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxxKSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuY29vcmRpbmF0ZXM9dGhpcy5jb29yZGluYXRlcy5jbG9uZSgpLHR9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiUG9pbnRcIn0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgTHQodGhpcy5jb29yZGluYXRlcy5jb3B5KCksdGhpcy5mYWN0b3J5KX0sZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXN9LGdldFk6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFkgY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS55fSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmNvb3JkaW5hdGVzLnNpemUoKX0saW5pdDpmdW5jdGlvbih0KXtudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLGYuaXNUcnVlKHQuc2l6ZSgpPD0xKSx0aGlzLmNvb3JkaW5hdGVzPXR9LGlzU2ltcGxlOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3d0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTHR9fSksTHQuc2VyaWFsVmVyc2lvblVJRD0weDQ0MDc3YmFkMTYxY2JjMDAsZShSdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJ0fX0pLGgoVHQsQiksZShUdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfUE9MWUdPTn0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm5bXTtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCksZT0tMSxuPXRoaXMuc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKSxpPTA7aTxuLmxlbmd0aDtpKyspZSsrLHRbZV09bltpXTtmb3IodmFyIHI9MDtyPHRoaXMuaG9sZXMubGVuZ3RoO3IrKylmb3IodmFyIHM9dGhpcy5ob2xlc1tyXS5nZXRDb29yZGluYXRlcygpLG89MDtvPHMubGVuZ3RoO28rKyllKyssdFtlXT1zW29dO3JldHVybiB0fSxnZXRBcmVhOmZ1bmN0aW9uKCl7dmFyIHQ9MDt0Kz1NYXRoLmFicyhoZS5zaWduZWRBcmVhKHRoaXMuc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0LT1NYXRoLmFicyhoZS5zaWduZWRBcmVhKHRoaXMuaG9sZXNbZV0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpKTtyZXR1cm4gdH0saXNSZWN0YW5nbGU6ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSlyZXR1cm4hMTtpZihudWxsPT09dGhpcy5zaGVsbClyZXR1cm4hMTtpZig1IT09dGhpcy5zaGVsbC5nZXROdW1Qb2ludHMoKSlyZXR1cm4hMTtmb3IodmFyIHQ9dGhpcy5zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxlPXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG49MDs1Pm47bisrKXt2YXIgaT10LmdldFgobik7aWYoaSE9PWUuZ2V0TWluWCgpJiZpIT09ZS5nZXRNYXhYKCkpcmV0dXJuITE7dmFyIHI9dC5nZXRZKG4pO2lmKHIhPT1lLmdldE1pblkoKSYmciE9PWUuZ2V0TWF4WSgpKXJldHVybiExfWZvcih2YXIgcz10LmdldFgoMCksbz10LmdldFkoMCksbj0xOzQ+PW47bisrKXt2YXIgaT10LmdldFgobikscj10LmdldFkobiksYT1pIT09cyx1PXIhPT1vO2lmKGE9PT11KXJldHVybiExO3M9aSxvPXJ9cmV0dXJuITB9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10LGk9dGhpcy5zaGVsbCxyPW4uc2hlbGw7aWYoIWkuZXF1YWxzRXhhY3QocixlKSlyZXR1cm4hMTtpZih0aGlzLmhvbGVzLmxlbmd0aCE9PW4uaG9sZXMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgcz0wO3M8dGhpcy5ob2xlcy5sZW5ndGg7cysrKWlmKCF0aGlzLmhvbGVzW3NdLmVxdWFsc0V4YWN0KG4uaG9sZXNbc10sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMubm9ybWFsaXplKHRoaXMuc2hlbGwsITApO2Zvcih2YXIgdD0wO3Q8dGhpcy5ob2xlcy5sZW5ndGg7dCsrKXRoaXMubm9ybWFsaXplKHRoaXMuaG9sZXNbdF0sITEpO3V0LnNvcnQodGhpcy5ob2xlcyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKGUuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBpPW5ldyBBcnJheShlLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpLmZpbGwobnVsbCk7QS5hcnJheWNvcHkoZS5nZXRDb29yZGluYXRlcygpLDAsaSwwLGkubGVuZ3RoKTt2YXIgcj1ILm1pbkNvb3JkaW5hdGUoZS5nZXRDb29yZGluYXRlcygpKTtILnNjcm9sbChpLHIpLEEuYXJyYXljb3B5KGksMCxlLmdldENvb3JkaW5hdGVzKCksMCxpLmxlbmd0aCksZS5nZXRDb29yZGluYXRlcygpW2kubGVuZ3RoXT1pWzBdLGhlLmlzQ0NXKGUuZ2V0Q29vcmRpbmF0ZXMoKSk9PT1uJiZILnJldmVyc2UoZS5nZXRDb29yZGluYXRlcygpKX19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbC5nZXRDb29yZGluYXRlKCl9LGdldE51bUludGVyaW9yUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhvbGVzLmxlbmd0aH0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDJ9LGdldExlbmd0aDpmdW5jdGlvbigpe3ZhciB0PTA7dCs9dGhpcy5zaGVsbC5nZXRMZW5ndGgoKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmhvbGVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5zaGVsbC5nZXROdW1Qb2ludHMoKSxlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5ob2xlc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH0scmV2ZXJzZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY29weSgpO3Quc2hlbGw9dGhpcy5zaGVsbC5jb3B5KCkucmV2ZXJzZSgpLHQuaG9sZXM9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQuaG9sZXNbZV09dGhpcy5ob2xlc1tlXS5jb3B5KCkucmV2ZXJzZSgpO3JldHVybiB0fSxjb252ZXhIdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkuY29udmV4SHVsbCgpfSxjb21wYXJlVG9TYW1lQ2xhc3M6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5zaGVsbCxuPXQuc2hlbGw7cmV0dXJuIGUuY29tcGFyZVRvU2FtZUNsYXNzKG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1pLGU9dGhpcy5zaGVsbCxuPXMuc2hlbGwsbz1lLmNvbXBhcmVUb1NhbWVDbGFzcyhuLHIpO2lmKDAhPT1vKXJldHVybiBvO2Zvcih2YXIgYT10aGlzLmdldE51bUludGVyaW9yUmluZygpLHU9cy5nZXROdW1JbnRlcmlvclJpbmcoKSxsPTA7YT5sJiZ1Pmw7KXt2YXIgaD10aGlzLmdldEludGVyaW9yUmluZ04obCksYz1zLmdldEludGVyaW9yUmluZ04obCksZj1oLmNvbXBhcmVUb1NhbWVDbGFzcyhjLHIpO2lmKDAhPT1mKXJldHVybiBmO2wrK31yZXR1cm4gYT5sPzE6dT5sPy0xOjB9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zaGVsbC5hcHBseSh0KTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0aGlzLmhvbGVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5zaGVsbC5hcHBseShuKSwhbi5pc0RvbmUoKSlmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoJiYodGhpcy5ob2xlc1tlXS5hcHBseShuKSwhbi5pc0RvbmUoKSk7ZSsrKTtuLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpLmZpbHRlcih0aGlzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgcj1hcmd1bWVudHNbMF07ci5maWx0ZXIodGhpcyksdGhpcy5zaGVsbC5hcHBseShyKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0aGlzLmhvbGVzW2VdLmFwcGx5KHIpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7dmFyIHQ9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKzEpLmZpbGwobnVsbCk7dFswXT10aGlzLnNoZWxsO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXRbZSsxXT10aGlzLmhvbGVzW2VdO3JldHVybiB0Lmxlbmd0aDw9MT90aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHRbMF0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpOnRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1CLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO3Quc2hlbGw9dGhpcy5zaGVsbC5jbG9uZSgpLHQuaG9sZXM9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQuaG9sZXNbZV09dGhpcy5ob2xlc1tlXS5jbG9uZSgpO3JldHVybiB0fSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIlBvbHlnb25cIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLnNoZWxsLmNvcHkoKSxlPW5ldyBBcnJheSh0aGlzLmhvbGVzLmxlbmd0aCkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10aGlzLmhvbGVzW25dLmNvcHkoKTtyZXR1cm4gbmV3IFR0KHQsZSx0aGlzLmZhY3RvcnkpfSxnZXRFeHRlcmlvclJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbH0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsLmlzRW1wdHkoKX0sZ2V0SW50ZXJpb3JSaW5nTjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ob2xlc1t0XX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bUnRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUdH19KSxUdC5zZXJpYWxWZXJzaW9uVUlEPS0weDMwN2ZmZWZkOGRjOTcyMDAsaChQdCxmdCksZShQdC5wcm90b3R5cGUse2dldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9NVUxUSVBPSU5UfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KT9mdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSk6ITF9cmV0dXJuIGZ0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmdlb21ldHJpZXNbdF0uZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiBmdC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGx0LkZBTFNFfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIk11bHRpUG9pbnRcIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKSxlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLmdlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgUHQodCx0aGlzLmZhY3RvcnkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt3dF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFB0fX0pLFB0LnNlcmlhbFZlcnNpb25VSUQ9LTB4NmZiMWVkNDE2MmUwZmMwMCxoKGJ0LFN0KSxlKGJ0LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX0xJTkVBUlJJTkd9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGx0LkZBTFNFfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8hMDpTdC5wcm90b3R5cGUuaXNDbG9zZWQuY2FsbCh0aGlzKX0scmV2ZXJzZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucG9pbnRzLmNvcHkoKTtDdC5yZXZlcnNlKHQpO3ZhciBlPXRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodCk7cmV0dXJuIGV9LHZhbGlkYXRlQ29uc3RydWN0aW9uOmZ1bmN0aW9uKCl7aWYoIXRoaXMuaXNFbXB0eSgpJiYhU3QucHJvdG90eXBlLmlzQ2xvc2VkLmNhbGwodGhpcykpdGhyb3cgbmV3IGkoXCJQb2ludHMgb2YgTGluZWFyUmluZyBkbyBub3QgZm9ybSBhIGNsb3NlZCBsaW5lc3RyaW5nXCIpO2lmKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPj0xJiZ0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKTxidC5NSU5JTVVNX1ZBTElEX1NJWkUpdGhyb3cgbmV3IGkoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZWFyUmluZyAoZm91bmQgXCIrdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gNClcIil9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTGluZWFyUmluZ1wifSxjb3B5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBidCh0aGlzLnBvaW50cy5jb3B5KCksdGhpcy5mYWN0b3J5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYnR9fSksYnQuTUlOSU1VTV9WQUxJRF9TSVpFPTQsYnQuc2VyaWFsVmVyc2lvblVJRD0tMHgzYjIyOWUyNjIzNjdhNjAwLGgoT3QsZnQpLGUoT3QucHJvdG90eXBlLHtnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTVVMVElQT0xZR09OfSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCk/ZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpOiExfXJldHVybiBmdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMn0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksbj0wO248dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZVtuXT10aGlzLmdlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2Zvcih2YXIgdD1uZXcgSSxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKylmb3IodmFyIG49dGhpcy5nZW9tZXRyaWVzW2VdLGk9bi5nZXRCb3VuZGFyeSgpLHI9MDtyPGkuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl0LmFkZChpLmdldEdlb21ldHJ5TihyKSk7dmFyIHM9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcodC50b0FycmF5KHMpKX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJNdWx0aVBvbHlnb25cIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKSxlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLmdlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgT3QodCx0aGlzLmZhY3RvcnkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE90fX0pLE90LnNlcmlhbFZlcnNpb25VSUQ9LTB4N2E1YWExMzY5MTcxOTgwLGUoX3QucHJvdG90eXBlLHtzZXRDb3B5VXNlckRhdGE6ZnVuY3Rpb24odCl7dGhpcy5pc1VzZXJEYXRhQ29waWVkPXR9LGVkaXQ6ZnVuY3Rpb24odCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDt2YXIgbj10aGlzLmVkaXRJbnRlcm5hbCh0LGUpO3JldHVybiB0aGlzLmlzVXNlckRhdGFDb3BpZWQmJm4uc2V0VXNlckRhdGEodC5nZXRVc2VyRGF0YSgpKSxufSxlZGl0SW50ZXJuYWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXRoaXMuZmFjdG9yeSYmKHRoaXMuZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdCBpbnN0YW5jZW9mIGZ0P3RoaXMuZWRpdEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpOnQgaW5zdGFuY2VvZiBUdD90aGlzLmVkaXRQb2x5Z29uKHQsZSk6dCBpbnN0YW5jZW9mIEx0P2UuZWRpdCh0LHRoaXMuZmFjdG9yeSk6dCBpbnN0YW5jZW9mIFN0P2UuZWRpdCh0LHRoaXMuZmFjdG9yeSk6KGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbnN1cHBvcnRlZCBHZW9tZXRyeSBjbGFzczogXCIrdC5nZXRDbGFzcygpLmdldE5hbWUoKSksbnVsbCl9LGVkaXRHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KSxpPW5ldyBJLHI9MDtyPG4uZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIHM9dGhpcy5lZGl0KG4uZ2V0R2VvbWV0cnlOKHIpLGUpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8aS5hZGQocyl9cmV0dXJuIG4uZ2V0Q2xhc3MoKT09PVB0P3RoaXMuZmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGkudG9BcnJheShbXSkpOm4uZ2V0Q2xhc3MoKT09PWd0P3RoaXMuZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoaS50b0FycmF5KFtdKSk6bi5nZXRDbGFzcygpPT09T3Q/dGhpcy5mYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihpLnRvQXJyYXkoW10pKTp0aGlzLmZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGkudG9BcnJheShbXSkpfSxlZGl0UG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPWUuZWRpdCh0LHRoaXMuZmFjdG9yeSk7aWYobnVsbD09PW4mJihuPXRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKG51bGwpKSxuLmlzRW1wdHkoKSlyZXR1cm4gbjt2YXIgaT10aGlzLmVkaXQobi5nZXRFeHRlcmlvclJpbmcoKSxlKTtpZihudWxsPT09aXx8aS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCk7Zm9yKHZhciByPW5ldyBJLHM9MDtzPG4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXt2YXIgbz10aGlzLmVkaXQobi5nZXRJbnRlcmlvclJpbmdOKHMpLGUpO251bGw9PT1vfHxvLmlzRW1wdHkoKXx8ci5hZGQobyl9cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKGksci50b0FycmF5KFtdKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF90fX0pLF90Lkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uPU10LGUoRHQucHJvdG90eXBlLHtlZGl0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRHR9fSksZShBdC5wcm90b3R5cGUse2VkaXQ6ZnVuY3Rpb24odCxlKXtpZih0IGluc3RhbmNlb2YgYnQpcmV0dXJuIGUuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCksdCkpO2lmKHQgaW5zdGFuY2VvZiBTdClyZXR1cm4gZS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZWRpdENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSk7aWYodCBpbnN0YW5jZW9mIEx0KXt2YXIgbj10aGlzLmVkaXRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCksdCk7cmV0dXJuIG4ubGVuZ3RoPjA/ZS5jcmVhdGVQb2ludChuWzBdKTplLmNyZWF0ZVBvaW50KCl9cmV0dXJuIHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQXR9fSksZShGdC5wcm90b3R5cGUse2VkaXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIGJ0P2UuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIFN0P2UuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIEx0P2UuY3JlYXRlUG9pbnQodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRnR9fSksX3QuTm9PcEdlb21ldHJ5T3BlcmF0aW9uPUR0LF90LkNvb3JkaW5hdGVPcGVyYXRpb249QXQsX3QuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uPUZ0LGUoR3QucHJvdG90eXBlLHtzZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUsbil7c3dpdGNoKGUpe2Nhc2UgRC5YOnRoaXMuY29vcmRpbmF0ZXNbdF0ueD1uO2JyZWFrO2Nhc2UgRC5ZOnRoaXMuY29vcmRpbmF0ZXNbdF0ueT1uO2JyZWFrO2Nhc2UgRC5aOnRoaXMuY29vcmRpbmF0ZXNbdF0uej1uO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IGkoXCJpbnZhbGlkIG9yZGluYXRlSW5kZXhcIil9fSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RofSxnZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUpe3N3aXRjaChlKXtjYXNlIEQuWDpyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS54O2Nhc2UgRC5ZOnJldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLnk7Y2FzZSBELlo6cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0uen1yZXR1cm4gci5OYU59LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07bi54PXRoaXMuY29vcmRpbmF0ZXNbZV0ueCxuLnk9dGhpcy5jb29yZGluYXRlc1tlXS55LG4uej10aGlzLmNvb3JkaW5hdGVzW2VdLnp9fSxnZXRDb29yZGluYXRlQ29weTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodGhpcy5jb29yZGluYXRlc1t0XSl9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpbWVuc2lvbn0sZ2V0WDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS54fSxjbG9uZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCksZT0wO2U8dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXRbZV09dGhpcy5jb29yZGluYXRlc1tlXS5jbG9uZSgpO3JldHVybiBuZXcgR3QodCx0aGlzLmRpbWVuc2lvbil9LGV4cGFuZEVudmVsb3BlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0fSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKSxlPTA7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdFtlXT10aGlzLmNvb3JkaW5hdGVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IEd0KHQsdGhpcy5kaW1lbnNpb24pfSx0b1N0cmluZzpmdW5jdGlvbigpe2lmKHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoPjApe3ZhciB0PW5ldyBQKDE3KnRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoKTt0LmFwcGVuZChcIihcIiksdC5hcHBlbmQodGhpcy5jb29yZGluYXRlc1swXSk7Zm9yKHZhciBlPTE7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5hcHBlbmQoXCIsIFwiKSx0LmFwcGVuZCh0aGlzLmNvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdC5hcHBlbmQoXCIpXCIpLHQudG9TdHJpbmcoKX1yZXR1cm5cIigpXCJ9LGdldFk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0ueX0sdG9Db29yZGluYXRlQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRCx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR3R9fSksR3Quc2VyaWFsVmVyc2lvblVJRD0tMHhjYjQ0YTc3OGRiMThlMDAsZShxdC5wcm90b3R5cGUse3JlYWRSZXNvbHZlOmZ1bmN0aW9uKCl7cmV0dXJuIHF0Lmluc3RhbmNlKCl9LGNyZWF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBHdCh0KX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgR3QoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gaT4zJiYoaT0zKSwyPmk/bmV3IEd0KG4pOm5ldyBHdChuLGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcXR9fSkscXQuaW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gcXQuaW5zdGFuY2VPYmplY3R9LHF0LnNlcmlhbFZlcnNpb25VSUQ9LTB4MzhlNDlmYTZjZjZmMmUwMCxxdC5pbnN0YW5jZU9iamVjdD1uZXcgcXQ7dmFyIG5vLGlvPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxybz16dCh7ZGVsZXRlOmt0LGhhczpYdCxnZXQ6WXQsc2V0Okh0LGtleXM6anQsdmFsdWVzOkt0LGVudHJpZXM6WnQsZm9yRWFjaDokdCxjbGVhcjpXdH0pLHNvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBNYXAmJk1hcC5wcm90b3R5cGUudmFsdWVzP01hcDpybzt0ZS5wcm90b3R5cGU9bmV3IEssdGUucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5tYXBfLmdldCh0KXx8bnVsbH0sdGUucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLm1hcF8uc2V0KHQsZSksZX0sdGUucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgSSxlPXRoaXMubWFwXy52YWx1ZXMoKSxuPWUubmV4dCgpOyFuLmRvbmU7KXQuYWRkKG4udmFsdWUpLG49ZS5uZXh0KCk7cmV0dXJuIHR9LHRlLnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe3ZhciB0PW5ldyBKO3JldHVybiB0aGlzLm1hcF8uZW50cmllcygpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWRkKGUpfSksdH0sdGUucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfLnNpemUoKX0sZShlZS5wcm90b3R5cGUse2VxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBlZSkpcmV0dXJuITE7dmFyIGU9dDtyZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lLm1vZGVsVHlwZSYmdGhpcy5zY2FsZT09PWUuc2NhbGV9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10LG49dGhpcy5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKSxpPWUuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCk7cmV0dXJuIG5ldyBiKG4pLmNvbXBhcmVUbyhuZXcgYihpKSl9LGdldFNjYWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2NhbGV9LGlzRmxvYXRpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR3x8dGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR19TSU5HTEV9LGdldFR5cGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlbFR5cGV9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9XCJVTktOT1dOXCI7cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkc/dD1cIkZsb2F0aW5nXCI6dGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR19TSU5HTEU/dD1cIkZsb2F0aW5nLVNpbmdsZVwiOnRoaXMubW9kZWxUeXBlPT09ZWUuRklYRUQmJih0PVwiRml4ZWQgKFNjYWxlPVwiK3RoaXMuZ2V0U2NhbGUoKStcIilcIiksdH0sbWFrZVByZWNpc2U6ZnVuY3Rpb24oKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07aWYoci5pc05hTih0KSlyZXR1cm4gdDtpZih0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HX1NJTkdMRSl7dmFyIGU9dDtyZXR1cm4gZX1yZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lZS5GSVhFRD9NYXRoLnJvdW5kKHQqdGhpcy5zY2FsZSkvdGhpcy5zY2FsZTp0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdO2lmKHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkcpcmV0dXJuIG51bGw7bi54PXRoaXMubWFrZVByZWNpc2Uobi54KSxuLnk9dGhpcy5tYWtlUHJlY2lzZShuLnkpfX0sZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzOmZ1bmN0aW9uKCl7dmFyIHQ9MTY7cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkc/dD0xNjp0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HX1NJTkdMRT90PTY6dGhpcy5tb2RlbFR5cGU9PT1lZS5GSVhFRCYmKHQ9MStNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLmxvZyh0aGlzLmdldFNjYWxlKCkpL01hdGgubG9nKDEwKSkpKSx0fSxzZXRTY2FsZTpmdW5jdGlvbih0KXt0aGlzLnNjYWxlPU1hdGguYWJzKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1LHNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlZX19KSxlZS5tb3N0UHJlY2lzZT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKT49MD90OmV9LGUobmUucHJvdG90eXBlLHtyZWFkUmVzb2x2ZTpmdW5jdGlvbigpe3JldHVybiBuZS5uYW1lVG9UeXBlTWFwLmdldCh0aGlzLm5hbWUpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3VdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBuZX19KSxuZS5zZXJpYWxWZXJzaW9uVUlEPS01NTI4NjAyNjMxNzMxNTllNCxuZS5uYW1lVG9UeXBlTWFwPW5ldyB0ZSxlZS5UeXBlPW5lLGVlLnNlcmlhbFZlcnNpb25VSUQ9MHg2YmVlNjQwNGU5YTI1YzAwLGVlLkZJWEVEPW5ldyBuZShcIkZJWEVEXCIpLGVlLkZMT0FUSU5HPW5ldyBuZShcIkZMT0FUSU5HXCIpLGVlLkZMT0FUSU5HX1NJTkdMRT1uZXcgbmUoXCJGTE9BVElORyBTSU5HTEVcIiksZWUubWF4aW11bVByZWNpc2VWYWx1ZT05MDA3MTk5MjU0NzQwOTkyLGUoaWUucHJvdG90eXBlLHt0b0dlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0LmlzTnVsbCgpP3RoaXMuY3JlYXRlUG9pbnQobnVsbCk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKSYmdC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZVBvaW50KG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKXx8dC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSldKTp0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpXSksbnVsbCl9LGNyZWF0ZUxpbmVTdHJpbmc6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IFN0KGUsdGhpcyl9fX0sY3JlYXRlTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBndChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBndCh0LHRoaXMpfX0sYnVpbGRHZW9tZXRyeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPSExLGk9ITEscj10Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXMuZ2V0Q2xhc3MoKTtudWxsPT09ZSYmKGU9byksbyE9PWUmJihuPSEwKSxzLmlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkKCkmJihpPSEwKX1pZihudWxsPT09ZSlyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtpZihufHxpKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkodCkpO3ZhciBhPXQuaXRlcmF0b3IoKS5uZXh0KCksdT10LnNpemUoKT4xO2lmKHUpe2lmKGEgaW5zdGFuY2VvZiBUdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvbHlnb24oaWUudG9Qb2x5Z29uQXJyYXkodCkpO2lmKGEgaW5zdGFuY2VvZiBTdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoaWUudG9MaW5lU3RyaW5nQXJyYXkodCkpO2lmKGEgaW5zdGFuY2VvZiBMdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGllLnRvUG9pbnRBcnJheSh0KSk7Zi5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuaGFuZGxlZCBjbGFzczogXCIrYS5nZXRDbGFzcygpLmdldE5hbWUoKSl9cmV0dXJuIGF9LGNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfSxjcmVhdGVQb2ludDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZVBvaW50KHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW3RdKTpudWxsKX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgTHQoZSx0aGlzKX19fSxnZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeX0sY3JlYXRlUG9seWdvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgVHQobnVsbCxudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoZSkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKG4sbnVsbCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IFR0KGkscix0aGlzKX19LGdldFNSSUQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5TUklEfSxjcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IGZ0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IGZ0KHQsdGhpcyl9fSxjcmVhdGVHZW9tZXRyeTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgX3QodGhpcyk7cmV0dXJuIGUuZWRpdCh0LHtlZGl0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTthcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5jcmVhdGUodCl9fX0pfSxnZXRQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsfSxjcmVhdGVMaW5lYXJSaW5nOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBidChlLHRoaXMpfX19LGNyZWF0ZU11bHRpUG9seWdvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgT3QobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgT3QodCx0aGlzKX19LGNyZWF0ZU11bHRpUG9pbnQ6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IFB0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IFB0KHQsdGhpcyl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobnVsbCE9PWU/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGUpOm51bGwpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYobnVsbD09PW4pcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7Zm9yKHZhciBpPW5ldyBBcnJheShuLnNpemUoKSkuZmlsbChudWxsKSxyPTA7cjxuLnNpemUoKTtyKyspe3ZhciBzPXRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSgxLG4uZ2V0RGltZW5zaW9uKCkpO0N0LmNvcHkobixyLHMsMCwxKSxpW3JdPXRoaXMuY3JlYXRlUG9pbnQocyl9cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChpKX19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaWV9fSksaWUudG9NdWx0aVBvbHlnb25BcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9HZW9tZXRyeUFycmF5PWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1mdW5jdGlvbigpe3JldHVybiBxdC5pbnN0YW5jZSgpfSxpZS50b011bHRpTGluZVN0cmluZ0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b0xpbmVTdHJpbmdBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9NdWx0aVBvaW50QXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvTGluZWFyUmluZ0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b1BvaW50QXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvUG9seWdvbkFycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX0saWUuc2VyaWFsVmVyc2lvblVJRD0tMHg1ZWE3NWYyMDUxZWViNDAwO3ZhciBvbz17dHlwZVN0cjovXlxccyooXFx3KylcXHMqXFwoXFxzKiguKilcXHMqXFwpXFxzKiQvLGVtcHR5VHlwZVN0cjovXlxccyooXFx3KylcXHMqRU1QVFlcXHMqJC8sc3BhY2VzOi9cXHMrLyxwYXJlbkNvbW1hOi9cXClcXHMqLFxccypcXCgvLGRvdWJsZVBhcmVuQ29tbWE6L1xcKVxccypcXClcXHMqLFxccypcXChcXHMqXFwoLyx0cmltUGFyZW5zOi9eXFxzKlxcKD8oLio/KVxcKT9cXHMqJC99O2UocmUucHJvdG90eXBlLHtyZWFkOmZ1bmN0aW9uKHQpe3ZhciBlLG4saTt0PXQucmVwbGFjZSgvW1xcblxccl0vZyxcIiBcIik7dmFyIHI9b28udHlwZVN0ci5leGVjKHQpO2lmKC0xIT09dC5zZWFyY2goXCJFTVBUWVwiKSYmKHI9b28uZW1wdHlUeXBlU3RyLmV4ZWModCksclsyXT12b2lkIDApLHImJihuPXJbMV0udG9Mb3dlckNhc2UoKSxpPXJbMl0sdW9bbl0mJihlPXVvW25dLmFwcGx5KHRoaXMsW2ldKSkpLHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIFdLVCBcIit0KTtyZXR1cm4gZX0sd3JpdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZXh0cmFjdEdlb21ldHJ5KHQpfSxleHRyYWN0R2VvbWV0cnk6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRHZW9tZXRyeVR5cGUoKS50b0xvd2VyQ2FzZSgpO2lmKCFhb1tlXSlyZXR1cm4gbnVsbDt2YXIgbixpPWUudG9VcHBlckNhc2UoKTtyZXR1cm4gbj10LmlzRW1wdHkoKT9pK1wiIEVNUFRZXCI6aStcIihcIithb1tlXS5hcHBseSh0aGlzLFt0XSkrXCIpXCJ9fSk7dmFyIGFvPXtjb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0LngrXCIgXCIrdC55fSxwb2ludDpmdW5jdGlvbih0KXtcbnJldHVybiBhby5jb29yZGluYXRlLmNhbGwodGhpcyx0LmNvb3JkaW5hdGVzLmNvb3JkaW5hdGVzWzBdKX0sbXVsdGlwb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5nZW9tZXRyaWVzLmxlbmd0aDtpPm47KytuKWUucHVzaChcIihcIithby5wb2ludC5hcHBseSh0aGlzLFt0Lmdlb21ldHJpZXNbbl1dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LGxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQucG9pbnRzLmNvb3JkaW5hdGVzLmxlbmd0aDtpPm47KytuKWUucHVzaChhby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3QucG9pbnRzLmNvb3JkaW5hdGVzW25dXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxsaW5lYXJyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10LnBvaW50cy5jb29yZGluYXRlcy5sZW5ndGg7aT5uOysrbillLnB1c2goYW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFt0LnBvaW50cy5jb29yZGluYXRlc1tuXV0pKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbXVsdGlsaW5lc3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbdC5nZW9tZXRyaWVzW25dXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxwb2x5Z29uOmZ1bmN0aW9uKHQpe3ZhciBlPVtdO2UucHVzaChcIihcIithby5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW3Quc2hlbGxdKStcIilcIik7Zm9yKHZhciBuPTAsaT10LmhvbGVzLmxlbmd0aDtpPm47KytuKWUucHVzaChcIihcIithby5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW3QuaG9sZXNbbl1dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LG11bHRpcG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5nZW9tZXRyaWVzLmxlbmd0aDtpPm47KytuKWUucHVzaChcIihcIithby5wb2x5Z29uLmFwcGx5KHRoaXMsW3QuZ2VvbWV0cmllc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sZ2VvbWV0cnljb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKHRoaXMuZXh0cmFjdEdlb21ldHJ5KHQuZ2VvbWV0cmllc1tuXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfX0sdW89e3BvaW50OmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KCk7dmFyIGU9dC50cmltKCkuc3BsaXQob28uc3BhY2VzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQobmV3IGcoTnVtYmVyLnBhcnNlRmxvYXQoZVswXSksTnVtYmVyLnBhcnNlRmxvYXQoZVsxXSkpKX0sbXVsdGlwb2ludDpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQoXCIsXCIpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksaS5wdXNoKHVvLnBvaW50LmFwcGx5KHRoaXMsW2VdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoaSl9LGxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZygpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3M+cjsrK3IpZT1uW3JdLnRyaW0oKS5zcGxpdChvby5zcGFjZXMpLGkucHVzaChuZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGkpfSxsaW5lYXJyaW5nOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChcIixcIiksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS50cmltKCkuc3BsaXQob28uc3BhY2VzKSxpLnB1c2gobmV3IGcoTnVtYmVyLnBhcnNlRmxvYXQoZVswXSksTnVtYmVyLnBhcnNlRmxvYXQoZVsxXSkpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhpKX0sbXVsdGlsaW5lc3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KG9vLnBhcmVuQ29tbWEpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksaS5wdXNoKHVvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbZV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGkpfSxwb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24oKTtmb3IodmFyIGUsbixpLHIscz10LnRyaW0oKS5zcGxpdChvby5wYXJlbkNvbW1hKSxvPVtdLGE9MCx1PXMubGVuZ3RoO3U+YTsrK2EpZT1zW2FdLnJlcGxhY2Uob28udHJpbVBhcmVucyxcIiQxXCIpLG49dW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFtlXSksaT10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4ucG9pbnRzKSwwPT09YT9yPWk6by5wdXNoKGkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKHIsbyl9LG11bHRpcG9seWdvbjpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChvby5kb3VibGVQYXJlbkNvbW1hKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3M+cjsrK3IpZT1uW3JdLnJlcGxhY2Uob28udHJpbVBhcmVucyxcIiQxXCIpLGkucHVzaCh1by5wb2x5Z29uLmFwcGx5KHRoaXMsW2VdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihpKX0sZ2VvbWV0cnljb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO3Q9dC5yZXBsYWNlKC8sXFxzKihbQS1aYS16XSkvZyxcInwkMVwiKTtmb3IodmFyIGU9dC50cmltKCkuc3BsaXQoXCJ8XCIpLG49W10saT0wLHI9ZS5sZW5ndGg7cj5pOysraSluLnB1c2godGhpcy5yZWFkKGVbaV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG4pfX07ZShzZS5wcm90b3R5cGUse3dyaXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX19KSxlKHNlLHt0b0xpbmVTdHJpbmc6ZnVuY3Rpb24odCxlKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7cmV0dXJuXCJMSU5FU1RSSU5HICggXCIrdC54K1wiIFwiK3QueStcIiwgXCIrZS54K1wiIFwiK2UueStcIiApXCJ9fSksZShvZS5wcm90b3R5cGUse2dldEluZGV4QWxvbmdTZWdtZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpLHRoaXMuaW50TGluZUluZGV4W3RdW2VdfSxnZXRUb3BvbG9neVN1bW1hcnk6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgUDtyZXR1cm4gdGhpcy5pc0VuZFBvaW50KCkmJnQuYXBwZW5kKFwiIGVuZHBvaW50XCIpLHRoaXMuX2lzUHJvcGVyJiZ0LmFwcGVuZChcIiBwcm9wZXJcIiksdGhpcy5pc0NvbGxpbmVhcigpJiZ0LmFwcGVuZChcIiBjb2xsaW5lYXJcIiksdC50b1N0cmluZygpfSxjb21wdXRlSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3RoaXMuaW5wdXRMaW5lc1swXVswXT10LHRoaXMuaW5wdXRMaW5lc1swXVsxXT1lLHRoaXMuaW5wdXRMaW5lc1sxXVswXT1uLHRoaXMuaW5wdXRMaW5lc1sxXVsxXT1pLHRoaXMucmVzdWx0PXRoaXMuY29tcHV0ZUludGVyc2VjdCh0LGUsbixpKX0sZ2V0SW50ZXJzZWN0aW9uTnVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVzdWx0fSxjb21wdXRlSW50TGluZUluZGV4OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpbnVsbD09PXRoaXMuaW50TGluZUluZGV4JiYodGhpcy5pbnRMaW5lSW5kZXg9QXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgyKX0pLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgwKSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMSkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMCksbj10aGlzLmdldEVkZ2VEaXN0YW5jZSh0LDEpO2U+bj8odGhpcy5pbnRMaW5lSW5kZXhbdF1bMF09MCx0aGlzLmludExpbmVJbmRleFt0XVsxXT0xKToodGhpcy5pbnRMaW5lSW5kZXhbdF1bMF09MSx0aGlzLmludExpbmVJbmRleFt0XVsxXT0wKX19LGlzUHJvcGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2lzUHJvcGVyfSxzZXRQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbih0KXt0aGlzLnByZWNpc2lvbk1vZGVsPXR9LGlzSW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDApPyEwOiEhdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDEpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHRoaXMucmVzdWx0O2UrKylpZighdGhpcy5pbnRQdFtlXS5lcXVhbHMyRCh0aGlzLmlucHV0TGluZXNbdF1bMF0pJiYhdGhpcy5pbnRQdFtlXS5lcXVhbHMyRCh0aGlzLmlucHV0TGluZXNbdF1bMV0pKXJldHVybiEwO3JldHVybiExfX0sZ2V0SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmludFB0W3RdfSxpc0VuZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJiF0aGlzLl9pc1Byb3Blcn0saGFzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVzdWx0IT09b2UuTk9fSU5URVJTRUNUSU9OfSxnZXRFZGdlRGlzdGFuY2U6ZnVuY3Rpb24odCxlKXt2YXIgbj1vZS5jb21wdXRlRWRnZURpc3RhbmNlKHRoaXMuaW50UHRbZV0sdGhpcy5pbnB1dExpbmVzW3RdWzBdLHRoaXMuaW5wdXRMaW5lc1t0XVsxXSk7cmV0dXJuIG59LGlzQ29sbGluZWFyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVzdWx0PT09b2UuQ09MTElORUFSX0lOVEVSU0VDVElPTn0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKHRoaXMuaW5wdXRMaW5lc1swXVswXSx0aGlzLmlucHV0TGluZXNbMF1bMV0pK1wiIC0gXCIrc2UudG9MaW5lU3RyaW5nKHRoaXMuaW5wdXRMaW5lc1sxXVswXSx0aGlzLmlucHV0TGluZXNbMV1bMV0pK3RoaXMuZ2V0VG9wb2xvZ3lTdW1tYXJ5KCl9LGdldEVuZHBvaW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuaW5wdXRMaW5lc1t0XVtlXX0saXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLnJlc3VsdDtlKyspaWYodGhpcy5pbnRQdFtlXS5lcXVhbHMyRCh0KSlyZXR1cm4hMDtyZXR1cm4hMX0sZ2V0SW50ZXJzZWN0aW9uQWxvbmdTZWdtZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpLHRoaXMuaW50UHRbdGhpcy5pbnRMaW5lSW5kZXhbdF1bZV1dfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvZX19KSxvZS5jb21wdXRlRWRnZURpc3RhbmNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1NYXRoLmFicyhuLngtZS54KSxyPU1hdGguYWJzKG4ueS1lLnkpLHM9LTE7aWYodC5lcXVhbHMoZSkpcz0wO2Vsc2UgaWYodC5lcXVhbHMobikpcz1pPnI/aTpyO2Vsc2V7dmFyIG89TWF0aC5hYnModC54LWUueCksYT1NYXRoLmFicyh0LnktZS55KTtzPWk+cj9vOmEsMCE9PXN8fHQuZXF1YWxzKGUpfHwocz1NYXRoLm1heChvLGEpKX1yZXR1cm4gZi5pc1RydWUoISgwPT09cyYmIXQuZXF1YWxzKGUpKSxcIkJhZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxzfSxvZS5ub25Sb2J1c3RDb21wdXRlRWRnZURpc3RhbmNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LngtZS54LHI9dC55LWUueSxzPU1hdGguc3FydChpKmkrcipyKTtyZXR1cm4gZi5pc1RydWUoISgwPT09cyYmIXQuZXF1YWxzKGUpKSxcIkludmFsaWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIiksc30sb2UuRE9OVF9JTlRFUlNFQ1Q9MCxvZS5ET19JTlRFUlNFQ1Q9MSxvZS5DT0xMSU5FQVI9MixvZS5OT19JTlRFUlNFQ1RJT049MCxvZS5QT0lOVF9JTlRFUlNFQ1RJT049MSxvZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OPTIsaChhZSxvZSksZShhZS5wcm90b3R5cGUse2lzSW5TZWdtZW50RW52ZWxvcGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDKHRoaXMuaW5wdXRMaW5lc1swXVswXSx0aGlzLmlucHV0TGluZXNbMF1bMV0pLG49bmV3IEModGhpcy5pbnB1dExpbmVzWzFdWzBdLHRoaXMuaW5wdXRMaW5lc1sxXVsxXSk7cmV0dXJuIGUuY29udGFpbnModCkmJm4uY29udGFpbnModCl9LGNvbXB1dGVJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtpZigzIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gb2UucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdGhpcy5faXNQcm9wZXI9ITEsQy5pbnRlcnNlY3RzKGUsbix0KSYmMD09PWhlLm9yaWVudGF0aW9uSW5kZXgoZSxuLHQpJiYwPT09aGUub3JpZW50YXRpb25JbmRleChuLGUsdCk/KHRoaXMuX2lzUHJvcGVyPSEwLCh0LmVxdWFscyhlKXx8dC5lcXVhbHMobikpJiYodGhpcy5faXNQcm9wZXI9ITEpLHRoaXMucmVzdWx0PW9lLlBPSU5UX0lOVEVSU0VDVElPTixudWxsKTp2b2lkKHRoaXMucmVzdWx0PW9lLk5PX0lOVEVSU0VDVElPTil9LG5vcm1hbGl6ZVRvTWluaW11bTpmdW5jdGlvbih0LGUsbixpLHIpe3IueD10aGlzLnNtYWxsZXN0SW5BYnNWYWx1ZSh0LngsZS54LG4ueCxpLngpLHIueT10aGlzLnNtYWxsZXN0SW5BYnNWYWx1ZSh0LnksZS55LG4ueSxpLnkpLHQueC09ci54LHQueS09ci55LGUueC09ci54LGUueS09ci55LG4ueC09ci54LG4ueS09ci55LGkueC09ci54LGkueS09ci55fSxzYWZlSENvb3JkaW5hdGVJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bnVsbDt0cnl7cj1GLmludGVyc2VjdGlvbih0LGUsbixpKX1jYXRjaChzKXtpZighKHMgaW5zdGFuY2VvZiB3KSl0aHJvdyBzO3I9YWUubmVhcmVzdEVuZHBvaW50KHQsZSxuLGkpfWZpbmFsbHl7fXJldHVybiByfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dGhpcy5pbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbih0LGUsbixpKTtyZXR1cm4gdGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhyKXx8KHI9bmV3IGcoYWUubmVhcmVzdEVuZHBvaW50KHQsZSxuLGkpKSksbnVsbCE9PXRoaXMucHJlY2lzaW9uTW9kZWwmJnRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2Uocikscn0sc21hbGxlc3RJbkFic1ZhbHVlOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQscz1NYXRoLmFicyhyKTtyZXR1cm4gTWF0aC5hYnMoZSk8cyYmKHI9ZSxzPU1hdGguYWJzKGUpKSxNYXRoLmFicyhuKTxzJiYocj1uLHM9TWF0aC5hYnMobikpLE1hdGguYWJzKGkpPHMmJihyPWkpLHJ9LGNoZWNrREQ6ZnVuY3Rpb24odCxlLG4saSxyKXt2YXIgcz1NLmludGVyc2VjdGlvbih0LGUsbixpKSxvPXRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMocyk7QS5vdXQucHJpbnRsbihcIkREIGluIGVudiA9IFwiK28rXCIgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcIitzKSxyLmRpc3RhbmNlKHMpPjFlLTQmJkEub3V0LnByaW50bG4oXCJEaXN0YW5jZSA9IFwiK3IuZGlzdGFuY2UocykpfSxpbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uZXcgZyh0KSxzPW5ldyBnKGUpLG89bmV3IGcobiksYT1uZXcgZyhpKSx1PW5ldyBnO3RoaXMubm9ybWFsaXplVG9FbnZDZW50cmUocixzLG8sYSx1KTt2YXIgbD10aGlzLnNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbihyLHMsbyxhKTtyZXR1cm4gbC54Kz11LngsbC55Kz11LnksbH0sY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1DLmludGVyc2VjdHModCxlLG4pLHM9Qy5pbnRlcnNlY3RzKHQsZSxpKSxvPUMuaW50ZXJzZWN0cyhuLGksdCksYT1DLmludGVyc2VjdHMobixpLGUpO3JldHVybiByJiZzPyh0aGlzLmludFB0WzBdPW4sdGhpcy5pbnRQdFsxXT1pLG9lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT04pOm8mJmE/KHRoaXMuaW50UHRbMF09dCx0aGlzLmludFB0WzFdPWUsb2UuQ09MTElORUFSX0lOVEVSU0VDVElPTik6ciYmbz8odGhpcy5pbnRQdFswXT1uLHRoaXMuaW50UHRbMV09dCwhbi5lcXVhbHModCl8fHN8fGE/b2UuQ09MTElORUFSX0lOVEVSU0VDVElPTjpvZS5QT0lOVF9JTlRFUlNFQ1RJT04pOnImJmE/KHRoaXMuaW50UHRbMF09bix0aGlzLmludFB0WzFdPWUsIW4uZXF1YWxzKGUpfHxzfHxvP29lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT046b2UuUE9JTlRfSU5URVJTRUNUSU9OKTpzJiZvPyh0aGlzLmludFB0WzBdPWksdGhpcy5pbnRQdFsxXT10LCFpLmVxdWFscyh0KXx8cnx8YT9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6cyYmYT8odGhpcy5pbnRQdFswXT1pLHRoaXMuaW50UHRbMV09ZSwhaS5lcXVhbHMoZSl8fHJ8fG8/b2UuQ09MTElORUFSX0lOVEVSU0VDVElPTjpvZS5QT0lOVF9JTlRFUlNFQ1RJT04pOm9lLk5PX0lOVEVSU0VDVElPTn0sbm9ybWFsaXplVG9FbnZDZW50cmU6ZnVuY3Rpb24odCxlLG4saSxyKXt2YXIgcz10Lng8ZS54P3QueDplLngsbz10Lnk8ZS55P3QueTplLnksYT10Lng+ZS54P3QueDplLngsdT10Lnk+ZS55P3QueTplLnksbD1uLng8aS54P24ueDppLngsaD1uLnk8aS55P24ueTppLnksYz1uLng+aS54P24ueDppLngsZj1uLnk+aS55P24ueTppLnksZz1zPmw/czpsLGQ9Yz5hP2E6YyxwPW8+aD9vOmgsdj1mPnU/dTpmLG09KGcrZCkvMix5PShwK3YpLzI7ci54PW0sci55PXksdC54LT1yLngsdC55LT1yLnksZS54LT1yLngsZS55LT1yLnksbi54LT1yLngsbi55LT1yLnksaS54LT1yLngsaS55LT1yLnl9LGNvbXB1dGVJbnRlcnNlY3Q6ZnVuY3Rpb24odCxlLG4saSl7aWYodGhpcy5faXNQcm9wZXI9ITEsIUMuaW50ZXJzZWN0cyh0LGUsbixpKSlyZXR1cm4gb2UuTk9fSU5URVJTRUNUSU9OO3ZhciByPWhlLm9yaWVudGF0aW9uSW5kZXgodCxlLG4pLHM9aGUub3JpZW50YXRpb25JbmRleCh0LGUsaSk7aWYocj4wJiZzPjB8fDA+ciYmMD5zKXJldHVybiBvZS5OT19JTlRFUlNFQ1RJT047dmFyIG89aGUub3JpZW50YXRpb25JbmRleChuLGksdCksYT1oZS5vcmllbnRhdGlvbkluZGV4KG4saSxlKTtpZihvPjAmJmE+MHx8MD5vJiYwPmEpcmV0dXJuIG9lLk5PX0lOVEVSU0VDVElPTjt2YXIgdT0wPT09ciYmMD09PXMmJjA9PT1vJiYwPT09YTtyZXR1cm4gdT90aGlzLmNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24odCxlLG4saSk6KDA9PT1yfHwwPT09c3x8MD09PW98fDA9PT1hPyh0aGlzLl9pc1Byb3Blcj0hMSx0LmVxdWFsczJEKG4pfHx0LmVxdWFsczJEKGkpP3RoaXMuaW50UHRbMF09dDplLmVxdWFsczJEKG4pfHxlLmVxdWFsczJEKGkpP3RoaXMuaW50UHRbMF09ZTowPT09cj90aGlzLmludFB0WzBdPW5ldyBnKG4pOjA9PT1zP3RoaXMuaW50UHRbMF09bmV3IGcoaSk6MD09PW8/dGhpcy5pbnRQdFswXT1uZXcgZyh0KTowPT09YSYmKHRoaXMuaW50UHRbMF09bmV3IGcoZSkpKToodGhpcy5faXNQcm9wZXI9ITAsdGhpcy5pbnRQdFswXT10aGlzLmludGVyc2VjdGlvbih0LGUsbixpKSksb2UuUE9JTlRfSU5URVJTRUNUSU9OKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYWV9fSksYWUubmVhcmVzdEVuZHBvaW50PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQscz1oZS5kaXN0YW5jZVBvaW50TGluZSh0LG4saSksbz1oZS5kaXN0YW5jZVBvaW50TGluZShlLG4saSk7cmV0dXJuIHM+byYmKHM9byxyPWUpLG89aGUuZGlzdGFuY2VQb2ludExpbmUobix0LGUpLHM+byYmKHM9byxyPW4pLG89aGUuZGlzdGFuY2VQb2ludExpbmUoaSx0LGUpLHM+byYmKHM9byxyPWkpLHJ9LGUodWUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB1ZX19KSx1ZS5vcmllbnRhdGlvbkluZGV4PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLngtdC54LHI9ZS55LXQueSxzPW4ueC1lLngsbz1uLnktZS55O3JldHVybiB1ZS5zaWduT2ZEZXQyeDIoaSxyLHMsbyl9LHVlLnNpZ25PZkRldDJ4Mj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1udWxsLHM9bnVsbCxvPW51bGwsYT0wO2lmKHI9MSwwPT09dHx8MD09PWkpcmV0dXJuIDA9PT1lfHwwPT09bj8wOmU+MD9uPjA/LXI6cjpuPjA/cjotcjtpZigwPT09ZXx8MD09PW4pcmV0dXJuIGk+MD90PjA/cjotcjp0PjA/LXI6cjtpZihlPjA/aT4wP2k+PWV8fChyPS1yLHM9dCx0PW4sbj1zLHM9ZSxlPWksaT1zKTotaT49ZT8ocj0tcixuPS1uLGk9LWkpOihzPXQsdD0tbixuPXMscz1lLGU9LWksaT1zKTppPjA/aT49LWU/KHI9LXIsdD0tdCxlPS1lKToocz0tdCx0PW4sbj1zLHM9LWUsZT1pLGk9cyk6ZT49aT8odD0tdCxlPS1lLG49LW4saT0taSk6KHI9LXIscz0tdCx0PS1uLG49cyxzPS1lLGU9LWksaT1zKSx0PjApe2lmKCEobj4wKSlyZXR1cm4gcjtpZighKG4+PXQpKXJldHVybiByfWVsc2V7aWYobj4wKXJldHVybi1yO2lmKCEodD49bikpcmV0dXJuLXI7cj0tcix0PS10LG49LW59Zm9yKDs7KXtpZihhKz0xLG89TWF0aC5mbG9vcihuL3QpLG4tPW8qdCxpLT1vKmUsMD5pKXJldHVybi1yO2lmKGk+ZSlyZXR1cm4gcjtpZih0Pm4rbil7aWYoaStpPmUpcmV0dXJuIHJ9ZWxzZXtpZihlPmkraSlyZXR1cm4tcjtuPXQtbixpPWUtaSxyPS1yfWlmKDA9PT1pKXJldHVybiAwPT09bj8wOi1yO2lmKDA9PT1uKXJldHVybiByO2lmKG89TWF0aC5mbG9vcih0L24pLHQtPW8qbixlLT1vKmksMD5lKXJldHVybiByO2lmKGU+aSlyZXR1cm4tcjtpZihuPnQrdCl7aWYoZStlPmkpcmV0dXJuLXJ9ZWxzZXtpZihpPmUrZSlyZXR1cm4gcjt0PW4tdCxlPWktZSxyPS1yfWlmKDA9PT1lKXJldHVybiAwPT09dD8wOnI7aWYoMD09PXQpcmV0dXJuLXJ9fSxlKGxlLnByb3RvdHlwZSx7Y291bnRTZWdtZW50OmZ1bmN0aW9uKHQsZSl7aWYodC54PHRoaXMucC54JiZlLng8dGhpcy5wLngpcmV0dXJuIG51bGw7aWYodGhpcy5wLng9PT1lLngmJnRoaXMucC55PT09ZS55KXJldHVybiB0aGlzLmlzUG9pbnRPblNlZ21lbnQ9ITAsbnVsbDtpZih0Lnk9PT10aGlzLnAueSYmZS55PT09dGhpcy5wLnkpe3ZhciBuPXQueCxpPWUueDtyZXR1cm4gbj5pJiYobj1lLngsaT10LngpLHRoaXMucC54Pj1uJiZ0aGlzLnAueDw9aSYmKHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCksbnVsbH1pZih0Lnk+dGhpcy5wLnkmJmUueTw9dGhpcy5wLnl8fGUueT50aGlzLnAueSYmdC55PD10aGlzLnAueSl7dmFyIHI9dC54LXRoaXMucC54LHM9dC55LXRoaXMucC55LG89ZS54LXRoaXMucC54LGE9ZS55LXRoaXMucC55LHU9dWUuc2lnbk9mRGV0MngyKHIscyxvLGEpO2lmKDA9PT11KXJldHVybiB0aGlzLmlzUG9pbnRPblNlZ21lbnQ9ITAsbnVsbDtzPmEmJih1PS11KSx1PjAmJnRoaXMuY3Jvc3NpbmdDb3VudCsrfX0saXNQb2ludEluUG9seWdvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldExvY2F0aW9uKCkhPT1MLkVYVEVSSU9SfSxnZXRMb2NhdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUG9pbnRPblNlZ21lbnQ/TC5CT1VOREFSWTp0aGlzLmNyb3NzaW5nQ291bnQlMj09PTE/TC5JTlRFUklPUjpMLkVYVEVSSU9SfSxpc09uU2VnbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUG9pbnRPblNlZ21lbnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGxlfX0pLGxlLmxvY2F0ZVBvaW50SW5SaW5nPWZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZSKGFyZ3VtZW50c1sxXSxEKSl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBsZSh0KSxpPW5ldyBnLHI9bmV3IGcscz0xO3M8ZS5zaXplKCk7cysrKWlmKGUuZ2V0Q29vcmRpbmF0ZShzLGkpLGUuZ2V0Q29vcmRpbmF0ZShzLTEsciksbi5jb3VudFNlZ21lbnQoaSxyKSxuLmlzT25TZWdtZW50KCkpcmV0dXJuIG4uZ2V0TG9jYXRpb24oKTtyZXR1cm4gbi5nZXRMb2NhdGlvbigpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSxuPW5ldyBsZShvKSxzPTE7czxhLmxlbmd0aDtzKyspe3ZhciBpPWFbc10scj1hW3MtMV07aWYobi5jb3VudFNlZ21lbnQoaSxyKSxuLmlzT25TZWdtZW50KCkpcmV0dXJuIG4uZ2V0TG9jYXRpb24oKX1yZXR1cm4gbi5nZXRMb2NhdGlvbigpfX0sZShoZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGhlfX0pLGhlLm9yaWVudGF0aW9uSW5kZXg9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBNLm9yaWVudGF0aW9uSW5kZXgodCxlLG4pfSxoZS5zaWduZWRBcmVhPWZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQubGVuZ3RoPDMpcmV0dXJuIDA7Zm9yKHZhciBlPTAsbj10WzBdLngsaT0xO2k8dC5sZW5ndGgtMTtpKyspe3ZhciByPXRbaV0ueC1uLHM9dFtpKzFdLnksbz10W2ktMV0ueTtlKz1yKihvLXMpfXJldHVybiBlLzJ9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWEuc2l6ZSgpO2lmKDM+dSlyZXR1cm4gMDt2YXIgbD1uZXcgZyxoPW5ldyBnLGM9bmV3IGc7YS5nZXRDb29yZGluYXRlKDAsaCksYS5nZXRDb29yZGluYXRlKDEsYyk7dmFyIG49aC54O2MueC09bjtmb3IodmFyIGU9MCxpPTE7dS0xPmk7aSsrKWwueT1oLnksaC54PWMueCxoLnk9Yy55LGEuZ2V0Q29vcmRpbmF0ZShpKzEsYyksYy54LT1uLGUrPWgueCoobC55LWMueSk7cmV0dXJuIGUvMn19LGhlLmRpc3RhbmNlTGluZUxpbmU9ZnVuY3Rpb24odCxlLG4saSl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIGhlLmRpc3RhbmNlUG9pbnRMaW5lKHQsbixpKTtpZihuLmVxdWFscyhpKSlyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUoaSx0LGUpO3ZhciByPSExO2lmKEMuaW50ZXJzZWN0cyh0LGUsbixpKSl7dmFyIHM9KGUueC10LngpKihpLnktbi55KS0oZS55LXQueSkqKGkueC1uLngpO2lmKDA9PT1zKXI9ITA7ZWxzZXt2YXIgbz0odC55LW4ueSkqKGkueC1uLngpLSh0Lngtbi54KSooaS55LW4ueSksYT0odC55LW4ueSkqKGUueC10LngpLSh0Lngtbi54KSooZS55LXQueSksdT1hL3MsbD1vL3M7KDA+bHx8bD4xfHwwPnV8fHU+MSkmJihyPSEwKX19ZWxzZSByPSEwO3JldHVybiByP1QubWluKGhlLmRpc3RhbmNlUG9pbnRMaW5lKHQsbixpKSxoZS5kaXN0YW5jZVBvaW50TGluZShlLG4saSksaGUuZGlzdGFuY2VQb2ludExpbmUobix0LGUpLGhlLmRpc3RhbmNlUG9pbnRMaW5lKGksdCxlKSk6MH0saGUuaXNQb2ludEluUmluZz1mdW5jdGlvbih0LGUpe3JldHVybiBoZS5sb2NhdGVQb2ludEluUmluZyh0LGUpIT09TC5FWFRFUklPUn0saGUuY29tcHV0ZUxlbmd0aD1mdW5jdGlvbih0KXt2YXIgZT10LnNpemUoKTtpZigxPj1lKXJldHVybiAwO3ZhciBuPTAsaT1uZXcgZzt0LmdldENvb3JkaW5hdGUoMCxpKTtmb3IodmFyIHI9aS54LHM9aS55LG89MTtlPm87bysrKXt0LmdldENvb3JkaW5hdGUobyxpKTt2YXIgYT1pLngsdT1pLnksbD1hLXIsaD11LXM7bis9TWF0aC5zcXJ0KGwqbCtoKmgpLHI9YSxzPXV9cmV0dXJuIG59LGhlLmlzQ0NXPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoLTE7aWYoMz5lKXRocm93IG5ldyBpKFwiUmluZyBoYXMgZmV3ZXIgdGhhbiA0IHBvaW50cywgc28gb3JpZW50YXRpb24gY2Fubm90IGJlIGRldGVybWluZWRcIik7Zm9yKHZhciBuPXRbMF0scj0wLHM9MTtlPj1zO3MrKyl7dmFyIG89dFtzXTtvLnk+bi55JiYobj1vLHI9cyl9dmFyIGE9cjtkbyBhLT0xLDA+YSYmKGE9ZSk7d2hpbGUodFthXS5lcXVhbHMyRChuKSYmYSE9PXIpO3ZhciB1PXI7ZG8gdT0odSsxKSVlO3doaWxlKHRbdV0uZXF1YWxzMkQobikmJnUhPT1yKTt2YXIgbD10W2FdLGg9dFt1XTtpZihsLmVxdWFsczJEKG4pfHxoLmVxdWFsczJEKG4pfHxsLmVxdWFsczJEKGgpKXJldHVybiExO3ZhciBjPWhlLmNvbXB1dGVPcmllbnRhdGlvbihsLG4saCksZj0hMTtyZXR1cm4gZj0wPT09Yz9sLng+aC54OmM+MH0saGUubG9jYXRlUG9pbnRJblJpbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbGUubG9jYXRlUG9pbnRJblJpbmcodCxlKX0saGUuZGlzdGFuY2VQb2ludExpbmVQZXJwZW5kaWN1bGFyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT0obi54LWUueCkqKG4ueC1lLngpKyhuLnktZS55KSoobi55LWUueSkscj0oKGUueS10LnkpKihuLngtZS54KS0oZS54LXQueCkqKG4ueS1lLnkpKS9pO3JldHVybiBNYXRoLmFicyhyKSpNYXRoLnNxcnQoaSl9LGhlLmNvbXB1dGVPcmllbnRhdGlvbj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhlLm9yaWVudGF0aW9uSW5kZXgodCxlLG4pfSxoZS5kaXN0YW5jZVBvaW50TGluZT1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PWUubGVuZ3RoKXRocm93IG5ldyBpKFwiTGluZSBhcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHZlcnRleFwiKTtmb3IodmFyIG49dC5kaXN0YW5jZShlWzBdKSxyPTA7cjxlLmxlbmd0aC0xO3IrKyl7dmFyIHM9aGUuZGlzdGFuY2VQb2ludExpbmUodCxlW3JdLGVbcisxXSk7bj5zJiYobj1zKX1yZXR1cm4gbn1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YXJndW1lbnRzWzJdO2lmKGEueD09PXUueCYmYS55PT09dS55KXJldHVybiBvLmRpc3RhbmNlKGEpO3ZhciBsPSh1LngtYS54KSoodS54LWEueCkrKHUueS1hLnkpKih1LnktYS55KSxoPSgoby54LWEueCkqKHUueC1hLngpKyhvLnktYS55KSoodS55LWEueSkpL2w7aWYoMD49aClyZXR1cm4gby5kaXN0YW5jZShhKTtpZihoPj0xKXJldHVybiBvLmRpc3RhbmNlKHUpO3ZhciBjPSgoYS55LW8ueSkqKHUueC1hLngpLShhLngtby54KSoodS55LWEueSkpL2w7cmV0dXJuIE1hdGguYWJzKGMpKk1hdGguc3FydChsKX19LGhlLmlzT25MaW5lPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBhZSxpPTE7aTxlLmxlbmd0aDtpKyspe3ZhciByPWVbaS0xXSxzPWVbaV07aWYobi5jb21wdXRlSW50ZXJzZWN0aW9uKHQscixzKSxuLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiEwfXJldHVybiExfSxoZS5DTE9DS1dJU0U9LTEsaGUuUklHSFQ9aGUuQ0xPQ0tXSVNFLGhlLkNPVU5URVJDTE9DS1dJU0U9MSxoZS5MRUZUPWhlLkNPVU5URVJDTE9DS1dJU0UsaGUuQ09MTElORUFSPTAsaGUuU1RSQUlHSFQ9aGUuQ09MTElORUFSLGUoY2UucHJvdG90eXBlLHttaW5YOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueCx0aGlzLnAxLngpfSxvcmllbnRhdGlvbkluZGV4OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9aGUub3JpZW50YXRpb25JbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMCksbj1oZS5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAxKTtyZXR1cm4gZT49MCYmbj49MD9NYXRoLm1heChlLG4pOjA+PWUmJjA+PW4/TWF0aC5tYXgoZSxuKTowfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGk9YXJndW1lbnRzWzBdO3JldHVybiBoZS5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsdGhpcy5wMSxpKX19LHRvR2VvbWV0cnk6ZnVuY3Rpb24odCl7cmV0dXJuIHQuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5wMCx0aGlzLnAxXSl9LGlzVmVydGljYWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMC54PT09dGhpcy5wMS54fSxlcXVhbHM6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgY2UpKXJldHVybiExO3ZhciBlPXQ7cmV0dXJuIHRoaXMucDAuZXF1YWxzKGUucDApJiZ0aGlzLnAxLmVxdWFscyhlLnAxKX0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBhZTtyZXR1cm4gZS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpLGUuaGFzSW50ZXJzZWN0aW9uKCk/ZS5nZXRJbnRlcnNlY3Rpb24oMCk6bnVsbH0scHJvamVjdDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQuZXF1YWxzKHRoaXMucDApfHx0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gbmV3IGcodCk7dmFyIGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpLG49bmV3IGc7cmV0dXJuIG4ueD10aGlzLnAwLngrZSoodGhpcy5wMS54LXRoaXMucDAueCksbi55PXRoaXMucDAueStlKih0aGlzLnAxLnktdGhpcy5wMC55KSxufWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciBpPWFyZ3VtZW50c1swXSxyPXRoaXMucHJvamVjdGlvbkZhY3RvcihpLnAwKSxzPXRoaXMucHJvamVjdGlvbkZhY3RvcihpLnAxKTtpZihyPj0xJiZzPj0xKXJldHVybiBudWxsO2lmKDA+PXImJjA+PXMpcmV0dXJuIG51bGw7dmFyIG89dGhpcy5wcm9qZWN0KGkucDApOzA+ciYmKG89dGhpcy5wMCkscj4xJiYobz10aGlzLnAxKTt2YXIgYT10aGlzLnByb2plY3QoaS5wMSk7cmV0dXJuIDA+cyYmKGE9dGhpcy5wMCkscz4xJiYoYT10aGlzLnAxKSxuZXcgY2UobyxhKX19LG5vcm1hbGl6ZTpmdW5jdGlvbigpe3RoaXMucDEuY29tcGFyZVRvKHRoaXMucDApPDAmJnRoaXMucmV2ZXJzZSgpfSxhbmdsZTpmdW5jdGlvbigpe3JldHVybiBNYXRoLmF0YW4yKHRoaXMucDEueS10aGlzLnAwLnksdGhpcy5wMS54LXRoaXMucDAueCl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10P3RoaXMucDA6dGhpcy5wMX0sZGlzdGFuY2VQZXJwZW5kaWN1bGFyOmZ1bmN0aW9uKHQpe3JldHVybiBoZS5kaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXIodCx0aGlzLnAwLHRoaXMucDEpfSxtaW5ZOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueSx0aGlzLnAxLnkpfSxtaWRQb2ludDpmdW5jdGlvbigpe3JldHVybiBjZS5taWRQb2ludCh0aGlzLnAwLHRoaXMucDEpfSxwcm9qZWN0aW9uRmFjdG9yOmZ1bmN0aW9uKHQpe2lmKHQuZXF1YWxzKHRoaXMucDApKXJldHVybiAwO2lmKHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiAxO3ZhciBlPXRoaXMucDEueC10aGlzLnAwLngsbj10aGlzLnAxLnktdGhpcy5wMC55LGk9ZSplK24qbjtpZigwPj1pKXJldHVybiByLk5hTjt2YXIgcz0oKHQueC10aGlzLnAwLngpKmUrKHQueS10aGlzLnAwLnkpKm4pL2k7cmV0dXJuIHN9LGNsb3Nlc3RQb2ludHM6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pbnRlcnNlY3Rpb24odCk7aWYobnVsbCE9PWUpcmV0dXJuW2UsZV07dmFyIG49bmV3IEFycmF5KDIpLmZpbGwobnVsbCksaT1yLk1BWF9WQUxVRSxzPW51bGwsbz10aGlzLmNsb3Nlc3RQb2ludCh0LnAwKTtpPW8uZGlzdGFuY2UodC5wMCksblswXT1vLG5bMV09dC5wMDt2YXIgYT10aGlzLmNsb3Nlc3RQb2ludCh0LnAxKTtzPWEuZGlzdGFuY2UodC5wMSksaT5zJiYoaT1zLG5bMF09YSxuWzFdPXQucDEpO3ZhciB1PXQuY2xvc2VzdFBvaW50KHRoaXMucDApO3M9dS5kaXN0YW5jZSh0aGlzLnAwKSxpPnMmJihpPXMsblswXT10aGlzLnAwLG5bMV09dSk7dmFyIGw9dC5jbG9zZXN0UG9pbnQodGhpcy5wMSk7cmV0dXJuIHM9bC5kaXN0YW5jZSh0aGlzLnAxKSxpPnMmJihpPXMsblswXT10aGlzLnAxLG5bMV09bCksbn0sY2xvc2VzdFBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtpZihlPjAmJjE+ZSlyZXR1cm4gdGhpcy5wcm9qZWN0KHQpO3ZhciBuPXRoaXMucDAuZGlzdGFuY2UodCksaT10aGlzLnAxLmRpc3RhbmNlKHQpO3JldHVybiBpPm4/dGhpcy5wMDp0aGlzLnAxfSxtYXhYOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMucDAueCx0aGlzLnAxLngpfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMC5kaXN0YW5jZSh0aGlzLnAxKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10aGlzLnAwLmNvbXBhcmVUbyhlLnAwKTtyZXR1cm4gMCE9PW4/bjp0aGlzLnAxLmNvbXBhcmVUbyhlLnAxKX0scmV2ZXJzZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucDA7dGhpcy5wMD10aGlzLnAxLHRoaXMucDE9dH0sZXF1YWxzVG9wbzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wMC5lcXVhbHModC5wMCkmJnRoaXMucDEuZXF1YWxzKHQucDEpfHx0aGlzLnAwLmVxdWFscyh0LnAxKSYmdGhpcy5wMS5lcXVhbHModC5wMCl9LGxpbmVJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7dHJ5e3ZhciBlPUYuaW50ZXJzZWN0aW9uKHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpO3JldHVybiBlfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIHcpKXRocm93IHR9ZmluYWxseXt9cmV0dXJuIG51bGx9LG1heFk6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC55LHRoaXMucDEueSl9LHBvaW50QWxvbmdPZmZzZXQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnAwLngrdCoodGhpcy5wMS54LXRoaXMucDAueCksaT10aGlzLnAwLnkrdCoodGhpcy5wMS55LXRoaXMucDAueSkscj10aGlzLnAxLngtdGhpcy5wMC54LHM9dGhpcy5wMS55LXRoaXMucDAueSxvPU1hdGguc3FydChyKnIrcypzKSxhPTAsdT0wO2lmKDAhPT1lKXtpZigwPj1vKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJDYW5ub3QgY29tcHV0ZSBvZmZzZXQgZnJvbSB6ZXJvLWxlbmd0aCBsaW5lIHNlZ21lbnRcIik7YT1lKnIvbyx1PWUqcy9vfXZhciBsPW4tdSxoPWkrYSxjPW5ldyBnKGwsaCk7cmV0dXJuIGN9LHNldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldENvb3JkaW5hdGVzKHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucDAueD1lLngsdGhpcy5wMC55PWUueSx0aGlzLnAxLng9bi54LHRoaXMucDEueT1uLnl9fSxzZWdtZW50RnJhY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO3JldHVybiAwPmU/ZT0wOihlPjF8fHIuaXNOYU4oZSkpJiYoZT0xKSxlfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiTElORVNUUklORyggXCIrdGhpcy5wMC54K1wiIFwiK3RoaXMucDAueStcIiwgXCIrdGhpcy5wMS54K1wiIFwiK3RoaXMucDEueStcIilcIn0saXNIb3Jpem9udGFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDAueT09PXRoaXMucDEueX0sZGlzdGFuY2U6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIGhlLmRpc3RhbmNlTGluZUxpbmUodGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIGhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsdGhpcy5wMCx0aGlzLnAxKX19LHBvaW50QWxvbmc6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGc7cmV0dXJuIGUueD10aGlzLnAwLngrdCoodGhpcy5wMS54LXRoaXMucDAueCksZS55PXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxlfSxoYXNoQ29kZTpmdW5jdGlvbigpe3ZhciB0PWphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAwLngpO3RePTMxKmphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAwLnkpO3ZhciBlPU1hdGgudHJ1bmModCleTWF0aC50cnVuYyh0Pj4zMiksbj1qYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS54KTtuXj0zMSpqYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS55KTt2YXIgaT1NYXRoLnRydW5jKG4pXk1hdGgudHJ1bmMobj4+MzIpO3JldHVybiBlXml9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3MsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNlfX0pLGNlLm1pZFBvaW50PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBnKCh0LngrZS54KS8yLCh0LnkrZS55KS8yKX0sY2Uuc2VyaWFsVmVyc2lvblVJRD0weDJkMjE3MjEzNWY0MTFjMDAsZShmZS5wcm90b3R5cGUse2lzSW50ZXJzZWN0czpmdW5jdGlvbigpe3JldHVybiF0aGlzLmlzRGlzam9pbnQoKX0saXNDb3ZlcnM6ZnVuY3Rpb24oKXt2YXIgdD1mZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV0pO3JldHVybiB0JiZ0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkJPVU5EQVJZXT09PWx0LkZBTFNFfSxpc0NvdmVyZWRCeTpmdW5jdGlvbigpe3ZhciB0PWZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSk7cmV0dXJuIHQmJnRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuRVhURVJJT1JdPT09bHQuRkFMU0V9LHNldDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj1NYXRoLnRydW5jKGUvMyksaT1lJTM7dGhpcy5tYXRyaXhbbl1baV09bHQudG9EaW1lbnNpb25WYWx1ZSh0LmNoYXJBdChlKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMubWF0cml4W3JdW3NdPW99fSxpc0NvbnRhaW5zOmZ1bmN0aW9uKCl7cmV0dXJuIGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LHNldEF0TGVhc3Q6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIG49TWF0aC50cnVuYyhlLzMpLGk9ZSUzO3RoaXMuc2V0QXRMZWFzdChuLGksbHQudG9EaW1lbnNpb25WYWx1ZSh0LmNoYXJBdChlKSkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTt0aGlzLm1hdHJpeFtyXVtzXTxvJiYodGhpcy5tYXRyaXhbcl1bc109byl9fSxzZXRBdExlYXN0SWZWYWxpZDpmdW5jdGlvbih0LGUsbil7dD49MCYmZT49MCYmdGhpcy5zZXRBdExlYXN0KHQsZSxuKX0saXNXaXRoaW46ZnVuY3Rpb24oKXtyZXR1cm4gZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09PT1sdC5GQUxTRX0saXNUb3VjaGVzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+ZT90aGlzLmlzVG91Y2hlcyhlLHQpOnQ9PT1sdC5BJiZlPT09bHQuQXx8dD09PWx0LkwmJmU9PT1sdC5MfHx0PT09bHQuTCYmZT09PWx0LkF8fHQ9PT1sdC5QJiZlPT09bHQuQXx8dD09PWx0LlAmJmU9PT1sdC5MP3RoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJihmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV0pKTohMX0saXNPdmVybGFwczpmdW5jdGlvbih0LGUpe3JldHVybiB0PT09bHQuUCYmZT09PWx0LlB8fHQ9PT1sdC5BJiZlPT09bHQuQT9mZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl0pJiZmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl0pOnQ9PT1sdC5MJiZlPT09bHQuTD8xPT09dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0mJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSk6ITF9LGlzRXF1YWxzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQhPT1lPyExOmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJnRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuRVhURVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBQKFwiMTIzNDU2Nzg5XCIpLGU9MDszPmU7ZSsrKWZvcih2YXIgbj0wOzM+bjtuKyspdC5zZXRDaGFyQXQoMyplK24sbHQudG9EaW1lbnNpb25TeW1ib2wodGhpcy5tYXRyaXhbZV1bbl0pKTtyZXR1cm4gdC50b1N0cmluZygpfSxzZXRBbGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7Mz5lO2UrKylmb3IodmFyIG49MDszPm47bisrKXRoaXMubWF0cml4W2VdW25dPXR9LGdldDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLm1hdHJpeFt0XVtlXX0sdHJhbnNwb3NlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tYXRyaXhbMV1bMF07cmV0dXJuIHRoaXMubWF0cml4WzFdWzBdPXRoaXMubWF0cml4WzBdWzFdLHRoaXMubWF0cml4WzBdWzFdPXQsdD10aGlzLm1hdHJpeFsyXVswXSx0aGlzLm1hdHJpeFsyXVswXT10aGlzLm1hdHJpeFswXVsyXSx0aGlzLm1hdHJpeFswXVsyXT10LHQ9dGhpcy5tYXRyaXhbMl1bMV0sdGhpcy5tYXRyaXhbMl1bMV09dGhpcy5tYXRyaXhbMV1bMl0sdGhpcy5tYXRyaXhbMV1bMl09dCx0aGlzfSxtYXRjaGVzOmZ1bmN0aW9uKHQpe2lmKDkhPT10Lmxlbmd0aCl0aHJvdyBuZXcgaShcIlNob3VsZCBiZSBsZW5ndGggOTogXCIrdCk7Zm9yKHZhciBlPTA7Mz5lO2UrKylmb3IodmFyIG49MDszPm47bisrKWlmKCFmZS5tYXRjaGVzKHRoaXMubWF0cml4W2VdW25dLHQuY2hhckF0KDMqZStuKSkpcmV0dXJuITE7cmV0dXJuITB9LGFkZDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDszPmU7ZSsrKWZvcih2YXIgbj0wOzM+bjtuKyspdGhpcy5zZXRBdExlYXN0KGUsbix0LmdldChlLG4pKX0saXNEaXNqb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXT09PWx0LkZBTFNFfSxpc0Nyb3NzZXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWx0LlAmJmU9PT1sdC5MfHx0PT09bHQuUCYmZT09PWx0LkF8fHQ9PT1sdC5MJiZlPT09bHQuQT9mZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl0pOnQ9PT1sdC5MJiZlPT09bHQuUHx8dD09PWx0LkEmJmU9PT1sdC5QfHx0PT09bHQuQSYmZT09PWx0Lkw/ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdKTp0PT09bHQuTCYmZT09PWx0Lkw/MD09PXRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdOiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZmV9fSksZmUubWF0Y2hlcz1mdW5jdGlvbigpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBlPT09bHQuU1lNX0RPTlRDQVJFPyEwOmU9PT1sdC5TWU1fVFJVRSYmKHQ+PTB8fHQ9PT1sdC5UUlVFKT8hMDplPT09bHQuU1lNX0ZBTFNFJiZ0PT09bHQuRkFMU0U/ITA6ZT09PWx0LlNZTV9QJiZ0PT09bHQuUD8hMDplPT09bHQuU1lNX0wmJnQ9PT1sdC5MPyEwOmU9PT1sdC5TWU1fQSYmdD09PWx0LkF9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9bmV3IGZlKG4pO3JldHVybiByLm1hdGNoZXMoaSl9fSxmZS5pc1RydWU9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+PTB8fHQ9PT1sdC5UUlVFfTt2YXIgbG89T2JqZWN0LmZyZWV6ZSh7Q29vcmRpbmF0ZTpnLENvb3JkaW5hdGVMaXN0Ok4sRW52ZWxvcGU6QyxMaW5lU2VnbWVudDpjZSxHZW9tZXRyeUZhY3Rvcnk6aWUsR2VvbWV0cnk6QixQb2ludDpMdCxMaW5lU3RyaW5nOlN0LExpbmVhclJpbmc6YnQsUG9seWdvbjpUdCxHZW9tZXRyeUNvbGxlY3Rpb246ZnQsTXVsdGlQb2ludDpQdCxNdWx0aUxpbmVTdHJpbmc6Z3QsTXVsdGlQb2x5Z29uOk90LERpbWVuc2lvbjpsdCxJbnRlcnNlY3Rpb25NYXRyaXg6ZmV9KTtlKGdlLnByb3RvdHlwZSx7YWRkUG9pbnQ6ZnVuY3Rpb24odCl7dGhpcy5wdENvdW50Kz0xLHRoaXMucHRDZW50U3VtLngrPXQueCx0aGlzLnB0Q2VudFN1bS55Kz10Lnl9LHNldEJhc2VQb2ludDpmdW5jdGlvbih0KXtudWxsPT09dGhpcy5hcmVhQmFzZVB0JiYodGhpcy5hcmVhQmFzZVB0PXQpfSxhZGRMaW5lU2VnbWVudHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGgtMTtuKyspe3ZhciBpPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtpZigwIT09aSl7ZSs9aTt2YXIgcj0odFtuXS54K3RbbisxXS54KS8yO3RoaXMubGluZUNlbnRTdW0ueCs9aSpyO3ZhciBzPSh0W25dLnkrdFtuKzFdLnkpLzI7dGhpcy5saW5lQ2VudFN1bS55Kz1pKnN9fXRoaXMudG90YWxMZW5ndGgrPWUsMD09PWUmJnQubGVuZ3RoPjAmJnRoaXMuYWRkUG9pbnQodFswXSl9LGFkZEhvbGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWhlLmlzQ0NXKHQpLG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfSxnZXRDZW50cm9pZDpmdW5jdGlvbigpe3ZhciB0PW5ldyBnO2lmKE1hdGguYWJzKHRoaXMuYXJlYXN1bTIpPjApdC54PXRoaXMuY2czLngvMy90aGlzLmFyZWFzdW0yLHQueT10aGlzLmNnMy55LzMvdGhpcy5hcmVhc3VtMjtlbHNlIGlmKHRoaXMudG90YWxMZW5ndGg+MCl0Lng9dGhpcy5saW5lQ2VudFN1bS54L3RoaXMudG90YWxMZW5ndGgsdC55PXRoaXMubGluZUNlbnRTdW0ueS90aGlzLnRvdGFsTGVuZ3RoO2Vsc2V7aWYoISh0aGlzLnB0Q291bnQ+MCkpcmV0dXJuIG51bGw7dC54PXRoaXMucHRDZW50U3VtLngvdGhpcy5wdENvdW50LHQueT10aGlzLnB0Q2VudFN1bS55L3RoaXMucHRDb3VudH1yZXR1cm4gdH0sYWRkU2hlbGw6ZnVuY3Rpb24odCl7dC5sZW5ndGg+MCYmdGhpcy5zZXRCYXNlUG9pbnQodFswXSk7Zm9yKHZhciBlPSFoZS5pc0NDVyh0KSxuPTA7bjx0Lmxlbmd0aC0xO24rKyl0aGlzLmFkZFRyaWFuZ2xlKHRoaXMuYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX0sYWRkVHJpYW5nbGU6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9aT8xOi0xO2dlLmNlbnRyb2lkMyh0LGUsbix0aGlzLnRyaWFuZ2xlQ2VudDMpO3ZhciBzPWdlLmFyZWEyKHQsZSxuKTt0aGlzLmNnMy54Kz1yKnMqdGhpcy50cmlhbmdsZUNlbnQzLngsdGhpcy5jZzMueSs9cipzKnRoaXMudHJpYW5nbGVDZW50My55LHRoaXMuYXJlYXN1bTIrPXIqc30sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkU2hlbGwodC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKTtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXRoaXMuYWRkSG9sZSh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBuPWFyZ3VtZW50c1swXTtpZihuLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZihuIGluc3RhbmNlb2YgTHQpdGhpcy5hZGRQb2ludChuLmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZihuIGluc3RhbmNlb2YgU3QpdGhpcy5hZGRMaW5lU2VnbWVudHMobi5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiBUdCl7dmFyIGk9bjt0aGlzLmFkZChpKX1lbHNlIGlmKG4gaW5zdGFuY2VvZiBmdClmb3IodmFyIHI9bixlPTA7ZTxyLmdldE51bUdlb21ldHJpZXMoKTtlKyspdGhpcy5hZGQoci5nZXRHZW9tZXRyeU4oZSkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ2V9fSksZ2UuYXJlYTI9ZnVuY3Rpb24odCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKG4ueC10LngpKihlLnktdC55KX0sZ2UuY2VudHJvaWQzPWZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiBpLng9dC54K2UueCtuLngsaS55PXQueStlLnkrbi55LG51bGx9LGdlLmdldENlbnRyb2lkPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBnZSh0KTtyZXR1cm4gZS5nZXRDZW50cm9pZCgpfSxkZS5wcm90b3R5cGU9bmV3IEVycm9yLGRlLnByb3RvdHlwZS5uYW1lPVwiRW1wdHlTdGFja0V4Y2VwdGlvblwiLHBlLnByb3RvdHlwZT1uZXcgeSxwZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxwZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKDA+dHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb247cmV0dXJuIHRoaXMuYXJyYXlfW3RdfSxwZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSx0fSxwZS5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLmFycmF5Xy5sZW5ndGgpdGhyb3cgbmV3IGRlO3JldHVybiB0aGlzLmFycmF5Xy5wb3AoKX0scGUucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5hcnJheV8ubGVuZ3RoKXRocm93IG5ldyBkZTtyZXR1cm4gdGhpcy5hcnJheV9bdGhpcy5hcnJheV8ubGVuZ3RoLTFdfSxwZS5wcm90b3R5cGUuZW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0scGUucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbXB0eSgpfSxwZS5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5pbmRleE9mKHQpfSxwZS5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LHBlLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LGUodmUucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dGhpcy50cmVlU2V0LmNvbnRhaW5zKHQpfHwodGhpcy5saXN0LmFkZCh0KSx0aGlzLnRyZWVTZXQuYWRkKHQpKX0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXJyYXkodGhpcy5saXN0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5saXN0LnRvQXJyYXkodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3pdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2ZX19KSx2ZS5maWx0ZXJDb29yZGluYXRlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IHZlLG49MDtuPHQubGVuZ3RoO24rKyllLmZpbHRlcih0W25dKTtyZXR1cm4gZS5nZXRDb29yZGluYXRlcygpfSxlKG1lLnByb3RvdHlwZSx7cHJlU29ydDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPTE7bjx0Lmxlbmd0aDtuKyspKHRbbl0ueTx0WzBdLnl8fHRbbl0ueT09PXRbMF0ueSYmdFtuXS54PHRbMF0ueCkmJihlPXRbMF0sdFswXT10W25dLHRbbl09ZSk7cmV0dXJuIHV0LnNvcnQodCwxLHQubGVuZ3RoLG5ldyB5ZSh0WzBdKSksdH0sY29tcHV0ZU9jdFJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jb21wdXRlT2N0UHRzKHQpLG49bmV3IE47cmV0dXJuIG4uYWRkKGUsITEpLG4uc2l6ZSgpPDM/bnVsbDoobi5jbG9zZVJpbmcoKSxuLnRvQ29vcmRpbmF0ZUFycmF5KCkpfSxsaW5lT3JQb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHQ9dGhpcy5jbGVhblJpbmcodCksMz09PXQubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW3RbMF0sdFsxXV0pO3ZhciBlPXRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KTtyZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVQb2x5Z29uKGUsbnVsbCl9LGNsZWFuUmluZzpmdW5jdGlvbih0KXtmLmVxdWFscyh0WzBdLHRbdC5sZW5ndGgtMV0pO2Zvcih2YXIgZT1uZXcgSSxuPW51bGwsaT0wO2k8PXQubGVuZ3RoLTI7aSsrKXt2YXIgcj10W2ldLHM9dFtpKzFdO3IuZXF1YWxzKHMpfHxudWxsIT09biYmdGhpcy5pc0JldHdlZW4obixyLHMpfHwoZS5hZGQociksbj1yKX1lLmFkZCh0W3QubGVuZ3RoLTFdKTt2YXIgbz1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIGUudG9BcnJheShvKX0saXNCZXR3ZWVuOmZ1bmN0aW9uKHQsZSxuKXtpZigwIT09aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQsZSxuKSlyZXR1cm4hMTtpZih0LnghPT1uLngpe2lmKHQueDw9ZS54JiZlLng8PW4ueClyZXR1cm4hMDtpZihuLng8PWUueCYmZS54PD10LngpcmV0dXJuITB9aWYodC55IT09bi55KXtpZih0Lnk8PWUueSYmZS55PD1uLnkpcmV0dXJuITA7aWYobi55PD1lLnkmJmUueTw9dC55KXJldHVybiEwfXJldHVybiExfSxyZWR1Y2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jb21wdXRlT2N0UmluZyh0KTtpZihudWxsPT09ZSlyZXR1cm4gdDtmb3IodmFyIG49bmV3IGF0LGk9MDtpPGUubGVuZ3RoO2krKyluLmFkZChlW2ldKTtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyloZS5pc1BvaW50SW5SaW5nKHRbaV0sZSl8fG4uYWRkKHRbaV0pO3ZhciByPUgudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHIubGVuZ3RoPDM/dGhpcy5wYWRBcnJheTMocik6cn0sZ2V0Q29udmV4SHVsbDpmdW5jdGlvbigpe2lmKDA9PT10aGlzLmlucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCk7aWYoMT09PXRoaXMuaW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMuaW5wdXRQdHNbMF0pO2lmKDI9PT10aGlzLmlucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuaW5wdXRQdHMpO3ZhciB0PXRoaXMuaW5wdXRQdHM7dGhpcy5pbnB1dFB0cy5sZW5ndGg+NTAmJih0PXRoaXMucmVkdWNlKHRoaXMuaW5wdXRQdHMpKTt2YXIgZT10aGlzLnByZVNvcnQodCksbj10aGlzLmdyYWhhbVNjYW4oZSksaT10aGlzLnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiB0aGlzLmxpbmVPclBvbHlnb24oaSl9LHBhZEFycmF5MzpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKW48dC5sZW5ndGg/ZVtuXT10W25dOmVbbl09dFswXTtyZXR1cm4gZX0sY29tcHV0ZU9jdFB0czpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KDgpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dFswXTtmb3IodmFyIGk9MTtpPHQubGVuZ3RoO2krKyl0W2ldLng8ZVswXS54JiYoZVswXT10W2ldKSx0W2ldLngtdFtpXS55PGVbMV0ueC1lWzFdLnkmJihlWzFdPXRbaV0pLHRbaV0ueT5lWzJdLnkmJihlWzJdPXRbaV0pLHRbaV0ueCt0W2ldLnk+ZVszXS54K2VbM10ueSYmKGVbM109dFtpXSksdFtpXS54PmVbNF0ueCYmKGVbNF09dFtpXSksdFtpXS54LXRbaV0ueT5lWzVdLngtZVs1XS55JiYoZVs1XT10W2ldKSx0W2ldLnk8ZVs2XS55JiYoZVs2XT10W2ldKSx0W2ldLngrdFtpXS55PGVbN10ueCtlWzddLnkmJihlWzddPXRbaV0pO3JldHVybiBlfSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpLG49MDtuPHQuc2l6ZSgpO24rKyl7dmFyIGk9dC5nZXQobik7ZVtuXT1pfXJldHVybiBlfSxncmFoYW1TY2FuOmZ1bmN0aW9uKHQpe3ZhciBlPW51bGwsbj1uZXcgcGU7ZT1uLnB1c2godFswXSksZT1uLnB1c2godFsxXSksZT1uLnB1c2godFsyXSk7Zm9yKHZhciBpPTM7aTx0Lmxlbmd0aDtpKyspe2ZvcihlPW4ucG9wKCk7IW4uZW1wdHkoKSYmaGUuY29tcHV0ZU9yaWVudGF0aW9uKG4ucGVlaygpLGUsdFtpXSk+MDspZT1uLnBvcCgpO2U9bi5wdXNoKGUpLGU9bi5wdXNoKHRbaV0pfXJldHVybiBlPW4ucHVzaCh0WzBdKSxufSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtZX19KSxtZS5leHRyYWN0Q29vcmRpbmF0ZXM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHZlO3JldHVybiB0LmFwcGx5KGUpLGUuZ2V0Q29vcmRpbmF0ZXMoKX0sZSh5ZS5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtyZXR1cm4geWUucG9sYXJDb21wYXJlKHRoaXMub3JpZ2luLG4saSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5ZX19KSx5ZS5wb2xhckNvbXBhcmU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9bi54LXQueCxvPW4ueS10LnksYT1oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLG4pO1xuaWYoYT09PWhlLkNPVU5URVJDTE9DS1dJU0UpcmV0dXJuIDE7aWYoYT09PWhlLkNMT0NLV0lTRSlyZXR1cm4tMTt2YXIgdT1pKmkrcipyLGw9cypzK28qbztyZXR1cm4gbD51Py0xOnU+bD8xOjB9LG1lLlJhZGlhbENvbXBhcmF0b3I9eWUsZSh4ZS5wcm90b3R5cGUse3RyYW5zZm9ybVBvaW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfSx0cmFuc2Zvcm1Qb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49ITAsaT10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSx0KTtudWxsIT09aSYmaSBpbnN0YW5jZW9mIGJ0JiYhaS5pc0VtcHR5KCl8fChuPSExKTtmb3IodmFyIHI9bmV3IEkscz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe3ZhciBvPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEludGVyaW9yUmluZ04ocyksdCk7bnVsbD09PW98fG8uaXNFbXB0eSgpfHwobyBpbnN0YW5jZW9mIGJ0fHwobj0hMSksci5hZGQobykpfWlmKG4pcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKGksci50b0FycmF5KFtdKSk7dmFyIGE9bmV3IEk7cmV0dXJuIG51bGwhPT1pJiZhLmFkZChpKSxhLmFkZEFsbChyKSx0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShhKX0sY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KX0sZ2V0SW5wdXRHZW9tZXRyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlucHV0R2VvbX0sdHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9dGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQuZ2V0R2VvbWV0cnlOKGkpLHQpO251bGwhPT1yJiYoci5pc0VtcHR5KCl8fG4uYWRkKHIpKX1yZXR1cm4gdGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9LHRyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29weSh0KX0sdHJhbnNmb3JtTGluZVN0cmluZzpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfSx0cmFuc2Zvcm1NdWx0aVBvaW50OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9dGhpcy50cmFuc2Zvcm1Qb2ludCh0LmdldEdlb21ldHJ5TihpKSx0KTtudWxsIT09ciYmKHIuaXNFbXB0eSgpfHxuLmFkZChyKSl9cmV0dXJuIHRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfSx0cmFuc2Zvcm1NdWx0aVBvbHlnb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj10aGlzLnRyYW5zZm9ybVBvbHlnb24odC5nZXRHZW9tZXRyeU4oaSksdCk7bnVsbCE9PXImJihyLmlzRW1wdHkoKXx8bi5hZGQocikpfXJldHVybiB0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX0sY29weTpmdW5jdGlvbih0KXtyZXR1cm4gdC5jb3B5KCl9LHRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPXRoaXMudHJhbnNmb3JtKHQuZ2V0R2VvbWV0cnlOKGkpKTtudWxsIT09ciYmKHRoaXMucHJ1bmVFbXB0eUdlb21ldHJ5JiZyLmlzRW1wdHkoKXx8bi5hZGQocikpfXJldHVybiB0aGlzLnByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT90aGlzLmZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheShuKSk6dGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9LHRyYW5zZm9ybTpmdW5jdGlvbih0KXtpZih0aGlzLmlucHV0R2VvbT10LHRoaXMuZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0IGluc3RhbmNlb2YgTHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgUHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBidClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFN0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgZ3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFR0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgT3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGZ0KXJldHVybiB0aGlzLnRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LG51bGwpO3Rocm93IG5ldyBpKFwiVW5rbm93biBHZW9tZXRyeSBzdWJ0eXBlOiBcIit0LmdldENsYXNzKCkuZ2V0TmFtZSgpKX0sdHJhbnNmb3JtTGluZWFyUmluZzpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KTtpZihudWxsPT09bilyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobnVsbCk7dmFyIGk9bi5zaXplKCk7cmV0dXJuIGk+MCYmND5pJiYhdGhpcy5wcmVzZXJ2ZVR5cGU/dGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobik6dGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHhlfX0pLGUoRWUucHJvdG90eXBlLHtzbmFwVmVydGljZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5faXNDbG9zZWQ/dC5zaXplKCktMTp0LnNpemUoKSxpPTA7bj5pO2krKyl7dmFyIHI9dC5nZXQoaSkscz10aGlzLmZpbmRTbmFwRm9yVmVydGV4KHIsZSk7bnVsbCE9PXMmJih0LnNldChpLG5ldyBnKHMpKSwwPT09aSYmdGhpcy5faXNDbG9zZWQmJnQuc2V0KHQuc2l6ZSgpLTEsbmV3IGcocykpKX19LGZpbmRTbmFwRm9yVmVydGV4OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe2lmKHQuZXF1YWxzMkQoZVtuXSkpcmV0dXJuIG51bGw7aWYodC5kaXN0YW5jZShlW25dKTx0aGlzLnNuYXBUb2xlcmFuY2UpcmV0dXJuIGVbbl19cmV0dXJuIG51bGx9LHNuYXBUbzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTih0aGlzLnNyY1B0cyk7dGhpcy5zbmFwVmVydGljZXMoZSx0KSx0aGlzLnNuYXBTZWdtZW50cyhlLHQpO3ZhciBuPWUudG9Db29yZGluYXRlQXJyYXkoKTtyZXR1cm4gbn0sc25hcFNlZ21lbnRzOmZ1bmN0aW9uKHQsZSl7aWYoMD09PWUubGVuZ3RoKXJldHVybiBudWxsO3ZhciBuPWUubGVuZ3RoO2VbMF0uZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkmJihuPWUubGVuZ3RoLTEpO2Zvcih2YXIgaT0wO24+aTtpKyspe3ZhciByPWVbaV0scz10aGlzLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAocix0KTtzPj0wJiZ0LmFkZChzKzEsbmV3IGcociksITEpfX0sZmluZFNlZ21lbnRJbmRleFRvU25hcDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1yLk1BWF9WQUxVRSxpPS0xLHM9MDtzPGUuc2l6ZSgpLTE7cysrKXtpZih0aGlzLnNlZy5wMD1lLmdldChzKSx0aGlzLnNlZy5wMT1lLmdldChzKzEpLHRoaXMuc2VnLnAwLmVxdWFsczJEKHQpfHx0aGlzLnNlZy5wMS5lcXVhbHMyRCh0KSl7aWYodGhpcy5hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyljb250aW51ZTtyZXR1cm4tMX12YXIgbz10aGlzLnNlZy5kaXN0YW5jZSh0KTtvPHRoaXMuc25hcFRvbGVyYW5jZSYmbj5vJiYobj1vLGk9cyl9cmV0dXJuIGl9LHNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe3RoaXMuYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRWV9fSksRWUuaXNDbG9zZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoPD0xPyExOnRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSl9LGUoSWUucHJvdG90eXBlLHtzbmFwVG86ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KSxpPW5ldyBOZShlLG4pO3JldHVybiBpLnRyYW5zZm9ybSh0aGlzLnNyY0dlb20pfSxzbmFwVG9TZWxmOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModGhpcy5zcmNHZW9tKSxpPW5ldyBOZSh0LG4sITApLHI9aS50cmFuc2Zvcm0odGhpcy5zcmNHZW9tKSxzPXI7cmV0dXJuIGUmJlIocyxSdCkmJihzPXIuYnVmZmVyKDApKSxzfSxjb21wdXRlU25hcFRvbGVyYW5jZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCh0KSxuPWUvMTA7cmV0dXJuIG59LGV4dHJhY3RUYXJnZXRDb29yZGluYXRlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IGF0LG49dC5nZXRDb29yZGluYXRlcygpLGk9MDtpPG4ubGVuZ3RoO2krKyllLmFkZChuW2ldKTtyZXR1cm4gZS50b0FycmF5KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKX0sY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1yLk1BWF9WQUxVRSxuPTA7bjx0Lmxlbmd0aC0xO24rKyl7dmFyIGk9dFtuXS5kaXN0YW5jZSh0W24rMV0pO2U+aSYmKGU9aSl9cmV0dXJuIGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEllfX0pLEllLnNuYXA9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHI9bmV3IEllKHQpO2lbMF09ci5zbmFwVG8oZSxuKTt2YXIgcz1uZXcgSWUoZSk7cmV0dXJuIGlbMV09cy5zbmFwVG8oaVswXSxuKSxpfSxJZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2U9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9SWUuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UodCksbj10LmdldFByZWNpc2lvbk1vZGVsKCk7aWYobi5nZXRUeXBlKCk9PT1lZS5GSVhFRCl7dmFyIGk9MS9uLmdldFNjYWxlKCkqMi8xLjQxNTtpPmUmJihlPWkpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV07cmV0dXJuIE1hdGgubWluKEllLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShyKSxJZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UocykpfX0sSWUuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2U9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCksbj1NYXRoLm1pbihlLmdldEhlaWdodCgpLGUuZ2V0V2lkdGgoKSksaT1uKkllLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUjtyZXR1cm4gaX0sSWUuc25hcFRvU2VsZj1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEllKHQpO3JldHVybiBpLnNuYXBUb1NlbGYoZSxuKX0sSWUuU05BUF9QUkVDSVNJT05fRkFDVE9SPTFlLTksaChOZSx4ZSksZShOZS5wcm90b3R5cGUse3NuYXBMaW5lOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEVlKHQsdGhpcy5zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbi5zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0aGlzLmlzU2VsZlNuYXApLG4uc25hcFRvKGUpfSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxpPXRoaXMuc25hcExpbmUobix0aGlzLnNuYXBQdHMpO3JldHVybiB0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTmV9fSksZShDZS5wcm90b3R5cGUse2dldENvbW1vbjpmdW5jdGlvbigpe3JldHVybiByLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5jb21tb25CaXRzKX0sYWRkOmZ1bmN0aW9uKHQpe3ZhciBlPXIuZG91YmxlVG9Mb25nQml0cyh0KTtpZih0aGlzLmlzRmlyc3QpcmV0dXJuIHRoaXMuY29tbW9uQml0cz1lLHRoaXMuY29tbW9uU2lnbkV4cD1DZS5zaWduRXhwQml0cyh0aGlzLmNvbW1vbkJpdHMpLHRoaXMuaXNGaXJzdD0hMSxudWxsO3ZhciBuPUNlLnNpZ25FeHBCaXRzKGUpO3JldHVybiBuIT09dGhpcy5jb21tb25TaWduRXhwPyh0aGlzLmNvbW1vbkJpdHM9MCxudWxsKToodGhpcy5jb21tb25NYW50aXNzYUJpdHNDb3VudD1DZS5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHRoaXMuY29tbW9uQml0cyxlKSx2b2lkKHRoaXMuY29tbW9uQml0cz1DZS56ZXJvTG93ZXJCaXRzKHRoaXMuY29tbW9uQml0cyw2NC0oMTIrdGhpcy5jb21tb25NYW50aXNzYUJpdHNDb3VudCkpKSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXIubG9uZ0JpdHNUb0RvdWJsZSh0KSxuPUxvbmcudG9CaW5hcnlTdHJpbmcodCksaT1cIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIituLHM9aS5zdWJzdHJpbmcoaS5sZW5ndGgtNjQpLG89cy5zdWJzdHJpbmcoMCwxKStcIiAgXCIrcy5zdWJzdHJpbmcoMSwxMikrXCIoZXhwKSBcIitzLnN1YnN0cmluZygxMikrXCIgWyBcIitlK1wiIF1cIjtyZXR1cm4gb319LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENlfX0pLENlLmdldEJpdD1mdW5jdGlvbih0LGUpe3ZhciBuPTE8PGU7cmV0dXJuIDAhPT0odCZuKT8xOjB9LENlLnNpZ25FeHBCaXRzPWZ1bmN0aW9uKHQpe3JldHVybiB0Pj41Mn0sQ2UuemVyb0xvd2VyQml0cz1mdW5jdGlvbih0LGUpe3ZhciBuPSgxPDxlKS0xLGk9fm4scj10Jmk7cmV0dXJuIHJ9LENlLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxpPTUyO2k+PTA7aS0tKXtpZihDZS5nZXRCaXQodCxpKSE9PUNlLmdldEJpdChlLGkpKXJldHVybiBuO24rK31yZXR1cm4gNTJ9LGUoU2UucHJvdG90eXBlLHthZGRDb21tb25CaXRzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBMZSh0aGlzLmNvbW1vbkNvb3JkKTt0LmFwcGx5KGUpLHQuZ2VvbWV0cnlDaGFuZ2VkKCl9LHJlbW92ZUNvbW1vbkJpdHM6ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMuY29tbW9uQ29vcmQueCYmMD09PXRoaXMuY29tbW9uQ29vcmQueSlyZXR1cm4gdDt2YXIgZT1uZXcgZyh0aGlzLmNvbW1vbkNvb3JkKTtlLng9LWUueCxlLnk9LWUueTt2YXIgbj1uZXcgTGUoZSk7cmV0dXJuIHQuYXBwbHkobiksdC5nZW9tZXRyeUNoYW5nZWQoKSx0fSxnZXRDb21tb25Db29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tbW9uQ29vcmR9LGFkZDpmdW5jdGlvbih0KXt0LmFwcGx5KHRoaXMuY2NGaWx0ZXIpLHRoaXMuY29tbW9uQ29vcmQ9dGhpcy5jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFNlfX0pLGUod2UucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dGhpcy5jb21tb25CaXRzWC5hZGQodC54KSx0aGlzLmNvbW1vbkJpdHNZLmFkZCh0LnkpfSxnZXRDb21tb25Db29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKHRoaXMuY29tbW9uQml0c1guZ2V0Q29tbW9uKCksdGhpcy5jb21tb25CaXRzWS5nZXRDb21tb24oKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3pdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3ZX19KSxlKExlLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRPcmRpbmF0ZShlLDApK3RoaXMudHJhbnMueCxpPXQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLnRyYW5zLnk7dC5zZXRPcmRpbmF0ZShlLDAsbiksdC5zZXRPcmRpbmF0ZShlLDEsaSl9LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiExfSxpc0dlb21ldHJ5Q2hhbmdlZDpmdW5jdGlvbigpe3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltjdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExlfX0pLFNlLkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXI9d2UsU2UuVHJhbnNsYXRlcj1MZSxlKFJlLnByb3RvdHlwZSx7bmV4dDpmdW5jdGlvbigpe2lmKHRoaXMuYXRTdGFydClyZXR1cm4gdGhpcy5hdFN0YXJ0PSExLFJlLmlzQXRvbWljKHRoaXMucGFyZW50KSYmdGhpcy5pbmRleCsrLHRoaXMucGFyZW50O2lmKG51bGwhPT10aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcil7aWYodGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiB0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCk7dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1pZih0aGlzLmluZGV4Pj10aGlzLm1heCl0aHJvdyBuZXcgeDt2YXIgdD10aGlzLnBhcmVudC5nZXRHZW9tZXRyeU4odGhpcy5pbmRleCsrKTtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ0Pyh0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1uZXcgUmUodCksdGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpKTp0fSxyZW1vdmU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSl9LGhhc05leHQ6ZnVuY3Rpb24oKXtpZih0aGlzLmF0U3RhcnQpcmV0dXJuITA7aWYobnVsbCE9PXRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuITA7dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1yZXR1cm4hKHRoaXMuaW5kZXg+PXRoaXMubWF4KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJlfX0pLFJlLmlzQXRvbWljPWZ1bmN0aW9uKHQpe3JldHVybiEodCBpbnN0YW5jZW9mIGZ0KX0sZShUZS5wcm90b3R5cGUse2xvY2F0ZUludGVybmFsOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFR0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoZS5pc0VtcHR5KCkpcmV0dXJuIEwuRVhURVJJT1I7dmFyIG49ZS5nZXRFeHRlcmlvclJpbmcoKSxpPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LG4pO2lmKGk9PT1MLkVYVEVSSU9SKXJldHVybiBMLkVYVEVSSU9SO2lmKGk9PT1MLkJPVU5EQVJZKXJldHVybiBMLkJPVU5EQVJZO2Zvcih2YXIgcj0wO3I8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtyKyspe3ZhciBzPWUuZ2V0SW50ZXJpb3JSaW5nTihyKSxvPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LHMpO2lmKG89PT1MLklOVEVSSU9SKXJldHVybiBMLkVYVEVSSU9SO2lmKG89PT1MLkJPVU5EQVJZKXJldHVybiBMLkJPVU5EQVJZfXJldHVybiBMLklOVEVSSU9SfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBTdCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdO2lmKCF1LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGEpKXJldHVybiBMLkVYVEVSSU9SO3ZhciBsPXUuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdS5pc0Nsb3NlZCgpfHwhYS5lcXVhbHMobFswXSkmJiFhLmVxdWFscyhsW2wubGVuZ3RoLTFdKT9oZS5pc09uTGluZShhLGwpP0wuSU5URVJJT1I6TC5FWFRFUklPUjpMLkJPVU5EQVJZfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBMdCl7dmFyIGg9YXJndW1lbnRzWzBdLGM9YXJndW1lbnRzWzFdLGY9Yy5nZXRDb29yZGluYXRlKCk7cmV0dXJuIGYuZXF1YWxzMkQoaCk/TC5JTlRFUklPUjpMLkVYVEVSSU9SfX0sbG9jYXRlSW5Qb2x5Z29uUmluZzpmdW5jdGlvbih0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP2hlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTpMLkVYVEVSSU9SfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRlKHQsZSkhPT1MLkVYVEVSSU9SfSx1cGRhdGVMb2NhdGlvbkluZm86ZnVuY3Rpb24odCl7dD09PUwuSU5URVJJT1ImJih0aGlzLmlzSW49ITApLHQ9PT1MLkJPVU5EQVJZJiZ0aGlzLm51bUJvdW5kYXJpZXMrK30sY29tcHV0ZUxvY2F0aW9uOmZ1bmN0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIEx0JiZ0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsZSkpLGUgaW5zdGFuY2VvZiBTdCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsZSkpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFR0KXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgZ3QpZm9yKHZhciBuPWUsaT0wO2k8bi5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj1uLmdldEdlb21ldHJ5TihpKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQscikpfWVsc2UgaWYoZSBpbnN0YW5jZW9mIE90KWZvcih2YXIgcz1lLGk9MDtpPHMuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIG89cy5nZXRHZW9tZXRyeU4oaSk7dGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbCh0LG8pKX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBmdClmb3IodmFyIGE9bmV3IFJlKGUpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCk7dSE9PWUmJnRoaXMuY29tcHV0ZUxvY2F0aW9uKHQsdSl9fSxsb2NhdGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/TC5FWFRFUklPUjplIGluc3RhbmNlb2YgU3Q/dGhpcy5sb2NhdGVJbnRlcm5hbCh0LGUpOmUgaW5zdGFuY2VvZiBUdD90aGlzLmxvY2F0ZUludGVybmFsKHQsZSk6KHRoaXMuaXNJbj0hMSx0aGlzLm51bUJvdW5kYXJpZXM9MCx0aGlzLmNvbXB1dGVMb2NhdGlvbih0LGUpLHRoaXMuYm91bmRhcnlSdWxlLmlzSW5Cb3VuZGFyeSh0aGlzLm51bUJvdW5kYXJpZXMpP0wuQk9VTkRBUlk6dGhpcy5udW1Cb3VuZGFyaWVzPjB8fHRoaXMuaXNJbj9MLklOVEVSSU9SOkwuRVhURVJJT1IpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUZX19KSxlKFBlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUGV9fSksUGUub2N0YW50PWZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO3ZhciBuPU1hdGguYWJzKHQpLHI9TWF0aC5hYnMoZSk7cmV0dXJuIHQ+PTA/ZT49MD9uPj1yPzA6MTpuPj1yPzc6NjplPj0wP24+PXI/MzoyOm4+PXI/NDo1fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1vLngtcy54LHU9by55LXMueTtpZigwPT09YSYmMD09PXUpdGhyb3cgbmV3IGkoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIitzKTtyZXR1cm4gUGUub2N0YW50KGEsdSl9fSxlKGJlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt9LHNpemU6ZnVuY3Rpb24oKXt9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7fSxpc0Nsb3NlZDpmdW5jdGlvbigpe30sc2V0RGF0YTpmdW5jdGlvbih0KXt9LGdldERhdGE6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJlfX0pLGUoT2UucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHRzW3RdfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX0sZ2V0U2VnbWVudE9jdGFudDpmdW5jdGlvbih0KXtyZXR1cm4gdD09PXRoaXMucHRzLmxlbmd0aC0xPy0xOlBlLm9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLnB0cykpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltiZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9lfX0pLGUoX2UucHJvdG90eXBlLHtnZXRCb3VuZHM6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9lfX0pLGUoTWUucHJvdG90eXBlLHtnZXRJdGVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm91bmRzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltfZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTWV9fSksZShEZS5wcm90b3R5cGUse3BvbGw6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLml0ZW1zLmdldCgxKTtyZXR1cm4gdGhpcy5pdGVtcy5zZXQoMSx0aGlzLml0ZW1zLmdldCh0aGlzLl9zaXplKSksdGhpcy5fc2l6ZS09MSx0aGlzLnJlb3JkZXIoMSksdH0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaXplfSxyZW9yZGVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49dGhpcy5pdGVtcy5nZXQodCk7Mip0PD10aGlzLl9zaXplJiYoZT0yKnQsZSE9PXRoaXMuX3NpemUmJnRoaXMuaXRlbXMuZ2V0KGUrMSkuY29tcGFyZVRvKHRoaXMuaXRlbXMuZ2V0KGUpKTwwJiZlKyssdGhpcy5pdGVtcy5nZXQoZSkuY29tcGFyZVRvKG4pPDApO3Q9ZSl0aGlzLml0ZW1zLnNldCh0LHRoaXMuaXRlbXMuZ2V0KGUpKTt0aGlzLml0ZW1zLnNldCh0LG4pfSxjbGVhcjpmdW5jdGlvbigpe3RoaXMuX3NpemU9MCx0aGlzLml0ZW1zLmNsZWFyKCl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuX3NpemV9LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZChudWxsKSx0aGlzLl9zaXplKz0xO3ZhciBlPXRoaXMuX3NpemU7Zm9yKHRoaXMuaXRlbXMuc2V0KDAsdCk7dC5jb21wYXJlVG8odGhpcy5pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk8MDtlLz0yKXRoaXMuaXRlbXMuc2V0KGUsdGhpcy5pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk7dGhpcy5pdGVtcy5zZXQoZSx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRGV9fSksZShBZS5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFlfX0pLGUoRmUucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlKXt9LHJlbW92ZTpmdW5jdGlvbih0LGUpe30scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGZX19KSxlKEdlLnByb3RvdHlwZSx7Z2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkQm91bmRhYmxlcy5zaXplKCl9LGdldENoaWxkQm91bmRhYmxlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkQm91bmRhYmxlc30sYWRkQ2hpbGRCb3VuZGFibGU6ZnVuY3Rpb24odCl7Zi5pc1RydWUobnVsbD09PXRoaXMuYm91bmRzKSx0aGlzLmNoaWxkQm91bmRhYmxlcy5hZGQodCl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuYm91bmRzJiYodGhpcy5ib3VuZHM9dGhpcy5jb21wdXRlQm91bmRzKCkpLHRoaXMuYm91bmRzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltfZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR2V9fSksR2Uuc2VyaWFsVmVyc2lvblVJRD0weDVhMWU1NWVjNDEzNjk4MDA7dmFyIGhvPXtyZXZlcnNlT3JkZXI6ZnVuY3Rpb24oKXtyZXR1cm57Y29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiBlLmNvbXBhcmVUbyh0KX19fSxtaW46ZnVuY3Rpb24odCl7cmV0dXJuIGhvLnNvcnQodCksdC5nZXQoMCl9LHNvcnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRvQXJyYXkoKTtlP3V0LnNvcnQobixlKTp1dC5zb3J0KG4pO2Zvcih2YXIgaT10Lml0ZXJhdG9yKCkscj0wLHM9bi5sZW5ndGg7cz5yO3IrKylpLm5leHQoKSxpLnNldChuW3JdKX0sc2luZ2xldG9uTGlzdDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgSTtyZXR1cm4gZS5hZGQodCksZX19O2UocWUucHJvdG90eXBlLHtleHBhbmRUb1F1ZXVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49cWUuaXNDb21wb3NpdGUodGhpcy5ib3VuZGFibGUxKSxyPXFlLmlzQ29tcG9zaXRlKHRoaXMuYm91bmRhYmxlMik7aWYobiYmcilyZXR1cm4gcWUuYXJlYSh0aGlzLmJvdW5kYWJsZTEpPnFlLmFyZWEodGhpcy5ib3VuZGFibGUyKT8odGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMix0LGUpLG51bGwpOih0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTIsdGhpcy5ib3VuZGFibGUxLHQsZSksbnVsbCk7aWYobilyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMix0LGUpLG51bGw7aWYocilyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUyLHRoaXMuYm91bmRhYmxlMSx0LGUpLG51bGw7dGhyb3cgbmV3IGkoXCJuZWl0aGVyIGJvdW5kYWJsZSBpcyBjb21wb3NpdGVcIil9LGlzTGVhdmVzOmZ1bmN0aW9uKCl7cmV0dXJuIShxZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTEpfHxxZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTIpKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlPGUuX2Rpc3RhbmNlPy0xOnRoaXMuX2Rpc3RhbmNlPmUuX2Rpc3RhbmNlPzE6MH0sZXhwYW5kOmZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj10LmdldENoaWxkQm91bmRhYmxlcygpLHM9ci5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksYT1uZXcgcWUobyxlLHRoaXMuaXRlbURpc3RhbmNlKTthLmdldERpc3RhbmNlKCk8aSYmbi5hZGQoYSl9fSxnZXRCb3VuZGFibGU6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10P3RoaXMuYm91bmRhYmxlMTp0aGlzLmJvdW5kYWJsZTJ9LGdldERpc3RhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfSxkaXN0YW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTGVhdmVzKCk/dGhpcy5pdGVtRGlzdGFuY2UuZGlzdGFuY2UodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMik6dGhpcy5ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuYm91bmRhYmxlMi5nZXRCb3VuZHMoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxZX19KSxxZS5hcmVhPWZ1bmN0aW9uKHQpe3JldHVybiB0LmdldEJvdW5kcygpLmdldEFyZWEoKX0scWUuaXNDb21wb3NpdGU9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBHZX0sZShCZS5wcm90b3R5cGUse2dldE5vZGVDYXBhY2l0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVDYXBhY2l0eX0sbGFzdE5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0KHQuc2l6ZSgpLTEpfSxzaXplOmZ1bmN0aW9uIHQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuc2l6ZSh0aGlzLnJvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSx0PTAsbj1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpIGluc3RhbmNlb2YgR2U/dCs9dGhpcy5zaXplKGkpOmkgaW5zdGFuY2VvZiBNZSYmKHQrPTEpfXJldHVybiB0fX0scmVtb3ZlSXRlbTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1udWxsLGk9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ciBpbnN0YW5jZW9mIE1lJiZyLmdldEl0ZW0oKT09PWUmJihuPXIpfXJldHVybiBudWxsIT09bj8odC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUobiksITApOiExfSxpdGVtc1RyZWU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5idWlsZCgpO3ZhciB0PXRoaXMuaXRlbXNUcmVlKHRoaXMucm9vdCk7cmV0dXJuIG51bGw9PT10P25ldyBJOnR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1uZXcgSSxpPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2lmKHIgaW5zdGFuY2VvZiBHZSl7dmFyIHM9dGhpcy5pdGVtc1RyZWUocik7bnVsbCE9PXMmJm4uYWRkKHMpfWVsc2UgciBpbnN0YW5jZW9mIE1lP24uYWRkKHIuZ2V0SXRlbSgpKTpmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIG4uc2l6ZSgpPD0wP251bGw6bn19LGluc2VydDpmdW5jdGlvbih0LGUpe2YuaXNUcnVlKCF0aGlzLmJ1aWx0LFwiQ2Fubm90IGluc2VydCBpdGVtcyBpbnRvIGFuIFNUUiBwYWNrZWQgUi10cmVlIGFmdGVyIGl0IGhhcyBiZWVuIGJ1aWx0LlwiKSx0aGlzLml0ZW1Cb3VuZGFibGVzLmFkZChuZXcgTWUodCxlKSl9LGJvdW5kYWJsZXNBdExldmVsOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBJO3JldHVybiB0aGlzLmJvdW5kYWJsZXNBdExldmVsKHQsdGhpcy5yb290LGUpLGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTtpZihmLmlzVHJ1ZShuPi0yKSxpLmdldExldmVsKCk9PT1uKXJldHVybiByLmFkZChpKSxudWxsO2Zvcih2YXIgcz1pLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKTtvIGluc3RhbmNlb2YgR2U/dGhpcy5ib3VuZGFibGVzQXRMZXZlbChuLG8scik6KGYuaXNUcnVlKG8gaW5zdGFuY2VvZiBNZSksLTE9PT1uJiZyLmFkZChvKSl9cmV0dXJuIG51bGx9fSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5idWlsZCgpO3ZhciBlPW5ldyBJO3JldHVybiB0aGlzLmlzRW1wdHkoKT9lOih0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnF1ZXJ5KHQsdGhpcy5yb290LGUpLGUpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07aWYodGhpcy5idWlsZCgpLHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLnJvb3QuZ2V0Qm91bmRzKCksbikmJnRoaXMucXVlcnkobix0aGlzLnJvb3QsaSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihSKGFyZ3VtZW50c1syXSxBZSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEdlKWZvcih2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1zLmdldENoaWxkQm91bmRhYmxlcygpLHU9MDt1PGEuc2l6ZSgpO3UrKyl7dmFyIGw9YS5nZXQodSk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGwuZ2V0Qm91bmRzKCkscikmJihsIGluc3RhbmNlb2YgR2U/dGhpcy5xdWVyeShyLGwsbyk6bCBpbnN0YW5jZW9mIE1lP28udmlzaXRJdGVtKGwuZ2V0SXRlbSgpKTpmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCkpfWVsc2UgaWYoUihhcmd1bWVudHNbMl0seSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEdlKWZvcih2YXIgaD1hcmd1bWVudHNbMF0sYz1hcmd1bWVudHNbMV0sZz1hcmd1bWVudHNbMl0sYT1jLmdldENoaWxkQm91bmRhYmxlcygpLHU9MDt1PGEuc2l6ZSgpO3UrKyl7dmFyIGw9YS5nZXQodSk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGwuZ2V0Qm91bmRzKCksaCkmJihsIGluc3RhbmNlb2YgR2U/dGhpcy5xdWVyeShoLGwsZyk6bCBpbnN0YW5jZW9mIE1lP2cuYWRkKGwuZ2V0SXRlbSgpKTpmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCkpfX0sYnVpbGQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWlsdD9udWxsOih0aGlzLnJvb3Q9dGhpcy5pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCk/dGhpcy5jcmVhdGVOb2RlKDApOnRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKHRoaXMuaXRlbUJvdW5kYWJsZXMsLTEpLHRoaXMuaXRlbUJvdW5kYWJsZXM9bnVsbCx2b2lkKHRoaXMuYnVpbHQ9ITApKX0sZ2V0Um9vdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1aWxkKCksdGhpcy5yb290fSxyZW1vdmU6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmJ1aWxkKCksdGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMucm9vdC5nZXRCb3VuZHMoKSx0KT90aGlzLnJlbW92ZSh0LHRoaXMucm9vdCxlKTohMX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdLHM9dGhpcy5yZW1vdmVJdGVtKGkscik7aWYocylyZXR1cm4hMDtmb3IodmFyIG89bnVsbCxhPWkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTthLmhhc05leHQoKTspe3ZhciB1PWEubmV4dCgpO2lmKHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh1LmdldEJvdW5kcygpLG4pJiZ1IGluc3RhbmNlb2YgR2UmJihzPXRoaXMucmVtb3ZlKG4sdSxyKSkpe289dTticmVha319cmV0dXJuIG51bGwhPT1vJiZvLmdldENoaWxkQm91bmRhYmxlcygpLmlzRW1wdHkoKSYmaS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUobyksc319LGNyZWF0ZUhpZ2hlckxldmVsczpmdW5jdGlvbih0LGUpe2YuaXNUcnVlKCF0LmlzRW1wdHkoKSk7dmFyIG49dGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSsxKTtyZXR1cm4gMT09PW4uc2l6ZSgpP24uZ2V0KDApOnRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKG4sZSsxKX0sZGVwdGg6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuZGVwdGgodGhpcy5yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wLG49dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaSBpbnN0YW5jZW9mIEdlKXt2YXIgcj10aGlzLmRlcHRoKGkpO3I+ZSYmKGU9cil9fXJldHVybiBlKzF9fSxjcmVhdGVQYXJlbnRCb3VuZGFibGVzOmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUoIXQuaXNFbXB0eSgpKTt2YXIgbj1uZXcgSTtuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpO3ZhciBpPW5ldyBJKHQpO2hvLnNvcnQoaSx0aGlzLmdldENvbXBhcmF0b3IoKSk7Zm9yKHZhciByPWkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO3RoaXMubGFzdE5vZGUobikuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuc2l6ZSgpPT09dGhpcy5nZXROb2RlQ2FwYWNpdHkoKSYmbi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKSx0aGlzLmxhc3ROb2RlKG4pLmFkZENoaWxkQm91bmRhYmxlKHMpfXJldHVybiBufSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbHQ/dGhpcy5yb290LmlzRW1wdHkoKTp0aGlzLml0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJlfX0pLEJlLmNvbXBhcmVEb3VibGVzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+ZT8xOmU+dD8tMTowfSxCZS5JbnRlcnNlY3RzT3A9emUsQmUuc2VyaWFsVmVyc2lvblVJRD0tMHgzNWVmNjRjODJkNGM1NDAwLEJlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMCxlKFZlLnByb3RvdHlwZSx7ZGlzdGFuY2U6ZnVuY3Rpb24odCxlKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZlfX0pLGgoa2UsQmUpLGUoa2UucHJvdG90eXBlLHtjcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzOmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUodC5sZW5ndGg+MCk7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQubGVuZ3RoO2krKyluLmFkZEFsbCh0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSh0W2ldLGUpKTtyZXR1cm4gbn0sY3JlYXRlTm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFllKHQpfSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP0JlLnByb3RvdHlwZS5zaXplLmNhbGwodGhpcyk6QmUucHJvdG90eXBlLnNpemUuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxpbnNlcnQ6ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gQmUucHJvdG90eXBlLmluc2VydC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0LmlzTnVsbCgpP251bGw6dm9pZCBCZS5wcm90b3R5cGUuaW5zZXJ0LmNhbGwodGhpcyx0LGUpfSxnZXRJbnRlcnNlY3RzT3A6ZnVuY3Rpb24oKXtyZXR1cm4ga2UuaW50ZXJzZWN0c09wfSx2ZXJ0aWNhbFNsaWNlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1NYXRoLnRydW5jKE1hdGguY2VpbCh0LnNpemUoKS9lKSksaT1uZXcgQXJyYXkoZSkuZmlsbChudWxsKSxyPXQuaXRlcmF0b3IoKSxzPTA7ZT5zO3MrKyl7aVtzXT1uZXcgSTtmb3IodmFyIG89MDtyLmhhc05leHQoKSYmbj5vOyl7dmFyIGE9ci5uZXh0KCk7aVtzXS5hZGQoYSksbysrfX1yZXR1cm4gaX0scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07QmUucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcyxlLG4pfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoUihhcmd1bWVudHNbMl0sQWUpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBHZSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO0JlLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsaSxyLHMpfWVsc2UgaWYoUihhcmd1bWVudHNbMl0seSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEdlKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl07QmUucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcyxvLGEsdSl9fSxnZXRDb21wYXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIGtlLnlDb21wYXJhdG9yfSxjcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4gQmUucHJvdG90eXBlLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXMuY2FsbCh0aGlzLHQsZSl9LHJlbW92ZTpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIEJlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIEJlLnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxkZXB0aDpmdW5jdGlvbigpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9CZS5wcm90b3R5cGUuZGVwdGguY2FsbCh0aGlzKTpCZS5wcm90b3R5cGUuZGVwdGguYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjcmVhdGVQYXJlbnRCb3VuZGFibGVzOmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUoIXQuaXNFbXB0eSgpKTt2YXIgbj1NYXRoLnRydW5jKE1hdGguY2VpbCh0LnNpemUoKS90aGlzLmdldE5vZGVDYXBhY2l0eSgpKSksaT1uZXcgSSh0KTtoby5zb3J0KGksa2UueENvbXBhcmF0b3IpO3ZhciByPXRoaXMudmVydGljYWxTbGljZXMoaSxNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLnNxcnQobikpKSk7cmV0dXJuIHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyhyLGUpfSxuZWFyZXN0TmVpZ2hib3VyOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLFZlKSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IHFlKHRoaXMuZ2V0Um9vdCgpLHRoaXMuZ2V0Um9vdCgpLHQpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoZSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxZSl7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIobixyLlBPU0lUSVZFX0lORklOSVRZKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBrZSYmUihhcmd1bWVudHNbMV0sVmUpKXt2YXIgaT1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sZT1uZXcgcWUodGhpcy5nZXRSb290KCksaS5nZXRSb290KCkscyk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFlJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hLGw9bnVsbCxoPW5ldyBEZTtmb3IoaC5hZGQobyk7IWguaXNFbXB0eSgpJiZ1PjA7KXt2YXIgYz1oLnBvbGwoKSxmPWMuZ2V0RGlzdGFuY2UoKTtpZihmPj11KWJyZWFrO2MuaXNMZWF2ZXMoKT8odT1mLGw9Yyk6Yy5leHBhbmRUb1F1ZXVlKGgsdSl9cmV0dXJuW2wuZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSxsLmdldEJvdW5kYWJsZSgxKS5nZXRJdGVtKCldfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZz1hcmd1bWVudHNbMF0sZD1hcmd1bWVudHNbMV0scD1hcmd1bWVudHNbMl0sdj1uZXcgTWUoZyxkKSxlPW5ldyBxZSh0aGlzLmdldFJvb3QoKSx2LHApO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoZSlbMF19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltGZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga2V9fSksa2UuY2VudHJlWD1mdW5jdGlvbih0KXtyZXR1cm4ga2UuYXZnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WCgpKX0sa2UuYXZnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQrZSkvMn0sa2UuY2VudHJlWT1mdW5jdGlvbih0KXtyZXR1cm4ga2UuYXZnKHQuZ2V0TWluWSgpLHQuZ2V0TWF4WSgpKX0saChZZSxHZSksZShZZS5wcm90b3R5cGUse2NvbXB1dGVCb3VuZHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bnVsbCxlPXRoaXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO251bGw9PT10P3Q9bmV3IEMobi5nZXRCb3VuZHMoKSk6dC5leHBhbmRUb0luY2x1ZGUobi5nZXRCb3VuZHMoKSl9cmV0dXJuIHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFllfX0pLGtlLlNUUnRyZWVOb2RlPVllLGtlLnNlcmlhbFZlcnNpb25VSUQ9MHgzOTkyMGY3ZDVmMjYxZTAsa2UueENvbXBhcmF0b3I9e2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxjb21wYXJlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIEJlLmNvbXBhcmVEb3VibGVzKGtlLmNlbnRyZVgodC5nZXRCb3VuZHMoKSksa2UuY2VudHJlWChlLmdldEJvdW5kcygpKSl9fSxrZS55Q29tcGFyYXRvcj17aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gQmUuY29tcGFyZURvdWJsZXMoa2UuY2VudHJlWSh0LmdldEJvdW5kcygpKSxrZS5jZW50cmVZKGUuZ2V0Qm91bmRzKCkpKX19LGtlLmludGVyc2VjdHNPcD17aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bSW50ZXJzZWN0c09wXX0saW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe3JldHVybiB0LmludGVyc2VjdHMoZSl9fSxrZS5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTAsZShVZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFVlfX0pLFVlLnJlbGF0aXZlU2lnbj1mdW5jdGlvbih0LGUpe3JldHVybiBlPnQ/LTE6dD5lPzE6MH0sVWUuY29tcGFyZT1mdW5jdGlvbih0LGUsbil7aWYoZS5lcXVhbHMyRChuKSlyZXR1cm4gMDt2YXIgaT1VZS5yZWxhdGl2ZVNpZ24oZS54LG4ueCkscj1VZS5yZWxhdGl2ZVNpZ24oZS55LG4ueSk7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKGkscik7Y2FzZSAxOnJldHVybiBVZS5jb21wYXJlVmFsdWUocixpKTtjYXNlIDI6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZShyLC1pKTtjYXNlIDM6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZSgtaSxyKTtjYXNlIDQ6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZSgtaSwtcik7Y2FzZSA1OnJldHVybiBVZS5jb21wYXJlVmFsdWUoLXIsLWkpO2Nhc2UgNjpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1yLGkpO2Nhc2UgNzpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKGksLXIpfXJldHVybiBmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiaW52YWxpZCBvY3RhbnQgdmFsdWVcIiksMH0sVWUuY29tcGFyZVZhbHVlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIDA+dD8tMTp0PjA/MTowPmU/LTE6ZT4wPzE6MH0sZShYZS5wcm90b3R5cGUse2dldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZH0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8ZS5zZWdtZW50SW5kZXg/LTE6dGhpcy5zZWdtZW50SW5kZXg+ZS5zZWdtZW50SW5kZXg/MTp0aGlzLmNvb3JkLmVxdWFsczJEKGUuY29vcmQpPzA6VWUuY29tcGFyZSh0aGlzLnNlZ21lbnRPY3RhbnQsdGhpcy5jb29yZCxlLmNvb3JkKX0saXNFbmRQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gMCE9PXRoaXMuc2VnbWVudEluZGV4fHx0aGlzLl9pc0ludGVyaW9yP3RoaXMuc2VnbWVudEluZGV4PT09dDohMH0saXNJbnRlcmlvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0ludGVyaW9yfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWGV9fSksZShIZS5wcm90b3R5cGUse2dldFNwbGl0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgTjt0aGlzLmFkZEVuZHBvaW50cygpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCksbj1lLm5leHQoKTtlLmhhc05leHQoKTspe3ZhciBpPWUubmV4dCgpO3RoaXMuYWRkRWRnZUNvb3JkaW5hdGVzKG4saSx0KSxuPWl9cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX0sYWRkQ29sbGFwc2VkTm9kZXM6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTt0aGlzLmZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2Rlcyh0KSx0aGlzLmZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyh0KTtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCkuaW50VmFsdWUoKTt0aGlzLmFkZCh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShuKSxuKX19LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpfX0sZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlLnNpemUoKS0yO2UrKyl7dmFyIG49dGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZSksaT0odGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZSsxKSx0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlKzIpKTtuLmVxdWFsczJEKGkpJiZ0LmFkZChuZXcgYihlKzEpKX19LGFkZEVkZ2VDb29yZGluYXRlczpmdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMixyPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUuc2VnbWVudEluZGV4KSxzPWUuaXNJbnRlcmlvcigpfHwhZS5jb29yZC5lcXVhbHMyRChyKTtzfHxpLS07bi5hZGQobmV3IGcodC5jb29yZCksITEpO2Zvcih2YXIgbz10LnNlZ21lbnRJbmRleCsxO288PWUuc2VnbWVudEluZGV4O28rKyluLmFkZCh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShvKSk7cyYmbi5hZGQobmV3IGcoZS5jb29yZCkpfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0sYWRkU3BsaXRFZGdlczpmdW5jdGlvbih0KXt0aGlzLmFkZEVuZHBvaW50cygpLHRoaXMuYWRkQ29sbGFwc2VkTm9kZXMoKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpLG49ZS5uZXh0KCk7ZS5oYXNOZXh0KCk7KXt2YXIgaT1lLm5leHQoKSxyPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4saSk7dC5hZGQociksbj1pfX0sZmluZENvbGxhcHNlSW5kZXg6ZnVuY3Rpb24odCxlLG4pe2lmKCF0LmNvb3JkLmVxdWFsczJEKGUuY29vcmQpKXJldHVybiExO3ZhciBpPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4O3JldHVybiBlLmlzSW50ZXJpb3IoKXx8aS0tLDE9PT1pPyhuWzBdPXQuc2VnbWVudEluZGV4KzEsITApOiExfSxmaW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5pdGVyYXRvcigpLGk9bi5uZXh0KCk7bi5oYXNOZXh0KCk7KXt2YXIgcj1uLm5leHQoKSxzPXRoaXMuZmluZENvbGxhcHNlSW5kZXgoaSxyLGUpO3MmJnQuYWRkKG5ldyBiKGVbMF0pKSxpPXJ9fSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZX0sYWRkRW5kcG9pbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lZGdlLnNpemUoKS0xO3RoaXMuYWRkKHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKDApLDApLHRoaXMuYWRkKHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfSxjcmVhdGVTcGxpdEVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyLGk9dGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLHI9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKGkpO3J8fG4tLTt2YXIgcz1uZXcgQXJyYXkobikuZmlsbChudWxsKSxvPTA7c1tvKytdPW5ldyBnKHQuY29vcmQpO2Zvcih2YXIgYT10LnNlZ21lbnRJbmRleCsxO2E8PWUuc2VnbWVudEluZGV4O2ErKylzW28rK109dGhpcy5lZGdlLmdldENvb3JkaW5hdGUoYSk7cmV0dXJuIHImJihzW29dPW5ldyBnKGUuY29vcmQpKSxuZXcgS2Uocyx0aGlzLmVkZ2UuZ2V0RGF0YSgpKX0sYWRkOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFhlKHRoaXMuZWRnZSx0LGUsdGhpcy5lZGdlLmdldFNlZ21lbnRPY3RhbnQoZSkpLGk9dGhpcy5ub2RlTWFwLmdldChuKTtyZXR1cm4gbnVsbCE9PWk/KGYuaXNUcnVlKGkuY29vcmQuZXF1YWxzMkQodCksXCJGb3VuZCBlcXVhbCBub2RlcyB3aXRoIGRpZmZlcmVudCBjb29yZGluYXRlc1wiKSxpKToodGhpcy5ub2RlTWFwLnB1dChuLG4pLG4pfSxjaGVja1NwbGl0RWRnZXNDb3JyZWN0bmVzczpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZXMoKSxuPXQuZ2V0KDApLGk9bi5nZXRDb29yZGluYXRlKDApO2lmKCFpLmVxdWFsczJEKGVbMF0pKXRocm93IG5ldyBsKFwiYmFkIHNwbGl0IGVkZ2Ugc3RhcnQgcG9pbnQgYXQgXCIraSk7dmFyIHI9dC5nZXQodC5zaXplKCktMSkscz1yLmdldENvb3JkaW5hdGVzKCksbz1zW3MubGVuZ3RoLTFdO2lmKCFvLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pKXRocm93IG5ldyBsKFwiYmFkIHNwbGl0IGVkZ2UgZW5kIHBvaW50IGF0IFwiK28pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIZX19KSxlKFdlLnByb3RvdHlwZSx7bmV4dDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5jdXJyTm9kZT8odGhpcy5jdXJyTm9kZT10aGlzLm5leHROb2RlLHRoaXMuY3VyclNlZ0luZGV4PXRoaXMuY3Vyck5vZGUuc2VnbWVudEluZGV4LHRoaXMucmVhZE5leHROb2RlKCksdGhpcy5jdXJyTm9kZSk6bnVsbD09PXRoaXMubmV4dE5vZGU/bnVsbDp0aGlzLm5leHROb2RlLnNlZ21lbnRJbmRleD09PXRoaXMuY3Vyck5vZGUuc2VnbWVudEluZGV4Pyh0aGlzLmN1cnJOb2RlPXRoaXMubmV4dE5vZGUsdGhpcy5jdXJyU2VnSW5kZXg9dGhpcy5jdXJyTm9kZS5zZWdtZW50SW5kZXgsdGhpcy5yZWFkTmV4dE5vZGUoKSx0aGlzLmN1cnJOb2RlKToodGhpcy5uZXh0Tm9kZS5zZWdtZW50SW5kZXg+dGhpcy5jdXJyTm9kZS5zZWdtZW50SW5kZXgsbnVsbCl9LHJlbW92ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKX0saGFzTmV4dDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5uZXh0Tm9kZX0scmVhZE5leHROb2RlOmZ1bmN0aW9uKCl7dGhpcy5ub2RlSXQuaGFzTmV4dCgpP3RoaXMubmV4dE5vZGU9dGhpcy5ub2RlSXQubmV4dCgpOnRoaXMubmV4dE5vZGU9bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdlfX0pLGUoamUucHJvdG90eXBlLHthZGRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2JlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gamV9fSksZShLZS5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzfSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wdHNbdF19LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGgtMV0pfSxnZXRTZWdtZW50T2N0YW50OmZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5wdHMubGVuZ3RoLTE/LTE6dGhpcy5zYWZlT2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LHNhZmVPY3RhbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5lcXVhbHMyRChlKT8wOlBlLm9jdGFudCh0LGUpfSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sYWRkSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmFkZEludGVyc2VjdGlvbk5vZGUodCxlKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj0oYXJndW1lbnRzWzJdLGFyZ3VtZW50c1szXSkscz1uZXcgZyhuLmdldEludGVyc2VjdGlvbihyKSk7dGhpcy5hZGRJbnRlcnNlY3Rpb24ocyxpKX19LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHNlLnRvTGluZVN0cmluZyhuZXcgR3QodGhpcy5wdHMpKX0sZ2V0Tm9kZUxpc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTGlzdH0sYWRkSW50ZXJzZWN0aW9uTm9kZTpmdW5jdGlvbih0LGUpe3ZhciBuPWUsaT1uKzE7aWYoaTx0aGlzLnB0cy5sZW5ndGgpe3ZhciByPXRoaXMucHRzW2ldO3QuZXF1YWxzMkQocikmJihuPWkpfXZhciBzPXRoaXMubm9kZUxpc3QuYWRkKHQsbik7cmV0dXJuIHN9LGFkZEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtpKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4saSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2plXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS2V9fSksS2UuZ2V0Tm9kZWRTdWJzdHJpbmdzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBJO3JldHVybiBLZS5nZXROb2RlZFN1YnN0cmluZ3ModCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1uLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtzLmdldE5vZGVMaXN0KCkuYWRkU3BsaXRFZGdlcyhpKX19LGUoWmUucHJvdG90eXBlLHtvdmVybGFwOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3QuZ2V0TGluZVNlZ21lbnQoZSx0aGlzLm92ZXJsYXBTZWcxKSxuLmdldExpbmVTZWdtZW50KGksdGhpcy5vdmVybGFwU2VnMiksdGhpcy5vdmVybGFwKHRoaXMub3ZlcmxhcFNlZzEsdGhpcy5vdmVybGFwU2VnMil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBaZX19KSxlKFFlLnByb3RvdHlwZSx7Z2V0TGluZVNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtlLnAwPXRoaXMucHRzW3RdLGUucDE9dGhpcy5wdHNbdCsxXX0sY29tcHV0ZVNlbGVjdDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLnB0c1tlXSxzPXRoaXMucHRzW25dO2lmKGkudGVtcEVudjEuaW5pdChyLHMpLG4tZT09PTEpcmV0dXJuIGkuc2VsZWN0KHRoaXMsZSksbnVsbDtpZighdC5pbnRlcnNlY3RzKGkudGVtcEVudjEpKXJldHVybiBudWxsO3ZhciBvPU1hdGgudHJ1bmMoKGUrbikvMik7XG5vPmUmJnRoaXMuY29tcHV0ZVNlbGVjdCh0LGUsbyxpKSxuPm8mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LG8sbixpKX0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZW5kLXRoaXMuc3RhcnQrMSkuZmlsbChudWxsKSxlPTAsbj10aGlzLnN0YXJ0O248PXRoaXMuZW5kO24rKyl0W2UrK109dGhpcy5wdHNbbl07cmV0dXJuIHR9LGNvbXB1dGVPdmVybGFwczpmdW5jdGlvbih0LGUpe3RoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwodGhpcy5zdGFydCx0aGlzLmVuZCx0LHQuc3RhcnQsdC5lbmQsZSl9LHNldElkOmZ1bmN0aW9uKHQpe3RoaXMuaWQ9dH0sc2VsZWN0OmZ1bmN0aW9uKHQsZSl7dGhpcy5jb21wdXRlU2VsZWN0KHQsdGhpcy5zdGFydCx0aGlzLmVuZCxlKX0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5lbnYpe3ZhciB0PXRoaXMucHRzW3RoaXMuc3RhcnRdLGU9dGhpcy5wdHNbdGhpcy5lbmRdO3RoaXMuZW52PW5ldyBDKHQsZSl9cmV0dXJuIHRoaXMuZW52fSxnZXRFbmRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZH0sZ2V0U3RhcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0fSxnZXRDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udGV4dH0sZ2V0SWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZH0sY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWw6ZnVuY3Rpb24odCxlLG4saSxyLHMpe3ZhciBvPXRoaXMucHRzW3RdLGE9dGhpcy5wdHNbZV0sdT1uLnB0c1tpXSxsPW4ucHRzW3JdO2lmKGUtdD09PTEmJnItaT09PTEpcmV0dXJuIHMub3ZlcmxhcCh0aGlzLHQsbixpKSxudWxsO2lmKHMudGVtcEVudjEuaW5pdChvLGEpLHMudGVtcEVudjIuaW5pdCh1LGwpLCFzLnRlbXBFbnYxLmludGVyc2VjdHMocy50ZW1wRW52MikpcmV0dXJuIG51bGw7dmFyIGg9TWF0aC50cnVuYygodCtlKS8yKSxjPU1hdGgudHJ1bmMoKGkrcikvMik7aD50JiYoYz5pJiZ0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKHQsaCxuLGksYyxzKSxyPmMmJnRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwodCxoLG4sYyxyLHMpKSxlPmgmJihjPmkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwoaCxlLG4saSxjLHMpLHI+YyYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbChoLGUsbixjLHIscykpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBRZX19KSxlKEplLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSmV9fSksSmUuaXNOb3J0aGVybj1mdW5jdGlvbih0KXtyZXR1cm4gdD09PUplLk5FfHx0PT09SmUuTld9LEplLmlzT3Bwb3NpdGU9ZnVuY3Rpb24odCxlKXtpZih0PT09ZSlyZXR1cm4hMTt2YXIgbj0odC1lKzQpJTQ7cmV0dXJuIDI9PT1ufSxKZS5jb21tb25IYWxmUGxhbmU9ZnVuY3Rpb24odCxlKXtpZih0PT09ZSlyZXR1cm4gdDt2YXIgbj0odC1lKzQpJTQ7aWYoMj09PW4pcmV0dXJuLTE7dmFyIGk9ZT50P3Q6ZSxyPXQ+ZT90OmU7cmV0dXJuIDA9PT1pJiYzPT09cj8zOml9LEplLmlzSW5IYWxmUGxhbmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT09PUplLlNFP3Q9PT1KZS5TRXx8dD09PUplLlNXOnQ9PT1lfHx0PT09ZSsxfSxKZS5xdWFkcmFudD1mdW5jdGlvbigpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IGkoXCJDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO3JldHVybiB0Pj0wP2U+PTA/SmUuTkU6SmUuU0U6ZT49MD9KZS5OVzpKZS5TV31pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO2lmKHIueD09PW4ueCYmci55PT09bi55KXRocm93IG5ldyBpKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIituKTtyZXR1cm4gci54Pj1uLng/ci55Pj1uLnk/SmUuTkU6SmUuU0U6ci55Pj1uLnk/SmUuTlc6SmUuU1d9fSxKZS5ORT0wLEplLk5XPTEsSmUuU1c9MixKZS5TRT0zLGUoJGUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiAkZX19KSwkZS5nZXRDaGFpblN0YXJ0SW5kaWNlcz1mdW5jdGlvbih0KXt2YXIgZT0wLG49bmV3IEk7bi5hZGQobmV3IGIoZSkpO2Rve3ZhciBpPSRlLmZpbmRDaGFpbkVuZCh0LGUpO24uYWRkKG5ldyBiKGkpKSxlPWl9d2hpbGUoZTx0Lmxlbmd0aC0xKTt2YXIgcj0kZS50b0ludEFycmF5KG4pO3JldHVybiByfSwkZS5maW5kQ2hhaW5FbmQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZTtuPHQubGVuZ3RoLTEmJnRbbl0uZXF1YWxzMkQodFtuKzFdKTspbisrO2lmKG4+PXQubGVuZ3RoLTEpcmV0dXJuIHQubGVuZ3RoLTE7Zm9yKHZhciBpPUplLnF1YWRyYW50KHRbbl0sdFtuKzFdKSxyPWUrMTtyPHQubGVuZ3RoOyl7aWYoIXRbci0xXS5lcXVhbHMyRCh0W3JdKSl7dmFyIHM9SmUucXVhZHJhbnQodFtyLTFdLHRbcl0pO2lmKHMhPT1pKWJyZWFrfXIrK31yZXR1cm4gci0xfSwkZS5nZXRDaGFpbnM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiAkZS5nZXRDaGFpbnModCxudWxsKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPW5ldyBJLHI9JGUuZ2V0Q2hhaW5TdGFydEluZGljZXMoZSkscz0wO3M8ci5sZW5ndGgtMTtzKyspe3ZhciBvPW5ldyBRZShlLHJbc10scltzKzFdLG4pO2kuYWRkKG8pfXJldHVybiBpfX0sJGUudG9JbnRBcnJheT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPXQuZ2V0KG4pLmludFZhbHVlKCk7cmV0dXJuIGV9LGUodG4ucHJvdG90eXBlLHtjb21wdXRlTm9kZXM6ZnVuY3Rpb24odCl7fSxnZXROb2RlZFN1YnN0cmluZ3M6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRufX0pLGUoZW4ucHJvdG90eXBlLHtzZXRTZWdtZW50SW50ZXJzZWN0b3I6ZnVuY3Rpb24odCl7dGhpcy5zZWdJbnQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdG5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlbn19KSxoKG5uLGVuKSxlKG5uLnByb3RvdHlwZSx7Z2V0TW9ub3RvbmVDaGFpbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb25vQ2hhaW5zfSxnZXROb2RlZFN1YnN0cmluZ3M6ZnVuY3Rpb24oKXtyZXR1cm4gS2UuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMubm9kZWRTZWdTdHJpbmdzKX0sZ2V0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbmRleH0sYWRkOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0kZS5nZXRDaGFpbnModC5nZXRDb29yZGluYXRlcygpLHQpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5zZXRJZCh0aGlzLmlkQ291bnRlcisrKSx0aGlzLmluZGV4Lmluc2VydChpLmdldEVudmVsb3BlKCksaSksdGhpcy5tb25vQ2hhaW5zLmFkZChpKX19LGNvbXB1dGVOb2RlczpmdW5jdGlvbih0KXt0aGlzLm5vZGVkU2VnU3RyaW5ncz10O2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTt0aGlzLmludGVyc2VjdENoYWlucygpfSxpbnRlcnNlY3RDaGFpbnM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IHJuKHRoaXMuc2VnSW50KSxlPXRoaXMubW9ub0NoYWlucy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT10aGlzLmluZGV4LnF1ZXJ5KG4uZ2V0RW52ZWxvcGUoKSkscj1pLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZihzLmdldElkKCk+bi5nZXRJZCgpJiYobi5jb21wdXRlT3ZlcmxhcHMocyx0KSx0aGlzLm5PdmVybGFwcysrKSx0aGlzLnNlZ0ludC5pc0RvbmUoKSlyZXR1cm4gbnVsbH19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5ufX0pLGgocm4sWmUpLGUocm4ucHJvdG90eXBlLHtvdmVybGFwOmZ1bmN0aW9uKCl7aWYoNCE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIFplLnByb3RvdHlwZS5vdmVybGFwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM10scj10LmdldENvbnRleHQoKSxzPW4uZ2V0Q29udGV4dCgpO3RoaXMuc2kucHJvY2Vzc0ludGVyc2VjdGlvbnMocixlLHMsaSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHJufX0pLG5uLlNlZ21lbnRPdmVybGFwQWN0aW9uPXJuLGgoc24sbCksZShzbi5wcm90b3R5cGUse2dldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gc259fSksc24ubXNnV2l0aENvb3JkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitlK1wiIF1cIjp0fSxlKG9uLnByb3RvdHlwZSx7cHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7fSxpc0RvbmU6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9ufX0pLGUoYW4ucHJvdG90eXBlLHtnZXRJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ufSxzZXRDaGVja0VuZFNlZ21lbnRzT25seTpmdW5jdGlvbih0KXt0aGlzLmlzQ2hlY2tFbmRTZWdtZW50c09ubHk9dH0sZ2V0SW50ZXJzZWN0aW9uU2VnbWVudHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRTZWdtZW50c30sY291bnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb25Db3VudH0sZ2V0SW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyc2VjdGlvbnN9LHNldEZpbmRBbGxJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQpe3RoaXMuZmluZEFsbEludGVyc2VjdGlvbnM9dH0sc2V0S2VlcEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCl7dGhpcy5rZWVwSW50ZXJzZWN0aW9ucz10fSxwcm9jZXNzSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXtpZighdGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucyYmdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4gbnVsbDtpZih0PT09biYmZT09PWkpcmV0dXJuIG51bGw7aWYodGhpcy5pc0NoZWNrRW5kU2VnbWVudHNPbmx5KXt2YXIgcj10aGlzLmlzRW5kU2VnbWVudCh0LGUpfHx0aGlzLmlzRW5kU2VnbWVudChuLGkpO2lmKCFyKXJldHVybiBudWxsfXZhciBzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxvPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLGE9bi5nZXRDb29yZGluYXRlcygpW2ldLHU9bi5nZXRDb29yZGluYXRlcygpW2krMV07dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHMsbyxhLHUpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMubGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpJiYodGhpcy5pbnRTZWdtZW50cz1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLmludFNlZ21lbnRzWzBdPXMsdGhpcy5pbnRTZWdtZW50c1sxXT1vLHRoaXMuaW50U2VnbWVudHNbMl09YSx0aGlzLmludFNlZ21lbnRzWzNdPXUsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbj10aGlzLmxpLmdldEludGVyc2VjdGlvbigwKSx0aGlzLmtlZXBJbnRlcnNlY3Rpb25zJiZ0aGlzLmludGVyc2VjdGlvbnMuYWRkKHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb24pLHRoaXMuaW50ZXJzZWN0aW9uQ291bnQrKyl9LGlzRW5kU2VnbWVudDpmdW5jdGlvbih0LGUpe3JldHVybiAwPT09ZT8hMDplPj10LnNpemUoKS0yfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb259LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPyExOm51bGwhPT10aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ufSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFufX0pLGFuLmNyZWF0ZUFsbEludGVyc2VjdGlvbnNGaW5kZXI9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFuKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlfSxhbi5jcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBhbih0KX0sYW4uY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgYW4odCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuc2V0S2VlcEludGVyc2VjdGlvbnMoITEpLGV9LGUodW4ucHJvdG90eXBlLHtleGVjdXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnNlZ0ludD9udWxsOnZvaWQgdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpfSxnZXRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnSW50LmdldEludGVyc2VjdGlvbnMoKX0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dGUoKSx0aGlzLl9pc1ZhbGlkfSxzZXRGaW5kQWxsSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0KXt0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9LGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7dGhpcy5faXNWYWxpZD0hMCx0aGlzLnNlZ0ludD1uZXcgYW4odGhpcy5saSksdGhpcy5zZWdJbnQuc2V0RmluZEFsbEludGVyc2VjdGlvbnModGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucyk7dmFyIHQ9bmV3IG5uO3JldHVybiB0LnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0aGlzLnNlZ0ludCksdC5jb21wdXRlTm9kZXModGhpcy5zZWdTdHJpbmdzKSx0aGlzLnNlZ0ludC5oYXNJbnRlcnNlY3Rpb24oKT8odGhpcy5faXNWYWxpZD0hMSxudWxsKTp2b2lkIDB9LGNoZWNrVmFsaWQ6ZnVuY3Rpb24oKXtpZih0aGlzLmV4ZWN1dGUoKSwhdGhpcy5faXNWYWxpZCl0aHJvdyBuZXcgc24odGhpcy5nZXRFcnJvck1lc3NhZ2UoKSx0aGlzLnNlZ0ludC5nZXRJbnRlcmlvckludGVyc2VjdGlvbigpKX0sZ2V0RXJyb3JNZXNzYWdlOmZ1bmN0aW9uKCl7aWYodGhpcy5faXNWYWxpZClyZXR1cm5cIm5vIGludGVyc2VjdGlvbnMgZm91bmRcIjt2YXIgdD10aGlzLnNlZ0ludC5nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpO3JldHVyblwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBiZXR3ZWVuIFwiK3NlLnRvTGluZVN0cmluZyh0WzBdLHRbMV0pK1wiIGFuZCBcIitzZS50b0xpbmVTdHJpbmcodFsyXSx0WzNdKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdW59fSksdW4uY29tcHV0ZUludGVyc2VjdGlvbnM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHVuKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLmlzVmFsaWQoKSxlLmdldEludGVyc2VjdGlvbnMoKX0sZShsbi5wcm90b3R5cGUse2NoZWNrVmFsaWQ6ZnVuY3Rpb24oKXt0aGlzLm52LmNoZWNrVmFsaWQoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbG59fSksbG4udG9TZWdtZW50U3RyaW5ncz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmFkZChuZXcgT2UoaS5nZXRDb29yZGluYXRlcygpLGkpKX1yZXR1cm4gZX0sbG4uY2hlY2tWYWxpZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgbG4odCk7ZS5jaGVja1ZhbGlkKCl9LGUoaG4ucHJvdG90eXBlLHttYXA6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dGhpcy5tYXBPcC5tYXAodC5nZXRHZW9tZXRyeU4obikpO2kuaXNFbXB0eSgpfHxlLmFkZChpKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheShlKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGhufX0pLGhuLm1hcD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBobihlKTtyZXR1cm4gbi5tYXAodCl9LGUoY24ucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjbn19KSxjbi5vcHBvc2l0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdD09PWNuLkxFRlQ/Y24uUklHSFQ6dD09PWNuLlJJR0hUP2NuLkxFRlQ6dH0sY24uT049MCxjbi5MRUZUPTEsY24uUklHSFQ9MixlKGZuLnByb3RvdHlwZSx7c2V0QWxsTG9jYXRpb25zOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09dH0saXNOdWxsOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XSE9PUwuTk9ORSlyZXR1cm4hMTtyZXR1cm4hMH0sc2V0QWxsTG9jYXRpb25zSWZOdWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09PT1MLk5PTkUmJih0aGlzLmxvY2F0aW9uW2VdPXQpfSxpc0xpbmU6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubG9jYXRpb24ubGVuZ3RofSxtZXJnZTpmdW5jdGlvbih0KXtpZih0LmxvY2F0aW9uLmxlbmd0aD50aGlzLmxvY2F0aW9uLmxlbmd0aCl7dmFyIGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7ZVtjbi5PTl09dGhpcy5sb2NhdGlvbltjbi5PTl0sZVtjbi5MRUZUXT1MLk5PTkUsZVtjbi5SSUdIVF09TC5OT05FLHRoaXMubG9jYXRpb249ZX1mb3IodmFyIG49MDtuPHRoaXMubG9jYXRpb24ubGVuZ3RoO24rKyl0aGlzLmxvY2F0aW9uW25dPT09TC5OT05FJiZuPHQubG9jYXRpb24ubGVuZ3RoJiYodGhpcy5sb2NhdGlvbltuXT10LmxvY2F0aW9uW25dKX0sZ2V0TG9jYXRpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG9jYXRpb259LGZsaXA6ZnVuY3Rpb24oKXtpZih0aGlzLmxvY2F0aW9uLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLmxvY2F0aW9uW2NuLkxFRlRdO3RoaXMubG9jYXRpb25bY24uTEVGVF09dGhpcy5sb2NhdGlvbltjbi5SSUdIVF0sdGhpcy5sb2NhdGlvbltjbi5SSUdIVF09dH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgUDtyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQoTC50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bY24uTEVGVF0pKSx0LmFwcGVuZChMLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltjbi5PTl0pKSx0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChMLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltjbi5SSUdIVF0pKSx0LnRvU3RyaW5nKCl9LHNldExvY2F0aW9uczpmdW5jdGlvbih0LGUsbil7dGhpcy5sb2NhdGlvbltjbi5PTl09dCx0aGlzLmxvY2F0aW9uW2NuLkxFRlRdPWUsdGhpcy5sb2NhdGlvbltjbi5SSUdIVF09bn0sZ2V0OmZ1bmN0aW9uKHQpe3JldHVybiB0PHRoaXMubG9jYXRpb24ubGVuZ3RoP3RoaXMubG9jYXRpb25bdF06TC5OT05FfSxpc0FyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MX0saXNBbnlOdWxsOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XT09PUwuTk9ORSlyZXR1cm4hMDtyZXR1cm4hMX0sc2V0TG9jYXRpb246ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TG9jYXRpb24oY24uT04sdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMubG9jYXRpb25bZV09bn19LGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5sb2NhdGlvbj1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLnNldEFsbExvY2F0aW9ucyhMLk5PTkUpfSxpc0VxdWFsT25TaWRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRpb25bZV09PT10LmxvY2F0aW9uW2VdfSxhbGxQb3NpdGlvbnNFcXVhbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKylpZih0aGlzLmxvY2F0aW9uW2VdIT09dClyZXR1cm4hMTtyZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZm59fSksZShnbi5wcm90b3R5cGUse2dldEdlb21ldHJ5Q291bnQ6ZnVuY3Rpb24oKXt2YXIgdD0wO3JldHVybiB0aGlzLmVsdFswXS5pc051bGwoKXx8dCsrLHRoaXMuZWx0WzFdLmlzTnVsbCgpfHx0KyssdH0sc2V0QWxsTG9jYXRpb25zOmZ1bmN0aW9uKHQsZSl7dGhpcy5lbHRbdF0uc2V0QWxsTG9jYXRpb25zKGUpfSxpc051bGw6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTnVsbCgpfSxzZXRBbGxMb2NhdGlvbnNJZk51bGw6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdCksdGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5lbHRbZV0uc2V0QWxsTG9jYXRpb25zSWZOdWxsKG4pfX0saXNMaW5lOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0xpbmUoKX0sbWVyZ2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7Mj5lO2UrKyludWxsPT09dGhpcy5lbHRbZV0mJm51bGwhPT10LmVsdFtlXT90aGlzLmVsdFtlXT1uZXcgZm4odC5lbHRbZV0pOnRoaXMuZWx0W2VdLm1lcmdlKHQuZWx0W2VdKX0sZmxpcDpmdW5jdGlvbigpe3RoaXMuZWx0WzBdLmZsaXAoKSx0aGlzLmVsdFsxXS5mbGlwKCl9LGdldExvY2F0aW9uOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uZ2V0KGNuLk9OKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmVsdFtlXS5nZXQobil9fSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3JldHVybiBudWxsIT09dGhpcy5lbHRbMF0mJih0LmFwcGVuZChcIkE6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzBdLnRvU3RyaW5nKCkpKSxudWxsIT09dGhpcy5lbHRbMV0mJih0LmFwcGVuZChcIiBCOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFsxXS50b1N0cmluZygpKSksdC50b1N0cmluZygpfSxpc0FyZWE6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5lbHRbMF0uaXNBcmVhKCl8fHRoaXMuZWx0WzFdLmlzQXJlYSgpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmlzQXJlYSgpfX0saXNBbnlOdWxsOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0FueU51bGwoKX0sc2V0TG9jYXRpb246ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0W3RdLnNldExvY2F0aW9uKGNuLk9OLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmVsdFtuXS5zZXRMb2NhdGlvbihpLHIpfX0saXNFcXVhbE9uU2lkZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVsdFswXS5pc0VxdWFsT25TaWRlKHQuZWx0WzBdLGUpJiZ0aGlzLmVsdFsxXS5pc0VxdWFsT25TaWRlKHQuZWx0WzFdLGUpfSxhbGxQb3NpdGlvbnNFcXVhbDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVsdFt0XS5hbGxQb3NpdGlvbnNFcXVhbChlKX0sdG9MaW5lOmZ1bmN0aW9uKHQpe3RoaXMuZWx0W3RdLmlzQXJlYSgpJiYodGhpcy5lbHRbdF09bmV3IGZuKHRoaXMuZWx0W3RdLmxvY2F0aW9uWzBdKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGdufX0pLGduLnRvTGluZUxhYmVsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgZ24oTC5OT05FKSxuPTA7Mj5uO24rKyllLnNldExvY2F0aW9uKG4sdC5nZXRMb2NhdGlvbihuKSk7cmV0dXJuIGV9LGUoZG4ucHJvdG90eXBlLHtjb21wdXRlUmluZzpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnJpbmcpcmV0dXJuIG51bGw7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLnB0cy5zaXplKCkpLmZpbGwobnVsbCksZT0wO2U8dGhpcy5wdHMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMucHRzLmdldChlKTt0aGlzLnJpbmc9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KSx0aGlzLl9pc0hvbGU9aGUuaXNDQ1codGhpcy5yaW5nLmdldENvb3JkaW5hdGVzKCkpfSxpc0lzb2xhdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLmxhYmVsLmdldEdlb21ldHJ5Q291bnQoKX0sY29tcHV0ZVBvaW50czpmdW5jdGlvbih0KXt0aGlzLnN0YXJ0RGU9dDt2YXIgZT10LG49ITA7ZG97aWYobnVsbD09PWUpdGhyb3cgbmV3IHNuKFwiRm91bmQgbnVsbCBEaXJlY3RlZEVkZ2VcIik7aWYoZS5nZXRFZGdlUmluZygpPT09dGhpcyl0aHJvdyBuZXcgc24oXCJEaXJlY3RlZCBFZGdlIHZpc2l0ZWQgdHdpY2UgZHVyaW5nIHJpbmctYnVpbGRpbmcgYXQgXCIrZS5nZXRDb29yZGluYXRlKCkpO3RoaXMuZWRnZXMuYWRkKGUpO3ZhciBpPWUuZ2V0TGFiZWwoKTtmLmlzVHJ1ZShpLmlzQXJlYSgpKSx0aGlzLm1lcmdlTGFiZWwoaSksdGhpcy5hZGRQb2ludHMoZS5nZXRFZGdlKCksZS5pc0ZvcndhcmQoKSxuKSxuPSExLHRoaXMuc2V0RWRnZVJpbmcoZSx0aGlzKSxlPXRoaXMuZ2V0TmV4dChlKX13aGlsZShlIT09dGhpcy5zdGFydERlKX0sZ2V0TGluZWFyUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJpbmd9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHRzLmdldCh0KX0sY29tcHV0ZU1heE5vZGVEZWdyZWU6ZnVuY3Rpb24oKXt0aGlzLm1heE5vZGVEZWdyZWU9MDt2YXIgdD10aGlzLnN0YXJ0RGU7ZG97dmFyIGU9dC5nZXROb2RlKCksbj1lLmdldEVkZ2VzKCkuZ2V0T3V0Z29pbmdEZWdyZWUodGhpcyk7bj50aGlzLm1heE5vZGVEZWdyZWUmJih0aGlzLm1heE5vZGVEZWdyZWU9biksdD10aGlzLmdldE5leHQodCl9d2hpbGUodCE9PXRoaXMuc3RhcnREZSk7dGhpcy5tYXhOb2RlRGVncmVlKj0yfSxhZGRQb2ludHM6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlKXt2YXIgcj0xO24mJihyPTApO2Zvcih2YXIgcz1yO3M8aS5sZW5ndGg7cysrKXRoaXMucHRzLmFkZChpW3NdKX1lbHNle3ZhciByPWkubGVuZ3RoLTI7biYmKHI9aS5sZW5ndGgtMSk7Zm9yKHZhciBzPXI7cz49MDtzLS0pdGhpcy5wdHMuYWRkKGlbc10pfX0saXNIb2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX0sc2V0SW5SZXN1bHQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN0YXJ0RGU7ZG8gdC5nZXRFZGdlKCkuc2V0SW5SZXN1bHQoITApLHQ9dC5nZXROZXh0KCk7d2hpbGUodCE9PXRoaXMuc3RhcnREZSl9LGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRMaW5lYXJSaW5nKCksbj1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighbi5jb250YWlucyh0KSlyZXR1cm4hMTtpZighaGUuaXNQb2ludEluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSkpcmV0dXJuITE7Zm9yKHZhciBpPXRoaXMuaG9sZXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2lmKHIuY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMX1yZXR1cm4hMH0sYWRkSG9sZTpmdW5jdGlvbih0KXt0aGlzLmhvbGVzLmFkZCh0KX0saXNTaGVsbDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5zaGVsbH0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sZ2V0TWF4Tm9kZURlZ3JlZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heE5vZGVEZWdyZWU8MCYmdGhpcy5jb21wdXRlTWF4Tm9kZURlZ3JlZSgpLHRoaXMubWF4Tm9kZURlZ3JlZX0sZ2V0U2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbH0sbWVyZ2VMYWJlbDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQsMCksdGhpcy5tZXJnZUxhYmVsKHQsMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9ZS5nZXRMb2NhdGlvbihuLGNuLlJJR0hUKTtpZihpPT09TC5OT05FKXJldHVybiBudWxsO2lmKHRoaXMubGFiZWwuZ2V0TG9jYXRpb24obik9PT1MLk5PTkUpcmV0dXJuIHRoaXMubGFiZWwuc2V0TG9jYXRpb24obixpKSxudWxsfX0sc2V0U2hlbGw6ZnVuY3Rpb24odCl7dGhpcy5zaGVsbD10LG51bGwhPT10JiZ0LmFkZEhvbGUodGhpcyl9LHRvUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHRoaXMuaG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpLG49MDtuPHRoaXMuaG9sZXMuc2l6ZSgpO24rKyllW25dPXRoaXMuaG9sZXMuZ2V0KG4pLmdldExpbmVhclJpbmcoKTt2YXIgaT10LmNyZWF0ZVBvbHlnb24odGhpcy5nZXRMaW5lYXJSaW5nKCksZSk7cmV0dXJuIGl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGRufX0pLGgocG4sZG4pLGUocG4ucHJvdG90eXBlLHtzZXRFZGdlUmluZzpmdW5jdGlvbih0LGUpe3Quc2V0TWluRWRnZVJpbmcoZSl9LGdldE5leHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0TmV4dE1pbigpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBwbn19KSxoKHZuLGRuKSxlKHZuLnByb3RvdHlwZSx7YnVpbGRNaW5pbWFsUmluZ3M6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSSxlPXRoaXMuc3RhcnREZTtkb3tpZihudWxsPT09ZS5nZXRNaW5FZGdlUmluZygpKXt2YXIgbj1uZXcgcG4oZSx0aGlzLmdlb21ldHJ5RmFjdG9yeSk7dC5hZGQobil9ZT1lLmdldE5leHQoKX13aGlsZShlIT09dGhpcy5zdGFydERlKTtyZXR1cm4gdH0sc2V0RWRnZVJpbmc6ZnVuY3Rpb24odCxlKXt0LnNldEVkZ2VSaW5nKGUpfSxsaW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3M6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN0YXJ0RGU7ZG97dmFyIGU9dC5nZXROb2RlKCk7ZS5nZXRFZGdlcygpLmxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0aGlzKSx0PXQuZ2V0TmV4dCgpfXdoaWxlKHQhPT10aGlzLnN0YXJ0RGUpfSxnZXROZXh0OmZ1bmN0aW9uKHQpe3JldHVybiB0LmdldE5leHQoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdm59fSksZShtbi5wcm90b3R5cGUse3NldFZpc2l0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNWaXNpdGVkPXR9LHNldEluUmVzdWx0OmZ1bmN0aW9uKHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH0saXNDb3ZlcmVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZH0saXNDb3ZlcmVkU2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZFNldH0sc2V0TGFiZWw6ZnVuY3Rpb24odCl7dGhpcy5sYWJlbD10fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxzZXRDb3ZlcmVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzQ292ZXJlZD10LHRoaXMuX2lzQ292ZXJlZFNldD0hMH0sdXBkYXRlSU06ZnVuY3Rpb24odCl7Zi5pc1RydWUodGhpcy5sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCk+PTIsXCJmb3VuZCBwYXJ0aWFsIGxhYmVsXCIpLHRoaXMuY29tcHV0ZUlNKHQpfSxpc0luUmVzdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9LGlzVmlzaXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1ufX0pLGgoeW4sbW4pLGUoeW4ucHJvdG90eXBlLHtpc0luY2lkZW50RWRnZUluUmVzdWx0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtpZihlLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpcmV0dXJuITB9cmV0dXJuITF9LGlzSXNvbGF0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmR9LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnRsbihcIm5vZGUgXCIrdGhpcy5jb29yZCtcIiBsYmw6IFwiK3RoaXMubGFiZWwpfSxjb21wdXRlSU06ZnVuY3Rpb24odCl7fSxjb21wdXRlTWVyZ2VkTG9jYXRpb246ZnVuY3Rpb24odCxlKXt2YXIgbj1MLk5PTkU7aWYobj10aGlzLmxhYmVsLmdldExvY2F0aW9uKGUpLCF0LmlzTnVsbChlKSl7dmFyIGk9dC5nZXRMb2NhdGlvbihlKTtuIT09TC5CT1VOREFSWSYmKG49aSl9cmV0dXJuIG59LHNldExhYmVsOmZ1bmN0aW9uKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG1uLnByb3RvdHlwZS5zZXRMYWJlbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLmxhYmVsP3RoaXMubGFiZWw9bmV3IGduKHQsZSk6dGhpcy5sYWJlbC5zZXRMb2NhdGlvbih0LGUpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzfSxtZXJnZUxhYmVsOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB5bil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VMYWJlbCh0LmxhYmVsKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ24pZm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPTA7Mj5uO24rKyl7dmFyIGk9dGhpcy5jb21wdXRlTWVyZ2VkTG9jYXRpb24oZSxuKSxyPXRoaXMubGFiZWwuZ2V0TG9jYXRpb24obik7cj09PUwuTk9ORSYmdGhpcy5sYWJlbC5zZXRMb2NhdGlvbihuLGkpfX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZXMuaW5zZXJ0KHQpLHQuc2V0Tm9kZSh0aGlzKX0sc2V0TGFiZWxCb3VuZGFyeTpmdW5jdGlvbih0KXtpZihudWxsPT09dGhpcy5sYWJlbClyZXR1cm4gbnVsbDt2YXIgZT1MLk5PTkU7bnVsbCE9PXRoaXMubGFiZWwmJihlPXRoaXMubGFiZWwuZ2V0TG9jYXRpb24odCkpO3ZhciBuPW51bGw7c3dpdGNoKGUpe2Nhc2UgTC5CT1VOREFSWTpuPUwuSU5URVJJT1I7YnJlYWs7Y2FzZSBMLklOVEVSSU9SOm49TC5CT1VOREFSWTticmVhaztkZWZhdWx0Om49TC5CT1VOREFSWX10aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsbil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHlufX0pLGUoeG4ucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZ2V0KHQpfSxhZGROb2RlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLm5vZGVNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09ZSYmKGU9dGhpcy5ub2RlRmFjdC5jcmVhdGVOb2RlKHQpLHRoaXMubm9kZU1hcC5wdXQodCxlKSksZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHluKXt2YXIgbj1hcmd1bWVudHNbMF0sZT10aGlzLm5vZGVNYXAuZ2V0KG4uZ2V0Q29vcmRpbmF0ZSgpKTtyZXR1cm4gbnVsbD09PWU/KHRoaXMubm9kZU1hcC5wdXQobi5nZXRDb29yZGluYXRlKCksbiksbik6KGUubWVyZ2VMYWJlbChuKSxlKX19LHByaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpfX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9LHZhbHVlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9LGdldEJvdW5kYXJ5Tm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpPT09TC5CT1VOREFSWSYmZS5hZGQoaSl9cmV0dXJuIGV9LGFkZDpmdW5jdGlvbih0KXt2YXIgZT10LmdldENvb3JkaW5hdGUoKSxuPXRoaXMuYWRkTm9kZShlKTtuLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geG59fSksZShFbi5wcm90b3R5cGUse2NvbXBhcmVEaXJlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZHg9PT10LmR4JiZ0aGlzLmR5PT09dC5keT8wOnRoaXMucXVhZHJhbnQ+dC5xdWFkcmFudD8xOnRoaXMucXVhZHJhbnQ8dC5xdWFkcmFudD8tMTpoZS5jb21wdXRlT3JpZW50YXRpb24odC5wMCx0LnAxLHRoaXMucDEpfSxnZXREeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmR5fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDB9LHNldE5vZGU6ZnVuY3Rpb24odCl7dGhpcy5ub2RlPXR9LHByaW50OmZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguYXRhbjIodGhpcy5keSx0aGlzLmR4KSxuPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksaT1uLmxhc3RJbmRleE9mKFwiLlwiKSxyPW4uc3Vic3RyaW5nKGkrMSk7dC5wcmludChcIiAgXCIrcitcIjogXCIrdGhpcy5wMCtcIiAtIFwiK3RoaXMucDErXCIgXCIrdGhpcy5xdWFkcmFudCtcIjpcIitlK1wiICAgXCIrdGhpcy5sYWJlbCl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9LGdldERpcmVjdGVkQ29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAxfSxnZXREeDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmR4fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZX0sZ2V0UXVhZHJhbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5xdWFkcmFudH0sZ2V0Tm9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGV9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9TWF0aC5hdGFuMih0aGlzLmR5LHRoaXMuZHgpLGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpLGk9ZS5zdWJzdHJpbmcobisxKTtyZXR1cm5cIiAgXCIraStcIjogXCIrdGhpcy5wMCtcIiAtIFwiK3RoaXMucDErXCIgXCIrdGhpcy5xdWFkcmFudCtcIjpcIit0K1wiICAgXCIrdGhpcy5sYWJlbH0sY29tcHV0ZUxhYmVsOmZ1bmN0aW9uKHQpe30saW5pdDpmdW5jdGlvbih0LGUpe3RoaXMucDA9dCx0aGlzLnAxPWUsdGhpcy5keD1lLngtdC54LHRoaXMuZHk9ZS55LXQueSx0aGlzLnF1YWRyYW50PUplLnF1YWRyYW50KHRoaXMuZHgsdGhpcy5keSksZi5pc1RydWUoISgwPT09dGhpcy5keCYmMD09PXRoaXMuZHkpLFwiRWRnZUVuZCB3aXRoIGlkZW50aWNhbCBlbmRwb2ludHMgZm91bmRcIil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFbn19KSxoKEluLEVuKSxlKEluLnByb3RvdHlwZSx7Z2V0TmV4dE1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHRNaW59LGdldERlcHRoOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRlcHRoW3RdfSxzZXRWaXNpdGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzVmlzaXRlZD10fSxjb21wdXRlRGlyZWN0ZWRMYWJlbDpmdW5jdGlvbigpe3RoaXMubGFiZWw9bmV3IGduKHRoaXMuZWRnZS5nZXRMYWJlbCgpKSx0aGlzLl9pc0ZvcndhcmR8fHRoaXMubGFiZWwuZmxpcCgpfSxnZXROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dH0sc2V0RGVwdGg6ZnVuY3Rpb24odCxlKXtpZigtOTk5IT09dGhpcy5kZXB0aFt0XSYmdGhpcy5kZXB0aFt0XSE9PWUpdGhyb3cgbmV3IHNuKFwiYXNzaWduZWQgZGVwdGhzIGRvIG5vdCBtYXRjaFwiLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTt0aGlzLmRlcHRoW3RdPWV9LGlzSW50ZXJpb3JBcmVhRWRnZTpmdW5jdGlvbiB0KCl7Zm9yKHZhciB0PSEwLGU9MDsyPmU7ZSsrKXRoaXMubGFiZWwuaXNBcmVhKGUpJiZ0aGlzLmxhYmVsLmdldExvY2F0aW9uKGUsY24uTEVGVCk9PT1MLklOVEVSSU9SJiZ0aGlzLmxhYmVsLmdldExvY2F0aW9uKGUsY24uUklHSFQpPT09TC5JTlRFUklPUnx8KHQ9ITEpO3JldHVybiB0fSxzZXROZXh0TWluOmZ1bmN0aW9uKHQpe3RoaXMubmV4dE1pbj10fSxwcmludDpmdW5jdGlvbih0KXtFbi5wcm90b3R5cGUucHJpbnQuY2FsbCh0aGlzLHQpLHQucHJpbnQoXCIgXCIrdGhpcy5kZXB0aFtjbi5MRUZUXStcIi9cIit0aGlzLmRlcHRoW2NuLlJJR0hUXSksdC5wcmludChcIiAoXCIrdGhpcy5nZXREZXB0aERlbHRhKCkrXCIpXCIpLHRoaXMuX2lzSW5SZXN1bHQmJnQucHJpbnQoXCIgaW5SZXN1bHRcIil9LHNldE1pbkVkZ2VSaW5nOmZ1bmN0aW9uKHQpe3RoaXMubWluRWRnZVJpbmc9dH0saXNMaW5lRWRnZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGFiZWwuaXNMaW5lKDApfHx0aGlzLmxhYmVsLmlzTGluZSgxKSxlPSF0aGlzLmxhYmVsLmlzQXJlYSgwKXx8dGhpcy5sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgwLEwuRVhURVJJT1IpLG49IXRoaXMubGFiZWwuaXNBcmVhKDEpfHx0aGlzLmxhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDEsTC5FWFRFUklPUik7cmV0dXJuIHQmJmUmJm59LHNldEVkZ2VSaW5nOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZVJpbmc9dH0sZ2V0TWluRWRnZVJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW5FZGdlUmluZ30sZ2V0RGVwdGhEZWx0YTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWRnZS5nZXREZXB0aERlbHRhKCk7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZHx8KHQ9LXQpLHR9LHNldEluUmVzdWx0OmZ1bmN0aW9uKHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH0sZ2V0U3ltOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltfSxpc0ZvcndhcmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZX0scHJpbnRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMucHJpbnQodCksdC5wcmludChcIiBcIiksdGhpcy5faXNGb3J3YXJkP3RoaXMuZWRnZS5wcmludCh0KTp0aGlzLmVkZ2UucHJpbnRSZXZlcnNlKHQpfSxzZXRTeW06ZnVuY3Rpb24odCl7dGhpcy5zeW09dH0sc2V0VmlzaXRlZEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5zZXRWaXNpdGVkKHQpLHRoaXMuc3ltLnNldFZpc2l0ZWQodCl9LHNldEVkZ2VEZXB0aHM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEVkZ2UoKS5nZXREZXB0aERlbHRhKCk7dGhpcy5faXNGb3J3YXJkfHwobj0tbik7dmFyIGk9MTt0PT09Y24uTEVGVCYmKGk9LTEpO3ZhciByPWNuLm9wcG9zaXRlKHQpLHM9bippLG89ZStzO3RoaXMuc2V0RGVwdGgodCxlKSx0aGlzLnNldERlcHRoKHIsbyl9LGdldEVkZ2VSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZVJpbmd9LGlzSW5SZXN1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH0sc2V0TmV4dDpmdW5jdGlvbih0KXt0aGlzLm5leHQ9dH0saXNWaXNpdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSW59fSksSW4uZGVwdGhGYWN0b3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PUwuRVhURVJJT1ImJmU9PT1MLklOVEVSSU9SPzE6dD09PUwuSU5URVJJT1ImJmU9PT1MLkVYVEVSSU9SPy0xOjB9LGUoTm4ucHJvdG90eXBlLHtjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgeW4odCxudWxsKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTm59fSksZShDbi5wcm90b3R5cGUse3ByaW50RWRnZXM6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiRWRnZXM6XCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlcy5zaXplKCk7ZSsrKXt0LnByaW50bG4oXCJlZGdlIFwiK2UrXCI6XCIpO3ZhciBuPXRoaXMuZWRnZXMuZ2V0KGUpO24ucHJpbnQodCksbi5laUxpc3QucHJpbnQodCl9fSxmaW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVzLmZpbmQodCl9LGFkZE5vZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHluKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubm9kZXMuYWRkTm9kZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5ub2Rlcy5hZGROb2RlKGUpfX0sZ2V0Tm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXMuaXRlcmF0b3IoKX0sbGlua1Jlc3VsdERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fSxkZWJ1Z1ByaW50bG46ZnVuY3Rpb24odCl7QS5vdXQucHJpbnRsbih0KX0saXNCb3VuZGFyeU5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm5vZGVzLmZpbmQoZSk7aWYobnVsbD09PW4pcmV0dXJuITE7dmFyIGk9bi5nZXRMYWJlbCgpO3JldHVybiBudWxsIT09aSYmaS5nZXRMb2NhdGlvbih0KT09PUwuQk9VTkRBUll9LGxpbmtBbGxEaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5saW5rQWxsRGlyZWN0ZWRFZGdlcygpfX0sbWF0Y2hJblNhbWVEaXJlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIHQuZXF1YWxzKG4pP2hlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsaSk9PT1oZS5DT0xMSU5FQVImJkplLnF1YWRyYW50KHQsZSk9PT1KZS5xdWFkcmFudChuLGkpOiExfSxnZXRFZGdlRW5kczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VFbmRMaXN0fSxkZWJ1Z1ByaW50OmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50KHQpfSxnZXRFZGdlSXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlcy5pdGVyYXRvcigpfSxmaW5kRWRnZUluU2FtZURpcmVjdGlvbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5lZGdlcy5zaXplKCk7bisrKXt2YXIgaT10aGlzLmVkZ2VzLmdldChuKSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxyWzBdLHJbMV0pKXJldHVybiBpO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLHJbci5sZW5ndGgtMV0scltyLmxlbmd0aC0yXSkpcmV0dXJuIGl9cmV0dXJuIG51bGx9LGluc2VydEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5lZGdlcy5hZGQodCl9LGZpbmRFZGdlRW5kOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKG4uZ2V0RWRnZSgpPT09dClyZXR1cm4gbn1yZXR1cm4gbnVsbH0sYWRkRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuZWRnZXMuYWRkKG4pO3ZhciBpPW5ldyBJbihuLCEwKSxyPW5ldyBJbihuLCExKTtpLnNldFN5bShyKSxyLnNldFN5bShpKSx0aGlzLmFkZChpKSx0aGlzLmFkZChyKX19LGFkZDpmdW5jdGlvbih0KXt0aGlzLm5vZGVzLmFkZCh0KSx0aGlzLmVkZ2VFbmRMaXN0LmFkZCh0KX0sZ2V0Tm9kZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlcy52YWx1ZXMoKX0sZmluZEVkZ2U6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHRoaXMuZWRnZXMuc2l6ZSgpO24rKyl7dmFyIGk9dGhpcy5lZGdlcy5nZXQobikscj1pLmdldENvb3JkaW5hdGVzKCk7aWYodC5lcXVhbHMoclswXSkmJmUuZXF1YWxzKHJbMV0pKXJldHVybiBpfXJldHVybiBudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDbn19KSxDbi5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fSxlKFNuLnByb3RvdHlwZSx7c29ydFNoZWxsc0FuZEhvbGVzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc0hvbGUoKT9uLmFkZChyKTplLmFkZChyKX19LGNvbXB1dGVQb2x5Z29uczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkudG9Qb2x5Z29uKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZChyKX1yZXR1cm4gZX0scGxhY2VGcmVlSG9sZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYobnVsbD09PWkuZ2V0U2hlbGwoKSl7dmFyIHI9dGhpcy5maW5kRWRnZVJpbmdDb250YWluaW5nKGksdCk7aWYobnVsbD09PXIpdGhyb3cgbmV3IHNuKFwidW5hYmxlIHRvIGFzc2lnbiBob2xlIHRvIGEgc2hlbGxcIixpLmdldENvb3JkaW5hdGUoMCkpO2kuc2V0U2hlbGwocil9fX0sYnVpbGRNaW5pbWFsRWRnZVJpbmdzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bmV3IEkscj10Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZihzLmdldE1heE5vZGVEZWdyZWUoKT4yKXtzLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO3ZhciBvPXMuYnVpbGRNaW5pbWFsUmluZ3MoKSxhPXRoaXMuZmluZFNoZWxsKG8pO251bGwhPT1hPyh0aGlzLnBsYWNlUG9seWdvbkhvbGVzKGEsbyksZS5hZGQoYSkpOm4uYWRkQWxsKG8pfWVsc2UgaS5hZGQocyl9cmV0dXJuIGl9LGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuc2hlbGxMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZihuLmNvbnRhaW5zUG9pbnQodCkpcmV0dXJuITB9cmV0dXJuITF9LGJ1aWxkTWF4aW1hbEVkZ2VSaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmlzSW5SZXN1bHQoKSYmaS5nZXRMYWJlbCgpLmlzQXJlYSgpJiZudWxsPT09aS5nZXRFZGdlUmluZygpKXt2YXIgcj1uZXcgdm4oaSx0aGlzLmdlb21ldHJ5RmFjdG9yeSk7ZS5hZGQociksci5zZXRJblJlc3VsdCgpfX1yZXR1cm4gZX0scGxhY2VQb2x5Z29uSG9sZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5pc0hvbGUoKSYmaS5zZXRTaGVsbCh0KX19LGdldFBvbHlnb25zOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb21wdXRlUG9seWdvbnModGhpcy5zaGVsbExpc3QpO3JldHVybiB0fSxmaW5kRWRnZVJpbmdDb250YWluaW5nOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0TGluZWFyUmluZygpLGk9bi5nZXRFbnZlbG9wZUludGVybmFsKCkscj1uLmdldENvb3JkaW5hdGVOKDApLHM9bnVsbCxvPW51bGwsYT1lLml0ZXJhdG9yKCk7YS5oYXNOZXh0KCk7KXt2YXIgdT1hLm5leHQoKSxsPXUuZ2V0TGluZWFyUmluZygpLGg9bC5nZXRFbnZlbG9wZUludGVybmFsKCk7bnVsbCE9PXMmJihvPXMuZ2V0TGluZWFyUmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7dmFyIGM9ITE7aC5jb250YWlucyhpKSYmaGUuaXNQb2ludEluUmluZyhyLGwuZ2V0Q29vcmRpbmF0ZXMoKSkmJihjPSEwKSxjJiYobnVsbD09PXN8fG8uY29udGFpbnMoaCkpJiYocz11KX1yZXR1cm4gc30sZmluZFNoZWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49bnVsbCxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuaXNIb2xlKCl8fChuPXIsZSsrKX1yZXR1cm4gZi5pc1RydWUoMT49ZSxcImZvdW5kIHR3byBzaGVsbHMgaW4gTWluaW1hbEVkZ2VSaW5nIGxpc3RcIiksbn0sYWRkOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0LmdldEVkZ2VFbmRzKCksdC5nZXROb2RlcygpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07Q24ubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMobik7dmFyIGk9dGhpcy5idWlsZE1heGltYWxFZGdlUmluZ3MoZSkscj1uZXcgSSxzPXRoaXMuYnVpbGRNaW5pbWFsRWRnZVJpbmdzKGksdGhpcy5zaGVsbExpc3Qscik7dGhpcy5zb3J0U2hlbGxzQW5kSG9sZXMocyx0aGlzLnNoZWxsTGlzdCxyKSx0aGlzLnBsYWNlRnJlZUhvbGVzKHRoaXMuc2hlbGxMaXN0LHIpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU259fSksZSh3bi5wcm90b3R5cGUse2NvbGxlY3RMaW5lczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuY29sbGVjdExpbmVFZGdlKG4sdCx0aGlzLmxpbmVFZGdlc0xpc3QpLHRoaXMuY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKG4sdCx0aGlzLmxpbmVFZGdlc0xpc3QpfX0sbGFiZWxJc29sYXRlZExpbmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5vcC5nZXRBcmdHZW9tZXRyeShlKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9LGJ1aWxkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCksdGhpcy5jb2xsZWN0TGluZXModCksdGhpcy5idWlsZExpbmVzKHQpLHRoaXMucmVzdWx0TGluZUxpc3R9LGNvbGxlY3RMaW5lRWRnZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRMYWJlbCgpLHI9dC5nZXRFZGdlKCk7dC5pc0xpbmVFZGdlKCkmJih0LmlzVmlzaXRlZCgpfHwhaWkuaXNSZXN1bHRPZk9wKGksZSl8fHIuaXNDb3ZlcmVkKCl8fChuLmFkZChyKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpfSxmaW5kQ292ZXJlZExpbmVFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm9wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl9Zm9yKHZhciBuPXRoaXMub3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0RWRnZSgpO2lmKGkuaXNMaW5lRWRnZSgpJiYhci5pc0NvdmVyZWRTZXQoKSl7dmFyIHM9dGhpcy5vcC5pc0NvdmVyZWRCeUEoaS5nZXRDb29yZGluYXRlKCkpO3Iuc2V0Q292ZXJlZChzKX19fSxsYWJlbElzb2xhdGVkTGluZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpO24uaXNJc29sYXRlZCgpJiYoaS5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTGluZShuLDApOnRoaXMubGFiZWxJc29sYXRlZExpbmUobiwxKSl9fSxidWlsZExpbmVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmxpbmVFZGdlc0xpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9KG4uZ2V0TGFiZWwoKSx0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4uZ2V0Q29vcmRpbmF0ZXMoKSkpO3RoaXMucmVzdWx0TGluZUxpc3QuYWRkKGkpLG4uc2V0SW5SZXN1bHQoITApfX0sY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldExhYmVsKCk7cmV0dXJuIHQuaXNMaW5lRWRnZSgpP251bGw6dC5pc1Zpc2l0ZWQoKT9udWxsOnQuaXNJbnRlcmlvckFyZWFFZGdlKCk/bnVsbDp0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCk/bnVsbDooZi5pc1RydWUoISh0LmlzSW5SZXN1bHQoKXx8dC5nZXRTeW0oKS5pc0luUmVzdWx0KCkpfHwhdC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKSx2b2lkKGlpLmlzUmVzdWx0T2ZPcChpLGUpJiZlPT09aWkuSU5URVJTRUNUSU9OJiYobi5hZGQodC5nZXRFZGdlKCkpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3bn19KSxlKExuLnByb3RvdHlwZSx7ZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKCF0aGlzLm9wLmlzQ292ZXJlZEJ5TEEoZSkpe3ZhciBuPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGUpO3RoaXMucmVzdWx0UG9pbnRMaXN0LmFkZChuKX19LGV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMub3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZighKG4uaXNJblJlc3VsdCgpfHxuLmlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKXx8MCE9PW4uZ2V0RWRnZXMoKS5nZXREZWdyZWUoKSYmdCE9PWlpLklOVEVSU0VDVElPTikpe3ZhciBpPW4uZ2V0TGFiZWwoKTtpaS5pc1Jlc3VsdE9mT3AoaSx0KSYmdGhpcy5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQobil9fX0sYnVpbGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2Rlcyh0KSx0aGlzLnJlc3VsdFBvaW50TGlzdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTG59fSksZShSbi5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJufX0pLGUoVG4ucHJvdG90eXBlLHtsb2NhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIFRuLmxvY2F0ZSh0LHRoaXMuZ2VvbSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1JuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVG59fSksVG4uaXNQb2ludEluUmluZz1mdW5jdGlvbih0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP2hlLmlzUG9pbnRJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOiExfSxUbi5jb250YWluc1BvaW50SW5Qb2x5Z29uPWZ1bmN0aW9uKHQsZSl7aWYoZS5pc0VtcHR5KCkpcmV0dXJuITE7dmFyIG49ZS5nZXRFeHRlcmlvclJpbmcoKTtpZighVG4uaXNQb2ludEluUmluZyh0LG4pKXJldHVybiExO2Zvcih2YXIgaT0wO2k8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtpKyspe3ZhciByPWUuZ2V0SW50ZXJpb3JSaW5nTihpKTtpZihUbi5pc1BvaW50SW5SaW5nKHQscikpcmV0dXJuITF9cmV0dXJuITB9LFRuLmNvbnRhaW5zUG9pbnQ9ZnVuY3Rpb24odCxlKXtpZihlIGluc3RhbmNlb2YgVHQpcmV0dXJuIFRuLmNvbnRhaW5zUG9pbnRJblBvbHlnb24odCxlKTtpZihlIGluc3RhbmNlb2YgZnQpZm9yKHZhciBuPW5ldyBSZShlKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkhPT1lJiZUbi5jb250YWluc1BvaW50KHQsaSkpcmV0dXJuITB9cmV0dXJuITF9LFRuLmxvY2F0ZT1mdW5jdGlvbih0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9MLkVYVEVSSU9SOlRuLmNvbnRhaW5zUG9pbnQodCxlKT9MLklOVEVSSU9SOkwuRVhURVJJT1J9LGUoUG4ucHJvdG90eXBlLHtnZXROZXh0Q1c6ZnVuY3Rpb24odCl7dGhpcy5nZXRFZGdlcygpO3ZhciBlPXRoaXMuZWRnZUxpc3QuaW5kZXhPZih0KSxuPWUtMTtyZXR1cm4gMD09PWUmJihuPXRoaXMuZWRnZUxpc3Quc2l6ZSgpLTEpLHRoaXMuZWRnZUxpc3QuZ2V0KG4pfSxwcm9wYWdhdGVTaWRlTGFiZWxzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1MLk5PTkUsbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKTtyLmlzQXJlYSh0KSYmci5nZXRMb2NhdGlvbih0LGNuLkxFRlQpIT09TC5OT05FJiYoZT1yLmdldExvY2F0aW9uKHQsY24uTEVGVCkpfWlmKGU9PT1MLk5PTkUpcmV0dXJuIG51bGw7Zm9yKHZhciBzPWUsbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKTtpZihyLmdldExvY2F0aW9uKHQsY24uT04pPT09TC5OT05FJiZyLnNldExvY2F0aW9uKHQsY24uT04scyksci5pc0FyZWEodCkpe3ZhciBvPXIuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSxhPXIuZ2V0TG9jYXRpb24odCxjbi5SSUdIVCk7aWYoYSE9PUwuTk9ORSl7aWYoYSE9PXMpdGhyb3cgbmV3IHNuKFwic2lkZSBsb2NhdGlvbiBjb25mbGljdFwiLGkuZ2V0Q29vcmRpbmF0ZSgpKTtvPT09TC5OT05FJiZmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZSAoYXQgXCIraS5nZXRDb29yZGluYXRlKCkrXCIpXCIpLHM9b31lbHNlIGYuaXNUcnVlKHIuZ2V0TG9jYXRpb24odCxjbi5MRUZUKT09PUwuTk9ORSxcImZvdW5kIHNpbmdsZSBudWxsIHNpZGVcIiksci5zZXRMb2NhdGlvbih0LGNuLlJJR0hULHMpLHIuc2V0TG9jYXRpb24odCxjbi5MRUZULHMpfX19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLml0ZXJhdG9yKCk7aWYoIXQuaGFzTmV4dCgpKXJldHVybiBudWxsO3ZhciBlPXQubmV4dCgpO3JldHVybiBlLmdldENvb3JkaW5hdGUoKX0scHJpbnQ6ZnVuY3Rpb24odCl7QS5vdXQucHJpbnRsbihcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KX19LGlzQXJlYUxhYmVsc0NvbnNpc3RlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModC5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMuY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCgwKX0sY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEVkZ2VzKCk7aWYoZS5zaXplKCk8PTApcmV0dXJuITA7dmFyIG49ZS5zaXplKCktMSxpPWUuZ2V0KG4pLmdldExhYmVsKCkscj1pLmdldExvY2F0aW9uKHQsY24uTEVGVCk7Zi5pc1RydWUociE9PUwuTk9ORSxcIkZvdW5kIHVubGFiZWxsZWQgYXJlYSBlZGdlXCIpO2Zvcih2YXIgcz1yLG89dGhpcy5pdGVyYXRvcigpO28uaGFzTmV4dCgpOyl7dmFyIGE9by5uZXh0KCksdT1hLmdldExhYmVsKCk7XG5mLmlzVHJ1ZSh1LmlzQXJlYSh0KSxcIkZvdW5kIG5vbi1hcmVhIGVkZ2VcIik7dmFyIGw9dS5nZXRMb2NhdGlvbih0LGNuLkxFRlQpLGg9dS5nZXRMb2NhdGlvbih0LGNuLlJJR0hUKTtpZihsPT09aClyZXR1cm4hMTtpZihoIT09cylyZXR1cm4hMTtzPWx9cmV0dXJuITB9LGZpbmRJbmRleDpmdW5jdGlvbih0KXt0aGlzLml0ZXJhdG9yKCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2VMaXN0LnNpemUoKTtlKyspe3ZhciBuPXRoaXMuZWRnZUxpc3QuZ2V0KGUpO2lmKG49PT10KXJldHVybiBlfXJldHVybi0xfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEVkZ2VzKCkuaXRlcmF0b3IoKX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuZWRnZUxpc3QmJih0aGlzLmVkZ2VMaXN0PW5ldyBJKHRoaXMuZWRnZU1hcC52YWx1ZXMoKSkpLHRoaXMuZWRnZUxpc3R9LGdldExvY2F0aW9uOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5wdEluQXJlYUxvY2F0aW9uW3RdPT09TC5OT05FJiYodGhpcy5wdEluQXJlYUxvY2F0aW9uW3RdPVRuLmxvY2F0ZShlLG5bdF0uZ2V0R2VvbWV0cnkoKSkpLHRoaXMucHRJbkFyZWFMb2NhdGlvblt0XX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgUDt0LmFwcGVuZChcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKSx0LmFwcGVuZChcIlxcblwiKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dC5hcHBlbmQobiksdC5hcHBlbmQoXCJcXG5cIil9cmV0dXJuIHQudG9TdHJpbmcoKX0sY29tcHV0ZUVkZ2VFbmRMYWJlbHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uY29tcHV0ZUxhYmVsKHQpfX0sY29tcHV0ZUxhYmVsbGluZzpmdW5jdGlvbih0KXt0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKHRbMF0uZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKSx0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMCksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDEpO2Zvcih2YXIgZT1bITEsITFdLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOylmb3IodmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCkscz0wOzI+cztzKyspci5pc0xpbmUocykmJnIuZ2V0TG9jYXRpb24ocyk9PT1MLkJPVU5EQVJZJiYoZVtzXT0hMCk7Zm9yKHZhciBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZm9yKHZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpLHM9MDsyPnM7cysrKWlmKHIuaXNBbnlOdWxsKHMpKXt2YXIgbz1MLk5PTkU7aWYoZVtzXSlvPUwuRVhURVJJT1I7ZWxzZXt2YXIgYT1pLmdldENvb3JkaW5hdGUoKTtvPXRoaXMuZ2V0TG9jYXRpb24ocyxhLHQpfXIuc2V0QWxsTG9jYXRpb25zSWZOdWxsKHMsbyl9fSxnZXREZWdyZWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlTWFwLnNpemUoKX0saW5zZXJ0RWRnZUVuZDpmdW5jdGlvbih0LGUpe3RoaXMuZWRnZU1hcC5wdXQodCxlKSx0aGlzLmVkZ2VMaXN0PW51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFBufX0pLGgoYm4sUG4pLGUoYm4ucHJvdG90eXBlLHtsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlczpmdW5jdGlvbigpe3RoaXMuZ2V0UmVzdWx0QXJlYUVkZ2VzKCk7Zm9yKHZhciB0PW51bGwsZT1udWxsLG49dGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkcsaT0wO2k8dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpO2krKyl7dmFyIHI9dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KGkpLHM9ci5nZXRTeW0oKTtpZihyLmdldExhYmVsKCkuaXNBcmVhKCkpc3dpdGNoKG51bGw9PT10JiZyLmlzSW5SZXN1bHQoKSYmKHQ9ciksbil7Y2FzZSB0aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlORzppZighcy5pc0luUmVzdWx0KCkpY29udGludWU7ZT1zLG49dGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HOmlmKCFyLmlzSW5SZXN1bHQoKSljb250aW51ZTtlLnNldE5leHQociksbj10aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlOR319aWYobj09PXRoaXMuTElOS0lOR19UT19PVVRHT0lORyl7aWYobnVsbD09PXQpdGhyb3cgbmV3IHNuKFwibm8gb3V0Z29pbmcgZGlyRWRnZSBmb3VuZFwiLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmLmlzVHJ1ZSh0LmlzSW5SZXN1bHQoKSxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxlLnNldE5leHQodCl9fSxpbnNlcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dDt0aGlzLmluc2VydEVkZ2VFbmQoZSxlKX0sZ2V0UmlnaHRtb3N0RWRnZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0RWRnZXMoKSxlPXQuc2l6ZSgpO2lmKDE+ZSlyZXR1cm4gbnVsbDt2YXIgbj10LmdldCgwKTtpZigxPT09ZSlyZXR1cm4gbjt2YXIgaT10LmdldChlLTEpLHI9bi5nZXRRdWFkcmFudCgpLHM9aS5nZXRRdWFkcmFudCgpO2lmKEplLmlzTm9ydGhlcm4ocikmJkplLmlzTm9ydGhlcm4ocykpcmV0dXJuIG47aWYoIUplLmlzTm9ydGhlcm4ocikmJiFKZS5pc05vcnRoZXJuKHMpKXJldHVybiBpO3JldHVybiAwIT09bi5nZXREeSgpP246MCE9PWkuZ2V0RHkoKT9pOihmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgdHdvIGhvcml6b250YWwgZWRnZXMgaW5jaWRlbnQgb24gbm9kZVwiKSxudWxsKX0scHJpbnQ6ZnVuY3Rpb24odCl7QS5vdXQucHJpbnRsbihcIkRpcmVjdGVkRWRnZVN0YXI6IFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dC5wcmludChcIm91dCBcIiksbi5wcmludCh0KSx0LnByaW50bG4oKSx0LnByaW50KFwiaW4gXCIpLG4uZ2V0U3ltKCkucHJpbnQodCksdC5wcmludGxuKCl9fSxnZXRSZXN1bHRBcmVhRWRnZXM6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3QpcmV0dXJuIHRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0O3RoaXMucmVzdWx0QXJlYUVkZ2VMaXN0PW5ldyBJO2Zvcih2YXIgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTsoZS5pc0luUmVzdWx0KCl8fGUuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKSYmdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3QuYWRkKGUpfXJldHVybiB0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdH0sdXBkYXRlTGFiZWxsaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKTtpLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLHQuZ2V0TG9jYXRpb24oMCkpLGkuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsdC5nZXRMb2NhdGlvbigxKSl9fSxsaW5rQWxsRGlyZWN0ZWRFZGdlczpmdW5jdGlvbigpe3RoaXMuZ2V0RWRnZXMoKTtmb3IodmFyIHQ9bnVsbCxlPW51bGwsbj10aGlzLmVkZ2VMaXN0LnNpemUoKS0xO24+PTA7bi0tKXt2YXIgaT10aGlzLmVkZ2VMaXN0LmdldChuKSxyPWkuZ2V0U3ltKCk7bnVsbD09PWUmJihlPXIpLG51bGwhPT10JiZyLnNldE5leHQodCksdD1pfWUuc2V0TmV4dCh0KX0sY29tcHV0ZURlcHRoczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLmZpbmRJbmRleCh0KSxuPSh0LmdldExhYmVsKCksdC5nZXREZXB0aChjbi5MRUZUKSksaT10LmdldERlcHRoKGNuLlJJR0hUKSxyPXRoaXMuY29tcHV0ZURlcHRocyhlKzEsdGhpcy5lZGdlTGlzdC5zaXplKCksbikscz10aGlzLmNvbXB1dGVEZXB0aHMoMCxlLHIpO2lmKHMhPT1pKXRocm93IG5ldyBzbihcImRlcHRoIG1pc21hdGNoIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YXJndW1lbnRzWzJdLGw9dSxoPW87YT5oO2grKyl7dmFyIGM9dGhpcy5lZGdlTGlzdC5nZXQoaCk7Yy5nZXRMYWJlbCgpO2Muc2V0RWRnZURlcHRocyhjbi5SSUdIVCxsKSxsPWMuZ2V0RGVwdGgoY24uTEVGVCl9cmV0dXJuIGx9fSxtZXJnZVN5bUxhYmVsczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKTtuLm1lcmdlKGUuZ2V0U3ltKCkuZ2V0TGFiZWwoKSl9fSxsaW5rTWluaW1hbERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj1udWxsLGk9dGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkcscj10aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCktMTtyPj0wO3ItLSl7dmFyIHM9dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KHIpLG89cy5nZXRTeW0oKTtzd2l0Y2gobnVsbD09PWUmJnMuZ2V0RWRnZVJpbmcoKT09PXQmJihlPXMpLGkpe2Nhc2UgdGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoby5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuPW8saT10aGlzLkxJTktJTkdfVE9fT1VUR09JTkc7YnJlYWs7Y2FzZSB0aGlzLkxJTktJTkdfVE9fT1VUR09JTkc6aWYocy5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuLnNldE5leHRNaW4ocyksaT10aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlOR319aT09PXRoaXMuTElOS0lOR19UT19PVVRHT0lORyYmKGYuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBmb3IgZmlyc3Qgb3V0Z29pbmcgZGlyRWRnZVwiKSxmLmlzVHJ1ZShlLmdldEVkZ2VSaW5nKCk9PT10LFwidW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlXCIpLG4uc2V0TmV4dE1pbihlKSl9LGdldE91dGdvaW5nRGVncmVlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD0wLGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5pc0luUmVzdWx0KCkmJnQrK31yZXR1cm4gdH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSx0PTAsZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmdldEVkZ2VSaW5nKCk9PT1pJiZ0Kyt9cmV0dXJuIHR9fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxmaW5kQ292ZXJlZExpbmVFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1MLk5PTkUsZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0U3ltKCk7aWYoIW4uaXNMaW5lRWRnZSgpKXtpZihuLmlzSW5SZXN1bHQoKSl7dD1MLklOVEVSSU9SO2JyZWFrfWlmKGkuaXNJblJlc3VsdCgpKXt0PUwuRVhURVJJT1I7YnJlYWt9fX1pZih0PT09TC5OT05FKXJldHVybiBudWxsO2Zvcih2YXIgcj10LGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldFN5bSgpO24uaXNMaW5lRWRnZSgpP24uZ2V0RWRnZSgpLnNldENvdmVyZWQocj09PUwuSU5URVJJT1IpOihuLmlzSW5SZXN1bHQoKSYmKHI9TC5FWFRFUklPUiksaS5pc0luUmVzdWx0KCkmJihyPUwuSU5URVJJT1IpKX19LGNvbXB1dGVMYWJlbGxpbmc6ZnVuY3Rpb24odCl7UG4ucHJvdG90eXBlLmNvbXB1dGVMYWJlbGxpbmcuY2FsbCh0aGlzLHQpLHRoaXMubGFiZWw9bmV3IGduKEwuTk9ORSk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRFZGdlKCkscj1pLmdldExhYmVsKCkscz0wOzI+cztzKyspe3ZhciBvPXIuZ2V0TG9jYXRpb24ocyk7byE9PUwuSU5URVJJT1ImJm8hPT1MLkJPVU5EQVJZfHx0aGlzLmxhYmVsLnNldExvY2F0aW9uKHMsTC5JTlRFUklPUil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBibn19KSxoKE9uLE5uKSxlKE9uLnByb3RvdHlwZSx7Y3JlYXRlTm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHluKHQsbmV3IGJuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT259fSksZShfbi5wcm90b3R5cGUse2NvbXB1dGVJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSl7dGhpcy5tY2UuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLmNoYWluSW5kZXgsdC5tY2UsdC5jaGFpbkluZGV4LGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBfbn19KSxlKE1uLnByb3RvdHlwZSx7aXNEZWxldGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudFR5cGU9PT1Nbi5ERUxFVEV9LHNldERlbGV0ZUV2ZW50SW5kZXg6ZnVuY3Rpb24odCl7dGhpcy5kZWxldGVFdmVudEluZGV4PXR9LGdldE9iamVjdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9ian0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMueFZhbHVlPGUueFZhbHVlPy0xOnRoaXMueFZhbHVlPmUueFZhbHVlPzE6dGhpcy5ldmVudFR5cGU8ZS5ldmVudFR5cGU/LTE6dGhpcy5ldmVudFR5cGU+ZS5ldmVudFR5cGU/MTowfSxnZXRJbnNlcnRFdmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluc2VydEV2ZW50fSxpc0luc2VydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV2ZW50VHlwZT09PU1uLklOU0VSVH0saXNTYW1lTGFiZWw6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PT10aGlzLmxhYmVsPyExOnRoaXMubGFiZWw9PT10LmxhYmVsfSxnZXREZWxldGVFdmVudEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZXRlRXZlbnRJbmRleH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE1ufX0pLE1uLklOU0VSVD0xLE1uLkRFTEVURT0yLGUoRG4ucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEbn19KSxlKEFuLnByb3RvdHlwZSx7aXNUcml2aWFsSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQ9PT1uJiYxPT09dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYoQW4uaXNBZGphY2VudFNlZ21lbnRzKGUsaSkpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXt2YXIgcj10LmdldE51bVBvaW50cygpLTE7aWYoMD09PWUmJmk9PT1yfHwwPT09aSYmZT09PXIpcmV0dXJuITB9fXJldHVybiExfSxnZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50fSxzZXRJc0RvbmVJZlByb3BlckludDpmdW5jdGlvbih0KXt0aGlzLmlzRG9uZVdoZW5Qcm9wZXJJbnQ9dH0saGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNQcm9wZXJJbnRlcmlvcn0saXNCb3VuZGFyeVBvaW50SW50ZXJuYWw6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldENvb3JkaW5hdGUoKTtpZih0LmlzSW50ZXJzZWN0aW9uKHIpKXJldHVybiEwfXJldHVybiExfSxoYXNQcm9wZXJJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNQcm9wZXJ9LGhhc0ludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0RvbmV9LGlzQm91bmRhcnlQb2ludDpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09ZT8hMTp0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVswXSk/ITA6ISF0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVsxXSl9LHNldEJvdW5kYXJ5Tm9kZXM6ZnVuY3Rpb24odCxlKXt0aGlzLmJkeU5vZGVzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuYmR5Tm9kZXNbMF09dCx0aGlzLmJkeU5vZGVzWzFdPWV9LGFkZEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKzt2YXIgcj10LmdldENvb3JkaW5hdGVzKClbZV0scz10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpXSxhPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpKzFdO3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihyLHMsbyxhKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5yZWNvcmRJc29sYXRlZCYmKHQuc2V0SXNvbGF0ZWQoITEpLG4uc2V0SXNvbGF0ZWQoITEpKSx0aGlzLm51bUludGVyc2VjdGlvbnMrKyx0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixpKXx8KHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCwhdGhpcy5pbmNsdWRlUHJvcGVyJiZ0aGlzLmxpLmlzUHJvcGVyKCl8fCh0LmFkZEludGVyc2VjdGlvbnModGhpcy5saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGksMSkpLHRoaXMubGkuaXNQcm9wZXIoKSYmKHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9dGhpcy5saS5nZXRJbnRlcnNlY3Rpb24oMCkuY29weSgpLHRoaXMuaGFzUHJvcGVyPSEwLHRoaXMuaXNEb25lV2hlblByb3BlckludCYmKHRoaXMuX2lzRG9uZT0hMCksdGhpcy5pc0JvdW5kYXJ5UG9pbnQodGhpcy5saSx0aGlzLmJkeU5vZGVzKXx8KHRoaXMuaGFzUHJvcGVySW50ZXJpb3I9ITApKSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBbn19KSxBbi5pc0FkamFjZW50U2VnbWVudHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9LGgoRm4sRG4pLGUoRm4ucHJvdG90eXBlLHtwcmVwYXJlRXZlbnRzOmZ1bmN0aW9uKCl7aG8uc29ydCh0aGlzLmV2ZW50cyk7Zm9yKHZhciB0PTA7dDx0aGlzLmV2ZW50cy5zaXplKCk7dCsrKXt2YXIgZT10aGlzLmV2ZW50cy5nZXQodCk7ZS5pc0RlbGV0ZSgpJiZlLmdldEluc2VydEV2ZW50KCkuc2V0RGVsZXRlRXZlbnRJbmRleCh0KX19LGNvbXB1dGVJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5PdmVybGFwcz0wLHRoaXMucHJlcGFyZUV2ZW50cygpO2Zvcih2YXIgZT0wO2U8dGhpcy5ldmVudHMuc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5ldmVudHMuZ2V0KGUpO2lmKG4uaXNJbnNlcnQoKSYmdGhpcy5wcm9jZXNzT3ZlcmxhcHMoZSxuLmdldERlbGV0ZUV2ZW50SW5kZXgoKSxuLHQpLHQuaXNEb25lKCkpYnJlYWt9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBbiYmUihhcmd1bWVudHNbMF0seSkmJlIoYXJndW1lbnRzWzFdLHkpKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy5hZGRFZGdlcyhpLGkpLHRoaXMuYWRkRWRnZXMocixyKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHMpfWVsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlIoYXJndW1lbnRzWzBdLHkpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFuKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl07dT90aGlzLmFkZEVkZ2VzKG8sbnVsbCk6dGhpcy5hZGRFZGdlcyhvKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKGEpfX0sYWRkRWRnZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldE1vbm90b25lQ2hhaW5FZGdlKCksaT1uLmdldFN0YXJ0SW5kZXhlcygpLHI9MDtyPGkubGVuZ3RoLTE7cisrKXt2YXIgcz1uZXcgX24obixyKSxvPW5ldyBNbihlLG4uZ2V0TWluWChyKSxzKTt0aGlzLmV2ZW50cy5hZGQobyksdGhpcy5ldmVudHMuYWRkKG5ldyBNbihuLmdldE1heFgociksbykpfX0scHJvY2Vzc092ZXJsYXBzOmZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj1uLmdldE9iamVjdCgpLHM9dDtlPnM7cysrKXt2YXIgbz10aGlzLmV2ZW50cy5nZXQocyk7aWYoby5pc0luc2VydCgpKXt2YXIgYT1vLmdldE9iamVjdCgpO24uaXNTYW1lTGFiZWwobyl8fChyLmNvbXB1dGVJbnRlcnNlY3Rpb25zKGEsaSksdGhpcy5uT3ZlcmxhcHMrKyl9fX0sYWRkRWRnZXM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5hZGRFZGdlKG4sbil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLGU9aS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5hZGRFZGdlKG4scil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGbn19KSxlKEduLnByb3RvdHlwZSx7Z2V0TWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWlufSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuISh0aGlzLm1pbj5lfHx0aGlzLm1heDx0KX0sZ2V0TWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4fSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcobmV3IGcodGhpcy5taW4sMCksbmV3IGcodGhpcy5tYXgsMCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHbn19KSxlKHFuLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lLHI9KG4ubWluK24ubWF4KS8yLHM9KGkubWluK2kubWF4KS8yO3JldHVybiBzPnI/LTE6cj5zPzE6MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHFufX0pLEduLk5vZGVDb21wYXJhdG9yPXFuLGgoQm4sR24pLGUoQm4ucHJvdG90eXBlLHtxdWVyeTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuaW50ZXJzZWN0cyh0LGUpP3ZvaWQgbi52aXNpdEl0ZW0odGhpcy5pdGVtKTpudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCbn19KSxoKHpuLEduKSxlKHpuLnByb3RvdHlwZSx7YnVpbGRFeHRlbnQ6ZnVuY3Rpb24odCxlKXt0aGlzLm1pbj1NYXRoLm1pbih0Lm1pbixlLm1pbiksdGhpcy5tYXg9TWF0aC5tYXgodC5tYXgsZS5tYXgpfSxxdWVyeTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuaW50ZXJzZWN0cyh0LGUpPyhudWxsIT09dGhpcy5ub2RlMSYmdGhpcy5ub2RlMS5xdWVyeSh0LGUsbiksdm9pZChudWxsIT09dGhpcy5ub2RlMiYmdGhpcy5ub2RlMi5xdWVyeSh0LGUsbikpKTpudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6bn19KSxlKFZuLnByb3RvdHlwZSx7YnVpbGRUcmVlOmZ1bmN0aW9uKCl7aG8uc29ydCh0aGlzLmxlYXZlcyxuZXcgSW50ZXJ2YWxSVHJlZU5vZGUuTm9kZUNvbXBhcmF0b3IpO2Zvcih2YXIgdD10aGlzLmxlYXZlcyxlPW51bGwsbj1uZXcgSTs7KXtpZih0aGlzLmJ1aWxkTGV2ZWwodCxuKSwxPT09bi5zaXplKCkpcmV0dXJuIG4uZ2V0KDApO2U9dCx0PW4sbj1lfX0saW5zZXJ0OmZ1bmN0aW9uKHQsZSxuKXtpZihudWxsIT09dGhpcy5yb290KXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJJbmRleCBjYW5ub3QgYmUgYWRkZWQgdG8gb25jZSBpdCBoYXMgYmVlbiBxdWVyaWVkXCIpO3RoaXMubGVhdmVzLmFkZChuZXcgQm4odCxlLG4pKX0scXVlcnk6ZnVuY3Rpb24odCxlLG4pe3RoaXMuaW5pdCgpLHRoaXMucm9vdC5xdWVyeSh0LGUsbil9LGJ1aWxkUm9vdDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P251bGw6dm9pZCh0aGlzLnJvb3Q9dGhpcy5idWlsZFRyZWUoKSl9LHByaW50Tm9kZTpmdW5jdGlvbih0KXtBLm91dC5wcmludGxuKHNlLnRvTGluZVN0cmluZyhuZXcgZyh0Lm1pbix0aGlzLmxldmVsKSxuZXcgZyh0Lm1heCx0aGlzLmxldmVsKSkpfSxpbml0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/bnVsbDp2b2lkIHRoaXMuYnVpbGRSb290KCl9LGJ1aWxkTGV2ZWw6ZnVuY3Rpb24odCxlKXt0aGlzLmxldmVsKyssZS5jbGVhcigpO2Zvcih2YXIgbj0wO248dC5zaXplKCk7bis9Mil7dmFyIGk9dC5nZXQobikscj1uKzE8dC5zaXplKCk/dC5nZXQobik6bnVsbDtpZihudWxsPT09cillLmFkZChpKTtlbHNle3ZhciBzPW5ldyB6bih0LmdldChuKSx0LmdldChuKzEpKTtlLmFkZChzKX19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWbn19KSxlKGtuLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNGb3JjZWRUb0xpbmVTdHJpbmcmJnQgaW5zdGFuY2VvZiBidCl7dmFyIGU9dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtyZXR1cm4gdGhpcy5saW5lcy5hZGQoZSksbnVsbH10IGluc3RhbmNlb2YgU3QmJnRoaXMubGluZXMuYWRkKHQpfSxzZXRGb3JjZVRvTGluZVN0cmluZzpmdW5jdGlvbih0KXt0aGlzLmlzRm9yY2VkVG9MaW5lU3RyaW5nPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrbn19KSxrbi5nZXRHZW9tZXRyeT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoa24uZ2V0TGluZXModCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIGUuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoa24uZ2V0TGluZXMoZSxuKSl9fSxrbi5nZXRMaW5lcz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIGtuLmdldExpbmVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSx2KSYmUihhcmd1bWVudHNbMV0sdikpe2Zvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtrbi5nZXRMaW5lcyhyLG4pfXJldHVybiBufWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPW5ldyBJO3JldHVybiBzLmFwcGx5KG5ldyBrbihhLG8pKSxhfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmUihhcmd1bWVudHNbMV0sdikpe3ZhciB1PWFyZ3VtZW50c1swXSxsPWFyZ3VtZW50c1sxXTtyZXR1cm4gdSBpbnN0YW5jZW9mIFN0P2wuYWRkKHUpOnUuYXBwbHkobmV3IGtuKGwpKSxsfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmUihhcmd1bWVudHNbMF0sdikmJlIoYXJndW1lbnRzWzFdLHYpKXtmb3IodmFyIGg9YXJndW1lbnRzWzBdLGM9YXJndW1lbnRzWzFdLGY9YXJndW1lbnRzWzJdLGk9aC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7a24uZ2V0TGluZXMocixjLGYpfXJldHVybiBjfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlIoYXJndW1lbnRzWzFdLHYpKXt2YXIgZz1hcmd1bWVudHNbMF0sZD1hcmd1bWVudHNbMV0scD1hcmd1bWVudHNbMl07cmV0dXJuIGcuYXBwbHkobmV3IGtuKGQscCkpLGR9fX0sZShZbi5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZCh0KX0sZ2V0SXRlbXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQWVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZbn19KSxlKFVuLnByb3RvdHlwZSx7bG9jYXRlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBsZSh0KSxuPW5ldyBYbihlKTtyZXR1cm4gdGhpcy5pbmRleC5xdWVyeSh0LnksdC55LG4pLGUuZ2V0TG9jYXRpb24oKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bUm5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVbn19KSxlKFhuLnByb3RvdHlwZSx7dmlzaXRJdGVtOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5jb3VudGVyLmNvdW50U2VnbWVudChlLmdldENvb3JkaW5hdGUoMCksZS5nZXRDb29yZGluYXRlKDEpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQWVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYbn19KSxlKEhuLnByb3RvdHlwZSx7aW5pdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9a24uZ2V0TGluZXModCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmFkZExpbmUocil9fSxhZGRMaW5lOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj1uZXcgY2UodFtlLTFdLHRbZV0pLGk9TWF0aC5taW4obi5wMC55LG4ucDEueSkscj1NYXRoLm1heChuLnAwLnksbi5wMS55KTt0aGlzLmluZGV4Lmluc2VydChpLHIsbil9fSxxdWVyeTpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgWW47cmV0dXJuIHRoaXMuaW5kZXgucXVlcnkodCxlLG4pLG4uZ2V0SXRlbXMoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMuaW5kZXgucXVlcnkoaSxyLHMpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSG59fSksVW4uU2VnbWVudFZpc2l0b3I9WG4sVW4uSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnk9SG4sZShXbi5wcm90b3R5cGUse2dldFNlZ21lbnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkfSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCksdC5wcmludGxuKFwiIGRpc3QgPSBcIit0aGlzLmRpc3QpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlKGUuc2VnbWVudEluZGV4LGUuZGlzdCl9LGlzRW5kUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10aGlzLnNlZ21lbnRJbmRleCYmMD09PXRoaXMuZGlzdD8hMDp0aGlzLnNlZ21lbnRJbmRleD09PXR9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmQrXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCtcIiBkaXN0ID0gXCIrdGhpcy5kaXN0fSxnZXREaXN0YW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3R9LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8dD8tMTp0aGlzLnNlZ21lbnRJbmRleD50PzE6dGhpcy5kaXN0PGU/LTE6dGhpcy5kaXN0PmU/MTowfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV259fSksZShqbi5wcm90b3R5cGUse3ByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpfX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9LGFkZFNwbGl0RWRnZXM6ZnVuY3Rpb24odCl7dGhpcy5hZGRFbmRwb2ludHMoKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpLG49ZS5uZXh0KCk7ZS5oYXNOZXh0KCk7KXt2YXIgaT1lLm5leHQoKSxyPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4saSk7dC5hZGQociksbj1pfX0sYWRkRW5kcG9pbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lZGdlLnB0cy5sZW5ndGgtMTt0aGlzLmFkZCh0aGlzLmVkZ2UucHRzWzBdLDAsMCksdGhpcy5hZGQodGhpcy5lZGdlLnB0c1t0XSx0LDApfSxjcmVhdGVTcGxpdEVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyLGk9dGhpcy5lZGdlLnB0c1tlLnNlZ21lbnRJbmRleF0scj1lLmRpc3Q+MHx8IWUuY29vcmQuZXF1YWxzMkQoaSk7cnx8bi0tO3ZhciBzPW5ldyBBcnJheShuKS5maWxsKG51bGwpLG89MDtzW28rK109bmV3IGcodC5jb29yZCk7Zm9yKHZhciBhPXQuc2VnbWVudEluZGV4KzE7YTw9ZS5zZWdtZW50SW5kZXg7YSsrKXNbbysrXT10aGlzLmVkZ2UucHRzW2FdO3JldHVybiByJiYoc1tvXT1lLmNvb3JkKSxuZXcgSm4ocyxuZXcgZ24odGhpcy5lZGdlLmxhYmVsKSl9LGFkZDpmdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IFduKHQsZSxuKSxyPXRoaXMubm9kZU1hcC5nZXQoaSk7cmV0dXJuIG51bGwhPT1yP3I6KHRoaXMubm9kZU1hcC5wdXQoaSxpKSxpKX0saXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKG4uY29vcmQuZXF1YWxzKHQpKXJldHVybiEwfXJldHVybiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqbn19KSxlKEtuLnByb3RvdHlwZSx7Z2V0Q2hhaW5TdGFydEluZGljZXM6ZnVuY3Rpb24odCl7dmFyIGU9MCxuPW5ldyBJO24uYWRkKG5ldyBiKGUpKTtkb3t2YXIgaT10aGlzLmZpbmRDaGFpbkVuZCh0LGUpO24uYWRkKG5ldyBiKGkpKSxlPWl9d2hpbGUoZTx0Lmxlbmd0aC0xKTt2YXIgcj1Lbi50b0ludEFycmF5KG4pO3JldHVybiByfSxmaW5kQ2hhaW5FbmQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49SmUucXVhZHJhbnQodFtlXSx0W2UrMV0pLGk9ZSsxO2k8dC5sZW5ndGg7KXt2YXIgcj1KZS5xdWFkcmFudCh0W2ktMV0sdFtpXSk7aWYociE9PW4pYnJlYWs7aSsrfXJldHVybiBpLTF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtufX0pLEtuLnRvSW50QXJyYXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfSxlKFpuLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHN9LGdldE1heFg6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIGU+bj9lOm59LGdldE1pblg6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIG4+ZT9lOm59LGNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW46ZnVuY3Rpb24oKXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3RoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLnN0YXJ0SW5kZXhbdF0sdGhpcy5zdGFydEluZGV4W3QrMV0sZSxlLnN0YXJ0SW5kZXhbbl0sZS5zdGFydEluZGV4W24rMV0saSl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9YXJndW1lbnRzWzNdLHU9YXJndW1lbnRzWzRdLGw9YXJndW1lbnRzWzVdLGg9dGhpcy5wdHNbcl0sYz10aGlzLnB0c1tzXSxmPW8ucHRzW2FdLGc9by5wdHNbdV07aWYocy1yPT09MSYmdS1hPT09MSlyZXR1cm4gbC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuZSxyLG8uZSxhKSxudWxsO2lmKHRoaXMuZW52MS5pbml0KGgsYyksdGhpcy5lbnYyLmluaXQoZixnKSwhdGhpcy5lbnYxLmludGVyc2VjdHModGhpcy5lbnYyKSlyZXR1cm4gbnVsbDt2YXIgZD1NYXRoLnRydW5jKChyK3MpLzIpLHA9TWF0aC50cnVuYygoYSt1KS8yKTtkPnImJihwPmEmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihyLGQsbyxhLHAsbCksdT5wJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4ocixkLG8scCx1LGwpKSxzPmQmJihwPmEmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihkLHMsbyxhLHAsbCksdT5wJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oZCxzLG8scCx1LGwpKX19LGdldFN0YXJ0SW5kZXhlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0SW5kZXh9LGNvbXB1dGVJbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0aGlzLnN0YXJ0SW5kZXgubGVuZ3RoLTE7bisrKWZvcih2YXIgaT0wO2k8dC5zdGFydEluZGV4Lmxlbmd0aC0xO2krKyl0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obix0LGksZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFpufX0pLGUoUW4ucHJvdG90eXBlLHtnZXREZXB0aDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmRlcHRoW3RdW2VdfSxzZXREZXB0aDpmdW5jdGlvbih0LGUsbil7dGhpcy5kZXB0aFt0XVtlXT1ufSxpc051bGw6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PTA7Mj50O3QrKylmb3IodmFyIGU9MDszPmU7ZSsrKWlmKHRoaXMuZGVwdGhbdF1bZV0hPT1Rbi5OVUxMX1ZBTFVFKXJldHVybiExO3JldHVybiEwfWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZGVwdGhbbl1bMV09PT1Rbi5OVUxMX1ZBTFVFfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuZGVwdGhbaV1bcl09PT1Rbi5OVUxMX1ZBTFVFfX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7Mj50O3QrKylpZighdGhpcy5pc051bGwodCkpe3ZhciBlPXRoaXMuZGVwdGhbdF1bMV07dGhpcy5kZXB0aFt0XVsyXTxlJiYoZT10aGlzLmRlcHRoW3RdWzJdKSwwPmUmJihlPTApO2Zvcih2YXIgbj0xOzM+bjtuKyspe3ZhciBpPTA7dGhpcy5kZXB0aFt0XVtuXT5lJiYoaT0xKSx0aGlzLmRlcHRoW3RdW25dPWl9fX0sZ2V0RGVsdGE6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGVwdGhbdF1bY24uUklHSFRdLXRoaXMuZGVwdGhbdF1bY24uTEVGVF19LGdldExvY2F0aW9uOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZGVwdGhbdF1bZV08PTA/TC5FWFRFUklPUjpMLklOVEVSSU9SfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiQTogXCIrdGhpcy5kZXB0aFswXVsxXStcIixcIit0aGlzLmRlcHRoWzBdWzJdK1wiIEI6IFwiK3RoaXMuZGVwdGhbMV1bMV0rXCIsXCIrdGhpcy5kZXB0aFsxXVsyXX0sYWRkOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7Mj5lO2UrKylmb3IodmFyIG49MTszPm47bisrKXt2YXIgaT10LmdldExvY2F0aW9uKGUsbik7aSE9PUwuRVhURVJJT1ImJmkhPT1MLklOVEVSSU9SfHwodGhpcy5pc051bGwoZSxuKT90aGlzLmRlcHRoW2VdW25dPVFuLmRlcHRoQXRMb2NhdGlvbihpKTp0aGlzLmRlcHRoW2VdW25dKz1Rbi5kZXB0aEF0TG9jYXRpb24oaSkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTtvPT09TC5JTlRFUklPUiYmdGhpcy5kZXB0aFtyXVtzXSsrfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUW59fSksUW4uZGVwdGhBdExvY2F0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09TC5FWFRFUklPUj8wOnQ9PT1MLklOVEVSSU9SPzE6UW4uTlVMTF9WQUxVRX0sUW4uTlVMTF9WQUxVRT0tMSxoKEpuLG1uKSxlKEpuLnByb3RvdHlwZSx7Z2V0RGVwdGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZXB0aH0sZ2V0Q29sbGFwc2VkRWRnZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3RbMF09dGhpcy5wdHNbMF0sdFsxXT10aGlzLnB0c1sxXTt2YXIgZT1uZXcgSm4odCxnbi50b0xpbmVMYWJlbCh0aGlzLmxhYmVsKSk7cmV0dXJuIGV9LGlzSXNvbGF0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJc29sYXRlZH0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHN9LHNldElzb2xhdGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzSXNvbGF0ZWQ9dH0sc2V0TmFtZTpmdW5jdGlvbih0KXt0aGlzLm5hbWU9dH0sZXF1YWxzOmZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEpuKSlyZXR1cm4hMTt2YXIgZT10O2lmKHRoaXMucHRzLmxlbmd0aCE9PWUucHRzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIG49ITAsaT0hMCxyPXRoaXMucHRzLmxlbmd0aCxzPTA7czx0aGlzLnB0cy5sZW5ndGg7cysrKWlmKHRoaXMucHRzW3NdLmVxdWFsczJEKGUucHRzW3NdKXx8KG49ITEpLHRoaXMucHRzW3NdLmVxdWFsczJEKGUucHRzWy0tcl0pfHwoaT0hMSksIW4mJiFpKXJldHVybiExO3JldHVybiEwfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMucHRzLmxlbmd0aD4wP3RoaXMucHRzWzBdOm51bGw7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5wdHNbdF19fSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLm5hbWUrXCI6IFwiKSx0LnByaW50KFwiTElORVNUUklORyAoXCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTt0LnByaW50KFwiKSAgXCIrdGhpcy5sYWJlbCtcIiBcIit0aGlzLmRlcHRoRGVsdGEpfSxjb21wdXRlSU06ZnVuY3Rpb24odCl7Sm4udXBkYXRlSU0odGhpcy5sYWJlbCx0KX0saXNDb2xsYXBzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbC5pc0FyZWEoKT8zIT09dGhpcy5wdHMubGVuZ3RoPyExOiEhdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzWzJdKTohMX0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aC0xXSl9LGdldE1heGltdW1TZWdtZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RoLTF9LGdldERlcHRoRGVsdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZXB0aERlbHRhfSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RofSxwcmludFJldmVyc2U6ZnVuY3Rpb24odCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5uYW1lK1wiOiBcIik7Zm9yKHZhciBlPXRoaXMucHRzLmxlbmd0aC0xO2U+PTA7ZS0tKXQucHJpbnQodGhpcy5wdHNbZV0rXCIgXCIpO3QucHJpbnRsbihcIlwiKX0sZ2V0TW9ub3RvbmVDaGFpbkVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMubWNlJiYodGhpcy5tY2U9bmV3IFpuKHRoaXMpKSx0aGlzLm1jZX0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5lbnYpe3RoaXMuZW52PW5ldyBDO2Zvcih2YXIgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLmVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5wdHNbdF0pfXJldHVybiB0aGlzLmVudn0sYWRkSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBnKHQuZ2V0SW50ZXJzZWN0aW9uKGkpKSxzPWUsbz10LmdldEVkZ2VEaXN0YW5jZShuLGkpLGE9cysxO2lmKGE8dGhpcy5wdHMubGVuZ3RoKXt2YXIgdT10aGlzLnB0c1thXTtyLmVxdWFsczJEKHUpJiYocz1hLG89MCl9dGhpcy5laUxpc3QuYWRkKHIscyxvKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgUDt0LmFwcGVuZChcImVkZ2UgXCIrdGhpcy5uYW1lK1wiOiBcIiksdC5hcHBlbmQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKHZhciBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5hcHBlbmQoXCIsXCIpLHQuYXBwZW5kKHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7cmV0dXJuIHQuYXBwZW5kKFwiKSAgXCIrdGhpcy5sYWJlbCtcIiBcIit0aGlzLmRlcHRoRGVsdGEpLHQudG9TdHJpbmcoKX0saXNQb2ludHdpc2VFcXVhbDpmdW5jdGlvbih0KXtpZih0aGlzLnB0cy5sZW5ndGghPT10LnB0cy5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWlmKCF0aGlzLnB0c1tlXS5lcXVhbHMyRCh0LnB0c1tlXSkpcmV0dXJuITE7cmV0dXJuITB9LHNldERlcHRoRGVsdGE6ZnVuY3Rpb24odCl7dGhpcy5kZXB0aERlbHRhPXR9LGdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWlMaXN0fSxhZGRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9MDtpPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7aSsrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBKbn19KSxKbi51cGRhdGVJTT1mdW5jdGlvbigpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBtbi5wcm90b3R5cGUudXBkYXRlSU0uYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxjbi5PTiksdC5nZXRMb2NhdGlvbigxLGNuLk9OKSwxKSx0LmlzQXJlYSgpJiYoZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsY24uTEVGVCksdC5nZXRMb2NhdGlvbigxLGNuLkxFRlQpLDIpLGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKSx0LmdldExvY2F0aW9uKDEsY24uUklHSFQpLDIpKX0saCgkbixDbiksZSgkbi5wcm90b3R5cGUse2luc2VydEJvdW5kYXJ5UG9pbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm5vZGVzLmFkZE5vZGUoZSksaT1uLmdldExhYmVsKCkscj0xLHM9TC5OT05FO3M9aS5nZXRMb2NhdGlvbih0LGNuLk9OKSxzPT09TC5CT1VOREFSWSYmcisrO3ZhciBvPSRuLmRldGVybWluZUJvdW5kYXJ5KHRoaXMuYm91bmRhcnlOb2RlUnVsZSxyKTtpLnNldExvY2F0aW9uKHQsbyl9LGNvbXB1dGVTZWxmTm9kZXM6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXB1dGVTZWxmTm9kZXModCxlLCExKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdLHM9bmV3IEFuKG4sITAsITEpO3Muc2V0SXNEb25lSWZQcm9wZXJJbnQocik7dmFyIG89dGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKSxhPXRoaXMucGFyZW50R2VvbSBpbnN0YW5jZW9mIGJ0fHx0aGlzLnBhcmVudEdlb20gaW5zdGFuY2VvZiBUdHx8dGhpcy5wYXJlbnRHZW9tIGluc3RhbmNlb2YgT3QsdT1pfHwhYTtyZXR1cm4gby5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLmVkZ2VzLHMsdSksdGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXModGhpcy5hcmdJbmRleCksc319LGNvbXB1dGVTcGxpdEVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmVpTGlzdC5hZGRTcGxpdEVkZ2VzKHQpfX0sY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgQW4oZSxuLCEwKTtpLnNldEJvdW5kYXJ5Tm9kZXModGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksdC5nZXRCb3VuZGFyeU5vZGVzKCkpO3ZhciByPXRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCk7cmV0dXJuIHIuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5lZGdlcyx0LmVkZ2VzLGkpLGl9LGdldEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50R2VvbX0sZ2V0Qm91bmRhcnlOb2RlUnVsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJvdW5kYXJ5Tm9kZVJ1bGV9LGhhc1Rvb0Zld1BvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHN9LGFkZFBvaW50OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMdCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRDb29yZGluYXRlKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LGUsTC5JTlRFUklPUil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBuPWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsbixMLklOVEVSSU9SKX19LGFkZFBvbHlnb246ZnVuY3Rpb24odCl7dGhpcy5hZGRQb2x5Z29uUmluZyh0LmdldEV4dGVyaW9yUmluZygpLEwuRVhURVJJT1IsTC5JTlRFUklPUik7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7dmFyIG49dC5nZXRJbnRlcmlvclJpbmdOKGUpO3RoaXMuYWRkUG9seWdvblJpbmcobixMLklOVEVSSU9SLEwuRVhURVJJT1IpfX0sYWRkRWRnZTpmdW5jdGlvbih0KXt0aGlzLmluc2VydEVkZ2UodCk7dmFyIGU9dC5nZXRDb29yZGluYXRlcygpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxlWzBdLEwuQk9VTkRBUlkpLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxlW2UubGVuZ3RoLTFdLEwuQk9VTkRBUlkpfSxhZGRMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5pbnZhbGlkUG9pbnQ9ZVswXSxudWxsO3ZhciBuPW5ldyBKbihlLG5ldyBnbih0aGlzLmFyZ0luZGV4LEwuSU5URVJJT1IpKTt0aGlzLmxpbmVFZGdlTWFwLnB1dCh0LG4pLHRoaXMuaW5zZXJ0RWRnZShuKSxmLmlzVHJ1ZShlLmxlbmd0aD49MixcImZvdW5kIExpbmVTdHJpbmcgd2l0aCBzaW5nbGUgcG9pbnRcIiksdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuYXJnSW5kZXgsZVswXSksdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSl9LGdldEludmFsaWRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludmFsaWRQb2ludH0sZ2V0Qm91bmRhcnlQb2ludHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ZVtuKytdPXIuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKX1yZXR1cm4gZX0sZ2V0Qm91bmRhcnlOb2RlczpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5ib3VuZGFyeU5vZGVzJiYodGhpcy5ib3VuZGFyeU5vZGVzPXRoaXMubm9kZXMuZ2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmFyZ0luZGV4KSksdGhpcy5ib3VuZGFyeU5vZGVzfSxhZGRTZWxmSW50ZXJzZWN0aW9uTm9kZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuaXNCb3VuZGFyeU5vZGUodCxlKT9udWxsOnZvaWQobj09PUwuQk9VTkRBUlkmJnRoaXMudXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT90aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodCxlKTp0aGlzLmluc2VydFBvaW50KHQsZSxuKSl9LGFkZFBvbHlnb25SaW5nOmZ1bmN0aW9uKHQsZSxuKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgaT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoaS5sZW5ndGg8NClyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuaW52YWxpZFBvaW50PWlbMF0sbnVsbDt2YXIgcj1lLHM9bjtoZS5pc0NDVyhpKSYmKHI9bixzPWUpO3ZhciBvPW5ldyBKbihpLG5ldyBnbih0aGlzLmFyZ0luZGV4LEwuQk9VTkRBUlkscixzKSk7dGhpcy5saW5lRWRnZU1hcC5wdXQodCxvKSx0aGlzLmluc2VydEVkZ2UobyksdGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LGlbMF0sTC5CT1VOREFSWSl9LGluc2VydFBvaW50OmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLm5vZGVzLmFkZE5vZGUoZSkscj1pLmdldExhYmVsKCk7bnVsbD09PXI/aS5sYWJlbD1uZXcgZ24odCxuKTpyLnNldExvY2F0aW9uKHQsbil9LGNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcjpmdW5jdGlvbigpe3JldHVybiBuZXcgRm59LGFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkscj1uLmVpTGlzdC5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7dGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSh0LHMuY29vcmQsaSl9fSxhZGQ6ZnVuY3Rpb24oKXtpZigxIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gQ24ucHJvdG90eXBlLmFkZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBPdCYmKHRoaXMudXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMSksdCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBTdCl0aGlzLmFkZExpbmVTdHJpbmcodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgTHQpdGhpcy5hZGRQb2ludCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZ3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIE90KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIGZ0KSl0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odC5nZXRDbGFzcygpLmdldE5hbWUoKSk7dGhpcy5hZGRDb2xsZWN0aW9uKHQpfX0sYWRkQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fSxsb2NhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIFIodGhpcy5wYXJlbnRHZW9tLFJ0KSYmdGhpcy5wYXJlbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKT41MD8obnVsbD09PXRoaXMuYXJlYVB0TG9jYXRvciYmKHRoaXMuYXJlYVB0TG9jYXRvcj1uZXcgVW4odGhpcy5wYXJlbnRHZW9tKSksdGhpcy5hcmVhUHRMb2NhdG9yLmxvY2F0ZSh0KSk6dGhpcy5wdExvY2F0b3IubG9jYXRlKHQsdGhpcy5wYXJlbnRHZW9tKX0sZmluZEVkZ2U6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmxpbmVFZGdlTWFwLmdldCh0KX1yZXR1cm4gQ24ucHJvdG90eXBlLmZpbmRFZGdlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gJG59fSksJG4uZGV0ZXJtaW5lQm91bmRhcnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5pc0luQm91bmRhcnkoZSk/TC5CT1VOREFSWTpMLklOVEVSSU9SfSxlKHRpLnByb3RvdHlwZSx7Z2V0QXJnR2VvbWV0cnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJnW3RdLmdldEdlb21ldHJ5KCl9LHNldENvbXB1dGF0aW9uUHJlY2lzaW9uOmZ1bmN0aW9uKHQpe3RoaXMucmVzdWx0UHJlY2lzaW9uTW9kZWw9dCx0aGlzLmxpLnNldFByZWNpc2lvbk1vZGVsKHRoaXMucmVzdWx0UHJlY2lzaW9uTW9kZWwpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB0aX19KSxlKGVpLnByb3RvdHlwZSx7Y29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj1laS5jb21wYXJlT3JpZW50ZWQodGhpcy5wdHMsdGhpcy5fb3JpZW50YXRpb24sZS5wdHMsZS5fb3JpZW50YXRpb24pO3JldHVybiBufSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZWl9fSksZWkub3JpZW50YXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIDE9PT1ILmluY3JlYXNpbmdEaXJlY3Rpb24odCl9LGVpLmNvbXBhcmVPcmllbnRlZD1mdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHI9ZT8xOi0xLHM9aT8xOi0xLG89ZT90Lmxlbmd0aDotMSxhPWk/bi5sZW5ndGg6LTEsdT1lPzA6dC5sZW5ndGgtMSxsPWk/MDpuLmxlbmd0aC0xOzspe3ZhciBoPXRbdV0uY29tcGFyZVRvKG5bbF0pO2lmKDAhPT1oKXJldHVybiBoO3UrPXIsbCs9czt2YXIgYz11PT09byxmPWw9PT1hO2lmKGMmJiFmKXJldHVybi0xO2lmKCFjJiZmKXJldHVybiAxO2lmKGMmJmYpcmV0dXJuIDB9fSxlKG5pLnByb3RvdHlwZSx7cHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludChcIk1VTFRJTElORVNUUklORyAoIFwiKTtmb3IodmFyIGU9MDtlPHRoaXMuZWRnZXMuc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5lZGdlcy5nZXQoZSk7ZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KFwiKFwiKTtmb3IodmFyIGk9bi5nZXRDb29yZGluYXRlcygpLHI9MDtyPGkubGVuZ3RoO3IrKylyPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoaVtyXS54K1wiIFwiK2lbcl0ueSk7dC5wcmludGxuKFwiKVwiKX10LnByaW50KFwiKSAgXCIpfSxhZGRBbGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpfSxmaW5kRWRnZUluZGV4OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlcy5zaXplKCk7ZSsrKWlmKHRoaXMuZWRnZXMuZ2V0KGUpLmVxdWFscyh0KSlyZXR1cm4gZTtyZXR1cm4tMX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlcy5pdGVyYXRvcigpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzfSxnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWRnZXMuZ2V0KHQpfSxmaW5kRXF1YWxFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBlaSh0LmdldENvb3JkaW5hdGVzKCkpLG49dGhpcy5vY2FNYXAuZ2V0KGUpO3JldHVybiBufSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5lZGdlcy5hZGQodCk7dmFyIGU9bmV3IGVpKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5vY2FNYXAucHV0KGUsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5pfX0pLGgoaWksdGkpLGUoaWkucHJvdG90eXBlLHtpbnNlcnRVbmlxdWVFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7dmFyIG49ZS5nZXRMYWJlbCgpLGk9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KGk9bmV3IGduKHQuZ2V0TGFiZWwoKSksaS5mbGlwKCkpO3ZhciByPWUuZ2V0RGVwdGgoKTtyLmlzTnVsbCgpJiZyLmFkZChuKSxyLmFkZChpKSxuLm1lcmdlKGkpfWVsc2UgdGhpcy5lZGdlTGlzdC5hZGQodCl9LGdldEdyYXBoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGh9LGNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldFN5bSgpO2UuaXNJblJlc3VsdCgpJiZuLmlzSW5SZXN1bHQoKSYmKGUuc2V0SW5SZXN1bHQoITEpLG4uc2V0SW5SZXN1bHQoITEpKX19LGlzQ292ZXJlZEJ5TEE6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5yZXN1bHRMaW5lTGlzdCk/ITA6ISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMucmVzdWx0UG9seUxpc3QpfSxjb21wdXRlR2VvbWV0cnk6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bmV3IEk7cmV0dXJuIHIuYWRkQWxsKHQpLHIuYWRkQWxsKGUpLHIuYWRkQWxsKG4pLHIuaXNFbXB0eSgpP2lpLmNyZWF0ZUVtcHR5UmVzdWx0KGksdGhpcy5hcmdbMF0uZ2V0R2VvbWV0cnkoKSx0aGlzLmFyZ1sxXS5nZXRHZW9tZXRyeSgpLHRoaXMuZ2VvbUZhY3QpOnRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShyKX0sbWVyZ2VTeW1MYWJlbHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkubWVyZ2VTeW1MYWJlbHMoKX19LGlzQ292ZXJlZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LGkpO2lmKHIhPT1MLkVYVEVSSU9SKXJldHVybiEwfXJldHVybiExfSxyZXBsYWNlQ29sbGFwc2VkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEksZT10aGlzLmVkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmlzQ29sbGFwc2VkKCkmJihlLnJlbW92ZSgpLHQuYWRkKG4uZ2V0Q29sbGFwc2VkRWRnZSgpKSl9dGhpcy5lZGdlTGlzdC5hZGRBbGwodCl9LHVwZGF0ZU5vZGVMYWJlbGxpbmc6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZXMoKS5nZXRMYWJlbCgpO2UuZ2V0TGFiZWwoKS5tZXJnZShuKX19LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXB1dGVPdmVybGF5KHQpLHRoaXMucmVzdWx0R2VvbX0saW5zZXJ0VW5pcXVlRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZShuKX19LGNvbXB1dGVPdmVybGF5OmZ1bmN0aW9uKHQpe3RoaXMuY29weVBvaW50cygwKSx0aGlzLmNvcHlQb2ludHMoMSksdGhpcy5hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCExKSx0aGlzLmFyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITEpLHRoaXMuYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLmFyZ1sxXSx0aGlzLmxpLCEwKTt2YXIgZT1uZXcgSTt0aGlzLmFyZ1swXS5jb21wdXRlU3BsaXRFZGdlcyhlKSx0aGlzLmFyZ1sxXS5jb21wdXRlU3BsaXRFZGdlcyhlKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2VzKGUpLHRoaXMuY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMoKSx0aGlzLnJlcGxhY2VDb2xsYXBzZWRFZGdlcygpLGxuLmNoZWNrVmFsaWQodGhpcy5lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLmdyYXBoLmFkZEVkZ2VzKHRoaXMuZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5jb21wdXRlTGFiZWxsaW5nKCksdGhpcy5sYWJlbEluY29tcGxldGVOb2RlcygpLHRoaXMuZmluZFJlc3VsdEFyZWFFZGdlcyh0KSx0aGlzLmNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCk7dmFyIG49bmV3IFNuKHRoaXMuZ2VvbUZhY3QpO24uYWRkKHRoaXMuZ3JhcGgpLHRoaXMucmVzdWx0UG9seUxpc3Q9bi5nZXRQb2x5Z29ucygpO3ZhciBpPW5ldyB3bih0aGlzLHRoaXMuZ2VvbUZhY3QsdGhpcy5wdExvY2F0b3IpO3RoaXMucmVzdWx0TGluZUxpc3Q9aS5idWlsZCh0KTt2YXIgcj1uZXcgTG4odGhpcyx0aGlzLmdlb21GYWN0LHRoaXMucHRMb2NhdG9yKTt0aGlzLnJlc3VsdFBvaW50TGlzdD1yLmJ1aWxkKHQpLFxudGhpcy5yZXN1bHRHZW9tPXRoaXMuY29tcHV0ZUdlb21ldHJ5KHRoaXMucmVzdWx0UG9pbnRMaXN0LHRoaXMucmVzdWx0TGluZUxpc3QsdGhpcy5yZXN1bHRQb2x5TGlzdCx0KX0sbGFiZWxJbmNvbXBsZXRlTm9kZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmFyZ1tlXS5nZXRHZW9tZXRyeSgpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX0sY29weVBvaW50czpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5hcmdbdF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPXRoaXMuZ3JhcGguYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSk7aS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fSxmaW5kUmVzdWx0QXJlYUVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmdyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpO2kuaXNBcmVhKCkmJiFuLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZpaS5pc1Jlc3VsdE9mT3AoaS5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKSxpLmdldExvY2F0aW9uKDEsY24uUklHSFQpLHQpJiZuLnNldEluUmVzdWx0KCEwKX19LGNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpLGk9ZS5nZXREZXB0aCgpO2lmKCFpLmlzTnVsbCgpKXtpLm5vcm1hbGl6ZSgpO2Zvcih2YXIgcj0wOzI+cjtyKyspbi5pc051bGwocil8fCFuLmlzQXJlYSgpfHxpLmlzTnVsbChyKXx8KDA9PT1pLmdldERlbHRhKHIpP24udG9MaW5lKHIpOihmLmlzVHJ1ZSghaS5pc051bGwocixjbi5MRUZUKSxcImRlcHRoIG9mIExFRlQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbihyLGNuLkxFRlQsaS5nZXRMb2NhdGlvbihyLGNuLkxFRlQpKSxmLmlzVHJ1ZSghaS5pc051bGwocixjbi5SSUdIVCksXCJkZXB0aCBvZiBSSUdIVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHIsY24uUklHSFQsaS5nZXRMb2NhdGlvbihyLGNuLlJJR0hUKSkpKX19fSxjb21wdXRlTGFiZWxsaW5nOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcy5hcmcpfXRoaXMubWVyZ2VTeW1MYWJlbHMoKSx0aGlzLnVwZGF0ZU5vZGVMYWJlbGxpbmcoKX0sbGFiZWxJbmNvbXBsZXRlTm9kZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7bi5pc0lzb2xhdGVkKCkmJih0KyssaS5pc051bGwoMCk/dGhpcy5sYWJlbEluY29tcGxldGVOb2RlKG4sMCk6dGhpcy5sYWJlbEluY29tcGxldGVOb2RlKG4sMSkpLG4uZ2V0RWRnZXMoKS51cGRhdGVMYWJlbGxpbmcoaSl9fSxpc0NvdmVyZWRCeUE6ZnVuY3Rpb24odCl7cmV0dXJuISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMucmVzdWx0UG9seUxpc3QpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBpaX19KSxpaS5vdmVybGF5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBpaSh0LGUpLHI9aS5nZXRSZXN1bHRHZW9tZXRyeShuKTtyZXR1cm4gcn0saWkuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXJldHVybiBpaS5jcmVhdGVFbXB0eVJlc3VsdChpaS5JTlRFUlNFQ1RJT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe3ZhciBuPWU7cmV0dXJuIGhuLm1hcCh0LHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltNYXBPcF19LG1hcDpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcnNlY3Rpb24obil9fSl9cmV0dXJuIHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxzaS5vdmVybGF5T3AodCxlLGlpLklOVEVSU0VDVElPTil9LGlpLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuU1lNRElGRkVSRU5DRSx0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9cmV0dXJuIHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxzaS5vdmVybGF5T3AodCxlLGlpLlNZTURJRkZFUkVOQ0UpfSxpaS5yZXN1bHREaW1lbnNpb249ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUuZ2V0RGltZW5zaW9uKCkscj1uLmdldERpbWVuc2lvbigpLHM9LTE7c3dpdGNoKHQpe2Nhc2UgaWkuSU5URVJTRUNUSU9OOnM9TWF0aC5taW4oaSxyKTticmVhaztjYXNlIGlpLlVOSU9OOnM9TWF0aC5tYXgoaSxyKTticmVhaztjYXNlIGlpLkRJRkZFUkVOQ0U6cz1pO2JyZWFrO2Nhc2UgaWkuU1lNRElGRkVSRU5DRTpzPU1hdGgubWF4KGkscil9cmV0dXJuIHN9LGlpLmNyZWF0ZUVtcHR5UmVzdWx0PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW51bGw7c3dpdGNoKGlpLnJlc3VsdERpbWVuc2lvbih0LGUsbikpe2Nhc2UtMTpyPWkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG5ldyBBcnJheSgwKS5maWxsKG51bGwpKTticmVhaztjYXNlIDA6cj1pLmNyZWF0ZVBvaW50KCk7YnJlYWs7Y2FzZSAxOnI9aS5jcmVhdGVMaW5lU3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnI9aS5jcmVhdGVQb2x5Z29uKCl9cmV0dXJuIHJ9LGlpLmRpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5pc0VtcHR5KCk/aWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuRElGRkVSRU5DRSx0LGUsdC5nZXRGYWN0b3J5KCkpOmUuaXNFbXB0eSgpP3QuY29weSgpOih0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5ESUZGRVJFTkNFKSl9LGlpLmlzUmVzdWx0T2ZPcD1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldExvY2F0aW9uKDApLGk9dC5nZXRMb2NhdGlvbigxKTtyZXR1cm4gaWkuaXNSZXN1bHRPZk9wKG4saSxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3N3aXRjaChyPT09TC5CT1VOREFSWSYmKHI9TC5JTlRFUklPUikscz09PUwuQk9VTkRBUlkmJihzPUwuSU5URVJJT1IpLG8pe2Nhc2UgaWkuSU5URVJTRUNUSU9OOnJldHVybiByPT09TC5JTlRFUklPUiYmcz09PUwuSU5URVJJT1I7Y2FzZSBpaS5VTklPTjpyZXR1cm4gcj09PUwuSU5URVJJT1J8fHM9PT1MLklOVEVSSU9SO2Nhc2UgaWkuRElGRkVSRU5DRTpyZXR1cm4gcj09PUwuSU5URVJJT1ImJnMhPT1MLklOVEVSSU9SO2Nhc2UgaWkuU1lNRElGRkVSRU5DRTpyZXR1cm4gcj09PUwuSU5URVJJT1ImJnMhPT1MLklOVEVSSU9SfHxyIT09TC5JTlRFUklPUiYmcz09PUwuSU5URVJJT1J9cmV0dXJuITF9fSxpaS5JTlRFUlNFQ1RJT049MSxpaS5VTklPTj0yLGlpLkRJRkZFUkVOQ0U9MyxpaS5TWU1ESUZGRVJFTkNFPTQsZShyaS5wcm90b3R5cGUse3NlbGZTbmFwOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBJZSh0KSxuPWUuc25hcFRvKHQsdGhpcy5zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbn0scmVtb3ZlQ29tbW9uQml0czpmdW5jdGlvbih0KXt0aGlzLmNicj1uZXcgU2UsdGhpcy5jYnIuYWRkKHRbMF0pLHRoaXMuY2JyLmFkZCh0WzFdKTt2YXIgZT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gZVswXT10aGlzLmNici5yZW1vdmVDb21tb25CaXRzKHRbMF0uY29weSgpKSxlWzFdPXRoaXMuY2JyLnJlbW92ZUNvbW1vbkJpdHModFsxXS5jb3B5KCkpLGV9LHByZXBhcmVSZXN1bHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2JyLmFkZENvbW1vbkJpdHModCksdH0sZ2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zbmFwKHRoaXMuZ2VvbSksbj1paS5vdmVybGF5T3AoZVswXSxlWzFdLHQpO3JldHVybiB0aGlzLnByZXBhcmVSZXN1bHQobil9LGNoZWNrVmFsaWQ6ZnVuY3Rpb24odCl7dC5pc1ZhbGlkKCl8fEEub3V0LnByaW50bG4oXCJTbmFwcGVkIGdlb21ldHJ5IGlzIGludmFsaWRcIil9LGNvbXB1dGVTbmFwVG9sZXJhbmNlOmZ1bmN0aW9uKCl7dGhpcy5zbmFwVG9sZXJhbmNlPUllLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSh0aGlzLmdlb21bMF0sdGhpcy5nZW9tWzFdKX0sc25hcDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlbW92ZUNvbW1vbkJpdHModCksbj1JZS5zbmFwKGVbMF0sZVsxXSx0aGlzLnNuYXBUb2xlcmFuY2UpO3JldHVybiBufSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiByaX19KSxyaS5vdmVybGF5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyByaSh0LGUpO3JldHVybiBpLmdldFJlc3VsdEdlb21ldHJ5KG4pfSxyaS51bmlvbj1mdW5jdGlvbih0LGUpe3JldHVybiByaS5vdmVybGF5T3AodCxlLGlpLlVOSU9OKX0scmkuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJpLm92ZXJsYXlPcCh0LGUsaWkuSU5URVJTRUNUSU9OKX0scmkuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiByaS5vdmVybGF5T3AodCxlLGlpLlNZTURJRkZFUkVOQ0UpfSxyaS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJpLm92ZXJsYXlPcCh0LGUsaWkuRElGRkVSRU5DRSl9LGUoc2kucHJvdG90eXBlLHtnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbih0KXt2YXIgZT1udWxsLG49ITEsaT1udWxsO3RyeXtlPWlpLm92ZXJsYXlPcCh0aGlzLmdlb21bMF0sdGhpcy5nZW9tWzFdLHQpO3ZhciByPSEwO3ImJihuPSEwKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBsKSl0aHJvdyB0O2k9dH1maW5hbGx5e31pZighbil0cnl7ZT1yaS5vdmVybGF5T3AodGhpcy5nZW9tWzBdLHRoaXMuZ2VvbVsxXSx0KX1jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgbD9pOnR9ZmluYWxseXt9cmV0dXJuIGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHNpfX0pLHNpLm92ZXJsYXlPcD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IHNpKHQsZSk7cmV0dXJuIGkuZ2V0UmVzdWx0R2VvbWV0cnkobil9LHNpLnVuaW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuVU5JT04pfSxzaS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gc2kub3ZlcmxheU9wKHQsZSxpaS5JTlRFUlNFQ1RJT04pfSxzaS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuU1lNRElGRkVSRU5DRSl9LHNpLmRpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gc2kub3ZlcmxheU9wKHQsZSxpaS5ESUZGRVJFTkNFKX0sZShvaS5wcm90b3R5cGUse2FkZFBvbHlnb246ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIGU9bnVsbCxuPTAsaT10aGlzLmhvcml6b250YWxCaXNlY3Rvcih0KTtpZigwPT09aS5nZXRMZW5ndGgoKSluPTAsZT1pLmdldENvb3JkaW5hdGUoKTtlbHNle3ZhciByPXNpLm92ZXJsYXlPcChpLHQsaWkuSU5URVJTRUNUSU9OKSxzPXRoaXMud2lkZXN0R2VvbWV0cnkocik7bj1zLmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpLGU9b2kuY2VudHJlKHMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX0obnVsbD09PXRoaXMuaW50ZXJpb3JQb2ludHx8bj50aGlzLm1heFdpZHRoKSYmKHRoaXMuaW50ZXJpb3JQb2ludD1lLHRoaXMubWF4V2lkdGg9bil9LGdldEludGVyaW9yUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvclBvaW50fSx3aWRlc3RHZW9tZXRyeTpmdW5jdGlvbiB0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmdCl7dmFyIGU9YXJndW1lbnRzWzBdO2lmKGUuaXNFbXB0eSgpKXJldHVybiBlO2Zvcih2YXIgdD1lLmdldEdlb21ldHJ5TigwKSxuPTE7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspZS5nZXRHZW9tZXRyeU4obikuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCk+dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKSYmKHQ9ZS5nZXRHZW9tZXRyeU4obikpO3JldHVybiB0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIGk9YXJndW1lbnRzWzBdO3JldHVybiBpIGluc3RhbmNlb2YgZnQ/dGhpcy53aWRlc3RHZW9tZXRyeShpKTppfX0saG9yaXpvbnRhbEJpc2VjdG9yOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG49YWkuZ2V0QmlzZWN0b3JZKHQpO3JldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbbmV3IGcoZS5nZXRNaW5YKCksbiksbmV3IGcoZS5nZXRNYXhYKCksbildKX0sYWRkOmZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpZm9yKHZhciBlPXQsbj0wO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKG4pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb2l9fSksb2kuY2VudHJlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyhvaS5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpLG9pLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSkpfSxvaS5hdmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4odCtlKS8yfSxlKGFpLnByb3RvdHlwZSx7dXBkYXRlSW50ZXJ2YWw6ZnVuY3Rpb24odCl7dDw9dGhpcy5jZW50cmVZP3Q+dGhpcy5sb1kmJih0aGlzLmxvWT10KTp0PnRoaXMuY2VudHJlWSYmdDx0aGlzLmhpWSYmKHRoaXMuaGlZPXQpfSxnZXRCaXNlY3Rvclk6ZnVuY3Rpb24oKXt0aGlzLnByb2Nlc3ModGhpcy5wb2x5LmdldEV4dGVyaW9yUmluZygpKTtmb3IodmFyIHQ9MDt0PHRoaXMucG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTt0KyspdGhpcy5wcm9jZXNzKHRoaXMucG9seS5nZXRJbnRlcmlvclJpbmdOKHQpKTt2YXIgZT1vaS5hdmcodGhpcy5oaVksdGhpcy5sb1kpO3JldHVybiBlfSxwcm9jZXNzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49MDtuPGUuc2l6ZSgpO24rKyl7dmFyIGk9ZS5nZXRZKG4pO3RoaXMudXBkYXRlSW50ZXJ2YWwoaSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhaX19KSxhaS5nZXRCaXNlY3Rvclk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFpKHQpO3JldHVybiBlLmdldEJpc2VjdG9yWSgpfSxvaS5TYWZlQmlzZWN0b3JGaW5kZXI9YWksZSh1aS5wcm90b3R5cGUse2FkZEVuZHBvaW50czpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBTdCl0aGlzLmFkZEVuZHBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgZT10LG49MDtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0aGlzLmFkZEVuZHBvaW50cyhlLmdldEdlb21ldHJ5TihuKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5hZGQoaVswXSksdGhpcy5hZGQoaVtpLmxlbmd0aC0xXSl9fSxnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JQb2ludH0sYWRkSW50ZXJpb3I6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRJbnRlcmlvcih0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgZT10LG49MDtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0aGlzLmFkZEludGVyaW9yKGUuZ2V0R2VvbWV0cnlOKG4pKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpZm9yKHZhciBpPWFyZ3VtZW50c1swXSxuPTE7bjxpLmxlbmd0aC0xO24rKyl0aGlzLmFkZChpW25dKX0sYWRkOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZGlzdGFuY2UodGhpcy5jZW50cm9pZCk7ZTx0aGlzLm1pbkRpc3RhbmNlJiYodGhpcy5pbnRlcmlvclBvaW50PW5ldyBnKHQpLHRoaXMubWluRGlzdGFuY2U9ZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVpfX0pLGUobGkucHJvdG90eXBlLHtnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JQb2ludH0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIEx0KXRoaXMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdClmb3IodmFyIGU9dCxuPTA7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4obikpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF0scj1pLmRpc3RhbmNlKHRoaXMuY2VudHJvaWQpO3I8dGhpcy5taW5EaXN0YW5jZSYmKHRoaXMuaW50ZXJpb3JQb2ludD1uZXcgZyhpKSx0aGlzLm1pbkRpc3RhbmNlPXIpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbGl9fSksZShoaS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGhpfX0pLGhpLnRvRGVncmVlcz1mdW5jdGlvbih0KXtyZXR1cm4gMTgwKnQvTWF0aC5QSX0saGkubm9ybWFsaXplPWZ1bmN0aW9uKHQpe2Zvcig7dD5NYXRoLlBJOyl0LT1oaS5QSV9USU1FU18yO2Zvcig7dDw9LU1hdGguUEk7KXQrPWhpLlBJX1RJTUVTXzI7cmV0dXJuIHR9LGhpLmFuZ2xlPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hdGFuMih0LnksdC54KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9bi54LWUueCxyPW4ueS1lLnk7cmV0dXJuIE1hdGguYXRhbjIocixpKX19LGhpLmlzQWN1dGU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9bi54LWUueCxvPW4ueS1lLnksYT1pKnMrcipvO3JldHVybiBhPjB9LGhpLmlzT2J0dXNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LngtZS54LHI9dC55LWUueSxzPW4ueC1lLngsbz1uLnktZS55LGE9aSpzK3IqbztyZXR1cm4gMD5hfSxoaS5pbnRlcmlvckFuZ2xlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1oaS5hbmdsZShlLHQpLHI9aGkuYW5nbGUoZSxuKTtyZXR1cm4gTWF0aC5hYnMoci1pKX0saGkubm9ybWFsaXplUG9zaXRpdmU9ZnVuY3Rpb24odCl7aWYoMD50KXtmb3IoOzA+dDspdCs9aGkuUElfVElNRVNfMjt0Pj1oaS5QSV9USU1FU18yJiYodD0wKX1lbHNle2Zvcig7dD49aGkuUElfVElNRVNfMjspdC09aGkuUElfVElNRVNfMjswPnQmJih0PTApfXJldHVybiB0fSxoaS5hbmdsZUJldHdlZW49ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWhpLmFuZ2xlKGUsdCkscj1oaS5hbmdsZShlLG4pO3JldHVybiBoaS5kaWZmKGkscil9LGhpLmRpZmY9ZnVuY3Rpb24odCxlKXt2YXIgbj1udWxsO3JldHVybiBuPWU+dD9lLXQ6dC1lLG4+TWF0aC5QSSYmKG49MipNYXRoLlBJLW4pLG59LGhpLnRvUmFkaWFucz1mdW5jdGlvbih0KXtyZXR1cm4gdCpNYXRoLlBJLzE4MH0saGkuZ2V0VHVybj1mdW5jdGlvbih0LGUpe3ZhciBuPU1hdGguc2luKGUtdCk7cmV0dXJuIG4+MD9oaS5DT1VOVEVSQ0xPQ0tXSVNFOjA+bj9oaS5DTE9DS1dJU0U6aGkuTk9ORX0saGkuYW5nbGVCZXR3ZWVuT3JpZW50ZWQ9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWhpLmFuZ2xlKGUsdCkscj1oaS5hbmdsZShlLG4pLHM9ci1pO3JldHVybiBzPD0tTWF0aC5QST9zK2hpLlBJX1RJTUVTXzI6cz5NYXRoLlBJP3MtaGkuUElfVElNRVNfMjpzfSxoaS5QSV9USU1FU18yPTIqTWF0aC5QSSxoaS5QSV9PVkVSXzI9TWF0aC5QSS8yLGhpLlBJX09WRVJfND1NYXRoLlBJLzQsaGkuQ09VTlRFUkNMT0NLV0lTRT1oZS5DT1VOVEVSQ0xPQ0tXSVNFLGhpLkNMT0NLV0lTRT1oZS5DTE9DS1dJU0UsaGkuTk9ORT1oZS5DT0xMSU5FQVIsZShjaS5wcm90b3R5cGUse2FyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuYXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LHNpZ25lZEFyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuc2lnbmVkQXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGludGVycG9sYXRlWjpmdW5jdGlvbih0KXtpZihudWxsPT09dCl0aHJvdyBuZXcgaShcIlN1cHBsaWVkIHBvaW50IGlzIG51bGwuXCIpO3JldHVybiBjaS5pbnRlcnBvbGF0ZVoodCx0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGxvbmdlc3RTaWRlTGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmxvbmdlc3RTaWRlTGVuZ3RoKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saXNBY3V0ZTpmdW5jdGlvbigpe3JldHVybiBjaS5pc0FjdXRlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sY2lyY3VtY2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmNpcmN1bWNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGFyZWEzRDpmdW5jdGlvbigpe3JldHVybiBjaS5hcmVhM0QodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxjZW50cm9pZDpmdW5jdGlvbigpe3JldHVybiBjaS5jZW50cm9pZCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGluQ2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmluQ2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY2l9fSksY2kuYXJlYT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE1hdGguYWJzKCgobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzIpfSxjaS5zaWduZWRBcmVhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4oKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yfSxjaS5kZXQ9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIHQqaS1lKm59LGNpLmludGVycG9sYXRlWj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1lLngscz1lLnksbz1uLngtcixhPWkueC1yLHU9bi55LXMsbD1pLnktcyxoPW8qbC1hKnUsYz10LngtcixmPXQueS1zLGc9KGwqYy1hKmYpL2gsZD0oLXUqYytvKmYpL2gscD1lLnorZyoobi56LWUueikrZCooaS56LWUueik7cmV0dXJuIHB9LGNpLmxvbmdlc3RTaWRlTGVuZ3RoPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmRpc3RhbmNlKGUpLHI9ZS5kaXN0YW5jZShuKSxzPW4uZGlzdGFuY2UodCksbz1pO3JldHVybiByPm8mJihvPXIpLHM+byYmKG89cyksb30sY2kuaXNBY3V0ZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhpLmlzQWN1dGUodCxlLG4pJiZoaS5pc0FjdXRlKGUsbix0KT8hIWhpLmlzQWN1dGUobix0LGUpOiExfSxjaS5jaXJjdW1jZW50cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4ueCxyPW4ueSxzPXQueC1pLG89dC55LXIsYT1lLngtaSx1PWUueS1yLGw9MipjaS5kZXQocyxvLGEsdSksaD1jaS5kZXQobyxzKnMrbypvLHUsYSphK3UqdSksYz1jaS5kZXQocyxzKnMrbypvLGEsYSphK3UqdSksZj1pLWgvbCxkPXIrYy9sO3JldHVybiBuZXcgZyhmLGQpfSxjaS5wZXJwZW5kaWN1bGFyQmlzZWN0b3I9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLngtdC54LGk9ZS55LXQueSxyPW5ldyBGKHQueCtuLzIsdC55K2kvMiwxKSxzPW5ldyBGKHQueC1pK24vMix0LnkrbitpLzIsMSk7cmV0dXJuIG5ldyBGKHIscyl9LGNpLmFuZ2xlQmlzZWN0b3I9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUuZGlzdGFuY2UodCkscj1lLmRpc3RhbmNlKG4pLHM9aS8oaStyKSxvPW4ueC10LngsYT1uLnktdC55LHU9bmV3IGcodC54K3Mqbyx0LnkrcyphKTtyZXR1cm4gdX0sY2kuYXJlYTNEPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLngtdC54LHI9ZS55LXQueSxzPWUuei10Lnosbz1uLngtdC54LGE9bi55LXQueSx1PW4uei10LnosbD1yKnUtcyphLGg9cypvLWkqdSxjPWkqYS1yKm8sZj1sKmwraCpoK2MqYyxnPU1hdGguc3FydChmKS8yO3JldHVybiBnfSxjaS5jZW50cm9pZD1mdW5jdGlvbih0LGUsbil7dmFyIGk9KHQueCtlLngrbi54KS8zLHI9KHQueStlLnkrbi55KS8zO3JldHVybiBuZXcgZyhpLHIpfSxjaS5pbkNlbnRyZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5kaXN0YW5jZShuKSxyPXQuZGlzdGFuY2Uobikscz10LmRpc3RhbmNlKGUpLG89aStyK3MsYT0oaSp0LngrciplLngrcypuLngpL28sdT0oaSp0LnkrciplLnkrcypuLnkpL287cmV0dXJuIG5ldyBnKGEsdSl9LGUoZmkucHJvdG90eXBlLHtnZXRSYWRpdXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5yYWRpdXN9LGdldERpYW1ldGVyOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuY2VudHJlKX12YXIgdD10aGlzLmV4dHJlbWFsUHRzWzBdLGU9dGhpcy5leHRyZW1hbFB0c1sxXTtyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCxlXSl9LGdldEV4dHJlbWFsUG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuZXh0cmVtYWxQdHN9LGNvbXB1dGVDaXJjbGVQb2ludHM6ZnVuY3Rpb24oKXtpZih0aGlzLmlucHV0LmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO2lmKDE9PT10aGlzLmlucHV0LmdldE51bVBvaW50cygpKXt2YXIgdD10aGlzLmlucHV0LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9W25ldyBnKHRbMF0pXSxudWxsfXZhciBlPXRoaXMuaW5wdXQuY29udmV4SHVsbCgpLG49ZS5nZXRDb29yZGluYXRlcygpLHQ9bjtpZihuWzBdLmVxdWFsczJEKG5bbi5sZW5ndGgtMV0pJiYodD1uZXcgQXJyYXkobi5sZW5ndGgtMSkuZmlsbChudWxsKSxILmNvcHlEZWVwKG4sMCx0LDAsbi5sZW5ndGgtMSkpLHQubGVuZ3RoPD0yKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPUguY29weURlZXAodCksbnVsbDtmb3IodmFyIGk9ZmkubG93ZXN0UG9pbnQodCkscj1maS5wb2ludFdpdE1pbkFuZ2xlV2l0aFgodCxpKSxzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBvPWZpLnBvaW50V2l0aE1pbkFuZ2xlV2l0aFNlZ21lbnQodCxpLHIpO2lmKGhpLmlzT2J0dXNlKGksbyxyKSlyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1bbmV3IGcoaSksbmV3IGcocildLG51bGw7aWYoaGkuaXNPYnR1c2UobyxpLHIpKWk9bztlbHNle2lmKCFoaS5pc09idHVzZShvLHIsaSkpcmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9W25ldyBnKGkpLG5ldyBnKHIpLG5ldyBnKG8pXSxudWxsO3I9b319Zi5zaG91bGROZXZlclJlYWNoSGVyZShcIkxvZ2ljIGZhaWx1cmUgaW4gTWluaW11bSBCb3VuZGluZyBDaXJjbGUgYWxnb3JpdGhtIVwiKX0sY29tcHV0ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5leHRyZW1hbFB0cz9udWxsOih0aGlzLmNvbXB1dGVDaXJjbGVQb2ludHMoKSx0aGlzLmNvbXB1dGVDZW50cmUoKSx2b2lkKG51bGwhPT10aGlzLmNlbnRyZSYmKHRoaXMucmFkaXVzPXRoaXMuY2VudHJlLmRpc3RhbmNlKHRoaXMuZXh0cmVtYWxQdHNbMF0pKSkpfSxnZXRGYXJ0aGVzdFBvaW50czpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLmV4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLmNlbnRyZSl9dmFyIHQ9dGhpcy5leHRyZW1hbFB0c1swXSxlPXRoaXMuZXh0cmVtYWxQdHNbdGhpcy5leHRyZW1hbFB0cy5sZW5ndGgtMV07cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsZV0pfSxnZXRDaXJjbGU6ZnVuY3Rpb24oKXtpZih0aGlzLmNvbXB1dGUoKSxudWxsPT09dGhpcy5jZW50cmUpcmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24oKTt2YXIgdD10aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLmNlbnRyZSk7cmV0dXJuIDA9PT10aGlzLnJhZGl1cz90OnQuYnVmZmVyKHRoaXMucmFkaXVzKX0sZ2V0Q2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuY2VudHJlfSxjb21wdXRlQ2VudHJlOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6dGhpcy5jZW50cmU9bnVsbDticmVhaztjYXNlIDE6dGhpcy5jZW50cmU9dGhpcy5leHRyZW1hbFB0c1swXTticmVhaztjYXNlIDI6dGhpcy5jZW50cmU9bmV3IGcoKHRoaXMuZXh0cmVtYWxQdHNbMF0ueCt0aGlzLmV4dHJlbWFsUHRzWzFdLngpLzIsKHRoaXMuZXh0cmVtYWxQdHNbMF0ueSt0aGlzLmV4dHJlbWFsUHRzWzFdLnkpLzIpO2JyZWFrO2Nhc2UgMzp0aGlzLmNlbnRyZT1jaS5jaXJjdW1jZW50cmUodGhpcy5leHRyZW1hbFB0c1swXSx0aGlzLmV4dHJlbWFsUHRzWzFdLHRoaXMuZXh0cmVtYWxQdHNbMl0pfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZml9fSksZmkucG9pbnRXaXRNaW5BbmdsZVdpdGhYPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXIuTUFYX1ZBTFVFLGk9bnVsbCxzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBvPXRbc107aWYobyE9PWUpe3ZhciBhPW8ueC1lLngsdT1vLnktZS55OzA+dSYmKHU9LXUpO3ZhciBsPU1hdGguc3FydChhKmErdSp1KSxoPXUvbDtuPmgmJihuPWgsaT1vKX19cmV0dXJuIGl9LGZpLmxvd2VzdFBvaW50PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10WzBdLG49MTtuPHQubGVuZ3RoO24rKyl0W25dLnk8ZS55JiYoZT10W25dKTtyZXR1cm4gZX0sZmkucG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPXIuTUFYX1ZBTFVFLHM9bnVsbCxvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBhPXRbb107aWYoYSE9PWUmJmEhPT1uKXt2YXIgdT1oaS5hbmdsZUJldHdlZW4oZSxhLG4pO2k+dSYmKGk9dSxzPWEpfX1yZXR1cm4gc30sZShnaS5wcm90b3R5cGUse2dldFdpZHRoQ29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLm1pbldpZHRoUHR9LGdldFN1cHBvcnRpbmdTZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLm1pbkJhc2VTZWcucDAsdGhpcy5taW5CYXNlU2VnLnAxXSl9LGdldERpYW1ldGVyOmZ1bmN0aW9uKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksbnVsbD09PXRoaXMubWluV2lkdGhQdClyZXR1cm4gdGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcobnVsbCk7dmFyIHQ9dGhpcy5taW5CYXNlU2VnLnByb2plY3QodGhpcy5taW5XaWR0aFB0KTtyZXR1cm4gdGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsdGhpcy5taW5XaWR0aFB0XSl9LGNvbXB1dGVXaWR0aENvbnZleDpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgVHQ/dGhpcy5jb252ZXhIdWxsUHRzPXQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKTp0aGlzLmNvbnZleEh1bGxQdHM9dC5nZXRDb29yZGluYXRlcygpLDA9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLm1pbldpZHRoPTAsdGhpcy5taW5XaWR0aFB0PW51bGwsdGhpcy5taW5CYXNlU2VnPW51bGwpOjE9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLm1pbldpZHRoPTAsdGhpcy5taW5XaWR0aFB0PXRoaXMuY29udmV4SHVsbFB0c1swXSx0aGlzLm1pbkJhc2VTZWcucDA9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMT10aGlzLmNvbnZleEh1bGxQdHNbMF0pOjI9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RofHwzPT09dGhpcy5jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5taW5XaWR0aD0wLHRoaXMubWluV2lkdGhQdD10aGlzLmNvbnZleEh1bGxQdHNbMF0sdGhpcy5taW5CYXNlU2VnLnAwPXRoaXMuY29udmV4SHVsbFB0c1swXSx0aGlzLm1pbkJhc2VTZWcucDE9dGhpcy5jb252ZXhIdWxsUHRzWzFdKTp0aGlzLmNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXIodGhpcy5jb252ZXhIdWxsUHRzKX0sY29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcjpmdW5jdGlvbih0KXt0aGlzLm1pbldpZHRoPXIuTUFYX1ZBTFVFO2Zvcih2YXIgZT0xLG49bmV3IGNlLGk9MDtpPHQubGVuZ3RoLTE7aSsrKW4ucDA9dFtpXSxuLnAxPXRbaSsxXSxlPXRoaXMuZmluZE1heFBlcnBEaXN0YW5jZSh0LG4sZSl9LGNvbXB1dGVNaW5pbXVtRGlhbWV0ZXI6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5taW5XaWR0aFB0KXJldHVybiBudWxsO2lmKHRoaXMuaXNDb252ZXgpdGhpcy5jb21wdXRlV2lkdGhDb252ZXgodGhpcy5pbnB1dEdlb20pO2Vsc2V7dmFyIHQ9bmV3IG1lKHRoaXMuaW5wdXRHZW9tKS5nZXRDb252ZXhIdWxsKCk7dGhpcy5jb21wdXRlV2lkdGhDb252ZXgodCl9fSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5taW5XaWR0aH0sZmluZE1heFBlcnBEaXN0YW5jZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbbl0pLHI9aSxzPW4sbz1zO3I+PWk7KWk9cixzPW8sbz1naS5uZXh0SW5kZXgodCxzKSxyPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbb10pO3JldHVybiBpPHRoaXMubWluV2lkdGgmJih0aGlzLm1pblB0SW5kZXg9cyx0aGlzLm1pbldpZHRoPWksdGhpcy5taW5XaWR0aFB0PXRbdGhpcy5taW5QdEluZGV4XSx0aGlzLm1pbkJhc2VTZWc9bmV3IGNlKGUpKSxzfSxnZXRNaW5pbXVtUmVjdGFuZ2xlOmZ1bmN0aW9uKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksMD09PXRoaXMubWluV2lkdGgpcmV0dXJuIHRoaXMubWluQmFzZVNlZy5wMC5lcXVhbHMyRCh0aGlzLm1pbkJhc2VTZWcucDEpP3RoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLm1pbkJhc2VTZWcucDApOnRoaXMubWluQmFzZVNlZy50b0dlb21ldHJ5KHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKSk7Zm9yKHZhciB0PXRoaXMubWluQmFzZVNlZy5wMS54LXRoaXMubWluQmFzZVNlZy5wMC54LGU9dGhpcy5taW5CYXNlU2VnLnAxLnktdGhpcy5taW5CYXNlU2VnLnAwLnksbj1yLk1BWF9WQUxVRSxpPS1yLk1BWF9WQUxVRSxzPXIuTUFYX1ZBTFVFLG89LXIuTUFYX1ZBTFVFLGE9MDthPHRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg7YSsrKXt2YXIgdT1naS5jb21wdXRlQyh0LGUsdGhpcy5jb252ZXhIdWxsUHRzW2FdKTt1PmkmJihpPXUpLG4+dSYmKG49dSk7dmFyIGw9Z2kuY29tcHV0ZUMoLWUsdCx0aGlzLmNvbnZleEh1bGxQdHNbYV0pO2w+byYmKG89bCkscz5sJiYocz1sKX12YXIgaD1naS5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsbyksYz1naS5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUscyksZj1naS5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxpKSxnPWdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LG4pLGQ9Zi5saW5lSW50ZXJzZWN0aW9uKGgpLHA9Zy5saW5lSW50ZXJzZWN0aW9uKGgpLHY9Zy5saW5lSW50ZXJzZWN0aW9uKGMpLG09Zi5saW5lSW50ZXJzZWN0aW9uKGMpLHk9dGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoW2QscCx2LG0sZF0pO3JldHVybiB0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbih5LG51bGwpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBnaX19KSxnaS5uZXh0SW5kZXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSsrLGU+PXQubGVuZ3RoJiYoZT0wKSxlfSxnaS5jb21wdXRlQz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHQqbi55LWUqbi54fSxnaS5nZXRNaW5pbXVtRGlhbWV0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnaSh0KS5nZXREaWFtZXRlcigpfSxnaS5nZXRNaW5pbXVtUmVjdGFuZ2xlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZ2kodCkuZ2V0TWluaW11bVJlY3RhbmdsZSgpfSxnaS5jb21wdXRlU2VnbWVudEZvckxpbmU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW51bGwscj1udWxsO3JldHVybiBNYXRoLmFicyhlKT5NYXRoLmFicyh0KT8oaT1uZXcgZygwLG4vZSkscj1uZXcgZygxLG4vZS10L2UpKTooaT1uZXcgZyhuL3QsMCkscj1uZXcgZyhuL3QtZS90LDEpKSxuZXcgY2UoaSxyKX07dmFyIGNvPU9iamVjdC5mcmVlemUoe0NlbnRyb2lkOmdlLENHQWxnb3JpdGhtczpoZSxDb252ZXhIdWxsOm1lLEludGVyaW9yUG9pbnRBcmVhOm9pLEludGVyaW9yUG9pbnRMaW5lOnVpLEludGVyaW9yUG9pbnRQb2ludDpsaSxSb2J1c3RMaW5lSW50ZXJzZWN0b3I6YWUsTWluaW11bUJvdW5kaW5nQ2lyY2xlOmZpLE1pbmltdW1EaWFtZXRlcjpnaX0pO2UoZGkucHJvdG90eXBlLHtnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbigpe3JldHVybiBuZXcgcGkodGhpcy5kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuaW5wdXRHZW9tKX0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7aWYoMD49dCl0aHJvdyBuZXcgaShcIlRvbGVyYW5jZSBtdXN0IGJlIHBvc2l0aXZlXCIpO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZGl9fSksZGkuZGVuc2lmeVBvaW50cz1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPW5ldyBjZSxyPW5ldyBOLHM9MDtzPHQubGVuZ3RoLTE7cysrKXtpLnAwPXRbc10saS5wMT10W3MrMV0sci5hZGQoaS5wMCwhMSk7dmFyIG89aS5nZXRMZW5ndGgoKSxhPU1hdGgudHJ1bmMoby9lKSsxO2lmKGE+MSlmb3IodmFyIHU9by9hLGw9MTthPmw7bCsrKXt2YXIgaD1sKnUvbyxjPWkucG9pbnRBbG9uZyhoKTtuLm1ha2VQcmVjaXNlKGMpLHIuYWRkKGMsITEpfX1yZXR1cm4gci5hZGQodFt0Lmxlbmd0aC0xXSwhMSksci50b0Nvb3JkaW5hdGVBcnJheSgpfSxkaS5kZW5zaWZ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGRpKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX0saChwaSx4ZSksZShwaS5wcm90b3R5cGUse3RyYW5zZm9ybU11bHRpUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfSx0cmFuc2Zvcm1Qb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49eGUucHJvdG90eXBlLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBPdD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxpPWRpLmRlbnNpZnlQb2ludHMobix0aGlzLmRpc3RhbmNlVG9sZXJhbmNlLGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBTdCYmMT09PWkubGVuZ3RoJiYoaT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSksdGhpcy5mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoaSl9LGNyZWF0ZVZhbGlkQXJlYTpmdW5jdGlvbih0KXtyZXR1cm4gdC5idWZmZXIoMCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHBpfX0pLGRpLkRlbnNpZnlUcmFuc2Zvcm1lcj1waTt2YXIgZm89T2JqZWN0LmZyZWV6ZSh7RGVuc2lmaWVyOmRpfSk7ZSh2aS5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztkb3tpZihudWxsPT09ZSlyZXR1cm4gbnVsbDtpZihlLmRlc3QoKS5lcXVhbHMyRCh0KSlyZXR1cm4gZTtlPWUub05leHQoKX13aGlsZShlIT09dGhpcyk7cmV0dXJuIG51bGx9LGRlc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnfSxvTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX25leHR9LGluc2VydDpmdW5jdGlvbih0KXtpZih0aGlzLm9OZXh0KCk9PT10aGlzKXJldHVybiB0aGlzLmluc2VydEFmdGVyKHQpLG51bGw7dmFyIGU9dGhpcy5jb21wYXJlVG8odCksbj10aGlzO2Rve3ZhciBpPW4ub05leHQoKSxyPWkuY29tcGFyZVRvKHQpO2lmKHIhPT1lfHxpPT09dGhpcylyZXR1cm4gbi5pbnNlcnRBZnRlcih0KSxudWxsO249aX13aGlsZShuIT09dGhpcyk7Zi5zaG91bGROZXZlclJlYWNoSGVyZSgpfSxpbnNlcnRBZnRlcjpmdW5jdGlvbih0KXtmLmVxdWFscyh0aGlzLl9vcmlnLHQub3JpZygpKTt2YXIgZT10aGlzLm9OZXh0KCk7dGhpcy5fc3ltLnNldE5leHQodCksdC5zeW0oKS5zZXROZXh0KGUpfSxkZWdyZWU6ZnVuY3Rpb24gdCgpe3ZhciB0PTAsZT10aGlzO2RvIHQrKyxlPWUub05leHQoKTt3aGlsZShlIT09dGhpcyk7cmV0dXJuIHR9LGVxdWFsczpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX29yaWcuZXF1YWxzMkQodCkmJnRoaXMuX3N5bS5fb3JpZy5lcXVhbHMoZSl9fSxkZWx0YVk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnLnktdGhpcy5fb3JpZy55fSxzeW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltfSxwcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bS5uZXh0KCkuX3N5bX0sY29tcGFyZUFuZ3VsYXJEaXJlY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kZWx0YVgoKSxuPXRoaXMuZGVsdGFZKCksaT10LmRlbHRhWCgpLHI9dC5kZWx0YVkoKTtpZihlPT09aSYmbj09PXIpcmV0dXJuIDA7dmFyIHM9SmUucXVhZHJhbnQoZSxuKSxvPUplLnF1YWRyYW50KGkscik7cmV0dXJuIHM+bz8xOm8+cz8tMTpoZS5jb21wdXRlT3JpZW50YXRpb24odC5fb3JpZyx0LmRlc3QoKSx0aGlzLmRlc3QoKSl9LHByZXZOb2RlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXM7Mj09PXQuZGVncmVlKCk7KWlmKHQ9dC5wcmV2KCksdD09PXRoaXMpcmV0dXJuIG51bGw7cmV0dXJuIHR9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10LG49dGhpcy5jb21wYXJlQW5ndWxhckRpcmVjdGlvbihlKTtyZXR1cm4gbn0sbmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9uZXh0fSxzZXRTeW06ZnVuY3Rpb24odCl7dGhpcy5fc3ltPXR9LG9yaWc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3JpZ30sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkhFKFwiK3RoaXMuX29yaWcueCtcIiBcIit0aGlzLl9vcmlnLnkrXCIsIFwiK3RoaXMuX3N5bS5fb3JpZy54K1wiIFwiK3RoaXMuX3N5bS5fb3JpZy55K1wiKVwifSxzZXROZXh0OmZ1bmN0aW9uKHQpe3RoaXMuX25leHQ9dH0saW5pdDpmdW5jdGlvbih0KXt0aGlzLnNldFN5bSh0KSx0LnNldFN5bSh0aGlzKSx0aGlzLnNldE5leHQodCksdC5zZXROZXh0KHRoaXMpfSxkZWx0YVg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnLngtdGhpcy5fb3JpZy54fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2aX19KSx2aS5pbml0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbCE9PXQuX3N5bXx8bnVsbCE9PWUuX3N5bXx8bnVsbCE9PXQuX25leHR8fG51bGwhPT1lLl9uZXh0KXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJFZGdlcyBhcmUgYWxyZWFkeSBpbml0aWFsaXplZFwiKTtyZXR1cm4gdC5pbml0KGUpLHR9LHZpLmNyZWF0ZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyB2aSh0KSxpPW5ldyB2aShlKTtyZXR1cm4gbi5pbml0KGkpLG59LGgobWksdmkpLGUobWkucHJvdG90eXBlLHttYXJrOmZ1bmN0aW9uKCl7dGhpcy5faXNNYXJrZWQ9ITB9LHNldE1hcms6ZnVuY3Rpb24odCl7dGhpcy5faXNNYXJrZWQ9dH0saXNNYXJrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1pfX0pLG1pLnNldE1hcmtCb3RoPWZ1bmN0aW9uKHQsZSl7dC5zZXRNYXJrKGUpLHQuc3ltKCkuc2V0TWFyayhlKX0sbWkuaXNNYXJrZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNNYXJrZWQoKX0sbWkuc2V0TWFyaz1mdW5jdGlvbih0LGUpe3Quc2V0TWFyayhlKX0sbWkubWFya0JvdGg9ZnVuY3Rpb24odCl7dC5tYXJrKCksdC5zeW0oKS5tYXJrKCl9LG1pLm1hcms9ZnVuY3Rpb24odCl7dC5tYXJrKCl9LGUoeWkucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMuY3JlYXRlKHQsZSk7bnVsbCE9PW4/bi5pbnNlcnQoaSk6dGhpcy52ZXJ0ZXhNYXAucHV0KHQsaSk7dmFyIHI9dGhpcy52ZXJ0ZXhNYXAuZ2V0KGUpO3JldHVybiBudWxsIT09cj9yLmluc2VydChpLnN5bSgpKTp0aGlzLnZlcnRleE1hcC5wdXQoZSxpLnN5bSgpKSxpfSxjcmVhdGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmNyZWF0ZUVkZ2UodCksaT10aGlzLmNyZWF0ZUVkZ2UoZSk7cmV0dXJuIHZpLmluaXQobixpKSxufSxjcmVhdGVFZGdlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdmkodCl9LGFkZEVkZ2U6ZnVuY3Rpb24odCxlKXtpZigheWkuaXNWYWxpZEVkZ2UodCxlKSlyZXR1cm4gbnVsbDt2YXIgbj10aGlzLnZlcnRleE1hcC5nZXQodCksaT1udWxsO2lmKG51bGwhPT1uJiYoaT1uLmZpbmQoZSkpLG51bGwhPT1pKXJldHVybiBpO3ZhciByPXRoaXMuaW5zZXJ0KHQsZSxuKTtyZXR1cm4gcn0sZ2V0VmVydGV4RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJ0ZXhNYXAudmFsdWVzKCl9LGZpbmRFZGdlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy52ZXJ0ZXhNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09bj9udWxsOm4uZmluZChlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geWl9fSkseWkuaXNWYWxpZEVkZ2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLmNvbXBhcmVUbyh0KTtyZXR1cm4gMCE9PW59LGgoeGksbWkpLGUoeGkucHJvdG90eXBlLHtzZXRTdGFydDpmdW5jdGlvbigpe3RoaXMuX2lzU3RhcnQ9ITB9LGlzU3RhcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNTdGFydH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geGl9fSksaChFaSx5aSksZShFaS5wcm90b3R5cGUse2NyZWF0ZUVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB4aSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRWl9fSksZShJaS5wcm90b3R5cGUse2FkZExpbmU6ZnVuY3Rpb24odCl7dGhpcy5saW5lcy5hZGQodGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC50b0Nvb3JkaW5hdGVBcnJheSgpKSl9LHVwZGF0ZVJpbmdTdGFydEVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNTdGFydCgpfHwodD10LnN5bSgpLHQuaXNTdGFydCgpKT9udWxsPT09dGhpcy5yaW5nU3RhcnRFZGdlPyh0aGlzLnJpbmdTdGFydEVkZ2U9dCxudWxsKTp2b2lkKHQub3JpZygpLmNvbXBhcmVUbyh0aGlzLnJpbmdTdGFydEVkZ2Uub3JpZygpKTwwJiYodGhpcy5yaW5nU3RhcnRFZGdlPXQpKTpudWxsfSxnZXRSZXN1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMucmVzdWx0JiZ0aGlzLmNvbXB1dGVSZXN1bHQoKSx0aGlzLnJlc3VsdH0scHJvY2VzczpmdW5jdGlvbih0KXt2YXIgZT10LnByZXZOb2RlKCk7bnVsbD09PWUmJihlPXQpLHRoaXMuc3RhY2tFZGdlcyhlKSx0aGlzLmJ1aWxkTGluZXMoKX0sYnVpbGRSaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBOLG49dDtmb3IoZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGk9PT10KWJyZWFrO2UuYWRkKGkub3JpZygpLmNvcHkoKSwhMSksbj1pfWUuYWRkKG4uZGVzdCgpLmNvcHkoKSwhMSksdGhpcy5hZGRMaW5lKGUpfSxidWlsZExpbmU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IE4sbj10O2Zvcih0aGlzLnJpbmdTdGFydEVkZ2U9bnVsbCxtaS5tYXJrQm90aChuKSxlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7dGhpcy51cGRhdGVSaW5nU3RhcnRFZGdlKG4pO3ZhciBpPW4ubmV4dCgpO2lmKGk9PT10KXJldHVybiB0aGlzLmJ1aWxkUmluZyh0aGlzLnJpbmdTdGFydEVkZ2UpLG51bGw7ZS5hZGQoaS5vcmlnKCkuY29weSgpLCExKSxuPWksbWkubWFya0JvdGgobil9ZS5hZGQobi5kZXN0KCkuY29weSgpLCExKSx0aGlzLnN0YWNrRWRnZXMobi5zeW0oKSksdGhpcy5hZGRMaW5lKGUpfSxzdGFja0VkZ2VzOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7ZG8gbWkuaXNNYXJrZWQoZSl8fHRoaXMubm9kZUVkZ2VTdGFjay5hZGQoZSksZT1lLm9OZXh0KCk7d2hpbGUoZSE9PXQpfSxjb21wdXRlUmVzdWx0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0VmVydGV4RWRnZXMoKSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO21pLmlzTWFya2VkKG4pfHx0aGlzLnByb2Nlc3Mobil9dGhpcy5yZXN1bHQ9dGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5saW5lcyl9LGJ1aWxkTGluZXM6ZnVuY3Rpb24oKXtmb3IoOyF0aGlzLm5vZGVFZGdlU3RhY2suZW1wdHkoKTspe3ZhciB0PXRoaXMubm9kZUVkZ2VTdGFjay5wb3AoKTttaS5pc01hcmtlZCh0KXx8dGhpcy5idWlsZExpbmUodCl9fSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTt0LmFwcGx5KHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBTdCYmdGhpcy5hZGQodCl9fSl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5hZGQoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0KXt2YXIgcj1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuZmFjdG9yeSYmKHRoaXMuZmFjdG9yeT1yLmdldEZhY3RvcnkoKSk7Zm9yKHZhciBzPXIuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbz0hMSxuPTE7bjxzLnNpemUoKTtuKyspe3ZhciBhPXRoaXMuZ3JhcGguYWRkRWRnZShzLmdldENvb3JkaW5hdGUobi0xKSxzLmdldENvb3JkaW5hdGUobikpO251bGwhPT1hJiYob3x8KGEuc2V0U3RhcnQoKSxvPSEwKSl9fX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSWl9fSksSWkuZGlzc29sdmU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IElpO3JldHVybiBlLmFkZCh0KSxlLmdldFJlc3VsdCgpfTt2YXIgZ289T2JqZWN0LmZyZWV6ZSh7TGluZURpc3NvbHZlcjpJaX0pO2UoTmkucHJvdG90eXBlLHtoYXNDaGlsZHJlbjpmdW5jdGlvbigpe2Zvcih2YXIgdD0wOzQ+dDt0KyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVt0XSlyZXR1cm4hMDtyZXR1cm4hMX0saXNQcnVuYWJsZTpmdW5jdGlvbigpe3JldHVybiEodGhpcy5oYXNDaGlsZHJlbigpfHx0aGlzLmhhc0l0ZW1zKCkpfSxhZGRBbGxJdGVtczpmdW5jdGlvbih0KXt0LmFkZEFsbCh0aGlzLml0ZW1zKTtmb3IodmFyIGU9MDs0PmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJnRoaXMuc3Vibm9kZVtlXS5hZGRBbGxJdGVtcyh0KTtyZXR1cm4gdH0sZ2V0Tm9kZUNvdW50OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzQ+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHQrPXRoaXMuc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0KzF9LHNpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ND5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrdGhpcy5pdGVtcy5zaXplKCl9LGFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nOmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDtlLmFkZEFsbCh0aGlzLml0ZW1zKTtmb3IodmFyIG49MDs0Pm47bisrKW51bGwhPT10aGlzLnN1Ym5vZGVbbl0mJnRoaXMuc3Vibm9kZVtuXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpfSx2aXNpdEl0ZW1zOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuaXRlbXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZS52aXNpdEl0ZW0obi5uZXh0KCkpfSxoYXNJdGVtczpmdW5jdGlvbigpe3JldHVybiF0aGlzLml0ZW1zLmlzRW1wdHkoKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4hMTtmb3IodmFyIG49ITEsaT0wOzQ+aTtpKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtpXSYmKG49dGhpcy5zdWJub2RlW2ldLnJlbW92ZSh0LGUpKSl7dGhpcy5zdWJub2RlW2ldLmlzUHJ1bmFibGUoKSYmKHRoaXMuc3Vibm9kZVtpXT1udWxsKTticmVha31yZXR1cm4gbj9uOm49dGhpcy5pdGVtcy5yZW1vdmUoZSl9LHZpc2l0OmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDt0aGlzLnZpc2l0SXRlbXModCxlKTtmb3IodmFyIG49MDs0Pm47bisrKW51bGwhPT10aGlzLnN1Ym5vZGVbbl0mJnRoaXMuc3Vibm9kZVtuXS52aXNpdCh0LGUpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxkZXB0aDpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDs0PmU7ZSsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXS5kZXB0aCgpO24+dCYmKHQ9bil9cmV0dXJuIHQrMX0saXNFbXB0eTpmdW5jdGlvbiB0KCl7dmFyIHQ9ITA7dGhpcy5pdGVtcy5pc0VtcHR5KCl8fCh0PSExKTtmb3IodmFyIGU9MDs0PmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0aGlzLnN1Ym5vZGVbZV0uaXNFbXB0eSgpfHwodD0hMSkpO3JldHVybiB0fSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5pdGVtcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3VdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOaX19KSxOaS5nZXRTdWJub2RlSW5kZXg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPS0xO3JldHVybiB0LmdldE1pblgoKT49ZSYmKHQuZ2V0TWluWSgpPj1uJiYoaT0zKSx0LmdldE1heFkoKTw9biYmKGk9MSkpLHQuZ2V0TWF4WCgpPD1lJiYodC5nZXRNaW5ZKCk+PW4mJihpPTIpLHQuZ2V0TWF4WSgpPD1uJiYoaT0wKSksaX0sQ2kuZXhwb25lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIFNpKDY0LHQpLTEwMjN9LENpLnBvd2VyT2YyPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLHQpfSxlKHdpLnByb3RvdHlwZSx7Z2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sY29tcHV0ZUtleTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zm9yKHRoaXMubGV2ZWw9d2kuY29tcHV0ZVF1YWRMZXZlbCh0KSx0aGlzLmVudj1uZXcgQyx0aGlzLmNvbXB1dGVLZXkodGhpcy5sZXZlbCx0KTshdGhpcy5lbnYuY29udGFpbnModCk7KXRoaXMubGV2ZWwrPTEsdGhpcy5jb21wdXRlS2V5KHRoaXMubGV2ZWwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9Q2kucG93ZXJPZjIoZSk7dGhpcy5wdC54PU1hdGguZmxvb3Iobi5nZXRNaW5YKCkvaSkqaSx0aGlzLnB0Lnk9TWF0aC5mbG9vcihuLmdldE1pblkoKS9pKSppLHRoaXMuZW52LmluaXQodGhpcy5wdC54LHRoaXMucHQueCtpLHRoaXMucHQueSx0aGlzLnB0LnkraSl9fSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVudn0sZ2V0Q2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKCh0aGlzLmVudi5nZXRNaW5YKCkrdGhpcy5lbnYuZ2V0TWF4WCgpKS8yLCh0aGlzLmVudi5nZXRNaW5ZKCkrdGhpcy5lbnYuZ2V0TWF4WSgpKS8yKX0sZ2V0UG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd2l9fSksd2kuY29tcHV0ZVF1YWRMZXZlbD1mdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpLGk9ZT5uP2U6bixyPUNpLmV4cG9uZW50KGkpKzE7cmV0dXJuIHJ9LGgoTGksTmkpLGUoTGkucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3ZhciBlPU5pLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuY2VudHJleCx0aGlzLmNlbnRyZXkpO2lmKC0xPT09ZSlyZXR1cm4gdGhpcztpZihudWxsIT09dGhpcy5zdWJub2RlW2VdKXt2YXIgbj10aGlzLnN1Ym5vZGVbZV07cmV0dXJuIG4uZmluZCh0KX1yZXR1cm4gdGhpc30saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lbnYuaW50ZXJzZWN0cyh0KX0sZ2V0U3Vibm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXRoaXMuc3Vibm9kZVt0XSYmKHRoaXMuc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuc3Vibm9kZVt0XX0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbnZ9LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9TmkuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmV4LHRoaXMuY2VudHJleSk7aWYoLTEhPT1lKXt2YXIgbj10aGlzLmdldFN1Ym5vZGUoZSk7cmV0dXJuIG4uZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc30sY3JlYXRlU3Vibm9kZTpmdW5jdGlvbih0KXt2YXIgZT0wLG49MCxpPTAscj0wO3N3aXRjaCh0KXtjYXNlIDA6ZT10aGlzLmVudi5nZXRNaW5YKCksbj10aGlzLmNlbnRyZXgsaT10aGlzLmVudi5nZXRNaW5ZKCkscj10aGlzLmNlbnRyZXk7YnJlYWs7Y2FzZSAxOmU9dGhpcy5jZW50cmV4LG49dGhpcy5lbnYuZ2V0TWF4WCgpLGk9dGhpcy5lbnYuZ2V0TWluWSgpLHI9dGhpcy5jZW50cmV5O2JyZWFrO2Nhc2UgMjplPXRoaXMuZW52LmdldE1pblgoKSxuPXRoaXMuY2VudHJleCxpPXRoaXMuY2VudHJleSxyPXRoaXMuZW52LmdldE1heFkoKTticmVhaztjYXNlIDM6ZT10aGlzLmNlbnRyZXgsbj10aGlzLmVudi5nZXRNYXhYKCksaT10aGlzLmNlbnRyZXkscj10aGlzLmVudi5nZXRNYXhZKCl9dmFyIHM9bmV3IEMoZSxuLGksciksbz1uZXcgTGkocyx0aGlzLmxldmVsLTEpO3JldHVybiBvfSxpbnNlcnROb2RlOmZ1bmN0aW9uKHQpe2YuaXNUcnVlKG51bGw9PT10aGlzLmVudnx8dGhpcy5lbnYuY29udGFpbnModC5lbnYpKTt2YXIgZT1OaS5nZXRTdWJub2RlSW5kZXgodC5lbnYsdGhpcy5jZW50cmV4LHRoaXMuY2VudHJleSk7aWYodC5sZXZlbD09PXRoaXMubGV2ZWwtMSl0aGlzLnN1Ym5vZGVbZV09dDtlbHNle3ZhciBuPXRoaXMuY3JlYXRlU3Vibm9kZShlKTtuLmluc2VydE5vZGUodCksdGhpcy5zdWJub2RlW2VdPW59fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMaX19KSxMaS5jcmVhdGVOb2RlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB3aSh0KSxuPW5ldyBMaShlLmdldEVudmVsb3BlKCksZS5nZXRMZXZlbCgpKTtyZXR1cm4gbn0sTGkuY3JlYXRlRXhwYW5kZWQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgQyhlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5lbnYpO3ZhciBpPUxpLmNyZWF0ZU5vZGUobik7cmV0dXJuIG51bGwhPT10JiZpLmluc2VydE5vZGUodCksaX0sZShSaS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJpfX0pLFJpLmlzWmVyb1dpZHRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS10O2lmKDA9PT1uKXJldHVybiEwO3ZhciBpPU1hdGgubWF4KE1hdGguYWJzKHQpLE1hdGguYWJzKGUpKSxyPW4vaSxzPUNpLmV4cG9uZW50KHIpO3JldHVybiBzPD1SaS5NSU5fQklOQVJZX0VYUE9ORU5UfSxSaS5NSU5fQklOQVJZX0VYUE9ORU5UPS01MCxoKFRpLE5pKSxlKFRpLnByb3RvdHlwZSx7aW5zZXJ0OmZ1bmN0aW9uKHQsZSl7dmFyIG49TmkuZ2V0U3Vibm9kZUluZGV4KHQsVGkub3JpZ2luLngsVGkub3JpZ2luLnkpO2lmKC0xPT09bilyZXR1cm4gdGhpcy5hZGQoZSksbnVsbDt2YXIgaT10aGlzLnN1Ym5vZGVbbl07aWYobnVsbD09PWl8fCFpLmdldEVudmVsb3BlKCkuY29udGFpbnModCkpe3ZhciByPUxpLmNyZWF0ZUV4cGFuZGVkKGksdCk7dGhpcy5zdWJub2RlW25dPXJ9dGhpcy5pbnNlcnRDb250YWluZWQodGhpcy5zdWJub2RlW25dLHQsZSl9LGlzU2VhcmNoTWF0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuITB9LGluc2VydENvbnRhaW5lZDpmdW5jdGlvbih0LGUsbil7Zi5pc1RydWUodC5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKGUpKTt2YXIgaT1SaS5pc1plcm9XaWR0aChlLmdldE1pblgoKSxlLmdldE1heFgoKSkscj1SaS5pc1plcm9XaWR0aChlLmdldE1pblkoKSxlLmdldE1heFkoKSkscz1udWxsO3M9aXx8cj90LmZpbmQoZSk6dC5nZXROb2RlKGUpLHMuYWRkKG4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUaX19KSxUaS5vcmlnaW49bmV3IGcoMCwwKSxlKFBpLnByb3RvdHlwZSx7c2l6ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5zaXplKCk6MH0saW5zZXJ0OmZ1bmN0aW9uKHQsZSl7dGhpcy5jb2xsZWN0U3RhdHModCk7dmFyIG49UGkuZW5zdXJlRXh0ZW50KHQsdGhpcy5taW5FeHRlbnQpO3RoaXMucm9vdC5pbnNlcnQobixlKX0scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IFluO3JldHVybiB0aGlzLnF1ZXJ5KHQsZSksZS5nZXRJdGVtcygpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5yb290LnZpc2l0KG4saSl9fSxxdWVyeUFsbDpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3JldHVybiB0aGlzLnJvb3QuYWRkQWxsSXRlbXModCksXG50fSxyZW1vdmU6ZnVuY3Rpb24odCxlKXt2YXIgbj1QaS5lbnN1cmVFeHRlbnQodCx0aGlzLm1pbkV4dGVudCk7cmV0dXJuIHRoaXMucm9vdC5yZW1vdmUobixlKX0sY29sbGVjdFN0YXRzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0V2lkdGgoKTtlPHRoaXMubWluRXh0ZW50JiZlPjAmJih0aGlzLm1pbkV4dGVudD1lKTt2YXIgbj10LmdldEhlaWdodCgpO248dGhpcy5taW5FeHRlbnQmJm4+MCYmKHRoaXMubWluRXh0ZW50PW4pfSxkZXB0aDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5kZXB0aCgpOjB9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMucm9vdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRmUsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFBpfX0pLFBpLmVuc3VyZUV4dGVudD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0TWluWCgpLGk9dC5nZXRNYXhYKCkscj10LmdldE1pblkoKSxzPXQuZ2V0TWF4WSgpO3JldHVybiBuIT09aSYmciE9PXM/dDoobj09PWkmJihuLT1lLzIsaT1uK2UvMikscj09PXMmJihyLT1lLzIscz1yK2UvMiksbmV3IEMobixpLHIscykpfSxQaS5zZXJpYWxWZXJzaW9uVUlEPS0weDY3OGI2MGM5NjdhMjU0MDA7dmFyIHBvPU9iamVjdC5mcmVlemUoe1F1YWR0cmVlOlBpfSksdm89T2JqZWN0LmZyZWV6ZSh7U1RSdHJlZTprZX0pLG1vPU9iamVjdC5mcmVlemUoe3F1YWR0cmVlOnBvLHN0cnRyZWU6dm99KSx5bz1bXCJQb2ludFwiLFwiTXVsdGlQb2ludFwiLFwiTGluZVN0cmluZ1wiLFwiTXVsdGlMaW5lU3RyaW5nXCIsXCJQb2x5Z29uXCIsXCJNdWx0aVBvbHlnb25cIl07ZShiaS5wcm90b3R5cGUse3JlYWQ6ZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwO2U9XCJzdHJpbmdcIj09dHlwZW9mIHQ/SlNPTi5wYXJzZSh0KTp0O3ZhciBuPWUudHlwZTtpZigheG9bbl0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK2UudHlwZSk7cmV0dXJuLTEhPT15by5pbmRleE9mKG4pP3hvW25dLmFwcGx5KHRoaXMsW2UuY29vcmRpbmF0ZXNdKTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09bj94b1tuXS5hcHBseSh0aGlzLFtlLmdlb21ldHJpZXNdKTp4b1tuXS5hcHBseSh0aGlzLFtlXSl9LHdyaXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0R2VvbWV0cnlUeXBlKCk7aWYoIUVvW2VdKXRocm93IG5ldyBFcnJvcihcIkdlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIEVvW2VdLmFwcGx5KHRoaXMsW3RdKX19KTt2YXIgeG89e0ZlYXR1cmU6ZnVuY3Rpb24odCl7dmFyIGU9e307Zm9yKHZhciBuIGluIHQpZVtuXT10W25dO2lmKHQuZ2VvbWV0cnkpe3ZhciBpPXQuZ2VvbWV0cnkudHlwZTtpZigheG9baV0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK3QudHlwZSk7ZS5nZW9tZXRyeT10aGlzLnJlYWQodC5nZW9tZXRyeSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD14by5iYm94LmFwcGx5KHRoaXMsW3QuYmJveF0pKSxlfSxGZWF0dXJlQ29sbGVjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT17fTtpZih0LmZlYXR1cmVzKXtlLmZlYXR1cmVzPVtdO2Zvcih2YXIgbj0wO248dC5mZWF0dXJlcy5sZW5ndGg7KytuKWUuZmVhdHVyZXMucHVzaCh0aGlzLnJlYWQodC5mZWF0dXJlc1tuXSkpfXJldHVybiB0LmJib3gmJihlLmJib3g9dGhpcy5wYXJzZS5iYm94LmFwcGx5KHRoaXMsW3QuYmJveF0pKSxlfSxjb29yZGluYXRlczpmdW5jdGlvbiB0KGUpe2Zvcih2YXIgdD1bXSxuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciBpPWVbbl07dC5wdXNoKG5ldyBnKGlbMF0saVsxXSkpfXJldHVybiB0fSxiYm94OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgZyh0WzBdLHRbMV0pLG5ldyBnKHRbMl0sdFsxXSksbmV3IGcodFsyXSx0WzNdKSxuZXcgZyh0WzBdLHRbM10pLG5ldyBnKHRbMF0sdFsxXSldKX0sUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodFswXSx0WzFdKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSl9LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbillLnB1c2goeG8uUG9pbnQuYXBwbHkodGhpcyxbdFtuXV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT14by5jb29yZGluYXRlcy5hcHBseSh0aGlzLFt0XSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZSl9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKWUucHVzaCh4by5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsW3Rbbl1dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9eG8uY29vcmRpbmF0ZXMuYXBwbHkodGhpcyxbdFswXV0pLG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhlKSxpPVtdLHI9MTtyPHQubGVuZ3RoOysrcil7dmFyIHM9dFtyXSxvPXhvLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsW3NdKSxhPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobyk7aS5wdXNoKGEpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4saSl9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKXt2YXIgaT10W25dO2UucHVzaCh4by5Qb2x5Z29uLmFwcGx5KHRoaXMsW2ldKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBpPXRbbl07ZS5wdXNoKHRoaXMucmVhZChpKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX19LEVvPXtjb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVyblt0LngsdC55XX0sUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9RW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFt0LmdldENvb3JkaW5hdGUoKV0pO3JldHVybnt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczplfX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPUVvLlBvaW50LmFwcGx5KHRoaXMsW2ldKTtlLnB1c2goci5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvaW50XCIsY29vcmRpbmF0ZXM6ZX19LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49dC5nZXRDb29yZGluYXRlcygpLGk9MDtpPG4ubGVuZ3RoOysraSl7dmFyIHI9bltpXTtlLnB1c2goRW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFtyXSkpfXJldHVybnt0eXBlOlwiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7KytuKXt2YXIgaT10Lmdlb21ldHJpZXNbbl0scj1Fby5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsW2ldKTtlLnB1c2goci5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aUxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sUG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT1bXSxuPUVvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbdC5zaGVsbF0pO2UucHVzaChuLmNvb3JkaW5hdGVzKTtmb3IodmFyIGk9MDtpPHQuaG9sZXMubGVuZ3RoOysraSl7dmFyIHI9dC5ob2xlc1tpXSxzPUVvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbcl0pO2UucHVzaChzLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIlBvbHlnb25cIixjb29yZGluYXRlczplfX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoOysrbil7dmFyIGk9dC5nZW9tZXRyaWVzW25dLHI9RW8uUG9seWdvbi5hcHBseSh0aGlzLFtpXSk7ZS5wdXNoKHIuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPWkuZ2V0R2VvbWV0cnlUeXBlKCk7ZS5wdXNoKEVvW3JdLmFwcGx5KHRoaXMsW2ldKSl9cmV0dXJue3R5cGU6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixnZW9tZXRyaWVzOmV9fX07ZShPaS5wcm90b3R5cGUse3JlYWQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wYXJzZXIucmVhZCh0KTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5nZXRUeXBlKCk9PT1lZS5GSVhFRCYmdGhpcy5yZWR1Y2VQcmVjaXNpb24oZSksZX0scmVkdWNlUHJlY2lzaW9uOmZ1bmN0aW9uKHQpe3ZhciBlLG47aWYodC5jb29yZGluYXRlKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5jb29yZGluYXRlKTtlbHNlIGlmKHQucG9pbnRzKWZvcihlPTAsbj10LnBvaW50cy5sZW5ndGg7bj5lO2UrKyl0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHQucG9pbnRzW2VdKTtlbHNlIGlmKHQuZ2VvbWV0cmllcylmb3IoZT0wLG49dC5nZW9tZXRyaWVzLmxlbmd0aDtuPmU7ZSsrKXRoaXMucmVkdWNlUHJlY2lzaW9uKHQuZ2VvbWV0cmllc1tlXSl9fSksZShfaS5wcm90b3R5cGUse3dyaXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX19KSxlKE1pLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnBhcnNlci5yZWFkKHQpO3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsLmdldFR5cGUoKT09PWVlLkZJWEVEJiZ0aGlzLnJlZHVjZVByZWNpc2lvbihlKSxlfSxyZWR1Y2VQcmVjaXNpb246ZnVuY3Rpb24odCl7aWYodC5jb29yZGluYXRlKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5jb29yZGluYXRlKTtlbHNlIGlmKHQucG9pbnRzKWZvcih2YXIgZT0wLG49dC5wb2ludHMuY29vcmRpbmF0ZXMubGVuZ3RoO24+ZTtlKyspdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0LnBvaW50cy5jb29yZGluYXRlc1tlXSk7ZWxzZSBpZih0Lmdlb21ldHJpZXMpZm9yKHZhciBpPTAscj10Lmdlb21ldHJpZXMubGVuZ3RoO3I+aTtpKyspdGhpcy5yZWR1Y2VQcmVjaXNpb24odC5nZW9tZXRyaWVzW2ldKX19KSxlKEFpLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIG9sLmdlb20uUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLkxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTGluZWFyUmluZz90aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5Qb2x5Z29uP3RoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLk11bHRpUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9pbnQodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTXVsdGlMaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21NdWx0aUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTXVsdGlQb2x5Z29uP3RoaXMuY29udmVydEZyb21NdWx0aVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uP3RoaXMuY29udmVydEZyb21Db2xsZWN0aW9uKHQpOnZvaWQgMH0sY29udmVydEZyb21Qb2ludDpmdW5jdGlvbih0KXt2YXIgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBnKGVbMF0sZVsxXSkpfSxjb252ZXJ0RnJvbUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodFswXSx0WzFdKX0pKX0sY29udmVydEZyb21MaW5lYXJSaW5nOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKHRbMF0sdFsxXSl9KSl9LGNvbnZlcnRGcm9tUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRMaW5lYXJSaW5ncygpLG49bnVsbCxpPVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIHM9dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcoZVtyXSk7MD09PXI/bj1zOmkucHVzaChzKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLGkpfSxjb252ZXJ0RnJvbU11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRQb2ludHMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2ludCh0KX0sdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9LGNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0TGluZVN0cmluZ3MoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxjb252ZXJ0RnJvbU11bHRpUG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT10LmdldFBvbHlnb25zKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KX0sdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sY29udmVydEZyb21Db2xsZWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0R2VvbWV0cmllcygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkKHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfSx3cml0ZTpmdW5jdGlvbih0KXtyZXR1cm5cIlBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9pbnQodC5nZXRDb29yZGluYXRlKCkpOlwiTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodCk6XCJMaW5lYXJSaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZWFyUmluZyh0KTpcIlBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQpOlwiTXVsdGlQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9pbnQodCk6XCJNdWx0aUxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCk6XCJNdWx0aVBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvbHlnb24odCk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Db2xsZWN0aW9uKHQpOnZvaWQgMH0sY29udmVydFRvUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBvbC5nZW9tLlBvaW50KFt0LngsdC55XSl9LGNvbnZlcnRUb0xpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludHMuY29vcmRpbmF0ZXMubWFwKERpKTtyZXR1cm4gbmV3IG9sLmdlb20uTGluZVN0cmluZyhlKX0sY29udmVydFRvTGluZWFyUmluZzpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50cy5jb29yZGluYXRlcy5tYXAoRGkpO3JldHVybiBuZXcgb2wuZ2VvbS5MaW5lYXJSaW5nKGUpfSxjb252ZXJ0VG9Qb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bdC5zaGVsbC5wb2ludHMuY29vcmRpbmF0ZXMubWFwKERpKV0sbj0wO248dC5ob2xlcy5sZW5ndGg7bisrKWUucHVzaCh0LmhvbGVzW25dLnBvaW50cy5jb29yZGluYXRlcy5tYXAoRGkpKTtyZXR1cm4gbmV3IG9sLmdlb20uUG9seWdvbihlKX0sY29udmVydFRvTXVsdGlQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IG9sLmdlb20uTXVsdGlQb2ludCh0LmdldENvb3JkaW5hdGVzKCkubWFwKERpKSl9LGNvbnZlcnRUb011bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvTGluZVN0cmluZyh0Lmdlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgb2wuZ2VvbS5NdWx0aUxpbmVTdHJpbmcoZSl9LGNvbnZlcnRUb011bHRpUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvUG9seWdvbih0Lmdlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgb2wuZ2VvbS5NdWx0aVBvbHlnb24oZSl9LGNvbnZlcnRUb0NvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7bisrKXt2YXIgaT10Lmdlb21ldHJpZXNbbl07ZS5wdXNoKHRoaXMud3JpdGUoaSkpfXJldHVybiBuZXcgb2wuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSk7dmFyIElvPU9iamVjdC5mcmVlemUoe0dlb0pTT05SZWFkZXI6T2ksR2VvSlNPTldyaXRlcjpfaSxPTDNQYXJzZXI6QWksV0tUUmVhZGVyOk1pLFdLVFdyaXRlcjpzZX0pO2UoRmkucHJvdG90eXBlLHtyZXNjYWxlOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMucmVzY2FsZShuLmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9bnVsbCxzPW51bGw7Mj09PWkubGVuZ3RoJiYocj1uZXcgZyhpWzBdKSxzPW5ldyBnKGlbMV0pKTtmb3IodmFyIGU9MDtlPGkubGVuZ3RoO2UrKylpW2VdLng9aVtlXS54L3RoaXMuc2NhbGVGYWN0b3IrdGhpcy5vZmZzZXRYLGlbZV0ueT1pW2VdLnkvdGhpcy5zY2FsZUZhY3Rvcit0aGlzLm9mZnNldFk7Mj09PWkubGVuZ3RoJiZpWzBdLmVxdWFsczJEKGlbMV0pJiZBLm91dC5wcmludGxuKGkpfX0sc2NhbGU6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5hZGQobmV3IEtlKHRoaXMuc2NhbGUoaS5nZXRDb29yZGluYXRlcygpKSxpLmdldERhdGEoKSkpfXJldHVybiBlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgcj1hcmd1bWVudHNbMF0scz1uZXcgQXJyYXkoci5sZW5ndGgpLmZpbGwobnVsbCksbj0wO248ci5sZW5ndGg7bisrKXNbbl09bmV3IGcoTWF0aC5yb3VuZCgocltuXS54LXRoaXMub2Zmc2V0WCkqdGhpcy5zY2FsZUZhY3RvciksTWF0aC5yb3VuZCgocltuXS55LXRoaXMub2Zmc2V0WSkqdGhpcy5zY2FsZUZhY3RvcikscltuXS56KTt2YXIgbz1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHMpO3JldHVybiBvfX0saXNJbnRlZ2VyUHJlY2lzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLnNjYWxlRmFjdG9yfSxnZXROb2RlZFN1YnN0cmluZ3M6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm5vZGVyLmdldE5vZGVkU3Vic3RyaW5ncygpO3JldHVybiB0aGlzLmlzU2NhbGVkJiZ0aGlzLnJlc2NhbGUodCksdH0sY29tcHV0ZU5vZGVzOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5pc1NjYWxlZCYmKGU9dGhpcy5zY2FsZSh0KSksdGhpcy5ub2Rlci5jb21wdXRlTm9kZXMoZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3RuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRml9fSk7dmFyIE5vPU9iamVjdC5mcmVlemUoe01DSW5kZXhOb2RlcjpubixTY2FsZWROb2RlcjpGaSxTZWdtZW50U3RyaW5nOmJlfSk7ZShHaS5wcm90b3R5cGUse2lzU2ltcGxlTXVsdGlQb2ludDpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtmb3IodmFyIGU9bmV3IGF0LG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dC5nZXRHZW9tZXRyeU4obikscj1pLmdldENvb3JkaW5hdGUoKTtpZihlLmNvbnRhaW5zKHIpKXJldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPXIsITE7ZS5hZGQocil9cmV0dXJuITB9LGlzU2ltcGxlUG9seWdvbmFsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1rbi5nZXRMaW5lcyh0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKCF0aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkoaSkpcmV0dXJuITF9cmV0dXJuITB9LGhhc0Nsb3NlZEVuZHBvaW50SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgcnQsbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj0oaS5nZXRNYXhpbXVtU2VnbWVudEluZGV4KCksaS5pc0Nsb3NlZCgpKSxzPWkuZ2V0Q29vcmRpbmF0ZSgwKTt0aGlzLmFkZEVuZHBvaW50KGUscyxyKTt2YXIgbz1pLmdldENvb3JkaW5hdGUoaS5nZXROdW1Qb2ludHMoKS0xKTt0aGlzLmFkZEVuZHBvaW50KGUsbyxyKX1mb3IodmFyIG49ZS52YWx1ZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGE9bi5uZXh0KCk7aWYoYS5pc0Nsb3NlZCYmMiE9PWEuZGVncmVlKXJldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPWEuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfSxnZXROb25TaW1wbGVMb2NhdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9ufSxpc1NpbXBsZUxpbmVhckdlb21ldHJ5OmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO3ZhciBlPW5ldyAkbigwLHQpLG49bmV3IGFlLGk9ZS5jb21wdXRlU2VsZk5vZGVzKG4sITApO3JldHVybiBpLmhhc0ludGVyc2VjdGlvbigpP2kuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMubm9uU2ltcGxlTG9jYXRpb249aS5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKTp0aGlzLmhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uKGUpPyExOiF0aGlzLmlzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcnx8IXRoaXMuaGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSk6ITB9LGhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldE1heGltdW1TZWdtZW50SW5kZXgoKSxyPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYoIXMuaXNFbmRQb2ludChpKSlyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1zLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX0sYWRkRW5kcG9pbnQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0KGUpO251bGw9PT1pJiYoaT1uZXcgcWkoZSksdC5wdXQoZSxpKSksaS5hZGRFbmRwb2ludChuKX0sY29tcHV0ZVNpbXBsZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1udWxsLHQuaXNFbXB0eSgpPyEwOnQgaW5zdGFuY2VvZiBTdD90aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCk6dCBpbnN0YW5jZW9mIGd0P3RoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KTp0IGluc3RhbmNlb2YgUHQ/dGhpcy5pc1NpbXBsZU11bHRpUG9pbnQodCk6Uih0LFJ0KT90aGlzLmlzU2ltcGxlUG9seWdvbmFsKHQpOnQgaW5zdGFuY2VvZiBmdD90aGlzLmlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uKHQpOiEwfSxpc1NpbXBsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPW51bGwsdGhpcy5jb21wdXRlU2ltcGxlKHRoaXMuaW5wdXRHZW9tKX0saXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmNvbXB1dGVTaW1wbGUobikpcmV0dXJuITF9cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEdpfX0pLGUocWkucHJvdG90eXBlLHthZGRFbmRwb2ludDpmdW5jdGlvbih0KXt0aGlzLmRlZ3JlZSsrLHRoaXMuaXNDbG9zZWR8PXR9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcWl9fSksR2kuRW5kcG9pbnRJbmZvPXFpLGUoQmkucHJvdG90eXBlLHtnZXRFbmRDYXBTdHlsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZENhcFN0eWxlfSxpc1NpbmdsZVNpZGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzU2luZ2xlU2lkZWR9LHNldFF1YWRyYW50U2VnbWVudHM6ZnVuY3Rpb24odCl7dGhpcy5xdWFkcmFudFNlZ21lbnRzPXQsMD09PXRoaXMucXVhZHJhbnRTZWdtZW50cyYmKHRoaXMuam9pblN0eWxlPUJpLkpPSU5fQkVWRUwpLHRoaXMucXVhZHJhbnRTZWdtZW50czwwJiYodGhpcy5qb2luU3R5bGU9QmkuSk9JTl9NSVRSRSx0aGlzLm1pdHJlTGltaXQ9TWF0aC5hYnModGhpcy5xdWFkcmFudFNlZ21lbnRzKSksMD49dCYmKHRoaXMucXVhZHJhbnRTZWdtZW50cz0xKSx0aGlzLmpvaW5TdHlsZSE9PUJpLkpPSU5fUk9VTkQmJih0aGlzLnF1YWRyYW50U2VnbWVudHM9QmkuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyl9LGdldEpvaW5TdHlsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmpvaW5TdHlsZX0sc2V0Sm9pblN0eWxlOmZ1bmN0aW9uKHQpe3RoaXMuam9pblN0eWxlPXR9LHNldFNpbXBsaWZ5RmFjdG9yOmZ1bmN0aW9uKHQpe3RoaXMuc2ltcGxpZnlGYWN0b3I9MD50PzA6dH0sZ2V0U2ltcGxpZnlGYWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaW1wbGlmeUZhY3Rvcn0sZ2V0UXVhZHJhbnRTZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnF1YWRyYW50U2VnbWVudHN9LHNldEVuZENhcFN0eWxlOmZ1bmN0aW9uKHQpe3RoaXMuZW5kQ2FwU3R5bGU9dH0sZ2V0TWl0cmVMaW1pdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pdHJlTGltaXR9LHNldE1pdHJlTGltaXQ6ZnVuY3Rpb24odCl7dGhpcy5taXRyZUxpbWl0PXR9LHNldFNpbmdsZVNpZGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzU2luZ2xlU2lkZWQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQml9fSksQmkuYnVmZmVyRGlzdGFuY2VFcnJvcj1mdW5jdGlvbih0KXt2YXIgZT1NYXRoLlBJLzIvdDtyZXR1cm4gMS1NYXRoLmNvcyhlLzIpfSxCaS5DQVBfUk9VTkQ9MSxCaS5DQVBfRkxBVD0yLEJpLkNBUF9TUVVBUkU9MyxCaS5KT0lOX1JPVU5EPTEsQmkuSk9JTl9NSVRSRT0yLEJpLkpPSU5fQkVWRUw9MyxCaS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTPTgsQmkuREVGQVVMVF9NSVRSRV9MSU1JVD01LEJpLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SPS4wMSxlKHppLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbkNvb3JkfSxnZXRSaWdodG1vc3RTaWRlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZSk7cmV0dXJuIDA+biYmKG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZS0xKSksMD5uJiYodGhpcy5taW5Db29yZD1udWxsLHRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpKSxufSxmaW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmLmlzVHJ1ZSh0aGlzLm1pbkluZGV4PjAmJnRoaXMubWluSW5kZXg8dC5sZW5ndGgsXCJyaWdodG1vc3QgcG9pbnQgZXhwZWN0ZWQgdG8gYmUgaW50ZXJpb3IgdmVydGV4IG9mIGVkZ2VcIik7dmFyIGU9dFt0aGlzLm1pbkluZGV4LTFdLG49dFt0aGlzLm1pbkluZGV4KzFdLGk9aGUuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMubWluQ29vcmQsbixlKSxyPSExO2UueTx0aGlzLm1pbkNvb3JkLnkmJm4ueTx0aGlzLm1pbkNvb3JkLnkmJmk9PT1oZS5DT1VOVEVSQ0xPQ0tXSVNFP3I9ITA6ZS55PnRoaXMubWluQ29vcmQueSYmbi55PnRoaXMubWluQ29vcmQueSYmaT09PWhlLkNMT0NLV0lTRSYmKHI9ITApLHImJih0aGlzLm1pbkluZGV4PXRoaXMubWluSW5kZXgtMSl9LGdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldEVkZ2UoKSxpPW4uZ2V0Q29vcmRpbmF0ZXMoKTtpZigwPmV8fGUrMT49aS5sZW5ndGgpcmV0dXJuLTE7aWYoaVtlXS55PT09aVtlKzFdLnkpcmV0dXJuLTE7dmFyIHI9Y24uTEVGVDtyZXR1cm4gaVtlXS55PGlbZSsxXS55JiYocj1jbi5SSUdIVCkscn0sZ2V0RWRnZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWVudGVkRGV9LGNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuPTA7bjxlLmxlbmd0aC0xO24rKykobnVsbD09PXRoaXMubWluQ29vcmR8fGVbbl0ueD50aGlzLm1pbkNvb3JkLngpJiYodGhpcy5taW5EZT10LHRoaXMubWluSW5kZXg9bix0aGlzLm1pbkNvb3JkPWVbbl0pfSxmaW5kUmlnaHRtb3N0RWRnZUF0Tm9kZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWluRGUuZ2V0Tm9kZSgpLGU9dC5nZXRFZGdlcygpO3RoaXMubWluRGU9ZS5nZXRSaWdodG1vc3RFZGdlKCksdGhpcy5taW5EZS5pc0ZvcndhcmQoKXx8KHRoaXMubWluRGU9dGhpcy5taW5EZS5nZXRTeW0oKSx0aGlzLm1pbkluZGV4PXRoaXMubWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpfSxmaW5kRWRnZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5pc0ZvcndhcmQoKSYmdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUobil9Zi5pc1RydWUoMCE9PXRoaXMubWluSW5kZXh8fHRoaXMubWluQ29vcmQuZXF1YWxzKHRoaXMubWluRGUuZ2V0Q29vcmRpbmF0ZSgpKSxcImluY29uc2lzdGVuY3kgaW4gcmlnaHRtb3N0IHByb2Nlc3NpbmdcIiksMD09PXRoaXMubWluSW5kZXg/dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpOnRoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpLHRoaXMub3JpZW50ZWREZT10aGlzLm1pbkRlO3ZhciBpPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZSh0aGlzLm1pbkRlLHRoaXMubWluSW5kZXgpO2k9PT1jbi5MRUZUJiYodGhpcy5vcmllbnRlZERlPXRoaXMubWluRGUuZ2V0U3ltKCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6aX19KSxWaS5wcm90b3R5cGUuYWRkTGFzdD1mdW5jdGlvbih0KXt0aGlzLmFycmF5Xy5wdXNoKHQpfSxWaS5wcm90b3R5cGUucmVtb3ZlRmlyc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8uc2hpZnQoKX0sVmkucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sZShraS5wcm90b3R5cGUse2NsZWFyVmlzaXRlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2Uuc2V0VmlzaXRlZCghMSl9fSxnZXRSaWdodG1vc3RDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmlnaHRNb3N0Q29vcmR9LGNvbXB1dGVOb2RlRGVwdGg6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuaXNWaXNpdGVkKCl8fGkuZ2V0U3ltKCkuaXNWaXNpdGVkKCkpe2U9aTticmVha319aWYobnVsbD09PWUpdGhyb3cgbmV3IHNuKFwidW5hYmxlIHRvIGZpbmQgZWRnZSB0byBjb21wdXRlIGRlcHRocyBhdCBcIit0LmdldENvb3JkaW5hdGUoKSk7dC5nZXRFZGdlcygpLmNvbXB1dGVEZXB0aHMoZSk7Zm9yKHZhciBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5zZXRWaXNpdGVkKCEwKSx0aGlzLmNvcHlTeW1EZXB0aHMoaSl9fSxjb21wdXRlRGVwdGg6ZnVuY3Rpb24odCl7dGhpcy5jbGVhclZpc2l0ZWRFZGdlcygpO3ZhciBlPXRoaXMuZmluZGVyLmdldEVkZ2UoKTtlLmdldE5vZGUoKSxlLmdldExhYmVsKCk7ZS5zZXRFZGdlRGVwdGhzKGNuLlJJR0hULHQpLHRoaXMuY29weVN5bURlcHRocyhlKSx0aGlzLmNvbXB1dGVEZXB0aHMoZSl9LGNyZWF0ZTpmdW5jdGlvbih0KXt0aGlzLmFkZFJlYWNoYWJsZSh0KSx0aGlzLmZpbmRlci5maW5kRWRnZSh0aGlzLmRpckVkZ2VMaXN0KSx0aGlzLnJpZ2h0TW9zdENvb3JkPXRoaXMuZmluZGVyLmdldENvb3JkaW5hdGUoKX0sZmluZFJlc3VsdEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RGVwdGgoY24uUklHSFQpPj0xJiZlLmdldERlcHRoKGNuLkxFRlQpPD0wJiYhZS5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmZS5zZXRJblJlc3VsdCghMCl9fSxjb21wdXRlRGVwdGhzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBKLG49bmV3IFZpLGk9dC5nZXROb2RlKCk7Zm9yKG4uYWRkTGFzdChpKSxlLmFkZChpKSx0LnNldFZpc2l0ZWQoITApOyFuLmlzRW1wdHkoKTspe3ZhciByPW4ucmVtb3ZlRmlyc3QoKTtlLmFkZChyKSx0aGlzLmNvbXB1dGVOb2RlRGVwdGgocik7Zm9yKHZhciBzPXIuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksYT1vLmdldFN5bSgpO2lmKCFhLmlzVmlzaXRlZCgpKXt2YXIgdT1hLmdldE5vZGUoKTtlLmNvbnRhaW5zKHUpfHwobi5hZGRMYXN0KHUpLGUuYWRkKHUpKX19fX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMucmlnaHRNb3N0Q29vcmQueDxlLnJpZ2h0TW9zdENvb3JkLng/LTE6dGhpcy5yaWdodE1vc3RDb29yZC54PmUucmlnaHRNb3N0Q29vcmQueD8xOjB9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZW52KXtmb3IodmFyIHQ9bmV3IEMsZT10aGlzLmRpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCkscj0wO3I8aS5sZW5ndGgtMTtyKyspdC5leHBhbmRUb0luY2x1ZGUoaVtyXSk7dGhpcy5lbnY9dH1yZXR1cm4gdGhpcy5lbnZ9LGFkZFJlYWNoYWJsZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgcGU7Zm9yKGUuYWRkKHQpOyFlLmVtcHR5KCk7KXt2YXIgbj1lLnBvcCgpO3RoaXMuYWRkKG4sZSl9fSxjb3B5U3ltRGVwdGhzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0U3ltKCk7ZS5zZXREZXB0aChjbi5MRUZULHQuZ2V0RGVwdGgoY24uUklHSFQpKSxlLnNldERlcHRoKGNuLlJJR0hULHQuZ2V0RGVwdGgoY24uTEVGVCkpfSxhZGQ6ZnVuY3Rpb24odCxlKXt0LnNldFZpc2l0ZWQoITApLHRoaXMubm9kZXMuYWRkKHQpO2Zvcih2YXIgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuZGlyRWRnZUxpc3QuYWRkKGkpO3ZhciByPWkuZ2V0U3ltKCkscz1yLmdldE5vZGUoKTtzLmlzVmlzaXRlZCgpfHxlLnB1c2gocyl9fSxnZXROb2RlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzfSxnZXREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlyRWRnZUxpc3R9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBraX19KSxlKFlpLnByb3RvdHlwZSx7aXNEZWxldGFibGU6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dGhpcy5pbnB1dExpbmVbdF0scz10aGlzLmlucHV0TGluZVtlXSxvPXRoaXMuaW5wdXRMaW5lW25dO3JldHVybiB0aGlzLmlzQ29uY2F2ZShyLHMsbykmJnRoaXMuaXNTaGFsbG93KHIscyxvLGkpP3RoaXMuaXNTaGFsbG93U2FtcGxlZChyLHMsdCxuLGkpOiExfSxkZWxldGVTaGFsbG93Q29uY2F2aXRpZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MSxlPSh0aGlzLmlucHV0TGluZS5sZW5ndGgtMSx0aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpKSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSksaT0hMTtuPHRoaXMuaW5wdXRMaW5lLmxlbmd0aDspe3ZhciByPSExO3RoaXMuaXNEZWxldGFibGUodCxlLG4sdGhpcy5kaXN0YW5jZVRvbCkmJih0aGlzLmlzRGVsZXRlZFtlXT1ZaS5ERUxFVEUscj0hMCxpPSEwKSx0PXI/bjplLGU9dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSl9cmV0dXJuIGl9LGlzU2hhbGxvd0NvbmNhdml0eTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLG4pLHM9cj09PXRoaXMuYW5nbGVPcmllbnRhdGlvbjtpZighcylyZXR1cm4hMTt2YXIgbz1oZS5kaXN0YW5jZVBvaW50TGluZShlLHQsbik7cmV0dXJuIGk+b30saXNTaGFsbG93U2FtcGxlZDpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPU1hdGgudHJ1bmMoKGktbikvWWkuTlVNX1BUU19UT19DSEVDSyk7MD49cyYmKHM9MSk7Zm9yKHZhciBvPW47aT5vO28rPXMpaWYoIXRoaXMuaXNTaGFsbG93KHQsZSx0aGlzLmlucHV0TGluZVtvXSxyKSlyZXR1cm4hMTtyZXR1cm4hMH0saXNDb25jYXZlOmZ1bmN0aW9uIHQoZSxuLGkpe3ZhciByPWhlLmNvbXB1dGVPcmllbnRhdGlvbihlLG4saSksdD1yPT09dGhpcy5hbmdsZU9yaWVudGF0aW9uO3JldHVybiB0fSxzaW1wbGlmeTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sPU1hdGguYWJzKHQpLDA+dCYmKHRoaXMuYW5nbGVPcmllbnRhdGlvbj1oZS5DTE9DS1dJU0UpLHRoaXMuaXNEZWxldGVkPW5ldyBBcnJheSh0aGlzLmlucHV0TGluZS5sZW5ndGgpLmZpbGwobnVsbCk7dmFyIGU9ITE7ZG8gZT10aGlzLmRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpO3doaWxlKGUpO3JldHVybiB0aGlzLmNvbGxhcHNlTGluZSgpfSxmaW5kTmV4dE5vbkRlbGV0ZWRJbmRleDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dCsxO2U8dGhpcy5pbnB1dExpbmUubGVuZ3RoJiZ0aGlzLmlzRGVsZXRlZFtlXT09PVlpLkRFTEVURTspZSsrO3JldHVybiBlfSxpc1NoYWxsb3c6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9aGUuZGlzdGFuY2VQb2ludExpbmUoZSx0LG4pO3JldHVybiBpPnJ9LGNvbGxhcHNlTGluZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgTixlPTA7ZTx0aGlzLmlucHV0TGluZS5sZW5ndGg7ZSsrKXRoaXMuaXNEZWxldGVkW2VdIT09WWkuREVMRVRFJiZ0LmFkZCh0aGlzLmlucHV0TGluZVtlXSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWWl9fSksWWkuc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgWWkodCk7cmV0dXJuIG4uc2ltcGxpZnkoZSl9LFlpLklOSVQ9MCxZaS5ERUxFVEU9MSxZaS5LRUVQPTEsWWkuTlVNX1BUU19UT19DSEVDSz0xMCxlKFVpLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnB0TGlzdC50b0FycmF5KFVpLkNPT1JESU5BVEVfQVJSQVlfVFlQRSk7cmV0dXJuIHR9LHNldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKHQpe3RoaXMucHJlY2lzaW9uTW9kZWw9dH0sYWRkUHQ6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodCk7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoZSksdGhpcy5pc1JlZHVuZGFudChlKT9udWxsOnZvaWQgdGhpcy5wdExpc3QuYWRkKGUpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7fSxhZGRQdHM6ZnVuY3Rpb24odCxlKXtpZihlKWZvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXRoaXMuYWRkUHQodFtuXSk7ZWxzZSBmb3IodmFyIG49dC5sZW5ndGgtMTtuPj0wO24tLSl0aGlzLmFkZFB0KHRbbl0pfSxpc1JlZHVuZGFudDpmdW5jdGlvbih0KXtpZih0aGlzLnB0TGlzdC5zaXplKCk8MSlyZXR1cm4hMTt2YXIgZT10aGlzLnB0TGlzdC5nZXQodGhpcy5wdExpc3Quc2l6ZSgpLTEpLG49dC5kaXN0YW5jZShlKTtyZXR1cm4gbjx0aGlzLm1pbmltaW1WZXJ0ZXhEaXN0YW5jZX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgaWUsZT10LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gZS50b1N0cmluZygpfSxjbG9zZVJpbmc6ZnVuY3Rpb24oKXtpZih0aGlzLnB0TGlzdC5zaXplKCk8MSlyZXR1cm4gbnVsbDt2YXIgdD1uZXcgZyh0aGlzLnB0TGlzdC5nZXQoMCkpLGU9dGhpcy5wdExpc3QuZ2V0KHRoaXMucHRMaXN0LnNpemUoKS0xKSxuPW51bGw7cmV0dXJuIHRoaXMucHRMaXN0LnNpemUoKT49MiYmKG49dGhpcy5wdExpc3QuZ2V0KHRoaXMucHRMaXN0LnNpemUoKS0yKSksdC5lcXVhbHMoZSk/bnVsbDp2b2lkIHRoaXMucHRMaXN0LmFkZCh0KX0sc2V0TWluaW11bVZlcnRleERpc3RhbmNlOmZ1bmN0aW9uKHQpe3RoaXMubWluaW1pbVZlcnRleERpc3RhbmNlPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFVpfX0pLFVpLkNPT1JESU5BVEVfQVJSQVlfVFlQRT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxlKFhpLnByb3RvdHlwZSx7YWRkTmV4dFNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtpZih0aGlzLnMwPXRoaXMuczEsdGhpcy5zMT10aGlzLnMyLHRoaXMuczI9dCx0aGlzLnNlZzAuc2V0Q29vcmRpbmF0ZXModGhpcy5zMCx0aGlzLnMxKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuc2VnMCx0aGlzLnNpZGUsdGhpcy5kaXN0YW5jZSx0aGlzLm9mZnNldDApLHRoaXMuc2VnMS5zZXRDb29yZGluYXRlcyh0aGlzLnMxLHRoaXMuczIpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5zZWcxLHRoaXMuc2lkZSx0aGlzLmRpc3RhbmNlLHRoaXMub2Zmc2V0MSksdGhpcy5zMS5lcXVhbHModGhpcy5zMikpcmV0dXJuIG51bGw7dmFyIG49aGUuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMuczAsdGhpcy5zMSx0aGlzLnMyKSxpPW49PT1oZS5DTE9DS1dJU0UmJnRoaXMuc2lkZT09PWNuLkxFRlR8fG49PT1oZS5DT1VOVEVSQ0xPQ0tXSVNFJiZ0aGlzLnNpZGU9PT1jbi5SSUdIVDswPT09bj90aGlzLmFkZENvbGxpbmVhcihlKTppP3RoaXMuYWRkT3V0c2lkZVR1cm4obixlKTp0aGlzLmFkZEluc2lkZVR1cm4obixlKX0sYWRkTGluZUVuZENhcDpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBjZSh0LGUpLGk9bmV3IGNlO3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixjbi5MRUZULHRoaXMuZGlzdGFuY2UsaSk7dmFyIHI9bmV3IGNlO3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixjbi5SSUdIVCx0aGlzLmRpc3RhbmNlLHIpO3ZhciBzPWUueC10Lngsbz1lLnktdC55LGE9TWF0aC5hdGFuMihvLHMpO3N3aXRjaCh0aGlzLmJ1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKXtjYXNlIEJpLkNBUF9ST1VORDp0aGlzLnNlZ0xpc3QuYWRkUHQoaS5wMSksdGhpcy5hZGRGaWxsZXRBcmMoZSxhK01hdGguUEkvMixhLU1hdGguUEkvMixoZS5DTE9DS1dJU0UsdGhpcy5kaXN0YW5jZSksdGhpcy5zZWdMaXN0LmFkZFB0KHIucDEpO2JyZWFrO2Nhc2UgQmkuQ0FQX0ZMQVQ6dGhpcy5zZWdMaXN0LmFkZFB0KGkucDEpLHRoaXMuc2VnTGlzdC5hZGRQdChyLnAxKTticmVhaztjYXNlIEJpLkNBUF9TUVVBUkU6dmFyIHU9bmV3IGc7dS54PU1hdGguYWJzKHRoaXMuZGlzdGFuY2UpKk1hdGguY29zKGEpLHUueT1NYXRoLmFicyh0aGlzLmRpc3RhbmNlKSpNYXRoLnNpbihhKTt2YXIgbD1uZXcgZyhpLnAxLngrdS54LGkucDEueSt1LnkpLGg9bmV3IGcoci5wMS54K3UueCxyLnAxLnkrdS55KTt0aGlzLnNlZ0xpc3QuYWRkUHQobCksdGhpcy5zZWdMaXN0LmFkZFB0KGgpfX0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNlZ0xpc3QuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdH0sYWRkTWl0cmVKb2luOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPSEwLHM9bnVsbDt0cnl7cz1GLmludGVyc2VjdGlvbihlLnAwLGUucDEsbi5wMCxuLnAxKTt2YXIgbz0wPj1pPzE6cy5kaXN0YW5jZSh0KS9NYXRoLmFicyhpKTtvPnRoaXMuYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSYmKHI9ITEpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIHcpKXRocm93IHQ7cz1uZXcgZygwLDApLHI9ITF9ZmluYWxseXt9cj90aGlzLnNlZ0xpc3QuYWRkUHQocyk6dGhpcy5hZGRMaW1pdGVkTWl0cmVKb2luKGUsbixpLHRoaXMuYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSl9LGFkZEZpbGxldENvcm5lcjpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPWUueC10Lngsbz1lLnktdC55LGE9TWF0aC5hdGFuMihvLHMpLHU9bi54LXQueCxsPW4ueS10LnksaD1NYXRoLmF0YW4yKGwsdSk7aT09PWhlLkNMT0NLV0lTRT9oPj1hJiYoYSs9MipNYXRoLlBJKTphPj1oJiYoYS09MipNYXRoLlBJKSx0aGlzLnNlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGRGaWxsZXRBcmModCxhLGgsaSxyKSx0aGlzLnNlZ0xpc3QuYWRkUHQobil9LGFkZE91dHNpZGVUdXJuOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMub2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLm9mZnNldDEucDApPHRoaXMuZGlzdGFuY2UqWGkuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1I/KHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLG51bGwpOnZvaWQodGhpcy5idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1CaS5KT0lOX01JVFJFP3RoaXMuYWRkTWl0cmVKb2luKHRoaXMuczEsdGhpcy5vZmZzZXQwLHRoaXMub2Zmc2V0MSx0aGlzLmRpc3RhbmNlKTp0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUJpLkpPSU5fQkVWRUw/dGhpcy5hZGRCZXZlbEpvaW4odGhpcy5vZmZzZXQwLHRoaXMub2Zmc2V0MSk6KGUmJnRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuYWRkRmlsbGV0Q29ybmVyKHRoaXMuczEsdGhpcy5vZmZzZXQwLnAxLHRoaXMub2Zmc2V0MS5wMCx0LHRoaXMuZGlzdGFuY2UpLHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApKSl9LGNyZWF0ZVNxdWFyZTpmdW5jdGlvbih0KXt0aGlzLnNlZ0xpc3QuYWRkUHQobmV3IGcodC54K3RoaXMuZGlzdGFuY2UsdC55K3RoaXMuZGlzdGFuY2UpKSx0aGlzLnNlZ0xpc3QuYWRkUHQobmV3IGcodC54K3RoaXMuZGlzdGFuY2UsdC55LXRoaXMuZGlzdGFuY2UpKSx0aGlzLnNlZ0xpc3QuYWRkUHQobmV3IGcodC54LXRoaXMuZGlzdGFuY2UsdC55LXRoaXMuZGlzdGFuY2UpKSx0aGlzLnNlZ0xpc3QuYWRkUHQobmV3IGcodC54LXRoaXMuZGlzdGFuY2UsdC55K3RoaXMuZGlzdGFuY2UpKSx0aGlzLnNlZ0xpc3QuY2xvc2VSaW5nKCl9LGFkZFNlZ21lbnRzOmZ1bmN0aW9uKHQsZSl7dGhpcy5zZWdMaXN0LmFkZFB0cyh0LGUpfSxhZGRGaXJzdFNlZ21lbnQ6ZnVuY3Rpb24oKXt0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQxLnAwKX0sYWRkTGFzdFNlZ21lbnQ6ZnVuY3Rpb24oKXt0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQxLnAxKX0saW5pdFNpZGVTZWdtZW50czpmdW5jdGlvbih0LGUsbil7dGhpcy5zMT10LHRoaXMuczI9ZSx0aGlzLnNpZGU9bix0aGlzLnNlZzEuc2V0Q29vcmRpbmF0ZXModCxlKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuc2VnMSxuLHRoaXMuZGlzdGFuY2UsdGhpcy5vZmZzZXQxKX0sYWRkTGltaXRlZE1pdHJlSm9pbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLnNlZzAucDEscz1oaS5hbmdsZShyLHRoaXMuc2VnMC5wMCksbz0oaGkuYW5nbGUocix0aGlzLnNlZzEucDEpLGhpLmFuZ2xlQmV0d2Vlbk9yaWVudGVkKHRoaXMuc2VnMC5wMCxyLHRoaXMuc2VnMS5wMSkpLGE9by8yLHU9aGkubm9ybWFsaXplKHMrYSksbD1oaS5ub3JtYWxpemUodStNYXRoLlBJKSxoPWkqbixjPWgqTWF0aC5hYnMoTWF0aC5zaW4oYSkpLGY9bi1jLGQ9ci54K2gqTWF0aC5jb3MobCkscD1yLnkraCpNYXRoLnNpbihsKSx2PW5ldyBnKGQscCksbT1uZXcgY2Uocix2KSx5PW0ucG9pbnRBbG9uZ09mZnNldCgxLGYpLHg9bS5wb2ludEFsb25nT2Zmc2V0KDEsLWYpO3RoaXMuc2lkZT09PWNuLkxFRlQ/KHRoaXMuc2VnTGlzdC5hZGRQdCh5KSx0aGlzLnNlZ0xpc3QuYWRkUHQoeCkpOih0aGlzLnNlZ0xpc3QuYWRkUHQoeCksdGhpcy5zZWdMaXN0LmFkZFB0KHkpKX0sY29tcHV0ZU9mZnNldFNlZ21lbnQ6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9ZT09PWNuLkxFRlQ/MTotMSxzPXQucDEueC10LnAwLngsbz10LnAxLnktdC5wMC55LGE9TWF0aC5zcXJ0KHMqcytvKm8pLHU9cipuKnMvYSxsPXIqbipvL2E7aS5wMC54PXQucDAueC1sLGkucDAueT10LnAwLnkrdSxpLnAxLng9dC5wMS54LWwsaS5wMS55PXQucDEueSt1fSxhZGRGaWxsZXRBcmM6ZnVuY3Rpb24odCxlLG4saSxyKXt2YXIgcz1pPT09aGUuQ0xPQ0tXSVNFPy0xOjEsbz1NYXRoLmFicyhlLW4pLGE9TWF0aC50cnVuYyhvL3RoaXMuZmlsbGV0QW5nbGVRdWFudHVtKy41KTtpZigxPmEpcmV0dXJuIG51bGw7dmFyIHU9bnVsbCxsPW51bGw7dT0wLGw9by9hO2Zvcih2YXIgaD11LGM9bmV3IGc7bz5oOyl7dmFyIGY9ZStzKmg7Yy54PXQueCtyKk1hdGguY29zKGYpLGMueT10LnkrcipNYXRoLnNpbihmKSx0aGlzLnNlZ0xpc3QuYWRkUHQoYyksaCs9bH19LGFkZEluc2lkZVR1cm46ZnVuY3Rpb24odCxlKXtpZih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5vZmZzZXQwLnAwLHRoaXMub2Zmc2V0MC5wMSx0aGlzLm9mZnNldDEucDAsdGhpcy5vZmZzZXQxLnAxKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpKXRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLmxpLmdldEludGVyc2VjdGlvbigwKSk7ZWxzZSBpZih0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITAsdGhpcy5vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMub2Zmc2V0MS5wMCk8dGhpcy5kaXN0YW5jZSpYaS5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSk7ZWxzZXtpZih0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQwLnAxKSx0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3I+MCl7dmFyIG49bmV3IGcoKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLm9mZnNldDAucDEueCt0aGlzLnMxLngpLyh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSksKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLm9mZnNldDAucDEueSt0aGlzLnMxLnkpLyh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSkpO3RoaXMuc2VnTGlzdC5hZGRQdChuKTt2YXIgaT1uZXcgZygodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MS5wMC54K3RoaXMuczEueCkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MS5wMC55K3RoaXMuczEueSkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5zZWdMaXN0LmFkZFB0KGkpfWVsc2UgdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMuczEpO3RoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApfX0sY3JlYXRlQ2lyY2xlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBnKHQueCt0aGlzLmRpc3RhbmNlLHQueSk7dGhpcy5zZWdMaXN0LmFkZFB0KGUpLHRoaXMuYWRkRmlsbGV0QXJjKHQsMCwyKk1hdGguUEksLTEsdGhpcy5kaXN0YW5jZSksdGhpcy5zZWdMaXN0LmNsb3NlUmluZygpfSxhZGRCZXZlbEpvaW46ZnVuY3Rpb24odCxlKXt0aGlzLnNlZ0xpc3QuYWRkUHQodC5wMSksdGhpcy5zZWdMaXN0LmFkZFB0KGUucDApfSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2U9dCx0aGlzLm1heEN1cnZlU2VnbWVudEVycm9yPXQqKDEtTWF0aC5jb3ModGhpcy5maWxsZXRBbmdsZVF1YW50dW0vMikpLHRoaXMuc2VnTGlzdD1uZXcgVWksdGhpcy5zZWdMaXN0LnNldFByZWNpc2lvbk1vZGVsKHRoaXMucHJlY2lzaW9uTW9kZWwpLHRoaXMuc2VnTGlzdC5zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UodCpYaS5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpfSxhZGRDb2xsaW5lYXI6ZnVuY3Rpb24odCl7dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuczAsdGhpcy5zMSx0aGlzLnMxLHRoaXMuczIpO3ZhciBlPXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7ZT49MiYmKHRoaXMuYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09QmkuSk9JTl9CRVZFTHx8dGhpcy5idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1CaS5KT0lOX01JVFJFPyh0JiZ0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQwLnAxKSx0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQxLnAwKSk6dGhpcy5hZGRGaWxsZXRDb3JuZXIodGhpcy5zMSx0aGlzLm9mZnNldDAucDEsdGhpcy5vZmZzZXQxLnAwLGhlLkNMT0NLV0lTRSx0aGlzLmRpc3RhbmNlKSl9LGNsb3NlUmluZzpmdW5jdGlvbigpe3RoaXMuc2VnTGlzdC5jbG9zZVJpbmcoKX0saGFzTmFycm93Q29uY2F2ZUFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWGl9fSksWGkuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1I9LjAwMSxYaS5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1I9LjAwMSxYaS5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1I9MWUtNixYaS5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUj04MCxlKEhpLnByb3RvdHlwZSx7Z2V0T2Zmc2V0Q3VydmU6ZnVuY3Rpb24odCxlKXtpZih0aGlzLmRpc3RhbmNlPWUsMD09PWUpcmV0dXJuIG51bGw7dmFyIG49MD5lLGk9TWF0aC5hYnMoZSkscj10aGlzLmdldFNlZ0dlbihpKTt0Lmxlbmd0aDw9MT90aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0scik6dGhpcy5jb21wdXRlT2Zmc2V0Q3VydmUodCxuLHIpO3ZhciBzPXIuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gbiYmSC5yZXZlcnNlKHMpLHN9LGNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuZGlzdGFuY2UpO2lmKGUpe24uYWRkU2VnbWVudHModCwhMCk7dmFyIHI9WWkuc2ltcGxpZnkodCwtaSkscz1yLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhyW3NdLHJbcy0xXSxjbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2Zvcih2YXIgbz1zLTI7bz49MDtvLS0pbi5hZGROZXh0U2VnbWVudChyW29dLCEwKX1lbHNle24uYWRkU2VnbWVudHModCwhMSk7dmFyIGE9WWkuc2ltcGxpZnkodCxpKSx1PWEubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGFbMF0sYVsxXSxjbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2Zvcih2YXIgbz0yO3U+PW87bysrKW4uYWRkTmV4dFNlZ21lbnQoYVtvXSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpLG4uY2xvc2VSaW5nKCl9LGNvbXB1dGVSaW5nQnVmZmVyQ3VydmU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5kaXN0YW5jZSk7ZT09PWNuLlJJR0hUJiYoaT0taSk7dmFyIHI9WWkuc2ltcGxpZnkodCxpKSxzPXIubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKHJbcy0xXSxyWzBdLGUpO2Zvcih2YXIgbz0xO3M+PW87bysrKXt2YXIgYT0xIT09bztuLmFkZE5leHRTZWdtZW50KHJbb10sYSl9bi5jbG9zZVJpbmcoKX0sY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5kaXN0YW5jZSksaT1ZaS5zaW1wbGlmeSh0LG4pLHI9aS5sZW5ndGgtMTtlLmluaXRTaWRlU2VnbWVudHMoaVswXSxpWzFdLGNuLkxFRlQpO2Zvcih2YXIgcz0yO3I+PXM7cysrKWUuYWRkTmV4dFNlZ21lbnQoaVtzXSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChpW3ItMV0saVtyXSk7dmFyIG89WWkuc2ltcGxpZnkodCwtbiksYT1vLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhvW2FdLG9bYS0xXSxjbi5MRUZUKTtmb3IodmFyIHM9YS0yO3M+PTA7cy0tKWUuYWRkTmV4dFNlZ21lbnQob1tzXSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChvWzFdLG9bMF0pLGUuY2xvc2VSaW5nKCl9LGNvbXB1dGVQb2ludEN1cnZlOmZ1bmN0aW9uKHQsZSl7c3dpdGNoKHRoaXMuYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UgQmkuQ0FQX1JPVU5EOmUuY3JlYXRlQ2lyY2xlKHQpO2JyZWFrO2Nhc2UgQmkuQ0FQX1NRVUFSRTplLmNyZWF0ZVNxdWFyZSh0KX19LGdldExpbmVDdXJ2ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMuZGlzdGFuY2U9ZSwwPmUmJiF0aGlzLmJ1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCkpcmV0dXJuIG51bGw7aWYoMD09PWUpcmV0dXJuIG51bGw7dmFyIG49TWF0aC5hYnMoZSksaT10aGlzLmdldFNlZ0dlbihuKTtpZih0Lmxlbmd0aDw9MSl0aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0saSk7ZWxzZSBpZih0aGlzLmJ1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCkpe3ZhciByPTA+ZTt0aGlzLmNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQscixpKX1lbHNlIHRoaXMuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSh0LGkpO3ZhciBzPWkuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gc30sZ2V0QnVmZmVyUGFyYW1ldGVyczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1ZlBhcmFtc30sc2ltcGxpZnlUb2xlcmFuY2U6ZnVuY3Rpb24odCl7cmV0dXJuIHQqdGhpcy5idWZQYXJhbXMuZ2V0U2ltcGxpZnlGYWN0b3IoKX0sZ2V0UmluZ0N1cnZlOmZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmRpc3RhbmNlPW4sdC5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuZ2V0TGluZUN1cnZlKHQsbik7aWYoMD09PW4pcmV0dXJuIEhpLmNvcHlDb29yZGluYXRlcyh0KTt2YXIgaT10aGlzLmdldFNlZ0dlbihuKTtyZXR1cm4gdGhpcy5jb21wdXRlUmluZ0J1ZmZlckN1cnZlKHQsZSxpKSxpLmdldENvb3JkaW5hdGVzKCl9LGNvbXB1dGVPZmZzZXRDdXJ2ZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKTtpZihlKXt2YXIgcj1ZaS5zaW1wbGlmeSh0LC1pKSxzPXIubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKHJbc10scltzLTFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPXMtMjtvPj0wO28tLSluLmFkZE5leHRTZWdtZW50KHJbb10sITApfWVsc2V7dmFyIGE9WWkuc2ltcGxpZnkodCxpKSx1PWEubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGFbMF0sYVsxXSxjbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2Zvcih2YXIgbz0yO3U+PW87bysrKW4uYWRkTmV4dFNlZ21lbnQoYVtvXSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpfSxnZXRTZWdHZW46ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBYaSh0aGlzLnByZWNpc2lvbk1vZGVsLHRoaXMuYnVmUGFyYW1zLHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIaX19KSxIaS5jb3B5Q29vcmRpbmF0ZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT1uZXcgZyh0W25dKTtyZXR1cm4gZX0sZShXaS5wcm90b3R5cGUse2ZpbmRTdGFiYmVkU2VnbWVudHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBJLG49dGhpcy5zdWJncmFwaHMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRFbnZlbG9wZSgpO3QueTxyLmdldE1pblkoKXx8dC55PnIuZ2V0TWF4WSgpfHx0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCxpLmdldERpcmVjdGVkRWRnZXMoKSxlKX1yZXR1cm4gZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEluKWZvcih2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1hcmd1bWVudHNbMl0sdT1vLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLG49MDtuPHUubGVuZ3RoLTE7bisrKXt0aGlzLnNlZy5wMD11W25dLHRoaXMuc2VnLnAxPXVbbisxXSx0aGlzLnNlZy5wMC55PnRoaXMuc2VnLnAxLnkmJnRoaXMuc2VnLnJldmVyc2UoKTt2YXIgbD1NYXRoLm1heCh0aGlzLnNlZy5wMC54LHRoaXMuc2VnLnAxLngpO2lmKCEobDxzLnh8fHRoaXMuc2VnLmlzSG9yaXpvbnRhbCgpfHxzLnk8dGhpcy5zZWcucDAueXx8cy55PnRoaXMuc2VnLnAxLnl8fGhlLmNvbXB1dGVPcmllbnRhdGlvbih0aGlzLnNlZy5wMCx0aGlzLnNlZy5wMSxzKT09PWhlLlJJR0hUKSl7dmFyIGg9by5nZXREZXB0aChjbi5MRUZUKTt0aGlzLnNlZy5wMC5lcXVhbHModVtuXSl8fChoPW8uZ2V0RGVwdGgoY24uUklHSFQpKTt2YXIgYz1uZXcgamkodGhpcy5zZWcsaCk7YS5hZGQoYyl9fWVsc2UgaWYoUihhcmd1bWVudHNbMl0seSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmUihhcmd1bWVudHNbMV0seSkpZm9yKHZhciBmPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXSxuPWQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciB2PW4ubmV4dCgpO3YuaXNGb3J3YXJkKCkmJnRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyhmLHYscCl9fSxnZXREZXB0aDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCk7aWYoMD09PWUuc2l6ZSgpKXJldHVybiAwO3ZhciBuPWhvLm1pbihlKTtyZXR1cm4gbi5sZWZ0RGVwdGh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdpfX0pLGUoamkucHJvdG90eXBlLHtjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtpZih0aGlzLnVwd2FyZFNlZy5taW5YKCk+PWUudXB3YXJkU2VnLm1heFgoKSlyZXR1cm4gMTtpZih0aGlzLnVwd2FyZFNlZy5tYXhYKCk8PWUudXB3YXJkU2VnLm1pblgoKSlyZXR1cm4tMTt2YXIgbj10aGlzLnVwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KGUudXB3YXJkU2VnKTtyZXR1cm4gMCE9PW4/bjoobj0tMSplLnVwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KHRoaXMudXB3YXJkU2VnKSwwIT09bj9uOnRoaXMudXB3YXJkU2VnLmNvbXBhcmVUbyhlLnVwd2FyZFNlZykpfSxjb21wYXJlWDpmdW5jdGlvbih0LGUpe3ZhciBuPXQucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnQucDEuY29tcGFyZVRvKGUucDEpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVwd2FyZFNlZy50b1N0cmluZygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaml9fSksV2kuRGVwdGhTZWdtZW50PWppLGUoS2kucHJvdG90eXBlLHthZGRQb2ludDpmdW5jdGlvbih0KXtpZih0aGlzLmRpc3RhbmNlPD0wKXJldHVybiBudWxsO1xudmFyIGU9dC5nZXRDb29yZGluYXRlcygpLG49dGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLEwuRVhURVJJT1IsTC5JTlRFUklPUil9LGFkZFBvbHlnb246ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kaXN0YW5jZSxuPWNuLkxFRlQ7dGhpcy5kaXN0YW5jZTwwJiYoZT0tdGhpcy5kaXN0YW5jZSxuPWNuLlJJR0hUKTt2YXIgaT10LmdldEV4dGVyaW9yUmluZygpLHI9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyhpLmdldENvb3JkaW5hdGVzKCkpO2lmKHRoaXMuZGlzdGFuY2U8MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkoaSx0aGlzLmRpc3RhbmNlKSlyZXR1cm4gbnVsbDtpZih0aGlzLmRpc3RhbmNlPD0wJiZyLmxlbmd0aDwzKXJldHVybiBudWxsO3RoaXMuYWRkUG9seWdvblJpbmcocixlLG4sTC5FWFRFUklPUixMLklOVEVSSU9SKTtmb3IodmFyIHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXt2YXIgbz10LmdldEludGVyaW9yUmluZ04ocyksYT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKG8uZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5kaXN0YW5jZT4wJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShvLC10aGlzLmRpc3RhbmNlKXx8dGhpcy5hZGRQb2x5Z29uUmluZyhhLGUsY24ub3Bwb3NpdGUobiksTC5JTlRFUklPUixMLkVYVEVSSU9SKX19LGlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5OmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNpKHRbMF0sdFsxXSx0WzJdKSxpPW4uaW5DZW50cmUoKSxyPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGksbi5wMCxuLnAxKTtyZXR1cm4gcjxNYXRoLmFicyhlKX0sYWRkTGluZVN0cmluZzpmdW5jdGlvbih0KXtpZih0aGlzLmRpc3RhbmNlPD0wJiYhdGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0QnVmZmVyUGFyYW1ldGVycygpLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDt2YXIgZT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbj10aGlzLmN1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLmRpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sTC5FWFRFUklPUixMLklOVEVSSU9SKX0sYWRkQ3VydmU6ZnVuY3Rpb24odCxlLG4pe2lmKG51bGw9PT10fHx0Lmxlbmd0aDwyKXJldHVybiBudWxsO3ZhciBpPW5ldyBLZSh0LG5ldyBnbigwLEwuQk9VTkRBUlksZSxuKSk7dGhpcy5jdXJ2ZUxpc3QuYWRkKGkpfSxnZXRDdXJ2ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGQodGhpcy5pbnB1dEdlb20pLHRoaXMuY3VydmVMaXN0fSxhZGRQb2x5Z29uUmluZzpmdW5jdGlvbih0LGUsbixpLHIpe2lmKDA9PT1lJiZ0Lmxlbmd0aDxidC5NSU5JTVVNX1ZBTElEX1NJWkUpcmV0dXJuIG51bGw7dmFyIHM9aSxvPXI7dC5sZW5ndGg+PWJ0Lk1JTklNVU1fVkFMSURfU0laRSYmaGUuaXNDQ1codCkmJihzPXIsbz1pLG49Y24ub3Bwb3NpdGUobikpO3ZhciBhPXRoaXMuY3VydmVCdWlsZGVyLmdldFJpbmdDdXJ2ZSh0LG4sZSk7dGhpcy5hZGRDdXJ2ZShhLHMsbyl9LGFkZDpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBndCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgT3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fSxpc0Vyb2RlZENvbXBsZXRlbHk6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldENvb3JkaW5hdGVzKCk7aWYobi5sZW5ndGg8NClyZXR1cm4gMD5lO2lmKDQ9PT1uLmxlbmd0aClyZXR1cm4gdGhpcy5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseShuLGUpO3ZhciBpPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHI9TWF0aC5taW4oaS5nZXRIZWlnaHQoKSxpLmdldFdpZHRoKCkpO3JldHVybiAwPmUmJjIqTWF0aC5hYnMoZSk+cn0sYWRkQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLaX19KSxlKFppLnByb3RvdHlwZSx7aXNUcml2aWFsSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQ9PT1uJiYxPT09dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYoWmkuaXNBZGphY2VudFNlZ21lbnRzKGUsaSkpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXt2YXIgcj10LnNpemUoKS0xO2lmKDA9PT1lJiZpPT09cnx8MD09PWkmJmU9PT1yKXJldHVybiEwfX1yZXR1cm4hMX0sZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH0saGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNQcm9wZXJJbnRlcmlvcn0sZ2V0TGluZUludGVyc2VjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGl9LGhhc1Byb3BlckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3Blcn0scHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKzt2YXIgcj10LmdldENvb3JkaW5hdGVzKClbZV0scz10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpXSxhPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpKzFdO3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihyLHMsbyxhKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucysrLHRoaXMuaGFzSW50ZXJpb3I9ITApLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLGkpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksaSwxKSx0aGlzLmxpLmlzUHJvcGVyKCkmJih0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMrKyx0aGlzLmhhc1Byb3Blcj0hMCx0aGlzLmhhc1Byb3BlckludGVyaW9yPSEwKSkpfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0saGFzSW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcmlvcn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb25dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBaaX19KSxaaS5pc0FkamFjZW50U2VnbWVudHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9LGUoUWkucHJvdG90eXBlLHtzZXRXb3JraW5nUHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw9dH0saW5zZXJ0VW5pcXVlRWRnZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe3ZhciBuPWUuZ2V0TGFiZWwoKSxpPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChpPW5ldyBnbih0LmdldExhYmVsKCkpLGkuZmxpcCgpKSxuLm1lcmdlKGkpO3ZhciByPVFpLmRlcHRoRGVsdGEoaSkscz1lLmdldERlcHRoRGVsdGEoKSxvPXMrcjtlLnNldERlcHRoRGVsdGEobyl9ZWxzZSB0aGlzLmVkZ2VMaXN0LmFkZCh0KSx0LnNldERlcHRoRGVsdGEoUWkuZGVwdGhEZWx0YSh0LmdldExhYmVsKCkpKX0sYnVpbGRTdWJncmFwaHM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKSxzPXIuZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpLG89bmV3IFdpKG4pLGE9by5nZXREZXB0aChzKTtyLmNvbXB1dGVEZXB0aChhKSxyLmZpbmRSZXN1bHRFZGdlcygpLG4uYWRkKHIpLGUuYWRkKHIuZ2V0RGlyZWN0ZWRFZGdlcygpLHIuZ2V0Tm9kZXMoKSl9fSxjcmVhdGVTdWJncmFwaHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5nZXROb2RlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZighaS5pc1Zpc2l0ZWQoKSl7dmFyIHI9bmV3IGtpO3IuY3JlYXRlKGkpLGUuYWRkKHIpfX1yZXR1cm4gaG8uc29ydChlLGhvLnJldmVyc2VPcmRlcigpKSxlfSxjcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCk7cmV0dXJuIHR9LGdldE5vZGVyOmZ1bmN0aW9uKHQpe2lmKG51bGwhPT10aGlzLndvcmtpbmdOb2RlcilyZXR1cm4gdGhpcy53b3JraW5nTm9kZXI7dmFyIGU9bmV3IG5uLG49bmV3IGFlO3JldHVybiBuLnNldFByZWNpc2lvbk1vZGVsKHQpLGUuc2V0U2VnbWVudEludGVyc2VjdG9yKG5ldyBaaShuKSksZX0sYnVmZmVyOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw7bnVsbD09PW4mJihuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5nZW9tRmFjdD10LmdldEZhY3RvcnkoKTt2YXIgaT1uZXcgSGkobix0aGlzLmJ1ZlBhcmFtcykscj1uZXcgS2kodCxlLGkpLHM9ci5nZXRDdXJ2ZXMoKTtpZihzLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dGhpcy5jb21wdXRlTm9kZWRFZGdlcyhzLG4pLHRoaXMuZ3JhcGg9bmV3IENuKG5ldyBPbiksdGhpcy5ncmFwaC5hZGRFZGdlcyh0aGlzLmVkZ2VMaXN0LmdldEVkZ2VzKCkpO3ZhciBvPXRoaXMuY3JlYXRlU3ViZ3JhcGhzKHRoaXMuZ3JhcGgpLGE9bmV3IFNuKHRoaXMuZ2VvbUZhY3QpO3RoaXMuYnVpbGRTdWJncmFwaHMobyxhKTt2YXIgdT1hLmdldFBvbHlnb25zKCk7aWYodS5zaXplKCk8PTApcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpO3ZhciBsPXRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh1KTtyZXR1cm4gbH0sY29tcHV0ZU5vZGVkRWRnZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldE5vZGVyKGUpO24uY29tcHV0ZU5vZGVzKHQpO2Zvcih2YXIgaT1uLmdldE5vZGVkU3Vic3RyaW5ncygpLHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldENvb3JkaW5hdGVzKCk7aWYoMiE9PW8ubGVuZ3RofHwhb1swXS5lcXVhbHMyRChvWzFdKSl7dmFyIGE9cy5nZXREYXRhKCksdT1uZXcgSm4ocy5nZXRDb29yZGluYXRlcygpLG5ldyBnbihhKSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKHUpfX19LHNldE5vZGVyOmZ1bmN0aW9uKHQpe3RoaXMud29ya2luZ05vZGVyPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFFpfX0pLFFpLmRlcHRoRGVsdGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRMb2NhdGlvbigwLGNuLkxFRlQpLG49dC5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKTtyZXR1cm4gZT09PUwuSU5URVJJT1ImJm49PT1MLkVYVEVSSU9SPzE6ZT09PUwuRVhURVJJT1ImJm49PT1MLklOVEVSSU9SPy0xOjB9LFFpLmNvbnZlcnRTZWdTdHJpbmdzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgaWUsbj1uZXcgSTt0Lmhhc05leHQoKTspe3ZhciBpPXQubmV4dCgpLHI9ZS5jcmVhdGVMaW5lU3RyaW5nKGkuZ2V0Q29vcmRpbmF0ZXMoKSk7bi5hZGQocil9cmV0dXJuIGUuYnVpbGRHZW9tZXRyeShuKX0sZShKaS5wcm90b3R5cGUse2NoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCk7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhuWzBdLHRoaXMuc2VnU3RyaW5ncyksdGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhuW24ubGVuZ3RoLTFdLHRoaXMuc2VnU3RyaW5ncyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHQ9ci5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOylmb3IodmFyIGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCkscz0xO3M8bi5sZW5ndGgtMTtzKyspaWYobltzXS5lcXVhbHMoaSkpdGhyb3cgbmV3IGwoXCJmb3VuZCBlbmRwdC9pbnRlcmlvciBwdCBpbnRlcnNlY3Rpb24gYXQgaW5kZXggXCIrcytcIiA6cHQgXCIraSl9LGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOylmb3IodmFyIGU9dC5uZXh0KCksbj10aGlzLnNlZ1N0cmluZ3MuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoZSxpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1yLmdldENvb3JkaW5hdGVzKCksYT1zLmdldENvb3JkaW5hdGVzKCksdT0wO3U8by5sZW5ndGgtMTt1KyspZm9yKHZhciBoPTA7aDxhLmxlbmd0aC0xO2grKyl0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHIsdSxzLGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBjPWFyZ3VtZW50c1swXSxmPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxkPWFyZ3VtZW50c1szXTtpZihjPT09ZyYmZj09PWQpcmV0dXJuIG51bGw7dmFyIHA9Yy5nZXRDb29yZGluYXRlcygpW2ZdLHY9Yy5nZXRDb29yZGluYXRlcygpW2YrMV0sbT1nLmdldENvb3JkaW5hdGVzKClbZF0seT1nLmdldENvb3JkaW5hdGVzKClbZCsxXTtpZih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocCx2LG0seSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMubGkuaXNQcm9wZXIoKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLmxpLHAsdil8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5saSxtLHkpKSl0aHJvdyBuZXcgbChcImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYXQgXCIrcCtcIi1cIit2K1wiIGFuZCBcIittK1wiLVwiK3kpfX0sY2hlY2tWYWxpZDpmdW5jdGlvbigpe3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0NvbGxhcHNlcygpfSxjaGVja0NvbGxhcHNlczpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD10aGlzLnNlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO3RoaXMuY2hlY2tDb2xsYXBzZXMoZSl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIG49YXJndW1lbnRzWzBdLGk9bi5nZXRDb29yZGluYXRlcygpLHQ9MDt0PGkubGVuZ3RoLTI7dCsrKXRoaXMuY2hlY2tDb2xsYXBzZShpW3RdLGlbdCsxXSxpW3QrMl0pfSxoYXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LmdldEludGVyc2VjdGlvbk51bSgpO2krKyl7dmFyIHI9dC5nZXRJbnRlcnNlY3Rpb24oaSk7aWYoIXIuZXF1YWxzKGUpJiYhci5lcXVhbHMobikpcmV0dXJuITB9cmV0dXJuITF9LGNoZWNrQ29sbGFwc2U6ZnVuY3Rpb24odCxlLG4pe2lmKHQuZXF1YWxzKG4pKXRocm93IG5ldyBsKFwiZm91bmQgbm9uLW5vZGVkIGNvbGxhcHNlIGF0IFwiK0ppLmZhY3QuY3JlYXRlTGluZVN0cmluZyhbdCxlLG5dKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEppfX0pLEppLmZhY3Q9bmV3IGllLGUoJGkucHJvdG90eXBlLHtpbnRlcnNlY3RzU2NhbGVkOmZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5taW4odC54LGUueCksaT1NYXRoLm1heCh0LngsZS54KSxyPU1hdGgubWluKHQueSxlLnkpLHM9TWF0aC5tYXgodC55LGUueSksbz10aGlzLm1heHg8bnx8dGhpcy5taW54Pml8fHRoaXMubWF4eTxyfHx0aGlzLm1pbnk+cztpZihvKXJldHVybiExO3ZhciBhPXRoaXMuaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpO3JldHVybiBmLmlzVHJ1ZSghKG8mJmEpLFwiRm91bmQgYmFkIGVudmVsb3BlIHRlc3RcIiksYX0saW5pdENvcm5lcnM6ZnVuY3Rpb24odCl7dmFyIGU9LjU7dGhpcy5taW54PXQueC1lLHRoaXMubWF4eD10LngrZSx0aGlzLm1pbnk9dC55LWUsdGhpcy5tYXh5PXQueStlLHRoaXMuY29ybmVyWzBdPW5ldyBnKHRoaXMubWF4eCx0aGlzLm1heHkpLHRoaXMuY29ybmVyWzFdPW5ldyBnKHRoaXMubWlueCx0aGlzLm1heHkpLHRoaXMuY29ybmVyWzJdPW5ldyBnKHRoaXMubWlueCx0aGlzLm1pbnkpLHRoaXMuY29ybmVyWzNdPW5ldyBnKHRoaXMubWF4eCx0aGlzLm1pbnkpfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIDE9PT10aGlzLnNjYWxlRmFjdG9yP3RoaXMuaW50ZXJzZWN0c1NjYWxlZCh0LGUpOih0aGlzLmNvcHlTY2FsZWQodCx0aGlzLnAwU2NhbGVkKSx0aGlzLmNvcHlTY2FsZWQoZSx0aGlzLnAxU2NhbGVkKSx0aGlzLmludGVyc2VjdHNTY2FsZWQodGhpcy5wMFNjYWxlZCx0aGlzLnAxU2NhbGVkKSl9LHNjYWxlOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqdGhpcy5zY2FsZUZhY3Rvcil9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcmlnaW5hbFB0fSxjb3B5U2NhbGVkOmZ1bmN0aW9uKHQsZSl7ZS54PXRoaXMuc2NhbGUodC54KSxlLnk9dGhpcy5zY2FsZSh0LnkpfSxnZXRTYWZlRW52ZWxvcGU6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5zYWZlRW52KXt2YXIgdD0kaS5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SL3RoaXMuc2NhbGVGYWN0b3I7dGhpcy5zYWZlRW52PW5ldyBDKHRoaXMub3JpZ2luYWxQdC54LXQsdGhpcy5vcmlnaW5hbFB0LngrdCx0aGlzLm9yaWdpbmFsUHQueS10LHRoaXMub3JpZ2luYWxQdC55K3QpfXJldHVybiB0aGlzLnNhZmVFbnZ9LGludGVyc2VjdHNQaXhlbENsb3N1cmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclswXSx0aGlzLmNvcm5lclsxXSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKT8hMDoodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclsxXSx0aGlzLmNvcm5lclsyXSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKT8hMDoodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclsyXSx0aGlzLmNvcm5lclszXSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKT8hMDoodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclszXSx0aGlzLmNvcm5lclswXSksISF0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpKSkpfSxpbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ITEsaT0hMTtyZXR1cm4gdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclswXSx0aGlzLmNvcm5lclsxXSksdGhpcy5saS5pc1Byb3BlcigpPyEwOih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzFdLHRoaXMuY29ybmVyWzJdKSx0aGlzLmxpLmlzUHJvcGVyKCk/ITA6KHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJihuPSEwKSx0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzJdLHRoaXMuY29ybmVyWzNdKSx0aGlzLmxpLmlzUHJvcGVyKCk/ITA6KHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJihpPSEwKSx0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzNdLHRoaXMuY29ybmVyWzBdKSx0aGlzLmxpLmlzUHJvcGVyKCk/ITA6biYmaT8hMDp0LmVxdWFscyh0aGlzLnB0KT8hMDohIWUuZXF1YWxzKHRoaXMucHQpKSkpfSxhZGRTbmFwcGVkTm9kZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0Q29vcmRpbmF0ZShlKSxpPXQuZ2V0Q29vcmRpbmF0ZShlKzEpO3JldHVybiB0aGlzLmludGVyc2VjdHMobixpKT8odC5hZGRJbnRlcnNlY3Rpb24odGhpcy5nZXRDb29yZGluYXRlKCksZSksITApOiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiAkaX19KSwkaS5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SPS43NSxlKHRyLnByb3RvdHlwZSx7c2VsZWN0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dC5nZXRMaW5lU2VnbWVudChlLHRoaXMuc2VsZWN0ZWRTZWdtZW50KSx0aGlzLnNlbGVjdCh0aGlzLnNlbGVjdGVkU2VnbWVudCl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB0cn19KSxlKGVyLnByb3RvdHlwZSx7c25hcDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc25hcCh0LG51bGwsLTEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1hcmd1bWVudHNbMl0scj1lLmdldFNhZmVFbnZlbG9wZSgpLHM9bmV3IG5yKGUsbixpKTtyZXR1cm4gdGhpcy5pbmRleC5xdWVyeShyLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LHZpc2l0SXRlbTpmdW5jdGlvbih0KXt2YXIgZT10O2Uuc2VsZWN0KHIscyl9fSkscy5pc05vZGVBZGRlZCgpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZXJ9fSksaChucix0ciksZShuci5wcm90b3R5cGUse2lzTm9kZUFkZGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzTm9kZUFkZGVkfSxzZWxlY3Q6ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdHIucHJvdG90eXBlLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRDb250ZXh0KCk7cmV0dXJuIG51bGwhPT10aGlzLnBhcmVudEVkZ2UmJm49PT10aGlzLnBhcmVudEVkZ2UmJmU9PT10aGlzLmhvdFBpeGVsVmVydGV4SW5kZXg/bnVsbDp2b2lkKHRoaXMuX2lzTm9kZUFkZGVkPXRoaXMuaG90UGl4ZWwuYWRkU25hcHBlZE5vZGUobixlKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5yfX0pLGVyLkhvdFBpeGVsU25hcEFjdGlvbj1ucixlKGlyLnByb3RvdHlwZSx7cHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO3ZhciByPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW2ldLGE9bi5nZXRDb29yZGluYXRlcygpW2krMV07aWYodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMubGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKXtmb3IodmFyIHU9MDt1PHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7dSsrKXRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zLmFkZCh0aGlzLmxpLmdldEludGVyc2VjdGlvbih1KSk7dC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5saSxpLDEpfX0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGdldEludGVyaW9ySW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb25dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBpcn19KSxlKHJyLnByb3RvdHlwZSx7Y2hlY2tDb3JyZWN0bmVzczpmdW5jdGlvbih0KXt2YXIgZT1LZS5nZXROb2RlZFN1YnN0cmluZ3ModCksbj1uZXcgSmkoZSk7dHJ5e24uY2hlY2tWYWxpZCgpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFMpKXRocm93IHQ7dC5wcmludFN0YWNrVHJhY2UoKX1maW5hbGx5e319LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe3JldHVybiBLZS5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5ub2RlZFNlZ1N0cmluZ3MpfSxzbmFwUm91bmQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyhuKSx0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyh0KX0sZmluZEludGVyaW9ySW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBpcihlKTtyZXR1cm4gdGhpcy5ub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IobiksdGhpcy5ub2Rlci5jb21wdXRlTm9kZXModCksbi5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKX0sY29tcHV0ZVZlcnRleFNuYXBzOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuY29tcHV0ZVZlcnRleFNuYXBzKG4pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLZSlmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9aS5nZXRDb29yZGluYXRlcygpLHM9MDtzPHIubGVuZ3RoO3MrKyl7dmFyIG89bmV3ICRpKHJbc10sdGhpcy5zY2FsZUZhY3Rvcix0aGlzLmxpKSxhPXRoaXMucG9pbnRTbmFwcGVyLnNuYXAobyxpLHMpO2EmJmkuYWRkSW50ZXJzZWN0aW9uKHJbc10scyl9fSxjb21wdXRlTm9kZXM6ZnVuY3Rpb24odCl7dGhpcy5ub2RlZFNlZ1N0cmluZ3M9dCx0aGlzLm5vZGVyPW5ldyBubix0aGlzLnBvaW50U25hcHBlcj1uZXcgZXIodGhpcy5ub2Rlci5nZXRJbmRleCgpKSx0aGlzLnNuYXBSb3VuZCh0LHRoaXMubGkpfSxjb21wdXRlSW50ZXJzZWN0aW9uU25hcHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bmV3ICRpKG4sdGhpcy5zY2FsZUZhY3Rvcix0aGlzLmxpKTt0aGlzLnBvaW50U25hcHBlci5zbmFwKGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdG5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBycn19KSxlKHNyLnByb3RvdHlwZSx7YnVmZmVyRml4ZWRQcmVjaXNpb246ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEZpKG5ldyBycihuZXcgZWUoMSkpLHQuZ2V0U2NhbGUoKSksbj1uZXcgUWkodGhpcy5idWZQYXJhbXMpO24uc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsKHQpLG4uc2V0Tm9kZXIoZSksdGhpcy5yZXN1bHRHZW9tZXRyeT1uLmJ1ZmZlcih0aGlzLmFyZ0dlb20sdGhpcy5kaXN0YW5jZSl9LGJ1ZmZlclJlZHVjZWRQcmVjaXNpb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PXNyLk1BWF9QUkVDSVNJT05fRElHSVRTO3Q+PTA7dC0tKXt0cnl7dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKHQpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIHNuKSl0aHJvdyB0O3RoaXMuc2F2ZUV4Y2VwdGlvbj10fWZpbmFsbHl7fWlmKG51bGwhPT10aGlzLnJlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsfXRocm93IHRoaXMuc2F2ZUV4Y2VwdGlvbn1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49c3IucHJlY2lzaW9uU2NhbGVGYWN0b3IodGhpcy5hcmdHZW9tLHRoaXMuZGlzdGFuY2UsZSksaT1uZXcgZWUobik7dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbihpKX19LGNvbXB1dGVHZW9tZXRyeTpmdW5jdGlvbigpe2lmKHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKSxudWxsIT09dGhpcy5yZXN1bHRHZW9tZXRyeSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLmFyZ0dlb20uZ2V0RmFjdG9yeSgpLmdldFByZWNpc2lvbk1vZGVsKCk7dC5nZXRUeXBlKCk9PT1lZS5GSVhFRD90aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpOnRoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbigpfSxzZXRRdWFkcmFudFNlZ21lbnRzOmZ1bmN0aW9uKHQpe3RoaXMuYnVmUGFyYW1zLnNldFF1YWRyYW50U2VnbWVudHModCl9LGJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uOmZ1bmN0aW9uKCl7dHJ5e3ZhciB0PW5ldyBRaSh0aGlzLmJ1ZlBhcmFtcyk7dGhpcy5yZXN1bHRHZW9tZXRyeT10LmJ1ZmZlcih0aGlzLmFyZ0dlb20sdGhpcy5kaXN0YW5jZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbCkpdGhyb3cgdDt0aGlzLnNhdmVFeGNlcHRpb249dH1maW5hbGx5e319LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRpc3RhbmNlPXQsdGhpcy5jb21wdXRlR2VvbWV0cnkoKSx0aGlzLnJlc3VsdEdlb21ldHJ5fSxzZXRFbmRDYXBTdHlsZTpmdW5jdGlvbih0KXt0aGlzLmJ1ZlBhcmFtcy5zZXRFbmRDYXBTdHlsZSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gc3J9fSksc3IuYnVmZmVyT3A9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHNyKHQpLGk9bi5nZXRSZXN1bHRHZW9tZXRyeShlKTtyZXR1cm4gaX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPW5ldyBzcihyKTthLnNldFF1YWRyYW50U2VnbWVudHMobyk7dmFyIGk9YS5nZXRSZXN1bHRHZW9tZXRyeShzKTtyZXR1cm4gaX1pZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEJpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB1PWFyZ3VtZW50c1swXSxsPWFyZ3VtZW50c1sxXSxoPWFyZ3VtZW50c1syXSxhPW5ldyBzcih1LGgpLGk9YS5nZXRSZXN1bHRHZW9tZXRyeShsKTtyZXR1cm4gaX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGM9YXJndW1lbnRzWzBdLGY9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLGQ9YXJndW1lbnRzWzNdLGE9bmV3IHNyKGMpO2Euc2V0UXVhZHJhbnRTZWdtZW50cyhnKSxhLnNldEVuZENhcFN0eWxlKGQpO3ZhciBpPWEuZ2V0UmVzdWx0R2VvbWV0cnkoZik7cmV0dXJuIGl9fSxzci5wcmVjaXNpb25TY2FsZUZhY3Rvcj1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkscj1ULm1heChNYXRoLmFicyhpLmdldE1heFgoKSksTWF0aC5hYnMoaS5nZXRNYXhZKCkpLE1hdGguYWJzKGkuZ2V0TWluWCgpKSxNYXRoLmFicyhpLmdldE1pblkoKSkpLHM9ZT4wP2U6MCxvPXIrMipzLGE9TWF0aC50cnVuYyhNYXRoLmxvZyhvKS9NYXRoLmxvZygxMCkrMSksdT1uLWEsbD1NYXRoLnBvdygxMCx1KTtyZXR1cm4gbH0sc3IuQ0FQX1JPVU5EPUJpLkNBUF9ST1VORCxzci5DQVBfQlVUVD1CaS5DQVBfRkxBVCxzci5DQVBfRkxBVD1CaS5DQVBfRkxBVCxzci5DQVBfU1FVQVJFPUJpLkNBUF9TUVVBUkUsc3IuTUFYX1BSRUNJU0lPTl9ESUdJVFM9MTI7dmFyIENvPU9iamVjdC5mcmVlemUoe0J1ZmZlck9wOnNyLEJ1ZmZlclBhcmFtZXRlcnM6Qml9KTtlKG9yLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBUdCYmdGhpcy5jb21wcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2h0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb3J9fSksb3IuZ2V0UG9seWdvbnM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBvci5nZXRQb2x5Z29ucyh0LG5ldyBJKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBlIGluc3RhbmNlb2YgVHQ/bi5hZGQoZSk6ZSBpbnN0YW5jZW9mIGZ0JiZlLmFwcGx5KG5ldyBvcihuKSksbn19LGUoYXIucHJvdG90eXBlLHtpc0luc2lkZUFyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbmRleD09PWFyLklOU0lERV9BUkVBfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGdldEdlb21ldHJ5Q29tcG9uZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcG9uZW50fSxnZXRTZWdtZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbmRleH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYXJ9fSksYXIuSU5TSURFX0FSRUE9LTEsZSh1ci5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgTHQmJnRoaXMucHRzLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB1cn19KSx1ci5nZXRQb2ludHM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0IGluc3RhbmNlb2YgTHQ/aG8uc2luZ2xldG9uTGlzdCh0KTp1ci5nZXRQb2ludHModCxuZXcgSSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gZSBpbnN0YW5jZW9mIEx0P24uYWRkKGUpOmUgaW5zdGFuY2VvZiBmdCYmZS5hcHBseShuZXcgdXIobikpLG59fSxlKGxyLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpeyh0IGluc3RhbmNlb2YgTHR8fHQgaW5zdGFuY2VvZiBTdHx8dCBpbnN0YW5jZW9mIFR0KSYmdGhpcy5sb2NhdGlvbnMuYWRkKG5ldyBhcih0LDAsdC5nZXRDb29yZGluYXRlKCkpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBscn19KSxsci5nZXRMb2NhdGlvbnM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEk7cmV0dXJuIHQuYXBwbHkobmV3IGxyKGUpKSxlfSxlKGhyLnByb3RvdHlwZSx7Y29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2U6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgwLHQpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPTEtZSxyPW9yLmdldFBvbHlnb25zKHRoaXMuZ2VvbVtlXSk7aWYoci5zaXplKCk+MCl7dmFyIHM9bHIuZ2V0TG9jYXRpb25zKHRoaXMuZ2VvbVtpXSk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShzLHIsbiksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uW2ldPW5bMF0sdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uW2VdPW5bMV0sbnVsbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZSKGFyZ3VtZW50c1swXSx5KSYmUihhcmd1bWVudHNbMV0seSkpe2Zvcih2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl0sbD0wO2w8by5zaXplKCk7bCsrKWZvcih2YXIgaD1vLmdldChsKSxjPTA7YzxhLnNpemUoKTtjKyspaWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShoLGEuZ2V0KGMpLHUpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGFyJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFR0KXt2YXIgZj1hcmd1bWVudHNbMF0sZz1hcmd1bWVudHNbMV0sZD1hcmd1bWVudHNbMl0scD1mLmdldENvb3JkaW5hdGUoKTtpZihMLkVYVEVSSU9SIT09dGhpcy5wdExvY2F0b3IubG9jYXRlKHAsZykpcmV0dXJuIHRoaXMubWluRGlzdGFuY2U9MCxkWzBdPWYsZFsxXT1uZXcgYXIoZyxwKSxudWxsfX0sY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKHIsbyxuKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX0sY29tcHV0ZUZhY2V0RGlzdGFuY2U6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxlPWtuLmdldExpbmVzKHRoaXMuZ2VvbVswXSksbj1rbi5nZXRMaW5lcyh0aGlzLmdlb21bMV0pLGk9dXIuZ2V0UG9pbnRzKHRoaXMuZ2VvbVswXSkscj11ci5nZXRQb2ludHModGhpcy5nZW9tWzFdKTtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyhlLG4sdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhlLHIsdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhuLGksdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCEwKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMoaSxyLHQpLHZvaWQgdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSkpKX0sbmVhcmVzdExvY2F0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbn0sdXBkYXRlTWluRGlzdGFuY2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXRbMF0/bnVsbDp2b2lkKGU/KHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblswXT10WzFdLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzBdKToodGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMF0sdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMV0pKX0sbmVhcmVzdFBvaW50czpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7dmFyIHQ9W3RoaXMubWluRGlzdGFuY2VMb2NhdGlvblswXS5nZXRDb29yZGluYXRlKCksdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzFdLmdldENvb3JkaW5hdGUoKV07cmV0dXJuIHR9LGNvbXB1dGVNaW5EaXN0YW5jZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihudWxsIT09dGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uKXJldHVybiBudWxsO2lmKHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVGYWNldERpc3RhbmNlKCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMubWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Zm9yKHZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKSxyPWUuZ2V0Q29vcmRpbmF0ZSgpLHM9MDtzPGkubGVuZ3RoLTE7cysrKXt2YXIgbz1oZS5kaXN0YW5jZVBvaW50TGluZShyLGlbc10saVtzKzFdKTtpZihvPHRoaXMubWluRGlzdGFuY2Upe3RoaXMubWluRGlzdGFuY2U9bzt2YXIgYT1uZXcgY2UoaVtzXSxpW3MrMV0pLHU9YS5jbG9zZXN0UG9pbnQocik7blswXT1uZXcgYXIodCxzLHUpLG5bMV09bmV3IGFyKGUsMCxyKX1pZih0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgU3Qpe3ZhciBsPWFyZ3VtZW50c1swXSxoPWFyZ3VtZW50c1sxXSxjPWFyZ3VtZW50c1syXTtpZihsLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShoLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtmb3IodmFyIGk9bC5nZXRDb29yZGluYXRlcygpLGY9aC5nZXRDb29yZGluYXRlcygpLHM9MDtzPGkubGVuZ3RoLTE7cysrKWZvcih2YXIgZz0wO2c8Zi5sZW5ndGgtMTtnKyspe3ZhciBvPWhlLmRpc3RhbmNlTGluZUxpbmUoaVtzXSxpW3MrMV0sZltnXSxmW2crMV0pO2lmKG88dGhpcy5taW5EaXN0YW5jZSl7dGhpcy5taW5EaXN0YW5jZT1vO3ZhciBkPW5ldyBjZShpW3NdLGlbcysxXSkscD1uZXcgY2UoZltnXSxmW2crMV0pLHY9ZC5jbG9zZXN0UG9pbnRzKHApO2NbMF09bmV3IGFyKGwscyx2WzBdKSxjWzFdPW5ldyBhcihoLGcsdlsxXSl9aWYodGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fSxjb21wdXRlTWluRGlzdGFuY2VQb2ludHM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpLGE9ci5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2Uoby5nZXRDb29yZGluYXRlKCkpO2lmKGE8dGhpcy5taW5EaXN0YW5jZSYmKHRoaXMubWluRGlzdGFuY2U9YSxuWzBdPW5ldyBhcihyLDAsci5nZXRDb29yZGluYXRlKCkpLG5bMV09bmV3IGFyKG8sMCxvLmdldENvb3JkaW5hdGUoKSkpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fSxkaXN0YW5jZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmdlb21bMF18fG51bGw9PT10aGlzLmdlb21bMV0pdGhyb3cgbmV3IGkoXCJudWxsIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuZ2VvbVswXS5pc0VtcHR5KCl8fHRoaXMuZ2VvbVsxXS5pc0VtcHR5KCk/MDoodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSx0aGlzLm1pbkRpc3RhbmNlKX0sY29tcHV0ZU1pbkRpc3RhbmNlTGluZXM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKHIsbyxuKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHJ9fSksaHIuZGlzdGFuY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgaHIodCxlKTtyZXR1cm4gbi5kaXN0YW5jZSgpfSxoci5pc1dpdGhpbkRpc3RhbmNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgaHIodCxlLG4pO3JldHVybiBpLmRpc3RhbmNlKCk8PW59LGhyLm5lYXJlc3RQb2ludHM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgaHIodCxlKTtyZXR1cm4gbi5uZWFyZXN0UG9pbnRzKCl9O3ZhciBTbz1PYmplY3QuZnJlZXplKHtEaXN0YW5jZU9wOmhyfSk7ZShjci5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuY29vcmRpbmF0ZXMpe2Zvcih2YXIgdD0wLGU9MCxuPW5ldyBOLGk9dGhpcy5kaXJlY3RlZEVkZ2VzLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmdldEVkZ2VEaXJlY3Rpb24oKT90Kys6ZSsrLG4uYWRkKHIuZ2V0RWRnZSgpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLCExLHIuZ2V0RWRnZURpcmVjdGlvbigpKX10aGlzLmNvb3JkaW5hdGVzPW4udG9Db29yZGluYXRlQXJyYXkoKSxlPnQmJkgucmV2ZXJzZSh0aGlzLmNvb3JkaW5hdGVzKX1yZXR1cm4gdGhpcy5jb29yZGluYXRlc30sdG9MaW5lU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSl9LGFkZDpmdW5jdGlvbih0KXt0aGlzLmRpcmVjdGVkRWRnZXMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjcn19KSxlKGZyLnByb3RvdHlwZSx7c2V0VmlzaXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH0saXNNYXJrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxzZXRNYXJrZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNNYXJrZWQ9dH0sZ2V0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGlzVmlzaXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9LHNldENvbnRleHQ6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZyfX0pLGZyLmdldENvbXBvbmVudFdpdGhWaXNpdGVkU3RhdGU9ZnVuY3Rpb24odCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dmFyIG49dC5uZXh0KCk7aWYobi5pc1Zpc2l0ZWQoKT09PWUpcmV0dXJuIG59cmV0dXJuIG51bGx9LGZyLnNldFZpc2l0ZWQ9ZnVuY3Rpb24odCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dmFyIG49dC5uZXh0KCk7bi5zZXRWaXNpdGVkKGUpfX0sZnIuc2V0TWFya2VkPWZ1bmN0aW9uKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3ZhciBuPXQubmV4dCgpO24uc2V0TWFya2VkKGUpfX0saChncixmciksZShnci5wcm90b3R5cGUse2lzUmVtb3ZlZDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5wYXJlbnRFZGdlfSxjb21wYXJlRGlyZWN0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnF1YWRyYW50PnQucXVhZHJhbnQ/MTp0aGlzLnF1YWRyYW50PHQucXVhZHJhbnQ/LTE6aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQucDAsdC5wMSx0aGlzLnAxKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZyb20uZ2V0Q29vcmRpbmF0ZSgpfSxwcmludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIiksaT1lLnN1YnN0cmluZyhuKzEpO3QucHJpbnQoXCIgIFwiK2krXCI6IFwiK3RoaXMucDArXCIgLSBcIit0aGlzLnAxK1wiIFwiK3RoaXMucXVhZHJhbnQrXCI6XCIrdGhpcy5hbmdsZSl9LGdldERpcmVjdGlvblB0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDF9LGdldEFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYW5nbGV9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9LGdldEZyb21Ob2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZnJvbX0sZ2V0U3ltOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltfSxzZXRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMucGFyZW50RWRnZT10fSxyZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLnN5bT1udWxsLHRoaXMucGFyZW50RWRnZT1udWxsfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50RWRnZX0sZ2V0UXVhZHJhbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5xdWFkcmFudH0sc2V0U3ltOmZ1bmN0aW9uKHQpe3RoaXMuc3ltPXR9LGdldFRvTm9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvfSxnZXRFZGdlRGlyZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZURpcmVjdGlvbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGdyfX0pLGdyLnRvRWRnZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmFkZChuLm5leHQoKS5wYXJlbnRFZGdlKTtyZXR1cm4gZX0saChkcixnciksZShkci5wcm90b3R5cGUse2dldE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gMiE9PXRoaXMuZ2V0VG9Ob2RlKCkuZ2V0RGVncmVlKCk/bnVsbDp0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCk9PT10aGlzLmdldFN5bSgpP3RoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKTooZi5pc1RydWUodGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpPT09dGhpcy5nZXRTeW0oKSksdGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZHJ9fSksaChwcixmciksZShwci5wcm90b3R5cGUse2lzUmVtb3ZlZDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5kaXJFZGdlfSxzZXREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKHQsZSl7dGhpcy5kaXJFZGdlPVt0LGVdLHQuc2V0RWRnZSh0aGlzKSxlLnNldEVkZ2UodGhpcyksdC5zZXRTeW0oZSksZS5zZXRTeW0odCksdC5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UodCksZS5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UoZSl9LGdldERpckVkZ2U6ZnVuY3Rpb24oKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5kaXJFZGdlW3RdfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbXIpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT1lP3RoaXMuZGlyRWRnZVswXTp0aGlzLmRpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PWU/dGhpcy5kaXJFZGdlWzFdOm51bGx9fSxyZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLmRpckVkZ2U9bnVsbH0sZ2V0T3Bwb3NpdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5kaXJFZGdlWzBdLmdldFRvTm9kZSgpOnRoaXMuZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLmRpckVkZ2VbMV0uZ2V0VG9Ob2RlKCk6bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHJ9fSksZSh2ci5wcm90b3R5cGUse2dldE5leHRFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMub3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZSsxKSl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLml0ZXJhdG9yKCk7aWYoIXQuaGFzTmV4dCgpKXJldHVybiBudWxsO3ZhciBlPXQubmV4dCgpO3JldHVybiBlLmdldENvb3JkaW5hdGUoKX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLm91dEVkZ2VzLml0ZXJhdG9yKCl9LHNvcnRFZGdlczpmdW5jdGlvbigpe3RoaXMuc29ydGVkfHwoaG8uc29ydCh0aGlzLm91dEVkZ2VzKSx0aGlzLnNvcnRlZD0hMCl9LHJlbW92ZTpmdW5jdGlvbih0KXt0aGlzLm91dEVkZ2VzLnJlbW92ZSh0KX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLm91dEVkZ2VzfSxnZXROZXh0Q1dFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMub3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZS0xKSl9LGdldEluZGV4OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBwcil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKHZhciBlPTA7ZTx0aGlzLm91dEVkZ2VzLnNpemUoKTtlKyspe3ZhciBuPXRoaXMub3V0RWRnZXMuZ2V0KGUpO2lmKG4uZ2V0RWRnZSgpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGdyKXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IodmFyIGU9MDtlPHRoaXMub3V0RWRnZXMuc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5vdXRFZGdlcy5nZXQoZSk7aWYobj09PWkpcmV0dXJuIGV9cmV0dXJuLTF9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgcj1hcmd1bWVudHNbMF0scz1yJXRoaXMub3V0RWRnZXMuc2l6ZSgpO3JldHVybiAwPnMmJihzKz10aGlzLm91dEVkZ2VzLnNpemUoKSksc319LGFkZDpmdW5jdGlvbih0KXt0aGlzLm91dEVkZ2VzLmFkZCh0KSx0aGlzLnNvcnRlZD0hMX0sZ2V0RGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3V0RWRnZXMuc2l6ZSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2cn19KSxoKG1yLGZyKSxlKG1yLnByb3RvdHlwZSx7aXNSZW1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnB0fSxhZGRPdXRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMuZGVTdGFyLmFkZCh0KX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxnZXRPdXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlU3Rhcn0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5wdD1udWxsO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmRlU3Rhci5yZW1vdmUodCl9fSxnZXRJbmRleDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kZVN0YXIuZ2V0SW5kZXgodCl9LGdldERlZ3JlZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlU3Rhci5nZXREZWdyZWUoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbXJ9fSksbXIuZ2V0RWRnZXNCZXR3ZWVuPWZ1bmN0aW9uKHQsZSl7dmFyIG49Z3IudG9FZGdlcyh0LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSksaT1uZXcgSihuKSxyPWdyLnRvRWRnZXMoZS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkpO3JldHVybiBpLnJldGFpbkFsbChyKSxpfSxoKHlyLHByKSxlKHlyLnByb3RvdHlwZSx7Z2V0TGluZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbmV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHlyfX0pLGUoeHIucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZ2V0KHQpfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0scmVtb3ZlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAucmVtb3ZlKHQpfSx2YWx1ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpfSxhZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5wdXQodC5nZXRDb29yZGluYXRlKCksdCksdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geHJ9fSksZShFci5wcm90b3R5cGUse2ZpbmROb2Rlc09mRGVncmVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXRoaXMubm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmdldERlZ3JlZSgpPT09dCYmZS5hZGQoaSl9cmV0dXJuIGV9LGRpckVkZ2VJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpckVkZ2VzLml0ZXJhdG9yKCl9LGVkZ2VJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzLml0ZXJhdG9yKCl9LHJlbW92ZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcHIpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMCkpLHRoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5lZGdlcy5yZW1vdmUodCksdC5yZW1vdmUoKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ3Ipe3ZhciBlPWFyZ3VtZW50c1swXSxuPWUuZ2V0U3ltKCk7bnVsbCE9PW4mJm4uc2V0U3ltKG51bGwpLGUuZ2V0RnJvbU5vZGUoKS5yZW1vdmUoZSksZS5yZW1vdmUoKSx0aGlzLmRpckVkZ2VzLnJlbW92ZShlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbXIpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0scj1pLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxzPXIuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpLG49by5nZXRTeW0oKTtudWxsIT09biYmdGhpcy5yZW1vdmUobiksdGhpcy5kaXJFZGdlcy5yZW1vdmUobyk7dmFyIGE9by5nZXRFZGdlKCk7bnVsbCE9PWEmJnRoaXMuZWRnZXMucmVtb3ZlKGEpfXRoaXMubm9kZU1hcC5yZW1vdmUoaS5nZXRDb29yZGluYXRlKCkpLGkucmVtb3ZlKCl9fSxmaW5kTm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLmZpbmQodCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LG5vZGVJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAuaXRlcmF0b3IoKX0sY29udGFpbnM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHByKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWRnZXMuY29udGFpbnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBncil7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRpckVkZ2VzLmNvbnRhaW5zKGUpfX0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZU1hcC5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHByKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5lZGdlcy5hZGQoZSksdGhpcy5hZGQoZS5nZXREaXJFZGdlKDApKSx0aGlzLmFkZChlLmdldERpckVkZ2UoMSkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBncil7dmFyIG49YXJndW1lbnRzWzBdO3RoaXMuZGlyRWRnZXMuYWRkKG4pfX0sZ2V0Tm9kZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFcn19KSxoKElyLEVyKSxlKElyLnByb3RvdHlwZSx7YWRkRWRnZTpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgZT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8PTEpcmV0dXJuIG51bGw7dmFyIG49ZVswXSxpPWVbZS5sZW5ndGgtMV0scj10aGlzLmdldE5vZGUobikscz10aGlzLmdldE5vZGUoaSksbz1uZXcgZHIocixzLGVbMV0sITApLGE9bmV3IGRyKHMscixlW2UubGVuZ3RoLTJdLCExKSx1PW5ldyB5cih0KTt1LnNldERpcmVjdGVkRWRnZXMobyxhKSx0aGlzLmFkZCh1KX0sZ2V0Tm9kZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmZpbmROb2RlKHQpO3JldHVybiBudWxsPT09ZSYmKGU9bmV3IG1yKHQpLHRoaXMuYWRkKGUpKSxlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBJcn19KSxlKE5yLnByb3RvdHlwZSx7YnVpbGRFZGdlU3RyaW5nc0ZvclVucHJvY2Vzc2VkTm9kZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmlzTWFya2VkKCl8fChmLmlzVHJ1ZSgyPT09ZS5nZXREZWdyZWUoKSksdGhpcy5idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdChlKSxlLnNldE1hcmtlZCghMCkpfX0sYnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2RlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpOzIhPT1lLmdldERlZ3JlZSgpJiYodGhpcy5idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdChlKSxlLnNldE1hcmtlZCghMCkpfX0sYnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzOmZ1bmN0aW9uKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzKCl9LGdldE1lcmdlZExpbmVTdHJpbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWVyZ2UoKSx0aGlzLm1lcmdlZExpbmVTdHJpbmdzfSxidWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmdldEVkZ2UoKS5pc01hcmtlZCgpfHx0aGlzLmVkZ2VTdHJpbmdzLmFkZCh0aGlzLmJ1aWxkRWRnZVN0cmluZ1N0YXJ0aW5nV2l0aChuKSl9fSxtZXJnZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLm1lcmdlZExpbmVTdHJpbmdzKXJldHVybiBudWxsO2ZyLnNldE1hcmtlZCh0aGlzLmdyYXBoLm5vZGVJdGVyYXRvcigpLCExKSxmci5zZXRNYXJrZWQodGhpcy5ncmFwaC5lZGdlSXRlcmF0b3IoKSwhMSksdGhpcy5lZGdlU3RyaW5ncz1uZXcgSSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2RlcygpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHMoKSx0aGlzLm1lcmdlZExpbmVTdHJpbmdzPW5ldyBJO2Zvcih2YXIgdD10aGlzLmVkZ2VTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTt0aGlzLm1lcmdlZExpbmVTdHJpbmdzLmFkZChlLnRvTGluZVN0cmluZygpKX19LGJ1aWxkRWRnZVN0cmluZ1N0YXJ0aW5nV2l0aDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgY3IodGhpcy5mYWN0b3J5KSxuPXQ7ZG8gZS5hZGQobiksbi5nZXRFZGdlKCkuc2V0TWFya2VkKCEwKSxuPW4uZ2V0TmV4dCgpO3doaWxlKG51bGwhPT1uJiZuIT09dCk7cmV0dXJuIGV9LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3QuYXBwbHkoe2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLmFkZCh0KX19KX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHYpKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5tZXJnZWRMaW5lU3RyaW5ncz1udWxsO2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtcbnZhciBpPW4ubmV4dCgpO3RoaXMuYWRkKGkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciByPWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5mYWN0b3J5JiYodGhpcy5mYWN0b3J5PXIuZ2V0RmFjdG9yeSgpKSx0aGlzLmdyYXBoLmFkZEVkZ2Uocil9fSxidWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wczpmdW5jdGlvbigpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0ZvclVucHJvY2Vzc2VkTm9kZXMoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTnJ9fSk7dmFyIHdvPU9iamVjdC5mcmVlemUoe0xpbmVNZXJnZXI6TnJ9KSxMbz1PYmplY3QuZnJlZXplKHtPdmVybGF5T3A6aWl9KTtoKENyLGdyKSxlKENyLnByb3RvdHlwZSx7Z2V0TmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHR9LGlzSW5SaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmVkZ2VSaW5nfSxzZXRSaW5nOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZVJpbmc9dH0sc2V0TGFiZWw6ZnVuY3Rpb24odCl7dGhpcy5sYWJlbD10fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxzZXROZXh0OmZ1bmN0aW9uKHQpe3RoaXMubmV4dD10fSxnZXRSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZVJpbmd9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENyfX0pLGgoU3IscHIpLGUoU3IucHJvdG90eXBlLHtnZXRMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU3J9fSksZSh3ci5wcm90b3R5cGUse2lzSW5jbHVkZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZH0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5yaW5nUHRzKXtmb3IodmFyIHQ9bmV3IE4sZT10aGlzLmRlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldEVkZ2UoKTt3ci5hZGRFZGdlKGkuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksbi5nZXRFZGdlRGlyZWN0aW9uKCksdCl9dGhpcy5yaW5nUHRzPXQudG9Db29yZGluYXRlQXJyYXkoKX1yZXR1cm4gdGhpcy5yaW5nUHRzfSxpc0luY2x1ZGVkU2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWRTZXR9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMucmluZ1B0cy5sZW5ndGg8PTM/ITE6KHRoaXMuZ2V0UmluZygpLHRoaXMucmluZy5pc1ZhbGlkKCkpfSxidWlsZDpmdW5jdGlvbih0KXt2YXIgZT10O2RvIHRoaXMuYWRkKGUpLGUuc2V0UmluZyh0aGlzKSxlPWUuZ2V0TmV4dCgpLGYuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGYuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpO3doaWxlKGUhPT10KX0saXNPdXRlckhvbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNIb2xlPyF0aGlzLmhhc1NoZWxsKCk6ITF9LGdldFBvbHlnb246ZnVuY3Rpb24oKXt2YXIgdD1udWxsO2lmKG51bGwhPT10aGlzLmhvbGVzKXt0PW5ldyBBcnJheSh0aGlzLmhvbGVzLnNpemUoKSkuZmlsbChudWxsKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuaG9sZXMuZ2V0KGUpfXZhciBuPXRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHRoaXMucmluZyx0KTtyZXR1cm4gbn0saXNIb2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX0saXNQcm9jZXNzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNQcm9jZXNzZWR9LGFkZEhvbGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXt2YXIgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuaG9sZXMmJih0aGlzLmhvbGVzPW5ldyBJKSx0aGlzLmhvbGVzLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygd3Ipe3ZhciBlPWFyZ3VtZW50c1swXTtlLnNldFNoZWxsKHRoaXMpO3ZhciBuPWUuZ2V0UmluZygpO251bGw9PT10aGlzLmhvbGVzJiYodGhpcy5ob2xlcz1uZXcgSSksdGhpcy5ob2xlcy5hZGQobil9fSxzZXRJbmNsdWRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc0luY2x1ZGVkPXQsdGhpcy5faXNJbmNsdWRlZFNldD0hMH0sZ2V0T3V0ZXJIb2xlOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IodmFyIHQ9MDt0PHRoaXMuZGVMaXN0LnNpemUoKTt0Kyspe3ZhciBlPXRoaXMuZGVMaXN0LmdldCh0KSxuPWUuZ2V0U3ltKCkuZ2V0UmluZygpO2lmKG4uaXNPdXRlckhvbGUoKSlyZXR1cm4gbn1yZXR1cm4gbnVsbH0sY29tcHV0ZUhvbGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldFJpbmcoKTt0aGlzLl9pc0hvbGU9aGUuaXNDQ1codC5nZXRDb29yZGluYXRlcygpKX0saGFzU2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuc2hlbGx9LGlzT3V0ZXJTaGVsbDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5nZXRPdXRlckhvbGUoKX0sZ2V0TGluZVN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5yaW5nUHRzKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLmdldENvb3JkaW5hdGVzKCkpKX0sZ2V0U2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0hvbGUoKT90aGlzLnNoZWxsOnRoaXN9LGFkZDpmdW5jdGlvbih0KXt0aGlzLmRlTGlzdC5hZGQodCl9LGdldFJpbmc6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5yaW5nKXJldHVybiB0aGlzLnJpbmc7dGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMucmluZ1B0cy5sZW5ndGg8MyYmQS5vdXQucHJpbnRsbih0aGlzLnJpbmdQdHMpO3RyeXt0aGlzLnJpbmc9dGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodGhpcy5yaW5nUHRzKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0O0Eub3V0LnByaW50bG4odGhpcy5yaW5nUHRzKX1maW5hbGx5e31yZXR1cm4gdGhpcy5yaW5nfSx1cGRhdGVJbmNsdWRlZDpmdW5jdGlvbigpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKHZhciB0PTA7dDx0aGlzLmRlTGlzdC5zaXplKCk7dCsrKXt2YXIgZT10aGlzLmRlTGlzdC5nZXQodCksbj1lLmdldFN5bSgpLmdldFJpbmcoKS5nZXRTaGVsbCgpO2lmKG51bGwhPT1uJiZuLmlzSW5jbHVkZWRTZXQoKSlyZXR1cm4gdGhpcy5zZXRJbmNsdWRlZCghbi5pc0luY2x1ZGVkKCkpLG51bGx9fSxzZXRTaGVsbDpmdW5jdGlvbih0KXt0aGlzLnNoZWxsPXR9LHNldFByb2Nlc3NlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Byb2Nlc3NlZD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3cn19KSx3ci5maW5kRGlyRWRnZXNJblJpbmc9ZnVuY3Rpb24odCl7dmFyIGU9dCxuPW5ldyBJO2RvIG4uYWRkKGUpLGU9ZS5nZXROZXh0KCksZi5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZi5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIik7d2hpbGUoZSE9PXQpO3JldHVybiBufSx3ci5hZGRFZGdlPWZ1bmN0aW9uKHQsZSxuKXtpZihlKWZvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKW4uYWRkKHRbaV0sITEpO2Vsc2UgZm9yKHZhciBpPXQubGVuZ3RoLTE7aT49MDtpLS0pbi5hZGQodFtpXSwhMSl9LHdyLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmc9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRSaW5nKCksaT1uLmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscz1udWxsLG89bnVsbCxhPWUuaXRlcmF0b3IoKTthLmhhc05leHQoKTspe3ZhciB1PWEubmV4dCgpLGw9dS5nZXRSaW5nKCksaD1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighaC5lcXVhbHMoaSkmJmguY29udGFpbnMoaSkpe3I9SC5wdE5vdEluTGlzdChuLmdldENvb3JkaW5hdGVzKCksbC5nZXRDb29yZGluYXRlcygpKTt2YXIgYz0hMTtoZS5pc1BvaW50SW5SaW5nKHIsbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09c3x8by5jb250YWlucyhoKSkmJihzPXUsbz1zLmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpfX1yZXR1cm4gc30sZShMci5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtyZXR1cm4gbi5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKS5jb21wYXJlVG8oaS5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMcn19KSx3ci5FbnZlbG9wZUNvbXBhcmF0b3I9THIsaChScixFciksZShSci5wcm90b3R5cGUse2ZpbmRFZGdlUmluZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgd3IodGhpcy5mYWN0b3J5KTtyZXR1cm4gZS5idWlsZCh0KSxlfSxjb21wdXRlRGVwdGhQYXJpdHk6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IoOzspe3ZhciB0PW51bGw7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlRGVwdGhQYXJpdHkodCl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfX0sY29tcHV0ZU5leHRDV0VkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtSci5jb21wdXRlTmV4dENXRWRnZXMoZSl9fSxhZGRFZGdlOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiBudWxsO3ZhciBuPWVbMF0saT1lW2UubGVuZ3RoLTFdLHI9dGhpcy5nZXROb2RlKG4pLHM9dGhpcy5nZXROb2RlKGkpLG89bmV3IENyKHIscyxlWzFdLCEwKSxhPW5ldyBDcihzLHIsZVtlLmxlbmd0aC0yXSwhMSksdT1uZXcgU3IodCk7dS5zZXREaXJlY3RlZEVkZ2VzKG8sYSksdGhpcy5hZGQodSl9LGRlbGV0ZUN1dEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxSci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLmRpckVkZ2VzKTtmb3IodmFyIHQ9bmV3IEksZT10aGlzLmRpckVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZighbi5pc01hcmtlZCgpKXt2YXIgaT1uLmdldFN5bSgpO2lmKG4uZ2V0TGFiZWwoKT09PWkuZ2V0TGFiZWwoKSl7bi5zZXRNYXJrZWQoITApLGkuc2V0TWFya2VkKCEwKTt2YXIgcj1uLmdldEVkZ2UoKTt0LmFkZChyLmdldExpbmUoKSl9fX1yZXR1cm4gdH0sZ2V0RWRnZVJpbmdzOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxSci5sYWJlbCh0aGlzLmRpckVkZ2VzLC0xKTt2YXIgdD1Sci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLmRpckVkZ2VzKTt0aGlzLmNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzKHQpO2Zvcih2YXIgZT1uZXcgSSxuPXRoaXMuZGlyRWRnZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKCFpLmlzTWFya2VkKCkmJiFpLmlzSW5SaW5nKCkpe3ZhciByPXRoaXMuZmluZEVkZ2VSaW5nKGkpO2UuYWRkKHIpfX1yZXR1cm4gZX0sZ2V0Tm9kZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmZpbmROb2RlKHQpO3JldHVybiBudWxsPT09ZSYmKGU9bmV3IG1yKHQpLHRoaXMuYWRkKGUpKSxlfSxjb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCkscj1Sci5maW5kSW50ZXJzZWN0aW9uTm9kZXMobixpKTtpZihudWxsIT09cilmb3IodmFyIHM9ci5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCk7UnIuY29tcHV0ZU5leHRDQ1dFZGdlcyhvLGkpfX19LGRlbGV0ZURhbmdsZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5maW5kTm9kZXNPZkRlZ3JlZSgxKSxlPW5ldyBKLG49bmV3IHBlLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyluLnB1c2goaS5uZXh0KCkpO2Zvcig7IW4uaXNFbXB0eSgpOyl7dmFyIHI9bi5wb3AoKTtSci5kZWxldGVBbGxFZGdlcyhyKTtmb3IodmFyIHM9ci5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCksaT1zLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgbz1pLm5leHQoKTtvLnNldE1hcmtlZCghMCk7dmFyIGE9by5nZXRTeW0oKTtudWxsIT09YSYmYS5zZXRNYXJrZWQoITApO3ZhciB1PW8uZ2V0RWRnZSgpO2UuYWRkKHUuZ2V0TGluZSgpKTt2YXIgbD1vLmdldFRvTm9kZSgpOzE9PT1Sci5nZXREZWdyZWVOb25EZWxldGVkKGwpJiZuLnB1c2gobCl9fXJldHVybiBlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBScn19KSxSci5maW5kTGFiZWxlZEVkZ2VSaW5ncz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0xLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYoIShyLmlzTWFya2VkKCl8fHIuZ2V0TGFiZWwoKT49MCkpe2UuYWRkKHIpO3ZhciBzPXdyLmZpbmREaXJFZGdlc0luUmluZyhyKTtSci5sYWJlbChzLG4pLG4rK319cmV0dXJuIGV9LFJyLmdldERlZ3JlZU5vbkRlbGV0ZWQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLG49MCxpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuaXNNYXJrZWQoKXx8bisrfXJldHVybiBufSxSci5kZWxldGVBbGxFZGdlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldE1hcmtlZCghMCk7dmFyIHI9aS5nZXRTeW0oKTtudWxsIT09ciYmci5zZXRNYXJrZWQoITApfX0sUnIubGFiZWw9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5zZXRMYWJlbChlKX19LFJyLmNvbXB1dGVOZXh0Q1dFZGdlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRPdXRFZGdlcygpLG49bnVsbCxpPW51bGwscj1lLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKCFzLmlzTWFya2VkKCkpe2lmKG51bGw9PT1uJiYobj1zKSxudWxsIT09aSl7dmFyIG89aS5nZXRTeW0oKTtvLnNldE5leHQocyl9aT1zfX1pZihudWxsIT09aSl7dmFyIG89aS5nZXRTeW0oKTtvLnNldE5leHQobil9fSxSci5jb21wdXRlTmV4dENDV0VkZ2VzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0T3V0RWRnZXMoKSxpPW51bGwscj1udWxsLHM9bi5nZXRFZGdlcygpLG89cy5zaXplKCktMTtvPj0wO28tLSl7dmFyIGE9cy5nZXQobyksdT1hLmdldFN5bSgpLGw9bnVsbDthLmdldExhYmVsKCk9PT1lJiYobD1hKTt2YXIgaD1udWxsO3UuZ2V0TGFiZWwoKT09PWUmJihoPXUpLG51bGw9PT1sJiZudWxsPT09aHx8KG51bGwhPT1oJiYocj1oKSxudWxsIT09bCYmKG51bGwhPT1yJiYoci5zZXROZXh0KGwpLHI9bnVsbCksbnVsbD09PWkmJihpPWwpKSl9bnVsbCE9PXImJihmLmlzVHJ1ZShudWxsIT09aSksci5zZXROZXh0KGkpKX0sUnIuZ2V0RGVncmVlPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLGk9MCxyPW4uaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO3MuZ2V0TGFiZWwoKT09PWUmJmkrK31yZXR1cm4gaX0sUnIuZmluZEludGVyc2VjdGlvbk5vZGVzPWZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPW51bGw7ZG97dmFyIHI9bi5nZXRGcm9tTm9kZSgpO1JyLmdldERlZ3JlZShyLGUpPjEmJihudWxsPT09aSYmKGk9bmV3IEkpLGkuYWRkKHIpKSxuPW4uZ2V0TmV4dCgpLGYuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGYuaXNUcnVlKG49PT10fHwhbi5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKG4hPT10KTtyZXR1cm4gaX0sZShUci5wcm90b3R5cGUse2dldEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmdlb21GYWN0b3J5JiYodGhpcy5nZW9tRmFjdG9yeT1uZXcgaWUpLHRoaXMucG9seWdvbml6ZSgpLHRoaXMuZXh0cmFjdE9ubHlQb2x5Z29uYWw/dGhpcy5nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMucG9seUxpc3QpOnRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheSh0aGlzLnBvbHlMaXN0KSl9LGdldEludmFsaWRSaW5nTGluZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5pbnZhbGlkUmluZ0xpbmVzfSxmaW5kVmFsaWRSaW5nczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuaXNWYWxpZCgpP2UuYWRkKHIpOm4uYWRkKHIuZ2V0TGluZVN0cmluZygpKX19LHBvbHlnb25pemU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5wb2x5TGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLnBvbHlMaXN0PW5ldyBJLG51bGw9PT10aGlzLmdyYXBoKXJldHVybiBudWxsO3RoaXMuZGFuZ2xlcz10aGlzLmdyYXBoLmRlbGV0ZURhbmdsZXMoKSx0aGlzLmN1dEVkZ2VzPXRoaXMuZ3JhcGguZGVsZXRlQ3V0RWRnZXMoKTt2YXIgdD10aGlzLmdyYXBoLmdldEVkZ2VSaW5ncygpLGU9bmV3IEk7dGhpcy5pbnZhbGlkUmluZ0xpbmVzPW5ldyBJLHRoaXMuaXNDaGVja2luZ1JpbmdzVmFsaWQ/dGhpcy5maW5kVmFsaWRSaW5ncyh0LGUsdGhpcy5pbnZhbGlkUmluZ0xpbmVzKTplPXQsdGhpcy5maW5kU2hlbGxzQW5kSG9sZXMoZSksVHIuYXNzaWduSG9sZXNUb1NoZWxscyh0aGlzLmhvbGVMaXN0LHRoaXMuc2hlbGxMaXN0KSxoby5zb3J0KHRoaXMuc2hlbGxMaXN0LG5ldyB3ci5FbnZlbG9wZUNvbXBhcmF0b3IpO3ZhciBuPSEwO3RoaXMuZXh0cmFjdE9ubHlQb2x5Z29uYWwmJihUci5maW5kRGlzam9pbnRTaGVsbHModGhpcy5zaGVsbExpc3QpLG49ITEpLHRoaXMucG9seUxpc3Q9VHIuZXh0cmFjdFBvbHlnb25zKHRoaXMuc2hlbGxMaXN0LG4pfSxnZXREYW5nbGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuZGFuZ2xlc30sZ2V0Q3V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5jdXRFZGdlc30sZ2V0UG9seWdvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5wb2x5TGlzdH0sYWRkOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuYWRkKG4pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIGk9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUZhY3Rvcnk9aS5nZXRGYWN0b3J5KCksbnVsbD09PXRoaXMuZ3JhcGgmJih0aGlzLmdyYXBoPW5ldyBScih0aGlzLmdlb21GYWN0b3J5KSksdGhpcy5ncmFwaC5hZGRFZGdlKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgcj1hcmd1bWVudHNbMF07ci5hcHBseSh0aGlzLmxpbmVTdHJpbmdBZGRlcil9fSxzZXRDaGVja1JpbmdzVmFsaWQ6ZnVuY3Rpb24odCl7dGhpcy5pc0NoZWNraW5nUmluZ3NWYWxpZD10fSxmaW5kU2hlbGxzQW5kSG9sZXM6ZnVuY3Rpb24odCl7dGhpcy5ob2xlTGlzdD1uZXcgSSx0aGlzLnNoZWxsTGlzdD1uZXcgSTtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5jb21wdXRlSG9sZSgpLG4uaXNIb2xlKCk/dGhpcy5ob2xlTGlzdC5hZGQobik6dGhpcy5zaGVsbExpc3QuYWRkKG4pfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVHJ9fSksVHIuZmluZE91dGVyU2hlbGxzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0T3V0ZXJIb2xlKCk7bnVsbD09PWl8fGkuaXNQcm9jZXNzZWQoKXx8KG4uc2V0SW5jbHVkZWQoITApLGkuc2V0UHJvY2Vzc2VkKCEwKSl9fSxUci5leHRyYWN0UG9seWdvbnM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTsoZXx8ci5pc0luY2x1ZGVkKCkpJiZuLmFkZChyLmdldFBvbHlnb24oKSl9cmV0dXJuIG59LFRyLmFzc2lnbkhvbGVzVG9TaGVsbHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7VHIuYXNzaWduSG9sZVRvU2hlbGwoaSxlKX19LFRyLmFzc2lnbkhvbGVUb1NoZWxsPWZ1bmN0aW9uKHQsZSl7dmFyIG49d3IuZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpO251bGwhPT1uJiZuLmFkZEhvbGUodCl9LFRyLmZpbmREaXNqb2ludFNoZWxscz1mdW5jdGlvbih0KXtUci5maW5kT3V0ZXJTaGVsbHModCk7dmFyIGU9bnVsbDtkb3tlPSExO2Zvcih2YXIgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmlzSW5jbHVkZWRTZXQoKXx8KGkudXBkYXRlSW5jbHVkZWQoKSxpLmlzSW5jbHVkZWRTZXQoKXx8KGU9ITApKX19d2hpbGUoZSl9LGUoUHIucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLnAuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUHJ9fSksVHIuTGluZVN0cmluZ0FkZGVyPVByO3ZhciBSbz1PYmplY3QuZnJlZXplKHtQb2x5Z29uaXplcjpUcn0pO2UoYnIucHJvdG90eXBlLHtjcmVhdGVFZGdlRW5kRm9yTmV4dDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uLnNlZ21lbnRJbmRleCsxO2lmKHI+PXQuZ2V0TnVtUG9pbnRzKCkmJm51bGw9PT1pKXJldHVybiBudWxsO3ZhciBzPXQuZ2V0Q29vcmRpbmF0ZShyKTtudWxsIT09aSYmaS5zZWdtZW50SW5kZXg9PT1uLnNlZ21lbnRJbmRleCYmKHM9aS5jb29yZCk7dmFyIG89bmV3IEVuKHQsbi5jb29yZCxzLG5ldyBnbih0LmdldExhYmVsKCkpKTtlLmFkZChvKX0sY3JlYXRlRWRnZUVuZEZvclByZXY6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bi5zZWdtZW50SW5kZXg7aWYoMD09PW4uZGlzdCl7aWYoMD09PXIpcmV0dXJuIG51bGw7ci0tfXZhciBzPXQuZ2V0Q29vcmRpbmF0ZShyKTtudWxsIT09aSYmaS5zZWdtZW50SW5kZXg+PXImJihzPWkuY29vcmQpO3ZhciBvPW5ldyBnbih0LmdldExhYmVsKCkpO28uZmxpcCgpO3ZhciBhPW5ldyBFbih0LG4uY29vcmQscyxvKTtlLmFkZChhKX0sY29tcHV0ZUVkZ2VFbmRzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSSxuPXQ7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmNvbXB1dGVFZGdlRW5kcyhpLGUpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1yLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCk7by5hZGRFbmRwb2ludHMoKTt2YXIgYT1vLml0ZXJhdG9yKCksdT1udWxsLGw9bnVsbDtpZighYS5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dmFyIGg9YS5uZXh0KCk7ZG8gdT1sLGw9aCxoPW51bGwsYS5oYXNOZXh0KCkmJihoPWEubmV4dCgpKSxudWxsIT09bCYmKHRoaXMuY3JlYXRlRWRnZUVuZEZvclByZXYocixzLGwsdSksdGhpcy5jcmVhdGVFZGdlRW5kRm9yTmV4dChyLHMsbCxoKSk7d2hpbGUobnVsbCE9PWwpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYnJ9fSksaChPcixFbiksZShPci5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0KXt0aGlzLmVkZ2VFbmRzLmFkZCh0KX0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiRWRnZUVuZEJ1bmRsZS0tPiBMYWJlbDogXCIrdGhpcy5sYWJlbCk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCksdC5wcmludGxuKCl9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VFbmRzLml0ZXJhdG9yKCl9LGdldEVkZ2VFbmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZUVuZHN9LGNvbXB1dGVMYWJlbE9uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAsaT0hMSxyPXRoaXMuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO289PT1MLkJPVU5EQVJZJiZuKyssbz09PUwuSU5URVJJT1ImJihpPSEwKX12YXIgbz1MLk5PTkU7aSYmKG89TC5JTlRFUklPUiksbj4wJiYobz0kbi5kZXRlcm1pbmVCb3VuZGFyeShlLG4pKSx0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsbyl9LGNvbXB1dGVMYWJlbFNpZGU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5nZXRMYWJlbCgpLmlzQXJlYSgpKXt2YXIgcj1pLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCxlKTtpZihyPT09TC5JTlRFUklPUilyZXR1cm4gdGhpcy5sYWJlbC5zZXRMb2NhdGlvbih0LGUsTC5JTlRFUklPUiksbnVsbDtyPT09TC5FWFRFUklPUiYmdGhpcy5sYWJlbC5zZXRMb2NhdGlvbih0LGUsTC5FWFRFUklPUil9fX0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sY29tcHV0ZUxhYmVsU2lkZXM6ZnVuY3Rpb24odCl7dGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsY24uTEVGVCksdGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsY24uUklHSFQpfSx1cGRhdGVJTTpmdW5jdGlvbih0KXtKbi51cGRhdGVJTSh0aGlzLmxhYmVsLHQpfSxjb21wdXRlTGFiZWw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSExLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5nZXRMYWJlbCgpLmlzQXJlYSgpJiYoZT0hMCl9ZT90aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUsTC5OT05FLEwuTk9ORSk6dGhpcy5sYWJlbD1uZXcgZ24oTC5OT05FKTtmb3IodmFyIHI9MDsyPnI7cisrKXRoaXMuY29tcHV0ZUxhYmVsT24ocix0KSxlJiZ0aGlzLmNvbXB1dGVMYWJlbFNpZGVzKHIpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPcn19KSxoKF9yLFBuKSxlKF9yLnByb3RvdHlwZSx7dXBkYXRlSU06ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24udXBkYXRlSU0odCl9fSxpbnNlcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lZGdlTWFwLmdldCh0KTtudWxsPT09ZT8oZT1uZXcgT3IodCksdGhpcy5pbnNlcnRFZGdlRW5kKHQsZSkpOmUuaW5zZXJ0KHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBfcn19KSxoKE1yLHluKSxlKE1yLnByb3RvdHlwZSx7dXBkYXRlSU1Gcm9tRWRnZXM6ZnVuY3Rpb24odCl7dGhpcy5lZGdlcy51cGRhdGVJTSh0KX0sY29tcHV0ZUlNOmZ1bmN0aW9uKHQpe3Quc2V0QXRMZWFzdElmVmFsaWQodGhpcy5sYWJlbC5nZXRMb2NhdGlvbigwKSx0aGlzLmxhYmVsLmdldExvY2F0aW9uKDEpLDApfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNcn19KSxoKERyLE5uKSxlKERyLnByb3RvdHlwZSx7Y3JlYXRlTm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IE1yKHQsbmV3IF9yKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRHJ9fSksZShBci5wcm90b3R5cGUse2luc2VydEVkZ2VFbmRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLm5vZGVzLmFkZChuKX19LGNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCksaT10aGlzLmFyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLHI9dC5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKSxzPXQuaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKTsyPT09biYmMj09PWk/ciYmZS5zZXRBdExlYXN0KFwiMjEyMTAxMjEyXCIpOjI9PT1uJiYxPT09aT8ociYmZS5zZXRBdExlYXN0KFwiRkZGMEZGRkYyXCIpLHMmJmUuc2V0QXRMZWFzdChcIjFGRkZGRjFGRlwiKSk6MT09PW4mJjI9PT1pPyhyJiZlLnNldEF0TGVhc3QoXCJGMEZGRkZGRjJcIikscyYmZS5zZXRBdExlYXN0KFwiMUYxRkZGRkZGXCIpKToxPT09biYmMT09PWkmJnMmJmUuc2V0QXRMZWFzdChcIjBGRkZGRkZGRlwiKX0sbGFiZWxJc29sYXRlZEVkZ2VzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5pc0lzb2xhdGVkKCkmJih0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlKGksZSx0aGlzLmFyZ1tlXS5nZXRHZW9tZXRyeSgpKSx0aGlzLmlzb2xhdGVkRWRnZXMuYWRkKGkpKX19LGxhYmVsSXNvbGF0ZWRFZGdlOmZ1bmN0aW9uKHQsZSxuKXtpZihuLmdldERpbWVuc2lvbigpPjApe3ZhciBpPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSxuKTt0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsaSl9ZWxzZSB0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsTC5FWFRFUklPUil9LGNvbXB1dGVJTTpmdW5jdGlvbigpe3ZhciB0PW5ldyBmZTtpZih0LnNldChMLkVYVEVSSU9SLEwuRVhURVJJT1IsMiksIXRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiB0aGlzLmNvbXB1dGVEaXNqb2ludElNKHQpLHQ7dGhpcy5hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCExKSx0aGlzLmFyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITEpO3ZhciBlPXRoaXMuYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLmFyZ1sxXSx0aGlzLmxpLCExKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlcygwKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlcygxKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscygwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscygxKSx0aGlzLmxhYmVsSXNvbGF0ZWROb2RlcygpLHRoaXMuY29tcHV0ZVByb3BlckludGVyc2VjdGlvbklNKGUsdCk7dmFyIG49bmV3IGJyLGk9bi5jb21wdXRlRWRnZUVuZHModGhpcy5hcmdbMF0uZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMoaSk7dmFyIHI9bi5jb21wdXRlRWRnZUVuZHModGhpcy5hcmdbMV0uZ2V0RWRnZUl0ZXJhdG9yKCkpO3JldHVybiB0aGlzLmluc2VydEVkZ2VFbmRzKHIpLHRoaXMubGFiZWxOb2RlRWRnZXMoKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygwLDEpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDEsMCksdGhpcy51cGRhdGVJTSh0KSx0fSxsYWJlbE5vZGVFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLmFyZyl9fSxjb3B5Tm9kZXNBbmRMYWJlbHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT10aGlzLm5vZGVzLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpO2kuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX0sbGFiZWxJbnRlcnNlY3Rpb25Ob2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSxyPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz10aGlzLm5vZGVzLmZpbmQocy5jb29yZCk7by5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmKGk9PT1MLkJPVU5EQVJZP28uc2V0TGFiZWxCb3VuZGFyeSh0KTpvLnNldExhYmVsKHQsTC5JTlRFUklPUikpfX0sbGFiZWxJc29sYXRlZE5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLG4pfSxjb21wdXRlSW50ZXJzZWN0aW9uTm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkscj1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89dGhpcy5ub2Rlcy5hZGROb2RlKHMuY29vcmQpO2k9PT1MLkJPVU5EQVJZP28uc2V0TGFiZWxCb3VuZGFyeSh0KTpvLmdldExhYmVsKCkuaXNOdWxsKHQpJiZvLnNldExhYmVsKHQsTC5JTlRFUklPUil9fSxsYWJlbElzb2xhdGVkTm9kZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7Zi5pc1RydWUobi5nZXRHZW9tZXRyeUNvdW50KCk+MCxcIm5vZGUgd2l0aCBlbXB0eSBsYWJlbCBmb3VuZFwiKSxlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwwKTp0aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMSkpfX0sdXBkYXRlSU06ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXNvbGF0ZWRFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi51cGRhdGVJTSh0KX1mb3IodmFyIGk9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci51cGRhdGVJTSh0KSxyLnVwZGF0ZUlNRnJvbUVkZ2VzKHQpfX0sY29tcHV0ZURpc2pvaW50SU06ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5hcmdbMF0uZ2V0R2VvbWV0cnkoKTtlLmlzRW1wdHkoKXx8KHQuc2V0KEwuSU5URVJJT1IsTC5FWFRFUklPUixlLmdldERpbWVuc2lvbigpKSx0LnNldChMLkJPVU5EQVJZLEwuRVhURVJJT1IsZS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSk7dmFyIG49dGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKTtuLmlzRW1wdHkoKXx8KHQuc2V0KEwuRVhURVJJT1IsTC5JTlRFUklPUixuLmdldERpbWVuc2lvbigpKSx0LnNldChMLkVYVEVSSU9SLEwuQk9VTkRBUlksbi5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFyfX0pLGUoRnIucHJvdG90eXBlLHtpc0NvbnRhaW5lZEluQm91bmRhcnk6ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFR0KXJldHVybiExO2lmKHQgaW5zdGFuY2VvZiBMdClyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0IGluc3RhbmNlb2YgU3QpcmV0dXJuIHRoaXMuaXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeSh0KTtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KG4pKXJldHVybiExfXJldHVybiEwfSxpc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeTpmdW5jdGlvbih0LGUpe2lmKHQuZXF1YWxzKGUpKXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQueD09PWUueCl7aWYodC54PT09dGhpcy5yZWN0RW52LmdldE1pblgoKXx8dC54PT09dGhpcy5yZWN0RW52LmdldE1heFgoKSlyZXR1cm4hMH1lbHNlIGlmKHQueT09PWUueSYmKHQueT09PXRoaXMucmVjdEVudi5nZXRNaW5ZKCl8fHQueT09PXRoaXMucmVjdEVudi5nZXRNYXhZKCkpKXJldHVybiEwO3JldHVybiExfSxpc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49bmV3IGcsaT1uZXcgZyxyPTA7cjxlLnNpemUoKS0xO3IrKylpZihlLmdldENvb3JkaW5hdGUocixuKSxlLmdldENvb3JkaW5hdGUocisxLGkpLCF0aGlzLmlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5KG4saSkpcmV0dXJuITE7cmV0dXJuITB9LGlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMdCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQuZ2V0Q29vcmRpbmF0ZSgpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gZS54PT09dGhpcy5yZWN0RW52LmdldE1pblgoKXx8ZS54PT09dGhpcy5yZWN0RW52LmdldE1heFgoKXx8ZS55PT09dGhpcy5yZWN0RW52LmdldE1pblkoKXx8ZS55PT09dGhpcy5yZWN0RW52LmdldE1heFkoKX19LGNvbnRhaW5zOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlY3RFbnYuY29udGFpbnModC5nZXRFbnZlbG9wZUludGVybmFsKCkpPyF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KTohMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRnJ9fSksRnIuY29udGFpbnM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgRnIodCk7cmV0dXJuIG4uY29udGFpbnMoZSl9LGUoR3IucHJvdG90eXBlLHtpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEModCxlKTtpZighdGhpcy5yZWN0RW52LmludGVyc2VjdHMobikpcmV0dXJuITE7aWYodGhpcy5yZWN0RW52LmludGVyc2VjdHModCkpcmV0dXJuITA7aWYodGhpcy5yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuITA7aWYodC5jb21wYXJlVG8oZSk+MCl7dmFyIGk9dDt0PWUsZT1pfXZhciByPSExO3JldHVybiBlLnk+dC55JiYocj0hMCkscj90aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuZGlhZ0Rvd24wLHRoaXMuZGlhZ0Rvd24xKTp0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuZGlhZ1VwMCx0aGlzLmRpYWdVcDEpLCEhdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR3J9fSksZShxci5wcm90b3R5cGUse2FwcGx5VG86ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKSYmIXRoaXMuX2lzRG9uZTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKG4gaW5zdGFuY2VvZiBmdCl0aGlzLmFwcGx5VG8obik7ZWxzZSBpZih0aGlzLnZpc2l0KG4pLHRoaXMuaXNEb25lKCkpcmV0dXJuIHRoaXMuX2lzRG9uZT0hMCxudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcXJ9fSksZShCci5wcm90b3R5cGUse2ludGVyc2VjdHM6ZnVuY3Rpb24odCl7aWYoIXRoaXMucmVjdEVudi5pbnRlcnNlY3RzKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTt2YXIgZT1uZXcgenIodGhpcy5yZWN0RW52KTtpZihlLmFwcGx5VG8odCksZS5pbnRlcnNlY3RzKCkpcmV0dXJuITA7dmFyIG49bmV3IFZyKHRoaXMucmVjdGFuZ2xlKTtpZihuLmFwcGx5VG8odCksbi5jb250YWluc1BvaW50KCkpcmV0dXJuITA7dmFyIGk9bmV3IGtyKHRoaXMucmVjdGFuZ2xlKTtyZXR1cm4gaS5hcHBseVRvKHQpLCEhaS5pbnRlcnNlY3RzKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJyfX0pLEJyLmludGVyc2VjdHM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgQnIodCk7cmV0dXJuIG4uaW50ZXJzZWN0cyhlKX0saCh6cixxciksZSh6ci5wcm90b3R5cGUse2lzRG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzPT09ITB9LHZpc2l0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiB0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKT90aGlzLnJlY3RFbnYuY29udGFpbnMoZSk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6ZS5nZXRNaW5YKCk+PXRoaXMucmVjdEVudi5nZXRNaW5YKCkmJmUuZ2V0TWF4WCgpPD10aGlzLnJlY3RFbnYuZ2V0TWF4WCgpPyh0aGlzLl9pbnRlcnNlY3RzPSEwLG51bGwpOmUuZ2V0TWluWSgpPj10aGlzLnJlY3RFbnYuZ2V0TWluWSgpJiZlLmdldE1heFkoKTw9dGhpcy5yZWN0RW52LmdldE1heFkoKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTp2b2lkIDA6bnVsbH0saW50ZXJzZWN0czpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6cn19KSxoKFZyLHFyKSxlKFZyLnByb3RvdHlwZSx7aXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnQ9PT0hMH0sdmlzaXQ6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgVHQpKXJldHVybiBudWxsO3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtmb3IodmFyIG49bmV3IGcsaT0wOzQ+aTtpKyspaWYodGhpcy5yZWN0U2VxLmdldENvb3JkaW5hdGUoaSxuKSxlLmNvbnRhaW5zKG4pJiZUbi5jb250YWluc1BvaW50SW5Qb2x5Z29uKG4sdCkpcmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITAsbnVsbH0sY29udGFpbnNQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluc1BvaW50fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWcn19KSxoKGtyLHFyKSxlKGtyLnByb3RvdHlwZSx7aW50ZXJzZWN0czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uPT09ITB9LHZpc2l0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDt2YXIgbj1rbi5nZXRMaW5lcyh0KTt0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKG4pfSxjaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYodGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyhuKSx0aGlzLmhhc0ludGVyc2VjdGlvbilyZXR1cm4gbnVsbH19LGNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49MTtuPGUuc2l6ZSgpO24rKylpZihlLmdldENvb3JkaW5hdGUobi0xLHRoaXMucDApLGUuZ2V0Q29vcmRpbmF0ZShuLHRoaXMucDEpLHRoaXMucmVjdEludGVyc2VjdG9yLmludGVyc2VjdHModGhpcy5wMCx0aGlzLnAxKSlyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb249ITAsbnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga3J9fSksaChZcix0aSksZShZci5wcm90b3R5cGUse2dldEludGVyc2VjdGlvbk1hdHJpeDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWxhdGUuY29tcHV0ZUlNKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFlyfX0pLFlyLmNvdmVycz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb3ZlcnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP3QuaXNSZWN0YW5nbGUoKT8hMDpZci5yZWxhdGUodCxlKS5pc0NvdmVycygpOiExfSxZci5pbnRlcnNlY3RzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP3QuaXNSZWN0YW5nbGUoKT9Cci5pbnRlcnNlY3RzKHQsZSk6ZS5pc1JlY3RhbmdsZSgpP0JyLmludGVyc2VjdHMoZSx0KTpZci5yZWxhdGUodCxlKS5pc0ludGVyc2VjdHMoKTohMX0sWXIudG91Y2hlcz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9Zci5yZWxhdGUodCxlKS5pc1RvdWNoZXModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTohMX0sWXIud2l0aGluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuY29udGFpbnModCl9LFlyLmNvdmVyZWRCeT1mdW5jdGlvbih0LGUpe3JldHVybiBZci5jb3ZlcnMoZSx0KX0sWXIucmVsYXRlPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBZcih0LGUpLGk9bi5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKTtyZXR1cm4gaX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEIpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTtyZXR1cm4gWXIucmVsYXRlV2l0aENoZWNrKHIscykubWF0Y2hlcyhvKX1pZihSKGFyZ3VtZW50c1syXSxWKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEIpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXSxsPWFyZ3VtZW50c1syXSxuPW5ldyBZcihhLHUsbCksaT1uLmdldEludGVyc2VjdGlvbk1hdHJpeCgpO3JldHVybiBpfX19LFlyLm92ZXJsYXBzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP1lyLnJlbGF0ZSh0LGUpLmlzT3ZlcmxhcHModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTohMX0sWXIuZGlzam9pbnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4hdC5pbnRlcnNlY3RzKGUpfSxZci5yZWxhdGVXaXRoQ2hlY2s9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLFlyLnJlbGF0ZSh0LGUpfSxZci5jcm9zc2VzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP1lyLnJlbGF0ZSh0LGUpLmlzQ3Jvc3Nlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpOiExfSxZci5jb250YWlucz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/dC5pc1JlY3RhbmdsZSgpP0ZyLmNvbnRhaW5zKHQsZSk6WXIucmVsYXRlKHQsZSkuaXNDb250YWlucygpOiExfTt2YXIgVG89T2JqZWN0LmZyZWV6ZSh7UmVsYXRlT3A6WXJ9KTtlKFVyLnByb3RvdHlwZSx7ZXh0cmFjdEVsZW1lbnRzOmZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Zm9yKHZhciBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pO3RoaXMuc2tpcEVtcHR5JiZpLmlzRW1wdHkoKXx8ZS5hZGQoaSl9fSxjb21iaW5lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5pbnB1dEdlb21zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3RFbGVtZW50cyhuLHQpfXJldHVybiAwPT09dC5zaXplKCk/bnVsbCE9PXRoaXMuZ2VvbUZhY3Rvcnk/dGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCk6bnVsbDp0aGlzLmdlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFVyfX0pLFVyLmNvbWJpbmU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IFVyKHQpO3JldHVybiBlLmNvbWJpbmUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLGU9bmV3IFVyKFVyLmNyZWF0ZUxpc3QobixpKSk7cmV0dXJuIGUuY29tYmluZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sZT1uZXcgVXIoVXIuY3JlYXRlTGlzdChyLHMsbykpO3JldHVybiBlLmNvbWJpbmUoKX19LFVyLmV4dHJhY3RGYWN0b3J5PWZ1bmN0aW9uKHQpe3JldHVybiB0LmlzRW1wdHkoKT9udWxsOnQuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpfSxVci5jcmVhdGVMaXN0PWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBJO3JldHVybiBuLmFkZCh0KSxuLmFkZChlKSxufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbj1uZXcgSTtyZXR1cm4gbi5hZGQoaSksbi5hZGQociksbi5hZGQocyksbn19LGUoWHIucHJvdG90eXBlLHt1bmlvbjpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgVGUsZT1uZXcgYXQsbj0wO248dGhpcy5wb2ludEdlb20uZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dGhpcy5wb2ludEdlb20uZ2V0R2VvbWV0cnlOKG4pLHI9aS5nZXRDb29yZGluYXRlKCkscz10LmxvY2F0ZShyLHRoaXMub3RoZXJHZW9tKTtzPT09TC5FWFRFUklPUiYmZS5hZGQocil9aWYoMD09PWUuc2l6ZSgpKXJldHVybiB0aGlzLm90aGVyR2VvbTt2YXIgbz1udWxsLGE9SC50b0Nvb3JkaW5hdGVBcnJheShlKTtyZXR1cm4gbz0xPT09YS5sZW5ndGg/dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2ludChhWzBdKTp0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKGEpLFVyLmNvbWJpbmUobyx0aGlzLm90aGVyR2VvbSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhyfX0pLFhyLnVuaW9uPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFhyKHQsZSk7cmV0dXJuIG4udW5pb24oKX0sZShIci5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXstMSE9PXRoaXMuc29ydEluZGV4JiZ0LmdldFNvcnRJbmRleCgpIT09dGhpcy5zb3J0SW5kZXh8fHRoaXMuY29tcHMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltodF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhyfX0pLEhyLmV4dHJhY3Q9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBIci5leHRyYWN0KHQsZSxuZXcgSSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTtyZXR1cm4gbi5nZXRTb3J0SW5kZXgoKT09PWk/ci5hZGQobik6biBpbnN0YW5jZW9mIGZ0JiZuLmFwcGx5KG5ldyBIcihpLHIpKSxyfX0sZShXci5wcm90b3R5cGUse3JlZHVjZVRvR2VvbWV0cmllczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPW51bGw7UihpLHkpP3I9dGhpcy51bmlvblRyZWUoaSk6aSBpbnN0YW5jZW9mIEImJihyPWkpLGUuYWRkKHIpfXJldHVybiBlfSxleHRyYWN0QnlFbnZlbG9wZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPW5ldyBJLHI9MDtyPGUuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIHM9ZS5nZXRHZW9tZXRyeU4ocik7cy5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9pLmFkZChzKTpuLmFkZChzKX1yZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KGkpfSx1bmlvbk9wdGltaXplZDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIW4uaW50ZXJzZWN0cyhpKSl7dmFyIHI9VXIuY29tYmluZSh0LGUpO3JldHVybiByfWlmKHQuZ2V0TnVtR2VvbWV0cmllcygpPD0xJiZlLmdldE51bUdlb21ldHJpZXMoKTw9MSlyZXR1cm4gdGhpcy51bmlvbkFjdHVhbCh0LGUpO3ZhciBzPW4uaW50ZXJzZWN0aW9uKGkpO3JldHVybiB0aGlzLnVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbih0LGUscyl9LHVuaW9uOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuaW5wdXRQb2x5cyl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwidW5pb24oKSBtZXRob2QgY2Fubm90IGJlIGNhbGxlZCB0d2ljZVwiKTtpZih0aGlzLmlucHV0UG9seXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuZ2VvbUZhY3Rvcnk9dGhpcy5pbnB1dFBvbHlzLml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKTtmb3IodmFyIHQ9bmV3IGtlKFdyLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWSksZT10aGlzLmlucHV0UG9seXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3QuaW5zZXJ0KG4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG4pfXRoaXMuaW5wdXRQb2x5cz1udWxsO3ZhciBpPXQuaXRlbXNUcmVlKCkscj10aGlzLnVuaW9uVHJlZShpKTtyZXR1cm4gcn0sYmluYXJ5VW5pb246ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmJpbmFyeVVuaW9uKHQsMCx0LnNpemUoKSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWFyZ3VtZW50c1syXTtpZigxPj1pLW4pe3ZhciByPVdyLmdldEdlb21ldHJ5KGUsbik7cmV0dXJuIHRoaXMudW5pb25TYWZlKHIsbnVsbCl9aWYoaS1uPT09MilyZXR1cm4gdGhpcy51bmlvblNhZmUoV3IuZ2V0R2VvbWV0cnkoZSxuKSxXci5nZXRHZW9tZXRyeShlLG4rMSkpO3ZhciBzPU1hdGgudHJ1bmMoKGkrbikvMikscj10aGlzLmJpbmFyeVVuaW9uKGUsbixzKSxvPXRoaXMuYmluYXJ5VW5pb24oZSxzLGkpO3JldHVybiB0aGlzLnVuaW9uU2FmZShyLG8pfX0scmVwZWF0ZWRVbmlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2U9bnVsbD09PWU/aS5jb3B5KCk6ZS51bmlvbihpKX1yZXR1cm4gZX0sdW5pb25TYWZlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT10P2UuY29weSgpOm51bGw9PT1lP3QuY29weSgpOnRoaXMudW5pb25PcHRpbWl6ZWQodCxlKX0sdW5pb25BY3R1YWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gV3IucmVzdHJpY3RUb1BvbHlnb25zKHQudW5pb24oZSkpfSx1bmlvblRyZWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZWR1Y2VUb0dlb21ldHJpZXModCksbj10aGlzLmJpbmFyeVVuaW9uKGUpO3JldHVybiBufSx1bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBJLHI9dGhpcy5leHRyYWN0QnlFbnZlbG9wZShuLHQsaSkscz10aGlzLmV4dHJhY3RCeUVudmVsb3BlKG4sZSxpKSxvPXRoaXMudW5pb25BY3R1YWwocixzKTtpLmFkZChvKTt2YXIgYT1Vci5jb21iaW5lKGkpO3JldHVybiBhfSxidWZmZXJVbmlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10LmdldCgwKS5nZXRGYWN0b3J5KCksbj1lLmJ1aWxkR2VvbWV0cnkodCksaT1uLmJ1ZmZlcigwKTtyZXR1cm4gaX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLGU9ci5nZXRGYWN0b3J5KCksbj1lLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihbcixzXSksaT1uLmJ1ZmZlcigwKTtyZXR1cm4gaX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdyfX0pLFdyLnJlc3RyaWN0VG9Qb2x5Z29ucz1mdW5jdGlvbih0KXtpZihSKHQsUnQpKXJldHVybiB0O3ZhciBlPW9yLmdldFBvbHlnb25zKHQpO3JldHVybiAxPT09ZS5zaXplKCk/ZS5nZXQoMCk6dC5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKGllLnRvUG9seWdvbkFycmF5KGUpKX0sV3IuZ2V0R2VvbWV0cnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT49dC5zaXplKCk/bnVsbDp0LmdldChlKX0sV3IudW5pb249ZnVuY3Rpb24odCl7dmFyIGU9bmV3IFdyKHQpO3JldHVybiBlLnVuaW9uKCl9LFdyLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWT00LGUoanIucHJvdG90eXBlLHt1bmlvbk5vT3B0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2VvbUZhY3QuY3JlYXRlUG9pbnQoKTtyZXR1cm4gc2kub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LHVuaW9uV2l0aE51bGw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PWU/dDpudWxsPT09dD9lOnQudW5pb24oZSl9LGV4dHJhY3Q6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5leHRyYWN0KG4pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgaT1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuZ2VvbUZhY3QmJih0aGlzLmdlb21GYWN0PWkuZ2V0RmFjdG9yeSgpKSxIci5leHRyYWN0KGksQi5TT1JUSU5ERVhfUE9MWUdPTix0aGlzLnBvbHlnb25zKSxIci5leHRyYWN0KGksQi5TT1JUSU5ERVhfTElORVNUUklORyx0aGlzLmxpbmVzKSxIci5leHRyYWN0KGksQi5TT1JUSU5ERVhfUE9JTlQsdGhpcy5wb2ludHMpfX0sdW5pb246ZnVuY3Rpb24gdCgpe2lmKG51bGw9PT10aGlzLmdlb21GYWN0KXJldHVybiBudWxsO3ZhciBlPW51bGw7aWYodGhpcy5wb2ludHMuc2l6ZSgpPjApe3ZhciBuPXRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLnBvaW50cyk7ZT10aGlzLnVuaW9uTm9PcHQobil9dmFyIGk9bnVsbDtpZih0aGlzLmxpbmVzLnNpemUoKT4wKXt2YXIgcj10aGlzLmdlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5saW5lcyk7aT10aGlzLnVuaW9uTm9PcHQocil9dmFyIHM9bnVsbDt0aGlzLnBvbHlnb25zLnNpemUoKT4wJiYocz1Xci51bmlvbih0aGlzLnBvbHlnb25zKSk7dmFyIG89dGhpcy51bmlvbldpdGhOdWxsKGkscyksdD1udWxsO3JldHVybiB0PW51bGw9PT1lP286bnVsbD09PW8/ZTpYci51bmlvbihlLG8pLG51bGw9PT10P3RoaXMuZ2VvbUZhY3QuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ganJ9fSksanIudW5pb249ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBqcih0KTtyZXR1cm4gZS51bmlvbigpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIG49YXJndW1lbnRzWzBdLGU9bmV3IGpyKG4pO3JldHVybiBlLnVuaW9uKCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxlPW5ldyBqcihpLHIpO3JldHVybiBlLnVuaW9uKCl9fTt2YXIgUG89T2JqZWN0LmZyZWV6ZSh7VW5hcnlVbmlvbk9wOmpyfSk7ZShLci5wcm90b3R5cGUse3Zpc2l0SW50ZXJpb3JSaW5nOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRDb29yZGluYXRlcygpLGk9blswXSxyPUtyLmZpbmREaWZmZXJlbnRQb2ludChuLGkpLHM9ZS5maW5kRWRnZUluU2FtZURpcmVjdGlvbihpLHIpLG89ZS5maW5kRWRnZUVuZChzKSxhPW51bGw7by5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsY24uUklHSFQpPT09TC5JTlRFUklPUj9hPW86by5nZXRTeW0oKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsY24uUklHSFQpPT09TC5JTlRFUklPUiYmKGE9by5nZXRTeW0oKSksZi5pc1RydWUobnVsbCE9PWEsXCJ1bmFibGUgdG8gZmluZCBkaXJFZGdlIHdpdGggSW50ZXJpb3Igb24gUkhTXCIpLHRoaXMudmlzaXRMaW5rZWREaXJlY3RlZEVkZ2VzKGEpfSx2aXNpdFNoZWxsSW50ZXJpb3JzOmZ1bmN0aW9uKHQsZSl7aWYodCBpbnN0YW5jZW9mIFR0KXt2YXIgbj10O3RoaXMudmlzaXRJbnRlcmlvclJpbmcobi5nZXRFeHRlcmlvclJpbmcoKSxlKX1pZih0IGluc3RhbmNlb2YgT3QpZm9yKHZhciBpPXQscj0wO3I8aS5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXt2YXIgbj1pLmdldEdlb21ldHJ5TihyKTt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSl9fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzY29ubmVjdGVkUmluZ2Nvb3JkfSxzZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsY24uUklHSFQpPT09TC5JTlRFUklPUiYmbi5zZXRJblJlc3VsdCghMCl9fSx2aXNpdExpbmtlZERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24odCl7dmFyIGU9dCxuPXQ7ZG8gZi5pc1RydWUobnVsbCE9PW4sXCJmb3VuZCBudWxsIERpcmVjdGVkIEVkZ2VcIiksbi5zZXRWaXNpdGVkKCEwKSxuPW4uZ2V0TmV4dCgpO3doaWxlKG4hPT1lKX0sYnVpbGRFZGdlUmluZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5pc0luUmVzdWx0KCkmJm51bGw9PT1pLmdldEVkZ2VSaW5nKCkpe3ZhciByPW5ldyB2bihpLHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtyLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO3ZhciBzPXIuYnVpbGRNaW5pbWFsUmluZ3MoKTtlLmFkZEFsbChzKX19cmV0dXJuIGV9LGhhc1VudmlzaXRlZFNoZWxsRWRnZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuc2l6ZSgpO2UrKyl7dmFyIG49dC5nZXQoZSk7aWYoIW4uaXNIb2xlKCkpe3ZhciBpPW4uZ2V0RWRnZXMoKSxyPWkuZ2V0KDApO2lmKHIuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKT09PUwuSU5URVJJT1IpZm9yKHZhciBzPTA7czxpLnNpemUoKTtzKyspaWYocj1pLmdldChzKSxcbiFyLmlzVmlzaXRlZCgpKXJldHVybiB0aGlzLmRpc2Nvbm5lY3RlZFJpbmdjb29yZD1yLmdldENvb3JkaW5hdGUoKSwhMH19cmV0dXJuITF9LGlzSW50ZXJpb3JzQ29ubmVjdGVkOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEk7dGhpcy5nZW9tR3JhcGguY29tcHV0ZVNwbGl0RWRnZXModCk7dmFyIGU9bmV3IENuKG5ldyBPbik7ZS5hZGRFZGdlcyh0KSx0aGlzLnNldEludGVyaW9yRWRnZXNJblJlc3VsdChlKSxlLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCk7dmFyIG49dGhpcy5idWlsZEVkZ2VSaW5ncyhlLmdldEVkZ2VFbmRzKCkpO3JldHVybiB0aGlzLnZpc2l0U2hlbGxJbnRlcmlvcnModGhpcy5nZW9tR3JhcGguZ2V0R2VvbWV0cnkoKSxlKSwhdGhpcy5oYXNVbnZpc2l0ZWRTaGVsbEVkZ2Uobil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtyfX0pLEtyLmZpbmREaWZmZXJlbnRQb2ludD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlKSlyZXR1cm4gdFtuXTtyZXR1cm4gbnVsbH0sZShaci5wcm90b3R5cGUse2hhc0NoaWxkcmVuOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7Mj50O3QrKylpZihudWxsIT09dGhpcy5zdWJub2RlW3RdKXJldHVybiEwO3JldHVybiExfSxpc1BydW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuISh0aGlzLmhhc0NoaWxkcmVuKCl8fHRoaXMuaGFzSXRlbXMoKSl9LGFkZEFsbEl0ZW1zOmZ1bmN0aW9uKHQpe3QuYWRkQWxsKHRoaXMuaXRlbXMpO2Zvcih2YXIgZT0wOzI+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmdGhpcy5zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fSxzaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzI+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHQrPXRoaXMuc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0K3RoaXMuaXRlbXMuc2l6ZSgpfSxhZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZzpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dHx8dGhpcy5pc1NlYXJjaE1hdGNoKHQpPyhlLmFkZEFsbCh0aGlzLml0ZW1zKSxudWxsIT09dGhpcy5zdWJub2RlWzBdJiZ0aGlzLnN1Ym5vZGVbMF0uYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKSx2b2lkKG51bGwhPT10aGlzLnN1Ym5vZGVbMV0mJnRoaXMuc3Vibm9kZVsxXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpKSk6bnVsbH0saGFzSXRlbXM6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pdGVtcy5pc0VtcHR5KCl9LHJlbW92ZTpmdW5jdGlvbih0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuITE7Zm9yKHZhciBuPSExLGk9MDsyPmk7aSsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbaV0mJihuPXRoaXMuc3Vibm9kZVtpXS5yZW1vdmUodCxlKSkpe3RoaXMuc3Vibm9kZVtpXS5pc1BydW5hYmxlKCkmJih0aGlzLnN1Ym5vZGVbaV09bnVsbCk7YnJlYWt9cmV0dXJuIG4/bjpuPXRoaXMuaXRlbXMucmVtb3ZlKGUpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxkZXB0aDpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDsyPmU7ZSsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXS5kZXB0aCgpO24+dCYmKHQ9bil9cmV0dXJuIHQrMX0sbm9kZVNpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7Mj5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLm5vZGVTaXplKCkpO3JldHVybiB0KzF9LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWnJ9fSksWnIuZ2V0U3Vibm9kZUluZGV4PWZ1bmN0aW9uKHQsZSl7dmFyIG49LTE7cmV0dXJuIHQubWluPj1lJiYobj0xKSx0Lm1heDw9ZSYmKG49MCksbn0sZShRci5wcm90b3R5cGUse2V4cGFuZFRvSW5jbHVkZTpmdW5jdGlvbih0KXt0Lm1heD50aGlzLm1heCYmKHRoaXMubWF4PXQubWF4KSx0Lm1pbjx0aGlzLm1pbiYmKHRoaXMubWluPXQubWluKX0sZ2V0V2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXgtdGhpcy5taW59LG92ZXJsYXBzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5vdmVybGFwcyh0Lm1pbix0Lm1heCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4hKHRoaXMubWluPm58fHRoaXMubWF4PGUpfX0sZ2V0TWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWlufSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW1wiK3RoaXMubWluK1wiLCBcIit0aGlzLm1heCtcIl1cIn0sY29udGFpbnM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBRcil7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvbnRhaW5zKHQubWluLHQubWF4KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIGU+PXRoaXMubWluJiZlPD10aGlzLm1heH19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiBuPj10aGlzLm1pbiYmaTw9dGhpcy5tYXh9fSxpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5taW49dCx0aGlzLm1heD1lLHQ+ZSYmKHRoaXMubWluPWUsdGhpcy5tYXg9dCl9LGdldE1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUXJ9fSksZShKci5wcm90b3R5cGUse2dldEludGVydmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJ2YWx9LGdldExldmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGV2ZWx9LGNvbXB1dGVLZXk6ZnVuY3Rpb24odCl7Zm9yKHRoaXMubGV2ZWw9SnIuY29tcHV0ZUxldmVsKHQpLHRoaXMuaW50ZXJ2YWw9bmV3IFFyLHRoaXMuY29tcHV0ZUludGVydmFsKHRoaXMubGV2ZWwsdCk7IXRoaXMuaW50ZXJ2YWwuY29udGFpbnModCk7KXRoaXMubGV2ZWwrPTEsdGhpcy5jb21wdXRlSW50ZXJ2YWwodGhpcy5sZXZlbCx0KX0sY29tcHV0ZUludGVydmFsOmZ1bmN0aW9uKHQsZSl7dmFyIG49Q2kucG93ZXJPZjIodCk7dGhpcy5wdD1NYXRoLmZsb29yKGUuZ2V0TWluKCkvbikqbix0aGlzLmludGVydmFsLmluaXQodGhpcy5wdCx0aGlzLnB0K24pfSxnZXRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBKcn19KSxKci5jb21wdXRlTGV2ZWw9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpLG49Q2kuZXhwb25lbnQoZSkrMTtyZXR1cm4gbn0saCgkcixaciksZSgkci5wcm90b3R5cGUse2dldEludGVydmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJ2YWx9LGZpbmQ6ZnVuY3Rpb24odCl7dmFyIGU9WnIuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmUpO2lmKC0xPT09ZSlyZXR1cm4gdGhpcztpZihudWxsIT09dGhpcy5zdWJub2RlW2VdKXt2YXIgbj10aGlzLnN1Ym5vZGVbZV07cmV0dXJuIG4uZmluZCh0KX1yZXR1cm4gdGhpc30saW5zZXJ0OmZ1bmN0aW9uKHQpe2YuaXNUcnVlKG51bGw9PT10aGlzLmludGVydmFsfHx0aGlzLmludGVydmFsLmNvbnRhaW5zKHQuaW50ZXJ2YWwpKTt2YXIgZT1aci5nZXRTdWJub2RlSW5kZXgodC5pbnRlcnZhbCx0aGlzLmNlbnRyZSk7aWYodC5sZXZlbD09PXRoaXMubGV2ZWwtMSl0aGlzLnN1Ym5vZGVbZV09dDtlbHNle3ZhciBuPXRoaXMuY3JlYXRlU3Vibm9kZShlKTtuLmluc2VydCh0KSx0aGlzLnN1Ym5vZGVbZV09bn19LGlzU2VhcmNoTWF0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuIHQub3ZlcmxhcHModGhpcy5pbnRlcnZhbCl9LGdldFN1Ym5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PT10aGlzLnN1Ym5vZGVbdF0mJih0aGlzLnN1Ym5vZGVbdF09dGhpcy5jcmVhdGVTdWJub2RlKHQpKSx0aGlzLnN1Ym5vZGVbdF19LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9WnIuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmUpO2lmKC0xIT09ZSl7dmFyIG49dGhpcy5nZXRTdWJub2RlKGUpO3JldHVybiBuLmdldE5vZGUodCl9cmV0dXJuIHRoaXN9LGNyZWF0ZVN1Ym5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9MCxuPTA7c3dpdGNoKHQpe2Nhc2UgMDplPXRoaXMuaW50ZXJ2YWwuZ2V0TWluKCksbj10aGlzLmNlbnRyZTticmVhaztjYXNlIDE6ZT10aGlzLmNlbnRyZSxuPXRoaXMuaW50ZXJ2YWwuZ2V0TWF4KCl9dmFyIGk9bmV3IFFyKGUsbikscj1uZXcgJHIoaSx0aGlzLmxldmVsLTEpO3JldHVybiByfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiAkcn19KSwkci5jcmVhdGVOb2RlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBKcih0KSxuPW5ldyAkcihlLmdldEludGVydmFsKCksZS5nZXRMZXZlbCgpKTtyZXR1cm4gbn0sJHIuY3JlYXRlRXhwYW5kZWQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgUXIoZSk7bnVsbCE9PXQmJm4uZXhwYW5kVG9JbmNsdWRlKHQuaW50ZXJ2YWwpO3ZhciBpPSRyLmNyZWF0ZU5vZGUobik7cmV0dXJuIG51bGwhPT10JiZpLmluc2VydCh0KSxpfSxoKHRzLFpyKSxlKHRzLnByb3RvdHlwZSx7aW5zZXJ0OmZ1bmN0aW9uKHQsZSl7dmFyIG49WnIuZ2V0U3Vibm9kZUluZGV4KHQsdHMub3JpZ2luKTtpZigtMT09PW4pcmV0dXJuIHRoaXMuYWRkKGUpLG51bGw7dmFyIGk9dGhpcy5zdWJub2RlW25dO2lmKG51bGw9PT1pfHwhaS5nZXRJbnRlcnZhbCgpLmNvbnRhaW5zKHQpKXt2YXIgcj0kci5jcmVhdGVFeHBhbmRlZChpLHQpO3RoaXMuc3Vibm9kZVtuXT1yfXRoaXMuaW5zZXJ0Q29udGFpbmVkKHRoaXMuc3Vibm9kZVtuXSx0LGUpfSxpc1NlYXJjaE1hdGNoOmZ1bmN0aW9uKHQpe3JldHVybiEwfSxpbnNlcnRDb250YWluZWQ6ZnVuY3Rpb24odCxlLG4pe2YuaXNUcnVlKHQuZ2V0SW50ZXJ2YWwoKS5jb250YWlucyhlKSk7dmFyIGk9UmkuaXNaZXJvV2lkdGgoZS5nZXRNaW4oKSxlLmdldE1heCgpKSxyPW51bGw7cj1pP3QuZmluZChlKTp0LmdldE5vZGUoZSksci5hZGQobil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRzfX0pLHRzLm9yaWdpbj0wLGUoZXMucHJvdG90eXBlLHtzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290LnNpemUoKTowfSxpbnNlcnQ6ZnVuY3Rpb24odCxlKXt0aGlzLmNvbGxlY3RTdGF0cyh0KTt2YXIgbj1lcy5lbnN1cmVFeHRlbnQodCx0aGlzLm1pbkV4dGVudCk7dGhpcy5yb290Lmluc2VydChuLGUpfSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMucXVlcnkobmV3IFFyKHQsdCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUXIpe3ZhciBlPWFyZ3VtZW50c1swXSxuPW5ldyBJO3JldHVybiB0aGlzLnF1ZXJ5KGUsbiksbn19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3RoaXMucm9vdC5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyhpLHIpfX0saXRlcmF0b3I6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTtyZXR1cm4gdGhpcy5yb290LmFkZEFsbEl0ZW1zKHQpLHQuaXRlcmF0b3IoKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZXMuZW5zdXJlRXh0ZW50KHQsdGhpcy5taW5FeHRlbnQpO3JldHVybiB0aGlzLnJvb3QucmVtb3ZlKG4sZSl9LGNvbGxlY3RTdGF0czpmdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCk7ZTx0aGlzLm1pbkV4dGVudCYmZT4wJiYodGhpcy5taW5FeHRlbnQ9ZSl9LGRlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290LmRlcHRoKCk6MH0sbm9kZVNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3Qubm9kZVNpemUoKTowfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlc319KSxlcy5lbnN1cmVFeHRlbnQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldE1pbigpLGk9dC5nZXRNYXgoKTtyZXR1cm4gbiE9PWk/dDoobj09PWkmJihuLT1lLzIsaT1uK2UvMiksbmV3IFFyKG4saSkpfSxlKG5zLnByb3RvdHlwZSx7aXNJbnNpZGU6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBuc319KSxlKGlzLnByb3RvdHlwZSx7dGVzdExpbmVTZWdtZW50OmZ1bmN0aW9uKHQsZSl7dmFyIG49bnVsbCxpPW51bGwscj1udWxsLHM9bnVsbCxvPW51bGwsYT1lLnAwLHU9ZS5wMTtpPWEueC10Lngscj1hLnktdC55LHM9dS54LXQueCxvPXUueS10LnksKHI+MCYmMD49b3x8bz4wJiYwPj1yKSYmKG49dWUuc2lnbk9mRGV0MngyKGkscixzLG8pLyhvLXIpLG4+MCYmdGhpcy5jcm9zc2luZ3MrKyl9LGJ1aWxkSW5kZXg6ZnVuY3Rpb24oKXt0aGlzLnRyZWU9bmV3IGVzO2Zvcih2YXIgdD1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHRoaXMucmluZy5nZXRDb29yZGluYXRlcygpKSxlPSRlLmdldENoYWlucyh0KSxuPTA7bjxlLnNpemUoKTtuKyspe3ZhciBpPWUuZ2V0KG4pLHI9aS5nZXRFbnZlbG9wZSgpO3RoaXMuaW50ZXJ2YWwubWluPXIuZ2V0TWluWSgpLHRoaXMuaW50ZXJ2YWwubWF4PXIuZ2V0TWF4WSgpLHRoaXMudHJlZS5pbnNlcnQodGhpcy5pbnRlcnZhbCxpKX19LHRlc3RNb25vdG9uZUNoYWluOmZ1bmN0aW9uKHQsZSxuKXtuLnNlbGVjdCh0LGUpfSxpc0luc2lkZTpmdW5jdGlvbih0KXt0aGlzLmNyb3NzaW5ncz0wO3ZhciBlPW5ldyBDKHIuTkVHQVRJVkVfSU5GSU5JVFksci5QT1NJVElWRV9JTkZJTklUWSx0LnksdC55KTt0aGlzLmludGVydmFsLm1pbj10LnksdGhpcy5pbnRlcnZhbC5tYXg9dC55O2Zvcih2YXIgbj10aGlzLnRyZWUucXVlcnkodGhpcy5pbnRlcnZhbCksaT1uZXcgcnModGhpcyx0KSxzPW4uaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpO3RoaXMudGVzdE1vbm90b25lQ2hhaW4oZSxpLG8pfXJldHVybiB0aGlzLmNyb3NzaW5ncyUyPT09MX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bbnNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBpc319KSxoKHJzLHRyKSxlKHJzLnByb3RvdHlwZSx7c2VsZWN0OmZ1bmN0aW9uKCl7aWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRyLnByb3RvdHlwZS5zZWxlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1jcC50ZXN0TGluZVNlZ21lbnQodGhpcy5wLHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiByc319KSxpcy5NQ1NlbGVjdGVyPXJzLGUoc3MucHJvdG90eXBlLHtpbnNlcnRFZGdlRW5kczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5ub2Rlcy5hZGQobil9fSxnZXROb2RlSXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlcy5pdGVyYXRvcigpfSxjb3B5Tm9kZXNBbmRMYWJlbHM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXROb2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9dGhpcy5ub2Rlcy5hZGROb2RlKGkuZ2V0Q29vcmRpbmF0ZSgpKTtyLnNldExhYmVsKGUsaS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGUpKX19LGJ1aWxkOmZ1bmN0aW9uKHQpe3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQsMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHModCwwKTt2YXIgZT1uZXcgYnIsbj1lLmNvbXB1dGVFZGdlRW5kcyh0LmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKG4pfSxjb21wdXRlSW50ZXJzZWN0aW9uTm9kZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspZm9yKHZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGUpLHM9aS5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKSxhPXRoaXMubm9kZXMuYWRkTm9kZShvLmNvb3JkKTtyPT09TC5CT1VOREFSWT9hLnNldExhYmVsQm91bmRhcnkoZSk6YS5nZXRMYWJlbCgpLmlzTnVsbChlKSYmYS5zZXRMYWJlbChlLEwuSU5URVJJT1IpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gc3N9fSksZShvcy5wcm90b3R5cGUse2lzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVHcmFwaC5nZXROb2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2lmKCFlLmdldEVkZ2VzKCkuaXNBcmVhTGFiZWxzQ29uc2lzdGVudCh0aGlzLmdlb21HcmFwaCkpcmV0dXJuIHRoaXMuaW52YWxpZFBvaW50PWUuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKSwhMX1yZXR1cm4hMH0sZ2V0SW52YWxpZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52YWxpZFBvaW50fSxoYXNEdXBsaWNhdGVSaW5nczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVHcmFwaC5nZXROb2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspZm9yKHZhciBlPXQubmV4dCgpLG49ZS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmdldEVkZ2VFbmRzKCkuc2l6ZSgpPjEpcmV0dXJuIHRoaXMuaW52YWxpZFBvaW50PWkuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGUoMCksITB9cmV0dXJuITF9LGlzTm9kZUNvbnNpc3RlbnRBcmVhOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZW9tR3JhcGguY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCEwLCEwKTtyZXR1cm4gdC5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5pbnZhbGlkUG9pbnQ9dC5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKToodGhpcy5ub2RlR3JhcGguYnVpbGQodGhpcy5nZW9tR3JhcGgpLHRoaXMuaXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50KCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvc319KSxlKGFzLnByb3RvdHlwZSx7YnVpbGRJbmRleDpmdW5jdGlvbigpe3RoaXMuaW5kZXg9bmV3IGtlO2Zvcih2YXIgdD0wO3Q8dGhpcy5yaW5ncy5zaXplKCk7dCsrKXt2YXIgZT10aGlzLnJpbmdzLmdldCh0KSxuPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3RoaXMuaW5kZXguaW5zZXJ0KG4sZSl9fSxnZXROZXN0ZWRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5lc3RlZFB0fSxpc05vbk5lc3RlZDpmdW5jdGlvbigpe3RoaXMuYnVpbGRJbmRleCgpO2Zvcih2YXIgdD0wO3Q8dGhpcy5yaW5ncy5zaXplKCk7dCsrKWZvcih2YXIgZT10aGlzLnJpbmdzLmdldCh0KSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKSxpPXRoaXMuaW5kZXgucXVlcnkoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpLHI9MDtyPGkuc2l6ZSgpO3IrKyl7dmFyIHM9aS5nZXQociksbz1zLmdldENvb3JkaW5hdGVzKCk7aWYoZSE9PXMmJmUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMocy5nZXRFbnZlbG9wZUludGVybmFsKCkpKXt2YXIgYT1scy5maW5kUHROb3ROb2RlKG4scyx0aGlzLmdyYXBoKTtpZihudWxsIT09YSl7dmFyIHU9aGUuaXNQb2ludEluUmluZyhhLG8pO2lmKHUpcmV0dXJuIHRoaXMubmVzdGVkUHQ9YSwhMX19fXJldHVybiEwfSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5yaW5ncy5hZGQodCksdGhpcy50b3RhbEVudi5leHBhbmRUb0luY2x1ZGUodC5nZXRFbnZlbG9wZUludGVybmFsKCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhc319KSxlKHVzLnByb3RvdHlwZSx7Z2V0RXJyb3JUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXJyb3JUeXBlfSxnZXRNZXNzYWdlOmZ1bmN0aW9uKCl7cmV0dXJuIHVzLmVyck1zZ1t0aGlzLmVycm9yVHlwZV19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1cIlwiO3JldHVybiBudWxsIT09dGhpcy5wdCYmKHQ9XCIgYXQgb3IgbmVhciBwb2ludCBcIit0aGlzLnB0KSx0aGlzLmdldE1lc3NhZ2UoKSt0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB1c319KSx1cy5FUlJPUj0wLHVzLlJFUEVBVEVEX1BPSU5UPTEsdXMuSE9MRV9PVVRTSURFX1NIRUxMPTIsdXMuTkVTVEVEX0hPTEVTPTMsdXMuRElTQ09OTkVDVEVEX0lOVEVSSU9SPTQsdXMuU0VMRl9JTlRFUlNFQ1RJT049NSx1cy5SSU5HX1NFTEZfSU5URVJTRUNUSU9OPTYsdXMuTkVTVEVEX1NIRUxMUz03LHVzLkRVUExJQ0FURV9SSU5HUz04LHVzLlRPT19GRVdfUE9JTlRTPTksdXMuSU5WQUxJRF9DT09SRElOQVRFPTEwLHVzLlJJTkdfTk9UX0NMT1NFRD0xMSx1cy5lcnJNc2c9W1wiVG9wb2xvZ3kgVmFsaWRhdGlvbiBFcnJvclwiLFwiUmVwZWF0ZWQgUG9pbnRcIixcIkhvbGUgbGllcyBvdXRzaWRlIHNoZWxsXCIsXCJIb2xlcyBhcmUgbmVzdGVkXCIsXCJJbnRlcmlvciBpcyBkaXNjb25uZWN0ZWRcIixcIlNlbGYtaW50ZXJzZWN0aW9uXCIsXCJSaW5nIFNlbGYtaW50ZXJzZWN0aW9uXCIsXCJOZXN0ZWQgc2hlbGxzXCIsXCJEdXBsaWNhdGUgUmluZ3NcIixcIlRvbyBmZXcgZGlzdGluY3QgcG9pbnRzIGluIGdlb21ldHJ5IGNvbXBvbmVudFwiLFwiSW52YWxpZCBDb29yZGluYXRlXCIsXCJSaW5nIGlzIG5vdCBjbG9zZWRcIl0sZShscy5wcm90b3R5cGUse2NoZWNrSW52YWxpZENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIWxzLmlzVmFsaWQodFtlXSkpcmV0dXJuIHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLklOVkFMSURfQ09PUkRJTkFURSx0W2VdKSxudWxsfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCl7dmFyIG49YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobi5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtmb3IodmFyIGU9MDtlPG4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobi5nZXRJbnRlcmlvclJpbmdOKGUpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfX0sY2hlY2tIb2xlc05vdE5lc3RlZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgYXMoZSksaT0wO2k8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtpKyspe3ZhciByPXQuZ2V0SW50ZXJpb3JSaW5nTihpKTtuLmFkZChyKX12YXIgcz1uLmlzTm9uTmVzdGVkKCk7c3x8KHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLk5FU1RFRF9IT0xFUyxuLmdldE5lc3RlZFBvaW50KCkpKX0sY2hlY2tDb25zaXN0ZW50QXJlYTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgb3ModCksbj1lLmlzTm9kZUNvbnNpc3RlbnRBcmVhKCk7cmV0dXJuIG4/dm9pZChlLmhhc0R1cGxpY2F0ZVJpbmdzKCkmJih0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5EVVBMSUNBVEVfUklOR1MsZS5nZXRJbnZhbGlkUG9pbnQoKSkpKToodGhpcy52YWxpZEVycj1uZXcgdXModXMuU0VMRl9JTlRFUlNFQ1RJT04sZS5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbCl9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMucGFyZW50R2VvbWV0cnkpLG51bGw9PT10aGlzLnZhbGlkRXJyfSxjaGVja1NoZWxsSW5zaWRlSG9sZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRDb29yZGluYXRlcygpLHI9ZS5nZXRDb29yZGluYXRlcygpLHM9bHMuZmluZFB0Tm90Tm9kZShpLGUsbik7aWYobnVsbCE9PXMpe3ZhciBvPWhlLmlzUG9pbnRJblJpbmcocyxyKTtpZighbylyZXR1cm4gc312YXIgYT1scy5maW5kUHROb3ROb2RlKHIsdCxuKTtpZihudWxsIT09YSl7dmFyIHU9aGUuaXNQb2ludEluUmluZyhhLGkpO3JldHVybiB1P2E6bnVsbH1yZXR1cm4gZi5zaG91bGROZXZlclJlYWNoSGVyZShcInBvaW50cyBpbiBzaGVsbCBhbmQgaG9sZSBhcHBlYXIgdG8gYmUgZXF1YWxcIiksbnVsbH0sY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nKG4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9fSxjaGVja0Nvbm5lY3RlZEludGVyaW9yczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgS3IodCk7ZS5pc0ludGVyaW9yc0Nvbm5lY3RlZCgpfHwodGhpcy52YWxpZEVycj1uZXcgdXModXMuRElTQ09OTkVDVEVEX0lOVEVSSU9SLGUuZ2V0Q29vcmRpbmF0ZSgpKSl9LGNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IGF0LG49ITAsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtpZihuKW49ITE7ZWxzZXtpZihlLmNvbnRhaW5zKHIuY29vcmQpKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5SSU5HX1NFTEZfSU5URVJTRUNUSU9OLHIuY29vcmQpLG51bGw7ZS5hZGQoci5jb29yZCl9fX0sY2hlY2tIb2xlc0luU2hlbGw6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRFeHRlcmlvclJpbmcoKSxpPW5ldyBpcyhuKSxyPTA7cjx0LmdldE51bUludGVyaW9yUmluZygpO3IrKyl7dmFyIHM9dC5nZXRJbnRlcmlvclJpbmdOKHIpLG89bHMuZmluZFB0Tm90Tm9kZShzLmdldENvb3JkaW5hdGVzKCksbixlKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDt2YXIgYT0haS5pc0luc2lkZShvKTtpZihhKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5IT0xFX09VVFNJREVfU0hFTEwsbyksbnVsbH19LGNoZWNrVG9vRmV3UG9pbnRzOmZ1bmN0aW9uKHQpe3JldHVybiB0Lmhhc1Rvb0Zld1BvaW50cygpPyh0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5UT09fRkVXX1BPSU5UUyx0LmdldEludmFsaWRQb2ludCgpKSxudWxsKTp2b2lkIDB9LGdldFZhbGlkYXRpb25FcnJvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5wYXJlbnRHZW9tZXRyeSksdGhpcy52YWxpZEVycn0sY2hlY2tWYWxpZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTHQpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFB0KXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhlLmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCl7dmFyIG49YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobi5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyhuKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt2YXIgaT1uZXcgJG4oMCxuKTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3ZhciByPW5ldyBhZTtpLmNvbXB1dGVTZWxmTm9kZXMociwhMCwhMCksdGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIHM9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMocy5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt2YXIgaT1uZXcgJG4oMCxzKTt0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCl7dmFyIG89YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobyksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmdzKG8pLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3ZhciBpPW5ldyAkbigwLG8pO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0NvbnNpc3RlbnRBcmVhKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLmlzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQmJih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwobyxpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQobyxpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt0aGlzLmNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPdCl7Zm9yKHZhciBhPWFyZ3VtZW50c1swXSx1PTA7dTxhLmdldE51bUdlb21ldHJpZXMoKTt1Kyspe3ZhciBsPWEuZ2V0R2VvbWV0cnlOKHUpO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobCksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmdzKGwpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfXZhciBpPW5ldyAkbigwLGEpO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0NvbnNpc3RlbnRBcmVhKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLmlzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQmJih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpKXJldHVybiBudWxsO2Zvcih2YXIgdT0wO3U8YS5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgbD1hLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrSG9sZXNJblNoZWxsKGwsaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9Zm9yKHZhciB1PTA7dTxhLmdldE51bUdlb21ldHJpZXMoKTt1Kyspe3ZhciBsPWEuZ2V0R2VvbWV0cnlOKHUpO2lmKHRoaXMuY2hlY2tIb2xlc05vdE5lc3RlZChsLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfWlmKHRoaXMuY2hlY2tTaGVsbHNOb3ROZXN0ZWQoYSxpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt0aGlzLmNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmdClmb3IodmFyIGg9YXJndW1lbnRzWzBdLHU9MDt1PGguZ2V0TnVtR2VvbWV0cmllcygpO3UrKyl7dmFyIGM9aC5nZXRHZW9tZXRyeU4odSk7aWYodGhpcy5jaGVja1ZhbGlkKGMpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgZj1hcmd1bWVudHNbMF07aWYodGhpcy52YWxpZEVycj1udWxsLGYuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKGYgaW5zdGFuY2VvZiBMdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgUHQpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIGJ0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBTdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgVHQpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIE90KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNle2lmKCEoZiBpbnN0YW5jZW9mIGZ0KSl0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oZi5nZXRDbGFzcygpLmdldE5hbWUoKSk7dGhpcy5jaGVja1ZhbGlkKGYpfX19LHNldFNlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkOmZ1bmN0aW9uKHQpe3RoaXMuaXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD10fSxjaGVja1NoZWxsTm90TmVzdGVkOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldENvb3JkaW5hdGVzKCkscj1lLmdldEV4dGVyaW9yUmluZygpLHM9ci5nZXRDb29yZGluYXRlcygpLG89bHMuZmluZFB0Tm90Tm9kZShpLHIsbik7aWYobnVsbD09PW8pcmV0dXJuIG51bGw7dmFyIGE9aGUuaXNQb2ludEluUmluZyhvLHMpO2lmKCFhKXJldHVybiBudWxsO2lmKGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk8PTApcmV0dXJuIHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLk5FU1RFRF9TSEVMTFMsbyksbnVsbDtmb3IodmFyIHU9bnVsbCxsPTA7bDxlLmdldE51bUludGVyaW9yUmluZygpO2wrKyl7dmFyIGg9ZS5nZXRJbnRlcmlvclJpbmdOKGwpO2lmKHU9dGhpcy5jaGVja1NoZWxsSW5zaWRlSG9sZSh0LGgsbiksbnVsbD09PXUpcmV0dXJuIG51bGx9dGhpcy52YWxpZEVycj1uZXcgdXModXMuTkVTVEVEX1NIRUxMUyx1KX0sY2hlY2tDbG9zZWRSaW5nczpmdW5jdGlvbih0KXtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0LmdldEV4dGVyaW9yUmluZygpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihlKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9LGNoZWNrQ2xvc2VkUmluZzpmdW5jdGlvbih0KXtpZighdC5pc0Nsb3NlZCgpKXt2YXIgZT1udWxsO3QuZ2V0TnVtUG9pbnRzKCk+PTEmJihlPXQuZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLlJJTkdfTk9UX0NMT1NFRCxlKX19LGNoZWNrU2hlbGxzTm90TmVzdGVkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspZm9yKHZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pLHI9aS5nZXRFeHRlcmlvclJpbmcoKSxzPTA7czx0LmdldE51bUdlb21ldHJpZXMoKTtzKyspaWYobiE9PXMpe3ZhciBvPXQuZ2V0R2VvbWV0cnlOKHMpO2lmKHRoaXMuY2hlY2tTaGVsbE5vdE5lc3RlZChyLG8sZSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsc319KSxscy5maW5kUHROb3ROb2RlPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bi5maW5kRWRnZShlKSxyPWkuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKSxzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBvPXRbc107aWYoIXIuaXNJbnRlcnNlY3Rpb24obykpcmV0dXJuIG99cmV0dXJuIG51bGx9LGxzLmlzVmFsaWQ9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBscyh0KTtyZXR1cm4gZS5pc1ZhbGlkKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgbj1hcmd1bWVudHNbMF07cmV0dXJuIHIuaXNOYU4obi54KT8hMTpyLmlzSW5maW5pdGUobi54KT8hMTpyLmlzTmFOKG4ueSk/ITE6IXIuaXNJbmZpbml0ZShuLnkpfX07dmFyIGJvPU9iamVjdC5mcmVlemUoe0lzVmFsaWRPcDpsc30pLE9vPU9iamVjdC5mcmVlemUoe0JvdW5kYXJ5T3A6ZHQsSXNTaW1wbGVPcDpHaSxidWZmZXI6Q28sZGlzdGFuY2U6U28sbGluZW1lcmdlOndvLG92ZXJsYXk6TG8scG9seWdvbml6ZTpSbyxyZWxhdGU6VG8sdW5pb246UG8sdmFsaWQ6Ym99KTtoKGhzLF90LkNvb3JkaW5hdGVPcGVyYXRpb24pLGUoaHMucHJvdG90eXBlLHtlZGl0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKSxpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciByPW5ldyBnKHRbaV0pO3RoaXMudGFyZ2V0UE0ubWFrZVByZWNpc2UociksbltpXT1yfXZhciBzPW5ldyBOKG4sITEpLG89cy50b0Nvb3JkaW5hdGVBcnJheSgpLGE9MDtlIGluc3RhbmNlb2YgU3QmJihhPTIpLGUgaW5zdGFuY2VvZiBidCYmKGE9NCk7dmFyIHU9bjtyZXR1cm4gdGhpcy5yZW1vdmVDb2xsYXBzZWQmJih1PW51bGwpLG8ubGVuZ3RoPGE/dTpvfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBoc319KSxlKGNzLnByb3RvdHlwZSx7Zml4UG9seWdvbmFsVG9wb2xvZ3k6ZnVuY3Rpb24odCl7dmFyIGU9dDt0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsfHwoZT10aGlzLmNoYW5nZVBNKHQsdGhpcy50YXJnZXRQTSkpO3ZhciBuPWUuYnVmZmVyKDApLGk9bjtyZXR1cm4gdGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KGk9dC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnkobikpLGl9LHJlZHVjZVBvaW50d2lzZTpmdW5jdGlvbih0KXt2YXIgZT1udWxsO2lmKHRoaXMuY2hhbmdlUHJlY2lzaW9uTW9kZWwpe3ZhciBuPXRoaXMuY3JlYXRlRmFjdG9yeSh0LmdldEZhY3RvcnkoKSx0aGlzLnRhcmdldFBNKTtlPW5ldyBfdChuKX1lbHNlIGU9bmV3IF90O3ZhciBpPXRoaXMucmVtb3ZlQ29sbGFwc2VkO3QuZ2V0RGltZW5zaW9uKCk+PTImJihpPSEwKTt2YXIgcj1lLmVkaXQodCxuZXcgaHModGhpcy50YXJnZXRQTSxpKSk7cmV0dXJuIHJ9LGNoYW5nZVBNOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5jcmVhdGVFZGl0b3IodC5nZXRGYWN0b3J5KCksZSk7cmV0dXJuIG4uZWRpdCh0LG5ldyBfdC5Ob09wR2VvbWV0cnlPcGVyYXRpb24pfSxzZXRSZW1vdmVDb2xsYXBzZWRDb21wb25lbnRzOmZ1bmN0aW9uKHQpe3RoaXMucmVtb3ZlQ29sbGFwc2VkPXR9LGNyZWF0ZUZhY3Rvcnk6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgaWUoZSx0LmdldFNSSUQoKSx0LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSk7cmV0dXJuIG59LHNldENoYW5nZVByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKHQpe3RoaXMuY2hhbmdlUHJlY2lzaW9uTW9kZWw9dH0scmVkdWNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucmVkdWNlUG9pbnR3aXNlKHQpO3JldHVybiB0aGlzLmlzUG9pbnR3aXNlP2U6UihlLFJ0KT9lLmlzVmFsaWQoKT9lOnRoaXMuZml4UG9seWdvbmFsVG9wb2xvZ3koZSk6ZX0sc2V0UG9pbnR3aXNlOmZ1bmN0aW9uKHQpe3RoaXMuaXNQb2ludHdpc2U9dH0sY3JlYXRlRWRpdG9yOmZ1bmN0aW9uKHQsZSl7aWYodC5nZXRQcmVjaXNpb25Nb2RlbCgpPT09ZSlyZXR1cm4gbmV3IF90O3ZhciBuPXRoaXMuY3JlYXRlRmFjdG9yeSh0LGUpLGk9bmV3IF90KG4pO3JldHVybiBpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjc319KSxjcy5yZWR1Y2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgY3MoZSk7cmV0dXJuIG4ucmVkdWNlKHQpfSxjcy5yZWR1Y2VQb2ludHdpc2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgY3MoZSk7cmV0dXJuIG4uc2V0UG9pbnR3aXNlKCEwKSxuLnJlZHVjZSh0KX07dmFyIF9vPU9iamVjdC5mcmVlemUoe0dlb21ldHJ5UHJlY2lzaW9uUmVkdWNlcjpjc30pO2UoZnMucHJvdG90eXBlLHtzaW1wbGlmeVNlY3Rpb246ZnVuY3Rpb24odCxlKXtpZih0KzE9PT1lKXJldHVybiBudWxsO3RoaXMuc2VnLnAwPXRoaXMucHRzW3RdLHRoaXMuc2VnLnAxPXRoaXMucHRzW2VdO2Zvcih2YXIgbj0tMSxpPXQscj10KzE7ZT5yO3IrKyl7dmFyIHM9dGhpcy5zZWcuZGlzdGFuY2UodGhpcy5wdHNbcl0pO3M+biYmKG49cyxpPXIpfWlmKG48PXRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpZm9yKHZhciByPXQrMTtlPnI7cisrKXRoaXMudXNlUHRbcl09ITE7ZWxzZSB0aGlzLnNpbXBsaWZ5U2VjdGlvbih0LGkpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKGksZSl9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0sc2ltcGxpZnk6ZnVuY3Rpb24oKXt0aGlzLnVzZVB0PW5ldyBBcnJheSh0aGlzLnB0cy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKHZhciB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMudXNlUHRbdF09ITA7dGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLnB0cy5sZW5ndGgtMSk7Zm9yKHZhciBlPW5ldyBOLHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspdGhpcy51c2VQdFt0XSYmZS5hZGQobmV3IGcodGhpcy5wdHNbdF0pKTtyZXR1cm4gZS50b0Nvb3JkaW5hdGVBcnJheSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmc319KSxmcy5zaW1wbGlmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBmcyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLnNpbXBsaWZ5KCl9LGUoZ3MucHJvdG90eXBlLHtzZXRFbnN1cmVWYWxpZDpmdW5jdGlvbih0KXt0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT10fSxnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlucHV0R2VvbS5pc0VtcHR5KCk/dGhpcy5pbnB1dEdlb20uY29weSgpOm5ldyBkcyh0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neSx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5pbnB1dEdlb20pfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXtpZigwPnQpdGhyb3cgbmV3IGkoXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBnc319KSxncy5zaW1wbGlmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBncyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9LGgoZHMseGUpLGUoZHMucHJvdG90eXBlLHt0cmFuc2Zvcm1Qb2x5Z29uOmZ1bmN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIG49eGUucHJvdG90eXBlLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBPdD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfSxjcmVhdGVWYWxpZEFyZWE6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5P3QuYnVmZmVyKDApOnR9LHRyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC50b0Nvb3JkaW5hdGVBcnJheSgpLGk9bnVsbDtyZXR1cm4gaT0wPT09bi5sZW5ndGg/bmV3IEFycmF5KDApLmZpbGwobnVsbCk6ZnMuc2ltcGxpZnkobix0aGlzLmRpc3RhbmNlVG9sZXJhbmNlKSx0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShpKX0sdHJhbnNmb3JtTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49eGUucHJvdG90eXBlLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LHRyYW5zZm9ybUxpbmVhclJpbmc6ZnVuY3Rpb24odCxlKXt2YXIgbj1lIGluc3RhbmNlb2YgVHQsaT14ZS5wcm90b3R5cGUudHJhbnNmb3JtTGluZWFyUmluZy5jYWxsKHRoaXMsdCxlKTtyZXR1cm4hbnx8aSBpbnN0YW5jZW9mIGJ0P2k6bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZHN9fSksZ3MuRFBUcmFuc2Zvcm1lcj1kcyxoKHBzLGNlKSxlKHBzLnByb3RvdHlwZSx7Z2V0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbmRleH0sZ2V0UGFyZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBwc319KSxlKHZzLnByb3RvdHlwZSx7YWRkVG9SZXN1bHQ6ZnVuY3Rpb24odCl7dGhpcy5yZXN1bHRTZWdzLmFkZCh0KX0sYXNMaW5lU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50TGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh2cy5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5yZXN1bHRTZWdzKSl9LGdldFJlc3VsdFNpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJlc3VsdFNlZ3Muc2l6ZSgpO3JldHVybiAwPT09dD8wOnQrMX0sZ2V0UGFyZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50TGluZX0sZ2V0U2VnbWVudDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zZWdzW3RdfSxnZXRQYXJlbnRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKX0sZ2V0TWluaW11bVNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW5pbXVtU2l6ZX0sYXNMaW5lYXJSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50TGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh2cy5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5yZXN1bHRTZWdzKSl9LGdldFNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2Vnc30saW5pdDpmdW5jdGlvbigpe3ZhciB0PXRoaXMucGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpO3RoaXMuc2Vncz1uZXcgQXJyYXkodC5sZW5ndGgtMSkuZmlsbChudWxsKTtmb3IodmFyIGU9MDtlPHQubGVuZ3RoLTE7ZSsrKXt2YXIgbj1uZXcgcHModFtlXSx0W2UrMV0sdGhpcy5wYXJlbnRMaW5lLGUpO3RoaXMuc2Vnc1tlXT1ufX0sZ2V0UmVzdWx0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdnMuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMucmVzdWx0U2Vncyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZzfX0pLHZzLmV4dHJhY3RDb29yZGluYXRlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKzEpLmZpbGwobnVsbCksbj1udWxsLGk9MDtpPHQuc2l6ZSgpO2krKyluPXQuZ2V0KGkpLGVbaV09bi5wMDtyZXR1cm4gZVtlLmxlbmd0aC0xXT1uLnAxLGV9LGUobXMucHJvdG90eXBlLHtyZW1vdmU6ZnVuY3Rpb24odCl7dGhpcy5pbmRleC5yZW1vdmUobmV3IEModC5wMCx0LnAxKSx0KX0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB2cylmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRTZWdtZW50cygpLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZVtuXTt0aGlzLmFkZChpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciByPWFyZ3VtZW50c1swXTt0aGlzLmluZGV4Lmluc2VydChuZXcgQyhyLnAwLHIucDEpLHIpfX0scXVlcnk6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEModC5wMCx0LnAxKSxuPW5ldyB5cyh0KTt0aGlzLmluZGV4LnF1ZXJ5KGUsbik7dmFyIGk9bi5nZXRJdGVtcygpO3JldHVybiBpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtc319KSxlKHlzLnByb3RvdHlwZSx7dmlzaXRJdGVtOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7Qy5pbnRlcnNlY3RzKGUucDAsZS5wMSx0aGlzLnF1ZXJ5U2VnLnAwLHRoaXMucXVlcnlTZWcucDEpJiZ0aGlzLml0ZW1zLmFkZCh0KX0sZ2V0SXRlbXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQWVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5c319KSxlKHhzLnByb3RvdHlwZSx7ZmxhdHRlbjpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubGluZVB0c1t0XSxpPXRoaXMubGluZVB0c1tlXSxyPW5ldyBjZShuLGkpO3JldHVybiB0aGlzLnJlbW92ZSh0aGlzLmxpbmUsdCxlKSx0aGlzLm91dHB1dEluZGV4LmFkZChyKSxyfSxoYXNCYWRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmhhc0JhZE91dHB1dEludGVyc2VjdGlvbihuKT8hMDohIXRoaXMuaGFzQmFkSW5wdXRJbnRlcnNlY3Rpb24odCxlLG4pfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LHNpbXBsaWZ5U2VjdGlvbjpmdW5jdGlvbih0LGUsbil7bis9MTt2YXIgaT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0KzE9PT1lKXt2YXIgcj10aGlzLmxpbmUuZ2V0U2VnbWVudCh0KTtyZXR1cm4gdGhpcy5saW5lLmFkZFRvUmVzdWx0KHIpLG51bGx9dmFyIHM9ITA7aWYodGhpcy5saW5lLmdldFJlc3VsdFNpemUoKTx0aGlzLmxpbmUuZ2V0TWluaW11bVNpemUoKSl7dmFyIG89bisxO288dGhpcy5saW5lLmdldE1pbmltdW1TaXplKCkmJihzPSExKX12YXIgYT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSx1PXRoaXMuZmluZEZ1cnRoZXN0UG9pbnQodGhpcy5saW5lUHRzLHQsZSxhKTthWzBdPnRoaXMuZGlzdGFuY2VUb2xlcmFuY2UmJihzPSExKTt2YXIgbD1uZXcgY2U7aWYobC5wMD10aGlzLmxpbmVQdHNbdF0sbC5wMT10aGlzLmxpbmVQdHNbZV0saVswXT10LGlbMV09ZSx0aGlzLmhhc0JhZEludGVyc2VjdGlvbih0aGlzLmxpbmUsaSxsKSYmKHM9ITEpLHMpe3ZhciByPXRoaXMuZmxhdHRlbih0LGUpO3JldHVybiB0aGlzLmxpbmUuYWRkVG9SZXN1bHQociksbnVsbH10aGlzLnNpbXBsaWZ5U2VjdGlvbih0LHUsbiksdGhpcy5zaW1wbGlmeVNlY3Rpb24odSxlLG4pfSxoYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMub3V0cHV0SW5kZXgucXVlcnkodCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKGksdCkpcmV0dXJuITB9cmV0dXJuITF9LGZpbmRGdXJ0aGVzdFBvaW50OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBjZTtyLnAwPXRbZV0sci5wMT10W25dO2Zvcih2YXIgcz0tMSxvPWUsYT1lKzE7bj5hO2ErKyl7dmFyIHU9dFthXSxsPXIuZGlzdGFuY2UodSk7bD5zJiYocz1sLG89YSl9cmV0dXJuIGlbMF09cyxvfSxzaW1wbGlmeTpmdW5jdGlvbih0KXt0aGlzLmxpbmU9dCx0aGlzLmxpbmVQdHM9dC5nZXRQYXJlbnRDb29yZGluYXRlcygpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5saW5lUHRzLmxlbmd0aC0xLDApfSxyZW1vdmU6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1lO24+aTtpKyspe3ZhciByPXQuZ2V0U2VnbWVudChpKTt0aGlzLmlucHV0SW5kZXgucmVtb3ZlKHIpfX0saGFzSW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQucDAsdC5wMSxlLnAwLGUucDEpLHRoaXMubGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpfSxoYXNCYWRJbnB1dEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPXRoaXMuaW5wdXRJbmRleC5xdWVyeShuKSxyPWkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24ocyxuKSl7aWYoeHMuaXNJbkxpbmVTZWN0aW9uKHQsZSxzKSljb250aW51ZTtyZXR1cm4hMH19cmV0dXJuITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHhzfX0pLHhzLmlzSW5MaW5lU2VjdGlvbj1mdW5jdGlvbih0LGUsbil7aWYobi5nZXRQYXJlbnQoKSE9PXQuZ2V0UGFyZW50KCkpcmV0dXJuITE7dmFyIGk9bi5nZXRJbmRleCgpO3JldHVybiBpPj1lWzBdJiZpPGVbMV19LGUoRXMucHJvdG90eXBlLHtzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LHNpbXBsaWZ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuaW5wdXRJbmRleC5hZGQoZS5uZXh0KCkpO2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1uZXcgeHModGhpcy5pbnB1dEluZGV4LHRoaXMub3V0cHV0SW5kZXgpO24uc2V0RGlzdGFuY2VUb2xlcmFuY2UodGhpcy5kaXN0YW5jZVRvbGVyYW5jZSksbi5zaW1wbGlmeShlLm5leHQoKSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFc319KSxlKElzLnByb3RvdHlwZSx7Z2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXtpZih0aGlzLmlucHV0R2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuaW5wdXRHZW9tLmNvcHkoKTt0aGlzLmxpbmVzdHJpbmdNYXA9bmV3IHRlLHRoaXMuaW5wdXRHZW9tLmFwcGx5KG5ldyBDcyh0aGlzKSksdGhpcy5saW5lU2ltcGxpZmllci5zaW1wbGlmeSh0aGlzLmxpbmVzdHJpbmdNYXAudmFsdWVzKCkpO3ZhciB0PW5ldyBOcyh0aGlzLmxpbmVzdHJpbmdNYXApLnRyYW5zZm9ybSh0aGlzLmlucHV0R2VvbSk7cmV0dXJuIHR9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe2lmKDA+dCl0aHJvdyBuZXcgaShcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLmxpbmVTaW1wbGlmaWVyLnNldERpc3RhbmNlVG9sZXJhbmNlKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBJc319KSxJcy5zaW1wbGlmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBJcyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9LGgoTnMseGUpLGUoTnMucHJvdG90eXBlLHt0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe2lmKDA9PT10LnNpemUoKSlyZXR1cm4gbnVsbDtpZihlIGluc3RhbmNlb2YgU3Qpe3ZhciBuPXRoaXMubGluZXN0cmluZ01hcC5nZXQoZSk7cmV0dXJuIHRoaXMuY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlKG4uZ2V0UmVzdWx0Q29vcmRpbmF0ZXMoKSl9cmV0dXJuIHhlLnByb3RvdHlwZS50cmFuc2Zvcm1Db29yZGluYXRlcy5jYWxsKHRoaXMsdCxlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTnN9fSksZShDcy5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgU3Qpe3ZhciBlPXQ7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIG49ZS5pc0Nsb3NlZCgpPzQ6MixpPW5ldyB2cyhlLG4pO3RoaXMudHBzLmxpbmVzdHJpbmdNYXAucHV0KGUsaSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ3N9fSksSXMuTGluZVN0cmluZ1RyYW5zZm9ybWVyPU5zLElzLkxpbmVTdHJpbmdNYXBCdWlsZGVyRmlsdGVyPUNzO3ZhciBNbz1PYmplY3QuZnJlZXplKHtEb3VnbGFzUGV1Y2tlclNpbXBsaWZpZXI6Z3MsVG9wb2xvZ3lQcmVzZXJ2aW5nU2ltcGxpZmllcjpJc30pO2UoU3MucHJvdG90eXBlLHtzcGxpdEF0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMubWluaW11bUxlbi90aGlzLnNlZ0xlbjtpZih0LmRpc3RhbmNlKHRoaXMuc2VnLnAwKTx0aGlzLm1pbmltdW1MZW4pcmV0dXJuIHRoaXMuc3BsaXRQdD10aGlzLnNlZy5wb2ludEFsb25nKGUpLG51bGw7aWYodC5kaXN0YW5jZSh0aGlzLnNlZy5wMSk8dGhpcy5taW5pbXVtTGVuKXJldHVybiB0aGlzLnNwbGl0UHQ9U3MucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5zZWcsZSksbnVsbDt0aGlzLnNwbGl0UHQ9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj10aGlzLmdldENvbnN0cmFpbmVkTGVuZ3RoKG4pLHM9ci90aGlzLnNlZ0xlbjtpLmVxdWFsczJEKHRoaXMuc2VnLnAwKT90aGlzLnNwbGl0UHQ9dGhpcy5zZWcucG9pbnRBbG9uZyhzKTp0aGlzLnNwbGl0UHQ9U3MucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5zZWcscyl9fSxzZXRNaW5pbXVtTGVuZ3RoOmZ1bmN0aW9uKHQpe3RoaXMubWluaW11bUxlbj10fSxnZXRDb25zdHJhaW5lZExlbmd0aDpmdW5jdGlvbih0KXtyZXR1cm4gdDx0aGlzLm1pbmltdW1MZW4/dGhpcy5taW5pbXVtTGVuOnR9LGdldFNwbGl0UG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcGxpdFB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTc319KSxTcy5wb2ludEFsb25nUmV2ZXJzZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBnO3JldHVybiBuLng9dC5wMS54LWUqKHQucDEueC10LnAwLngpLG4ueT10LnAxLnktZSoodC5wMS55LXQucDAueSksbn0sZSh3cy5wcm90b3R5cGUse2ZpbmRTcGxpdFBvaW50OmZ1bmN0aW9uKHQsZSl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3c319KSxlKExzLnByb3RvdHlwZSx7ZmluZFNwbGl0UG9pbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldExpbmVTZWdtZW50KCksaT1uLmdldExlbmd0aCgpLHI9aS8yLHM9bmV3IFNzKG4pLG89THMucHJvamVjdGVkU3BsaXRQb2ludCh0LGUpLGE9MipvLmRpc3RhbmNlKGUpKi44LHU9YTtyZXR1cm4gdT5yJiYodT1yKSxzLnNldE1pbmltdW1MZW5ndGgodSkscy5zcGxpdEF0KG8pLHMuZ2V0U3BsaXRQb2ludCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt3c119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExzfX0pLExzLnByb2plY3RlZFNwbGl0UG9pbnQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldExpbmVTZWdtZW50KCksaT1uLnByb2plY3QoZSk7cmV0dXJuIGl9LGUoUnMucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBSc319KSxScy50cmlBcmVhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShlLnktdC55KSoobi54LXQueCl9LFJzLmlzSW5DaXJjbGVERE5vcm1hbGl6ZWQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Xy52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KGkueCkscz1fLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3QoaS55KSxvPV8udmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdChpLngpLGE9Xy52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KGkueSksdT1fLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3QoaS54KSxsPV8udmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdChpLnkpLGg9ci5tdWx0aXBseShhKS5zZWxmU3VidHJhY3Qoby5tdWx0aXBseShzKSksYz1vLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdCh1Lm11bHRpcGx5KGEpKSxmPXUubXVsdGlwbHkocykuc2VsZlN1YnRyYWN0KHIubXVsdGlwbHkobCkpLGc9ci5tdWx0aXBseShyKS5zZWxmQWRkKHMubXVsdGlwbHkocykpLGQ9by5tdWx0aXBseShvKS5zZWxmQWRkKGEubXVsdGlwbHkoYSkpLHA9dS5tdWx0aXBseSh1KS5zZWxmQWRkKGwubXVsdGlwbHkobCkpLHY9Zy5zZWxmTXVsdGlwbHkoYykuc2VsZkFkZChkLnNlbGZNdWx0aXBseShmKSkuc2VsZkFkZChwLnNlbGZNdWx0aXBseShoKSksbT12LmRvdWJsZVZhbHVlKCk+MDtyZXR1cm4gbX0sUnMuY2hlY2tSb2J1c3RJbkNpcmNsZT1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1Scy5pc0luQ2lyY2xlTm9uUm9idXN0KHQsZSxuLGkpLHM9UnMuaXNJbkNpcmNsZUREU2xvdyh0LGUsbixpKSxvPVJzLmlzSW5DaXJjbGVDQyh0LGUsbixpKSxhPWNpLmNpcmN1bWNlbnRyZSh0LGUsbik7QS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKGkuZGlzdGFuY2UoYSktdC5kaXN0YW5jZShhKSkvdC5kaXN0YW5jZShhKSkscj09PXMmJnI9PT1vfHwoQS5vdXQucHJpbnRsbihcImluQ2lyY2xlIHJvYnVzdG5lc3MgZmFpbHVyZSAoZG91YmxlIHJlc3VsdCA9IFwiK3IrXCIsIEREIHJlc3VsdCA9IFwiK3MrXCIsIENDIHJlc3VsdCA9IFwiK28rXCIpXCIpLEEub3V0LnByaW50bG4oc2UudG9MaW5lU3RyaW5nKG5ldyBHdChbdCxlLG4saV0pKSksQS5vdXQucHJpbnRsbihcIkNpcmN1bWNlbnRyZSA9IFwiK3NlLnRvUG9pbnQoYSkrXCIgcmFkaXVzID0gXCIrdC5kaXN0YW5jZShhKSksQS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKGkuZGlzdGFuY2UoYSkvdC5kaXN0YW5jZShhKS0xKSksQS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYiA9IFwiK01hdGguYWJzKGkuZGlzdGFuY2UoYSkvZS5kaXN0YW5jZShhKS0xKSksQS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYyA9IFwiK01hdGguYWJzKGkuZGlzdGFuY2UoYSkvbi5kaXN0YW5jZShhKS0xKSksQS5vdXQucHJpbnRsbigpKX0sUnMuaXNJbkNpcmNsZURERmFzdD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1fLnNxcih0LngpLnNlbGZBZGQoXy5zcXIodC55KSkuc2VsZk11bHRpcGx5KFJzLnRyaUFyZWFEREZhc3QoZSxuLGkpKSxzPV8uc3FyKGUueCkuc2VsZkFkZChfLnNxcihlLnkpKS5zZWxmTXVsdGlwbHkoUnMudHJpQXJlYURERmFzdCh0LG4saSkpLG89Xy5zcXIobi54KS5zZWxmQWRkKF8uc3FyKG4ueSkpLnNlbGZNdWx0aXBseShScy50cmlBcmVhRERGYXN0KHQsZSxpKSksYT1fLnNxcihpLngpLnNlbGZBZGQoXy5zcXIoaS55KSkuc2VsZk11bHRpcGx5KFJzLnRyaUFyZWFEREZhc3QodCxlLG4pKSx1PXIuc2VsZlN1YnRyYWN0KHMpLnNlbGZBZGQobykuc2VsZlN1YnRyYWN0KGEpLGw9dS5kb3VibGVWYWx1ZSgpPjA7cmV0dXJuIGx9LFJzLmlzSW5DaXJjbGVDQz1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1jaS5jaXJjdW1jZW50cmUodCxlLG4pLHM9dC5kaXN0YW5jZShyKSxvPWkuZGlzdGFuY2UociktcztyZXR1cm4gMD49b30sUnMuaXNJbkNpcmNsZU5vcm1hbGl6ZWQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dC54LWkueCxzPXQueS1pLnksbz1lLngtaS54LGE9ZS55LWkueSx1PW4ueC1pLngsbD1uLnktaS55LGg9ciphLW8qcyxjPW8qbC11KmEsZj11KnMtcipsLGc9cipyK3MqcyxkPW8qbythKmEscD11KnUrbCpsLHY9ZypjK2QqZitwKmg7cmV0dXJuIHY+MH0sUnMuaXNJbkNpcmNsZUREU2xvdz1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1fLnZhbHVlT2YoaS54KSxzPV8udmFsdWVPZihpLnkpLG89Xy52YWx1ZU9mKHQueCksYT1fLnZhbHVlT2YodC55KSx1PV8udmFsdWVPZihlLngpLGw9Xy52YWx1ZU9mKGUueSksaD1fLnZhbHVlT2Yobi54KSxjPV8udmFsdWVPZihuLnkpLGY9by5tdWx0aXBseShvKS5hZGQoYS5tdWx0aXBseShhKSkubXVsdGlwbHkoUnMudHJpQXJlYUREU2xvdyh1LGwsaCxjLHIscykpLGc9dS5tdWx0aXBseSh1KS5hZGQobC5tdWx0aXBseShsKSkubXVsdGlwbHkoUnMudHJpQXJlYUREU2xvdyhvLGEsaCxjLHIscykpLGQ9aC5tdWx0aXBseShoKS5hZGQoYy5tdWx0aXBseShjKSkubXVsdGlwbHkoUnMudHJpQXJlYUREU2xvdyhvLGEsdSxsLHIscykpLHA9ci5tdWx0aXBseShyKS5hZGQocy5tdWx0aXBseShzKSkubXVsdGlwbHkoUnMudHJpQXJlYUREU2xvdyhvLGEsdSxsLGgsYykpLHY9Zi5zdWJ0cmFjdChnKS5hZGQoZCkuc3VidHJhY3QocCksbT12LmRvdWJsZVZhbHVlKCk+MDtcbnJldHVybiBtfSxScy5pc0luQ2lyY2xlTm9uUm9idXN0PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPSh0LngqdC54K3QueSp0LnkpKlJzLnRyaUFyZWEoZSxuLGkpLShlLngqZS54K2UueSplLnkpKlJzLnRyaUFyZWEodCxuLGkpKyhuLngqbi54K24ueSpuLnkpKlJzLnRyaUFyZWEodCxlLGkpLShpLngqaS54K2kueSppLnkpKlJzLnRyaUFyZWEodCxlLG4pPjA7cmV0dXJuIHJ9LFJzLmlzSW5DaXJjbGVSb2J1c3Q9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIFJzLmlzSW5DaXJjbGVOb3JtYWxpemVkKHQsZSxuLGkpfSxScy50cmlBcmVhRERTbG93PWZ1bmN0aW9uKHQsZSxuLGkscixzKXtyZXR1cm4gbi5zdWJ0cmFjdCh0KS5tdWx0aXBseShzLnN1YnRyYWN0KGUpKS5zdWJ0cmFjdChpLnN1YnRyYWN0KGUpLm11bHRpcGx5KHIuc3VidHJhY3QodCkpKX0sUnMudHJpQXJlYURERmFzdD1mdW5jdGlvbih0LGUsbil7dmFyIGk9Xy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxyPV8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShfLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3QodC54KSk7cmV0dXJuIGkuc2VsZlN1YnRyYWN0KHIpfSxlKFRzLnByb3RvdHlwZSx7Y2lyY2xlQ2VudGVyOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFRzKHRoaXMuZ2V0WCgpLHRoaXMuZ2V0WSgpKSxpPXRoaXMuYmlzZWN0b3Iobix0KSxyPXRoaXMuYmlzZWN0b3IodCxlKSxzPW5ldyBGKGksciksbz1udWxsO3RyeXtvPW5ldyBUcyhzLmdldFgoKSxzLmdldFkoKSl9Y2F0Y2goaSl7aWYoIShpIGluc3RhbmNlb2YgdykpdGhyb3cgaTtBLmVyci5wcmludGxuKFwiYTogXCIrbitcIiAgYjogXCIrdCtcIiAgYzogXCIrZSksQS5lcnIucHJpbnRsbihpKX1maW5hbGx5e31yZXR1cm4gb30sZG90OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnAueCp0LmdldFgoKSt0aGlzLnAueSp0LmdldFkoKX0sbWFnbjpmdW5jdGlvbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy5wLngqdGhpcy5wLngrdGhpcy5wLnkqdGhpcy5wLnkpfSxnZXRaOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC56fSxiaXNlY3RvcjpmdW5jdGlvbih0LGUpe3ZhciBuPWUuZ2V0WCgpLXQuZ2V0WCgpLGk9ZS5nZXRZKCktdC5nZXRZKCkscj1uZXcgRih0LmdldFgoKStuLzIsdC5nZXRZKCkraS8yLDEpLHM9bmV3IEYodC5nZXRYKCktaStuLzIsdC5nZXRZKCkrbitpLzIsMSk7cmV0dXJuIG5ldyBGKHIscyl9LGVxdWFsczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMucC54PT09dC5nZXRYKCkmJnRoaXMucC55PT09dC5nZXRZKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5wLmRpc3RhbmNlKGUuZ2V0Q29vcmRpbmF0ZSgpKTxufX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB9LGlzSW5DaXJjbGU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBScy5pc0luQ2lyY2xlUm9idXN0KHQucCxlLnAsbi5wLHRoaXMucCl9LGludGVycG9sYXRlWlZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldFgoKSxyPXQuZ2V0WSgpLHM9ZS5nZXRYKCktaSxvPW4uZ2V0WCgpLWksYT1lLmdldFkoKS1yLHU9bi5nZXRZKCktcixsPXMqdS1vKmEsaD10aGlzLmdldFgoKS1pLGM9dGhpcy5nZXRZKCktcixmPSh1KmgtbypjKS9sLGc9KC1hKmgrcypjKS9sLGQ9dC5nZXRaKCkrZiooZS5nZXRaKCktdC5nZXRaKCkpK2cqKG4uZ2V0WigpLXQuZ2V0WigpKTtyZXR1cm4gZH0sbWlkUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9KHRoaXMucC54K3QuZ2V0WCgpKS8yLG49KHRoaXMucC55K3QuZ2V0WSgpKS8yLGk9KHRoaXMucC56K3QuZ2V0WigpKS8yO3JldHVybiBuZXcgVHMoZSxuLGkpfSxyaWdodE9mOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQuZGVzdCgpLHQub3JpZygpKX0saXNDQ1c6ZnVuY3Rpb24odCxlKXtyZXR1cm4odC5wLngtdGhpcy5wLngpKihlLnAueS10aGlzLnAueSktKHQucC55LXRoaXMucC55KSooZS5wLngtdGhpcy5wLngpPjB9LGdldFg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnh9LGNyb3NzUHJvZHVjdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wLngqdC5nZXRZKCktdGhpcy5wLnkqdC5nZXRYKCl9LHNldFo6ZnVuY3Rpb24odCl7dGhpcy5wLno9dH0sdGltZXM6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBUcyh0KnRoaXMucC54LHQqdGhpcy5wLnkpfSxjcm9zczpmdW5jdGlvbigpe3JldHVybiBuZXcgVHModGhpcy5wLnksLXRoaXMucC54KX0sbGVmdE9mOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQub3JpZygpLHQuZGVzdCgpKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIlBPSU5UIChcIit0aGlzLnAueCtcIiBcIit0aGlzLnAueStcIilcIn0sc3ViOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVHModGhpcy5wLngtdC5nZXRYKCksdGhpcy5wLnktdC5nZXRZKCkpfSxnZXRZOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC55fSxjbGFzc2lmeTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMsaT1lLnN1Yih0KSxyPW4uc3ViKHQpLHM9aS5jcm9zc1Byb2R1Y3Qocik7cmV0dXJuIHM+MD9Ucy5MRUZUOjA+cz9Ucy5SSUdIVDppLmdldFgoKSpyLmdldFgoKTwwfHxpLmdldFkoKSpyLmdldFkoKTwwP1RzLkJFSElORDppLm1hZ24oKTxyLm1hZ24oKT9Ucy5CRVlPTkQ6dC5lcXVhbHMobik/VHMuT1JJR0lOOmUuZXF1YWxzKG4pP1RzLkRFU1RJTkFUSU9OOlRzLkJFVFdFRU59LHN1bTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFRzKHRoaXMucC54K3QuZ2V0WCgpLHRoaXMucC55K3QuZ2V0WSgpKX0sZGlzdGFuY2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGUuZ2V0WCgpLXQuZ2V0WCgpLDIpK01hdGgucG93KGUuZ2V0WSgpLXQuZ2V0WSgpLDIpKX0sY2lyY3VtUmFkaXVzUmF0aW86ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmNpcmNsZUNlbnRlcih0LGUpLGk9dGhpcy5kaXN0YW5jZShuLHQpLHI9dGhpcy5kaXN0YW5jZSh0aGlzLHQpLHM9dGhpcy5kaXN0YW5jZSh0LGUpO3JldHVybiByPnMmJihyPXMpLHM9dGhpcy5kaXN0YW5jZShlLHRoaXMpLHI+cyYmKHI9cyksaS9yfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUc319KSxUcy5pbnRlcnBvbGF0ZVo9ZnVuY3Rpb24oKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9ZS5kaXN0YW5jZShuKSxyPXQuZGlzdGFuY2UoZSkscz1uLnotZS56LG89ZS56K3MqKHIvaSk7cmV0dXJuIG99aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXSxsPWFyZ3VtZW50c1syXSxoPWFyZ3VtZW50c1szXSxjPXUueCxmPXUueSxnPWwueC1jLGQ9aC54LWMscD1sLnktZix2PWgueS1mLG09Zyp2LWQqcCx5PWEueC1jLHg9YS55LWYsRT0odip5LWQqeCkvbSxJPSgtcCp5K2cqeCkvbSxOPXUueitFKihsLnotdS56KStJKihoLnotdS56KTtyZXR1cm4gTn19LFRzLkxFRlQ9MCxUcy5SSUdIVD0xLFRzLkJFWU9ORD0yLFRzLkJFSElORD0zLFRzLkJFVFdFRU49NCxUcy5PUklHSU49NSxUcy5ERVNUSU5BVElPTj02LGgoUHMsVHMpLGUoUHMucHJvdG90eXBlLHtnZXRDb25zdHJhaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RyYWludH0sc2V0T25Db25zdHJhaW50OmZ1bmN0aW9uKHQpe3RoaXMuX2lzT25Db25zdHJhaW50PXR9LG1lcmdlOmZ1bmN0aW9uKHQpe3QuX2lzT25Db25zdHJhaW50JiYodGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5jb25zdHJhaW50PXQuY29uc3RyYWludCl9LGlzT25Db25zdHJhaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzT25Db25zdHJhaW50fSxzZXRDb25zdHJhaW50OmZ1bmN0aW9uKHQpe3RoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuY29uc3RyYWludD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQc319KSxlKGJzLnByb3RvdHlwZSx7ZXF1YWxzTm9uT3JpZW50ZWQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZXF1YWxzT3JpZW50ZWQodCk/ITA6ISF0aGlzLmVxdWFsc09yaWVudGVkKHQuc3ltKCkpfSx0b0xpbmVTZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBjZSh0aGlzLnZlcnRleC5nZXRDb29yZGluYXRlKCksdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX0sZGVzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN5bSgpLm9yaWcoKX0sb05leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0fSxlcXVhbHNPcmllbnRlZDpmdW5jdGlvbih0KXtyZXR1cm4hKCF0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpKXx8IXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpKX0sZE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpLnN5bSgpfSxsUHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHQuc3ltKCl9LHJQcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKX0scm90OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdH0sb1ByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90Lm5leHQuX3JvdH0sc3ltOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5fcm90fSxzZXRPcmlnOmZ1bmN0aW9uKHQpe3RoaXMudmVydGV4PXR9LGxOZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5yb3QoKX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZSh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfSxpbnZSb3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90LnN5bSgpfSxzZXREZXN0OmZ1bmN0aW9uKHQpe3RoaXMuc3ltKCkuc2V0T3JpZyh0KX0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGRlbGV0ZTpmdW5jdGlvbigpe3RoaXMuX3JvdD1udWxsfSxvcmlnOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmVydGV4fSxyTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3QubmV4dC5pbnZSb3QoKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnZlcnRleC5nZXRDb29yZGluYXRlKCksZT10aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCk7cmV0dXJuIHNlLnRvTGluZVN0cmluZyh0LGUpfSxpc0xpdmU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3JvdH0sZ2V0UHJpbWFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSk8PTA/dGhpczp0aGlzLnN5bSgpfSxkUHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkuaW52Um90KCl9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5uZXh0PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJzfX0pLGJzLm1ha2VFZGdlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGJzLGk9bmV3IGJzLHI9bmV3IGJzLHM9bmV3IGJzO24uX3JvdD1pLGkuX3JvdD1yLHIuX3JvdD1zLHMuX3JvdD1uLG4uc2V0TmV4dChuKSxpLnNldE5leHQocyksci5zZXROZXh0KHIpLHMuc2V0TmV4dChpKTt2YXIgbz1uO3JldHVybiBvLnNldE9yaWcodCksby5zZXREZXN0KGUpLG99LGJzLnN3YXA9ZnVuY3Rpb24odCl7dmFyIGU9dC5vUHJldigpLG49dC5zeW0oKS5vUHJldigpO2JzLnNwbGljZSh0LGUpLGJzLnNwbGljZSh0LnN5bSgpLG4pLGJzLnNwbGljZSh0LGUubE5leHQoKSksYnMuc3BsaWNlKHQuc3ltKCksbi5sTmV4dCgpKSx0LnNldE9yaWcoZS5kZXN0KCkpLHQuc2V0RGVzdChuLmRlc3QoKSl9LGJzLnNwbGljZT1mdW5jdGlvbih0LGUpe3ZhciBuPXQub05leHQoKS5yb3QoKSxpPWUub05leHQoKS5yb3QoKSxyPWUub05leHQoKSxzPXQub05leHQoKSxvPWkub05leHQoKSxhPW4ub05leHQoKTt0LnNldE5leHQociksZS5zZXROZXh0KHMpLG4uc2V0TmV4dChvKSxpLnNldE5leHQoYSl9LGJzLmNvbm5lY3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj1icy5tYWtlRWRnZSh0LmRlc3QoKSxlLm9yaWcoKSk7cmV0dXJuIGJzLnNwbGljZShuLHQubE5leHQoKSksYnMuc3BsaWNlKG4uc3ltKCksZSksbn0sZShPcy5wcm90b3R5cGUse2luc2VydFNpdGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zdWJkaXYubG9jYXRlKHQpO2lmKHRoaXMuc3ViZGl2LmlzVmVydGV4T2ZFZGdlKGUsdCkpcmV0dXJuIGU7dGhpcy5zdWJkaXYuaXNPbkVkZ2UoZSx0LmdldENvb3JkaW5hdGUoKSkmJihlPWUub1ByZXYoKSx0aGlzLnN1YmRpdi5kZWxldGUoZS5vTmV4dCgpKSk7dmFyIG49dGhpcy5zdWJkaXYubWFrZUVkZ2UoZS5vcmlnKCksdCk7YnMuc3BsaWNlKG4sZSk7dmFyIGk9bjtkbyBuPXRoaXMuc3ViZGl2LmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKTt3aGlsZShlLmxOZXh0KCkhPT1pKTtmb3IoOzspe3ZhciByPWUub1ByZXYoKTtpZihyLmRlc3QoKS5yaWdodE9mKGUpJiZ0LmlzSW5DaXJjbGUoZS5vcmlnKCksci5kZXN0KCksZS5kZXN0KCkpKWJzLnN3YXAoZSksZT1lLm9QcmV2KCk7ZWxzZXtpZihlLm9OZXh0KCk9PT1pKXJldHVybiBuO2U9ZS5vTmV4dCgpLmxQcmV2KCl9fX0saW5zZXJ0U2l0ZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZShuKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9zfX0pLGUoX3MucHJvdG90eXBlLHtsb2NhdGU6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBfc319KSxlKE1zLnByb3RvdHlwZSx7aW5pdDpmdW5jdGlvbigpe3RoaXMubGFzdEVkZ2U9dGhpcy5maW5kRWRnZSgpfSxsb2NhdGU6ZnVuY3Rpb24odCl7dGhpcy5sYXN0RWRnZS5pc0xpdmUoKXx8dGhpcy5pbml0KCk7dmFyIGU9dGhpcy5zdWJkaXYubG9jYXRlRnJvbUVkZ2UodCx0aGlzLmxhc3RFZGdlKTtyZXR1cm4gdGhpcy5sYXN0RWRnZT1lLGV9LGZpbmRFZGdlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zdWJkaXYuZ2V0RWRnZXMoKTtyZXR1cm4gdC5pdGVyYXRvcigpLm5leHQoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bX3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNc319KSxoKERzLGwpLGUoRHMucHJvdG90eXBlLHtnZXRTZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEc319KSxEcy5tc2dXaXRoU3BhdGlhbD1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrZStcIiBdXCI6dH0sZShBcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQXN9fSksZShGcy5wcm90b3R5cGUse2dldFRyaWFuZ2xlVmVydGljZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEJzO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZVZlcnRpY2VzKCl9LGlzRnJhbWVWZXJ0ZXg6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZXF1YWxzKHRoaXMuZnJhbWVWZXJ0ZXhbMF0pPyEwOnQuZXF1YWxzKHRoaXMuZnJhbWVWZXJ0ZXhbMV0pPyEwOiEhdC5lcXVhbHModGhpcy5mcmFtZVZlcnRleFsyXSl9LGlzVmVydGV4T2ZFZGdlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuISghZS5lcXVhbHModC5vcmlnKCksdGhpcy50b2xlcmFuY2UpJiYhZS5lcXVhbHModC5kZXN0KCksdGhpcy50b2xlcmFuY2UpKX0sY29ubmVjdDpmdW5jdGlvbih0LGUpe3ZhciBuPWJzLmNvbm5lY3QodCxlKTtyZXR1cm4gdGhpcy5xdWFkRWRnZXMuYWRkKG4pLG59LGdldFZvcm9ub2lDZWxsUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBJLGk9dDtkb3t2YXIgcj10LnJvdCgpLm9yaWcoKS5nZXRDb29yZGluYXRlKCk7bi5hZGQociksdD10Lm9QcmV2KCl9d2hpbGUodCE9PWkpO3ZhciBzPW5ldyBOO3MuYWRkQWxsKG4sITEpLHMuY2xvc2VSaW5nKCkscy5zaXplKCk8NCYmKEEub3V0LnByaW50bG4ocykscy5hZGQocy5nZXQocy5zaXplKCktMSksITApKTt2YXIgbz1zLnRvQ29vcmRpbmF0ZUFycmF5KCksYT1lLmNyZWF0ZVBvbHlnb24oZS5jcmVhdGVMaW5lYXJSaW5nKG8pLG51bGwpLHU9aS5vcmlnKCk7cmV0dXJuIGEuc2V0VXNlckRhdGEodS5nZXRDb29yZGluYXRlKCkpLGF9LHNldExvY2F0b3I6ZnVuY3Rpb24odCl7dGhpcy5sb2NhdG9yPXR9LGluaXRTdWJkaXY6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1ha2VFZGdlKHRoaXMuZnJhbWVWZXJ0ZXhbMF0sdGhpcy5mcmFtZVZlcnRleFsxXSksZT10aGlzLm1ha2VFZGdlKHRoaXMuZnJhbWVWZXJ0ZXhbMV0sdGhpcy5mcmFtZVZlcnRleFsyXSk7YnMuc3BsaWNlKHQuc3ltKCksZSk7dmFyIG49dGhpcy5tYWtlRWRnZSh0aGlzLmZyYW1lVmVydGV4WzJdLHRoaXMuZnJhbWVWZXJ0ZXhbMF0pO3JldHVybiBicy5zcGxpY2UoZS5zeW0oKSxuKSxicy5zcGxpY2Uobi5zeW0oKSx0KSx0fSxpc0ZyYW1lQm9yZGVyRWRnZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtGcy5nZXRUcmlhbmdsZUVkZ2VzKHQsZSk7dmFyIG49bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7RnMuZ2V0VHJpYW5nbGVFZGdlcyh0LnN5bSgpLG4pO3ZhciBpPXQubE5leHQoKS5kZXN0KCk7aWYodGhpcy5pc0ZyYW1lVmVydGV4KGkpKXJldHVybiEwO3ZhciByPXQuc3ltKCkubE5leHQoKS5kZXN0KCk7cmV0dXJuISF0aGlzLmlzRnJhbWVWZXJ0ZXgocil9LG1ha2VFZGdlOmZ1bmN0aW9uKHQsZSl7dmFyIG49YnMubWFrZUVkZ2UodCxlKTtyZXR1cm4gdGhpcy5xdWFkRWRnZXMuYWRkKG4pLG59LHZpc2l0VHJpYW5nbGVzOmZ1bmN0aW9uKHQsZSl7dGhpcy52aXNpdGVkS2V5Kys7dmFyIG49bmV3IHBlO24ucHVzaCh0aGlzLnN0YXJ0aW5nRWRnZSk7Zm9yKHZhciBpPW5ldyBKOyFuLmVtcHR5KCk7KXt2YXIgcj1uLnBvcCgpO2lmKCFpLmNvbnRhaW5zKHIpKXt2YXIgcz10aGlzLmZldGNoVHJpYW5nbGVUb1Zpc2l0KHIsbixlLGkpO251bGwhPT1zJiZ0LnZpc2l0KHMpfX19LGlzRnJhbWVFZGdlOmZ1bmN0aW9uKHQpe3JldHVybiEoIXRoaXMuaXNGcmFtZVZlcnRleCh0Lm9yaWcoKSkmJiF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5kZXN0KCkpKX0saXNPbkVkZ2U6ZnVuY3Rpb24odCxlKXt0aGlzLnNlZy5zZXRDb29yZGluYXRlcyh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCksdC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTt2YXIgbj10aGlzLnNlZy5kaXN0YW5jZShlKTtyZXR1cm4gbjx0aGlzLmVkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZX0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEModGhpcy5mcmFtZUVudil9LGNyZWF0ZUZyYW1lOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCksaT0wO2k9ZT5uPzEwKmU6MTAqbix0aGlzLmZyYW1lVmVydGV4WzBdPW5ldyBUcygodC5nZXRNYXhYKCkrdC5nZXRNaW5YKCkpLzIsdC5nZXRNYXhZKCkraSksdGhpcy5mcmFtZVZlcnRleFsxXT1uZXcgVHModC5nZXRNaW5YKCktaSx0LmdldE1pblkoKS1pKSx0aGlzLmZyYW1lVmVydGV4WzJdPW5ldyBUcyh0LmdldE1heFgoKStpLHQuZ2V0TWluWSgpLWkpLHRoaXMuZnJhbWVFbnY9bmV3IEModGhpcy5mcmFtZVZlcnRleFswXS5nZXRDb29yZGluYXRlKCksdGhpcy5mcmFtZVZlcnRleFsxXS5nZXRDb29yZGluYXRlKCkpLHRoaXMuZnJhbWVFbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuZnJhbWVWZXJ0ZXhbMl0uZ2V0Q29vcmRpbmF0ZSgpKX0sZ2V0VHJpYW5nbGVDb29yZGluYXRlczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgenM7cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlcygpfSxnZXRWZXJ0aWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEosbj10aGlzLnF1YWRFZGdlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLm9yaWcoKTshdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHIpfHxlLmFkZChyKTt2YXIgcz1pLmRlc3QoKTshdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHMpfHxlLmFkZChzKX1yZXR1cm4gZX0sZmV0Y2hUcmlhbmdsZVRvVmlzaXQ6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPTAsbz0hMTtkb3t0aGlzLnRyaUVkZ2VzW3NdPXIsdGhpcy5pc0ZyYW1lRWRnZShyKSYmKG89ITApO3ZhciBhPXIuc3ltKCk7aS5jb250YWlucyhhKXx8ZS5wdXNoKGEpLGkuYWRkKHIpLHMrKyxyPXIubE5leHQoKX13aGlsZShyIT09dCk7cmV0dXJuIG8mJiFuP251bGw6dGhpcy50cmlFZGdlc30sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5xdWFkRWRnZXM7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLmdldFByaW1hcnlFZGdlcyghMSksbj1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCksaT0wLHI9ZS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7bltpKytdPXQuY3JlYXRlTGluZVN0cmluZyhbcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHMuZGVzdCgpLmdldENvb3JkaW5hdGUoKV0pfXJldHVybiB0LmNyZWF0ZU11bHRpTGluZVN0cmluZyhuKX19LGdldFZlcnRleFVuaXF1ZUVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPW5ldyBKLGk9dGhpcy5xdWFkRWRnZXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpLHM9ci5vcmlnKCk7bi5jb250YWlucyhzKXx8KG4uYWRkKHMpLCF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocyl8fGUuYWRkKHIpKTt2YXIgbz1yLnN5bSgpLGE9by5vcmlnKCk7bi5jb250YWlucyhhKXx8KG4uYWRkKGEpLCF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgoYSl8fGUuYWRkKG8pKX1yZXR1cm4gZX0sZ2V0VHJpYW5nbGVFZGdlczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgcXM7cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlRWRnZXMoKX0sZ2V0UHJpbWFyeUVkZ2VzOmZ1bmN0aW9uKHQpe3RoaXMudmlzaXRlZEtleSsrO3ZhciBlPW5ldyBJLG49bmV3IHBlO24ucHVzaCh0aGlzLnN0YXJ0aW5nRWRnZSk7Zm9yKHZhciBpPW5ldyBKOyFuLmVtcHR5KCk7KXt2YXIgcj1uLnBvcCgpO2lmKCFpLmNvbnRhaW5zKHIpKXt2YXIgcz1yLmdldFByaW1hcnkoKTshdCYmdGhpcy5pc0ZyYW1lRWRnZShzKXx8ZS5hZGQocyksbi5wdXNoKHIub05leHQoKSksbi5wdXNoKHIuc3ltKCkub05leHQoKSksaS5hZGQociksaS5hZGQoci5zeW0oKSl9fXJldHVybiBlfSxkZWxldGU6ZnVuY3Rpb24odCl7YnMuc3BsaWNlKHQsdC5vUHJldigpKSxicy5zcGxpY2UodC5zeW0oKSx0LnN5bSgpLm9QcmV2KCkpO3ZhciBlPXQuc3ltKCksbj10LnJvdCgpLGk9dC5yb3QoKS5zeW0oKTt0aGlzLnF1YWRFZGdlcy5yZW1vdmUodCksdGhpcy5xdWFkRWRnZXMucmVtb3ZlKGUpLHRoaXMucXVhZEVkZ2VzLnJlbW92ZShuKSx0aGlzLnF1YWRFZGdlcy5yZW1vdmUoaSksdC5kZWxldGUoKSxlLmRlbGV0ZSgpLG4uZGVsZXRlKCksaS5kZWxldGUoKX0sbG9jYXRlRnJvbUVkZ2U6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxpPXRoaXMucXVhZEVkZ2VzLnNpemUoKSxyPWU7Oyl7aWYobisrLG4+aSl0aHJvdyBuZXcgRHMoci50b0xpbmVTZWdtZW50KCkpO2lmKHQuZXF1YWxzKHIub3JpZygpKXx8dC5lcXVhbHMoci5kZXN0KCkpKWJyZWFrO2lmKHQucmlnaHRPZihyKSlyPXIuc3ltKCk7ZWxzZSBpZih0LnJpZ2h0T2Yoci5vTmV4dCgpKSl7aWYodC5yaWdodE9mKHIuZFByZXYoKSkpYnJlYWs7cj1yLmRQcmV2KCl9ZWxzZSByPXIub05leHQoKX1yZXR1cm4gcn0sZ2V0VG9sZXJhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9sZXJhbmNlfSxnZXRWb3Jvbm9pQ2VsbFBvbHlnb25zOmZ1bmN0aW9uKHQpe3RoaXMudmlzaXRUcmlhbmdsZXMobmV3IEdzLCEwKTtmb3IodmFyIGU9bmV3IEksbj10aGlzLmdldFZlcnRleFVuaXF1ZUVkZ2VzKCExKSxpPW4uaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2UuYWRkKHRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29uKHIsdCkpfXJldHVybiBlfSxnZXRWb3Jvbm9pRGlhZ3JhbTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbnModCk7cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheShlKSl9LGdldFRyaWFuZ2xlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5nZXRUcmlhbmdsZUNvb3JkaW5hdGVzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKSxpPTAscj1lLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtuW2krK109dC5jcmVhdGVQb2x5Z29uKHQuY3JlYXRlTGluZWFyUmluZyhzKSxudWxsKX1yZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9LGluc2VydFNpdGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5sb2NhdGUodCk7aWYodC5lcXVhbHMoZS5vcmlnKCksdGhpcy50b2xlcmFuY2UpfHx0LmVxdWFscyhlLmRlc3QoKSx0aGlzLnRvbGVyYW5jZSkpcmV0dXJuIGU7dmFyIG49dGhpcy5tYWtlRWRnZShlLm9yaWcoKSx0KTticy5zcGxpY2UobixlKTt2YXIgaT1uO2RvIG49dGhpcy5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCk7d2hpbGUoZS5sTmV4dCgpIT09aSk7cmV0dXJuIGl9LGxvY2F0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFRzKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubG9jYXRvci5sb2NhdGUodCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubG9jYXRvci5sb2NhdGUobmV3IFRzKGUpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9dGhpcy5sb2NhdG9yLmxvY2F0ZShuZXcgVHMobikpO2lmKG51bGw9PT1yKXJldHVybiBudWxsO3ZhciBzPXI7ci5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKG4pJiYocz1yLnN5bSgpKTt2YXIgbz1zO2Rve2lmKG8uZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRChpKSlyZXR1cm4gbztvPW8ub05leHQoKX13aGlsZShvIT09cyk7cmV0dXJuIG51bGx9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGc319KSxGcy5nZXRUcmlhbmdsZUVkZ2VzPWZ1bmN0aW9uKHQsZSl7aWYoZVswXT10LGVbMV09ZVswXS5sTmV4dCgpLGVbMl09ZVsxXS5sTmV4dCgpLGVbMl0ubE5leHQoKSE9PWVbMF0pdGhyb3cgbmV3IGkoXCJFZGdlcyBkbyBub3QgZm9ybSBhIHRyaWFuZ2xlXCIpfSxlKEdzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRbMF0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxuPXRbMV0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxpPXRbMl0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxyPWNpLmNpcmN1bWNlbnRyZShlLG4saSkscz1uZXcgVHMociksbz0wOzM+bztvKyspdFtvXS5yb3QoKS5zZXRPcmlnKHMpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEdzfX0pLGUocXMucHJvdG90eXBlLHtnZXRUcmlhbmdsZUVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJpTGlzdH0sdmlzaXQ6ZnVuY3Rpb24odCl7dGhpcy50cmlMaXN0LmFkZCh0LmNsb25lKCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHFzfX0pLGUoQnMucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt0aGlzLnRyaUxpc3QuYWRkKFt0WzBdLm9yaWcoKSx0WzFdLm9yaWcoKSx0WzJdLm9yaWcoKV0pfSxnZXRUcmlhbmdsZVZlcnRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJpTGlzdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQXNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCc319KSxlKHpzLnByb3RvdHlwZSx7Y2hlY2tUcmlhbmdsZVNpemU6ZnVuY3Rpb24odCl7dmFyIGU9XCJcIjt0Lmxlbmd0aD49Mj9lPXNlLnRvTGluZVN0cmluZyh0WzBdLHRbMV0pOnQubGVuZ3RoPj0xJiYoZT1zZS50b1BvaW50KHRbMF0pKX0sdmlzaXQ6ZnVuY3Rpb24odCl7dGhpcy5jb29yZExpc3QuY2xlYXIoKTtmb3IodmFyIGU9MDszPmU7ZSsrKXt2YXIgbj10W2VdLm9yaWcoKTt0aGlzLmNvb3JkTGlzdC5hZGQobi5nZXRDb29yZGluYXRlKCkpfWlmKHRoaXMuY29vcmRMaXN0LnNpemUoKT4wKXt0aGlzLmNvb3JkTGlzdC5jbG9zZVJpbmcoKTt2YXIgaT10aGlzLmNvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO2lmKDQhPT1pLmxlbmd0aClyZXR1cm4gbnVsbDt0aGlzLnRyaUNvb3Jkcy5hZGQoaSl9fSxnZXRUcmlhbmdsZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmlDb29yZHN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4genN9fSksRnMuVHJpYW5nbGVDaXJjdW1jZW50cmVWaXNpdG9yPUdzLEZzLlRyaWFuZ2xlRWRnZXNMaXN0VmlzaXRvcj1xcyxGcy5UcmlhbmdsZVZlcnRleExpc3RWaXNpdG9yPUJzLEZzLlRyaWFuZ2xlQ29vcmRpbmF0ZXNWaXNpdG9yPXpzLEZzLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUj0xZTMsZShWcy5wcm90b3R5cGUse2dldExpbmVTZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubHN9LGdldEVuZFo6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMSk7cmV0dXJuIHQuen0sZ2V0U3RhcnRaOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDApO3JldHVybiB0Lnp9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5scy5pbnRlcnNlY3Rpb24odC5nZXRMaW5lU2VnbWVudCgpKX0sZ2V0U3RhcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5scy5nZXRDb29yZGluYXRlKDApfSxnZXRFbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5scy5nZXRDb29yZGluYXRlKDEpfSxnZXRFbmRZOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDEpO3JldHVybiB0Lnl9LGdldFN0YXJ0WDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgwKTtyZXR1cm4gdC54fSxlcXVhbHNUb3BvOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxzLmVxdWFsc1RvcG8odC5nZXRMaW5lU2VnbWVudCgpKX0sZ2V0U3RhcnRZOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDApO3JldHVybiB0Lnl9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxnZXRFbmRYOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDEpO3JldHVybiB0Lnh9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubHMudG9TdHJpbmcoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVnN9fSksZShrcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga3N9fSksZShZcy5wcm90b3R5cGUse2lzUmVwZWF0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb3VudD4xfSxnZXRSaWdodDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJpZ2h0fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucH0sc2V0TGVmdDpmdW5jdGlvbih0KXt0aGlzLmxlZnQ9dH0sZ2V0WDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAueH0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGdldENvdW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY291bnR9LGdldExlZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZWZ0fSxnZXRZOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC55fSxpbmNyZW1lbnQ6ZnVuY3Rpb24oKXt0aGlzLmNvdW50PXRoaXMuY291bnQrMX0sc2V0UmlnaHQ6ZnVuY3Rpb24odCl7dGhpcy5yaWdodD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZc319KSxlKFVzLnByb3RvdHlwZSx7aW5zZXJ0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnNlcnQodCxudWxsKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKG51bGw9PT10aGlzLnJvb3QpcmV0dXJuIHRoaXMucm9vdD1uZXcgWXMoZSxuKSx0aGlzLnJvb3Q7aWYodGhpcy50b2xlcmFuY2U+MCl7dmFyIGk9dGhpcy5maW5kQmVzdE1hdGNoTm9kZShlKTtpZihudWxsIT09aSlyZXR1cm4gaS5pbmNyZW1lbnQoKSxpfXJldHVybiB0aGlzLmluc2VydEV4YWN0KGUsbil9fSxxdWVyeTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cyxlPXRoaXM7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPW5ldyBJO3JldHVybiB0aGlzLnF1ZXJ5KG4saSksaX1pZigyPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMmJlIoYXJndW1lbnRzWzFdLHkpKSFmdW5jdGlvbigpe3ZhciBuPXRbMF0saT10WzFdO2UucXVlcnlOb2RlKGUucm9vdCxuLCEwLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltrc119LHZpc2l0OmZ1bmN0aW9uKHQpe2kuYWRkKHQpfX0pfSgpO2Vsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDJiZSKGFyZ3VtZW50c1sxXSxrcykpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXTt0aGlzLnF1ZXJ5Tm9kZSh0aGlzLnJvb3QsciwhMCxzKX19LHF1ZXJ5Tm9kZTpmdW5jdGlvbih0LGUsbixpKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDt2YXIgcj1udWxsLHM9bnVsbCxvPW51bGw7bj8ocj1lLmdldE1pblgoKSxzPWUuZ2V0TWF4WCgpLG89dC5nZXRYKCkpOihyPWUuZ2V0TWluWSgpLHM9ZS5nZXRNYXhZKCksbz10LmdldFkoKSk7dmFyIGE9bz5yLHU9cz49bzthJiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldExlZnQoKSxlLCFuLGkpLGUuY29udGFpbnModC5nZXRDb29yZGluYXRlKCkpJiZpLnZpc2l0KHQpLHUmJnRoaXMucXVlcnlOb2RlKHQuZ2V0UmlnaHQoKSxlLCFuLGkpfSxmaW5kQmVzdE1hdGNoTm9kZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgWHModCx0aGlzLnRvbGVyYW5jZSk7cmV0dXJuIHRoaXMucXVlcnkoZS5xdWVyeUVudmVsb3BlKCksZSksZS5nZXROb2RlKCl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMucm9vdH0saW5zZXJ0RXhhY3Q6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5yb290LGk9dGhpcy5yb290LHI9ITAscz0hMDtudWxsIT09bjspe2lmKG51bGwhPT1uKXt2YXIgbz10LmRpc3RhbmNlKG4uZ2V0Q29vcmRpbmF0ZSgpKTw9dGhpcy50b2xlcmFuY2U7aWYobylyZXR1cm4gbi5pbmNyZW1lbnQoKSxufXM9cj90Lng8bi5nZXRYKCk6dC55PG4uZ2V0WSgpLGk9bixuPXM/bi5nZXRMZWZ0KCk6bi5nZXRSaWdodCgpLHI9IXJ9dGhpcy5udW1iZXJPZk5vZGVzPXRoaXMubnVtYmVyT2ZOb2RlcysxO3ZhciBhPW5ldyBZcyh0LGUpO3JldHVybiBzP2kuc2V0TGVmdChhKTppLnNldFJpZ2h0KGEpLGF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFVzfX0pLFVzLnRvQ29vcmRpbmF0ZXM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBVcy50b0Nvb3JkaW5hdGVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9bmV3IE4scj1lLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KWZvcih2YXIgcz1yLm5leHQoKSxvPW4/cy5nZXRDb3VudCgpOjEsYT0wO28+YTthKyspaS5hZGQocy5nZXRDb29yZGluYXRlKCksITApO3JldHVybiBpLnRvQ29vcmRpbmF0ZUFycmF5KCl9fSxlKFhzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wLmRpc3RhbmNlKHQuZ2V0Q29vcmRpbmF0ZSgpKSxuPWU8PXRoaXMudG9sZXJhbmNlO2lmKCFuKXJldHVybiBudWxsO3ZhciBpPSExOyhudWxsPT09dGhpcy5tYXRjaE5vZGV8fGU8dGhpcy5tYXRjaERpc3R8fG51bGwhPT10aGlzLm1hdGNoTm9kZSYmZT09PXRoaXMubWF0Y2hEaXN0JiZ0LmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5tYXRjaE5vZGUuZ2V0Q29vcmRpbmF0ZSgpKTwxKSYmKGk9ITApLGkmJih0aGlzLm1hdGNoTm9kZT10LHRoaXMubWF0Y2hEaXN0PWUpfSxxdWVyeUVudmVsb3BlOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEModGhpcy5wKTtyZXR1cm4gdC5leHBhbmRCeSh0aGlzLnRvbGVyYW5jZSksdH0sZ2V0Tm9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hdGNoTm9kZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5ba3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYc319KSxVcy5CZXN0TWF0Y2hWaXNpdG9yPVhzLGUoSHMucHJvdG90eXBlLHtnZXRJbml0aWFsVmVydGljZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbml0aWFsVmVydGljZXN9LGdldEtEVDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmtkdH0sZW5mb3JjZUNvbnN0cmFpbnRzOmZ1bmN0aW9uKCl7dGhpcy5hZGRDb25zdHJhaW50VmVydGljZXMoKTt2YXIgdD0wLGU9MDtkbyBlPXRoaXMuZW5mb3JjZUdhYnJpZWwodGhpcy5zZWdtZW50cyksdCsrO3doaWxlKGU+MCYmdDxIcy5NQVhfU1BMSVRfSVRFUil9LGluc2VydFNpdGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUobil9fSxnZXRWZXJ0ZXhGYWN0b3J5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmVydGV4RmFjdG9yeX0sZ2V0UG9pbnRBcnJheTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5pbml0aWFsVmVydGljZXMuc2l6ZSgpK3RoaXMuc2VnVmVydGljZXMuc2l6ZSgpKS5maWxsKG51bGwpLGU9MCxuPXRoaXMuaW5pdGlhbFZlcnRpY2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0W2UrK109aS5nZXRDb29yZGluYXRlKCl9Zm9yKHZhciByPXRoaXMuc2VnVmVydGljZXMuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBpPXIubmV4dCgpO3RbZSsrXT1pLmdldENvb3JkaW5hdGUoKX1yZXR1cm4gdH0sc2V0Q29uc3RyYWludHM6ZnVuY3Rpb24odCxlKXt0aGlzLnNlZ21lbnRzPXQsdGhpcy5zZWdWZXJ0aWNlcz1lfSxjb21wdXRlQ29udmV4SHVsbDpmdW5jdGlvbigpe3ZhciB0PW5ldyBpZSxlPXRoaXMuZ2V0UG9pbnRBcnJheSgpLG49bmV3IG1lKGUsdCk7dGhpcy5jb252ZXhIdWxsPW4uZ2V0Q29udmV4SHVsbCgpfSxhZGRDb25zdHJhaW50VmVydGljZXM6ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVDb252ZXhIdWxsKCksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLnNlZ1ZlcnRpY2VzKX0sZmluZE5vbkdhYnJpZWxQb2ludDpmdW5jdGlvbih0KXt2YXIgZT10LmdldFN0YXJ0KCksbj10LmdldEVuZCgpLGk9bmV3IGcoKGUueCtuLngpLzIsKGUueStuLnkpLzIpLHM9ZS5kaXN0YW5jZShpKSxvPW5ldyBDKGkpO28uZXhwYW5kQnkocyk7Zm9yKHZhciBhPXRoaXMua2R0LnF1ZXJ5KG8pLHU9bnVsbCxsPXIuTUFYX1ZBTFVFLGg9YS5pdGVyYXRvcigpO2guaGFzTmV4dCgpOyl7dmFyIGM9aC5uZXh0KCksZj1jLmdldENvb3JkaW5hdGUoKTtpZighZi5lcXVhbHMyRChlKSYmIWYuZXF1YWxzMkQobikpe3ZhciBkPWkuZGlzdGFuY2UoZik7aWYocz5kKXt2YXIgcD1kOyhudWxsPT09dXx8bD5wKSYmKHU9ZixsPXApfX19cmV0dXJuIHV9LGdldENvbnN0cmFpbnRTZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ21lbnRzfSxzZXRTcGxpdFBvaW50RmluZGVyOmZ1bmN0aW9uKHQpe3RoaXMuc3BsaXRGaW5kZXI9dH0sZ2V0Q29udmV4SHVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnZleEh1bGx9LGdldFRvbGVyYW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvbGVyYW5jZX0sZW5mb3JjZUdhYnJpZWw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49MCxpPW5ldyBJLHI9dC5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz10aGlzLmZpbmROb25HYWJyaWVsUG9pbnQocyk7aWYobnVsbCE9PW8pe3RoaXMuc3BsaXRQdD10aGlzLnNwbGl0RmluZGVyLmZpbmRTcGxpdFBvaW50KHMsbyk7dmFyIGE9dGhpcy5jcmVhdGVWZXJ0ZXgodGhpcy5zcGxpdFB0LHMpLHU9KHRoaXMuaW5zZXJ0U2l0ZShhKSxuZXcgVnMocy5nZXRTdGFydFgoKSxzLmdldFN0YXJ0WSgpLHMuZ2V0U3RhcnRaKCksYS5nZXRYKCksYS5nZXRZKCksYS5nZXRaKCkscy5nZXREYXRhKCkpKSxsPW5ldyBWcyhhLmdldFgoKSxhLmdldFkoKSxhLmdldFooKSxzLmdldEVuZFgoKSxzLmdldEVuZFkoKSxzLmdldEVuZFooKSxzLmdldERhdGEoKSk7ZS5hZGQodSksZS5hZGQobCksaS5hZGQocyksbis9MX19cmV0dXJuIHQucmVtb3ZlQWxsKGkpLHQuYWRkQWxsKGUpLG59LGNyZWF0ZVZlcnRleDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1udWxsO3JldHVybiBlPW51bGwhPT10aGlzLnZlcnRleEZhY3Rvcnk/dGhpcy52ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleCh0LG51bGwpOm5ldyBQcyh0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLGU9bnVsbDtyZXR1cm4gZT1udWxsIT09dGhpcy52ZXJ0ZXhGYWN0b3J5P3RoaXMudmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgobixpKTpuZXcgUHMobiksZS5zZXRPbkNvbnN0cmFpbnQoITApLGV9fSxnZXRTdWJkaXZpc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN1YmRpdn0sY29tcHV0ZUJvdW5kaW5nQm94OmZ1bmN0aW9uKCl7dmFyIHQ9SHMuY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuaW5pdGlhbFZlcnRpY2VzKSxlPUhzLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLnNlZ1ZlcnRpY2VzKSxuPW5ldyBDKHQpO24uZXhwYW5kVG9JbmNsdWRlKGUpO3ZhciBpPS4yKm4uZ2V0V2lkdGgoKSxyPS4yKm4uZ2V0SGVpZ2h0KCkscz1NYXRoLm1heChpLHIpO3RoaXMuY29tcHV0ZUFyZWFFbnY9bmV3IEMobiksdGhpcy5jb21wdXRlQXJlYUVudi5leHBhbmRCeShzKX0sc2V0VmVydGV4RmFjdG9yeTpmdW5jdGlvbih0KXt0aGlzLnZlcnRleEZhY3Rvcnk9dH0sZm9ybUluaXRpYWxEZWxhdW5heTpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5zdWJkaXY9bmV3IEZzKHRoaXMuY29tcHV0ZUFyZWFFbnYsdGhpcy50b2xlcmFuY2UpLHRoaXMuc3ViZGl2LnNldExvY2F0b3IobmV3IE1zKHRoaXMuc3ViZGl2KSksdGhpcy5pbmNEZWw9bmV3IE9zKHRoaXMuc3ViZGl2KSx0aGlzLmluc2VydFNpdGVzKHRoaXMuaW5pdGlhbFZlcnRpY2VzKX0saW5zZXJ0U2l0ZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUHMpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMua2R0Lmluc2VydCh0LmdldENvb3JkaW5hdGUoKSx0KTtpZihlLmlzUmVwZWF0ZWQoKSl7dmFyIG49ZS5nZXREYXRhKCk7cmV0dXJuIG4ubWVyZ2UodCksbn1yZXR1cm4gdGhpcy5pbmNEZWwuaW5zZXJ0U2l0ZSh0KSx0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGk9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0U2l0ZSh0aGlzLmNyZWF0ZVZlcnRleChpKSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIc319KSxIcy5jb21wdXRlVmVydGV4RW52ZWxvcGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBDLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5leHBhbmRUb0luY2x1ZGUoaS5nZXRDb29yZGluYXRlKCkpfXJldHVybiBlfSxIcy5NQVhfU1BMSVRfSVRFUj05OSxlKFdzLnByb3RvdHlwZSx7Y3JlYXRlOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMuc3ViZGl2KXJldHVybiBudWxsO3ZhciB0PVdzLmVudmVsb3BlKHRoaXMuc2l0ZUNvb3JkcyksZT1Xcy50b1ZlcnRpY2VzKHRoaXMuc2l0ZUNvb3Jkcyk7dGhpcy5zdWJkaXY9bmV3IEZzKHQsdGhpcy50b2xlcmFuY2UpO3ZhciBuPW5ldyBPcyh0aGlzLnN1YmRpdik7bi5pbnNlcnRTaXRlcyhlKX0sc2V0VG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMudG9sZXJhbmNlPXR9LHNldFNpdGVzOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zaXRlQ29vcmRzPVdzLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHYpKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5zaXRlQ29vcmRzPVdzLnVuaXF1ZShILnRvQ29vcmRpbmF0ZUFycmF5KGUpKX19LGdldEVkZ2VzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2LmdldEVkZ2VzKHQpfSxnZXRTdWJkaXZpc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2fSxnZXRUcmlhbmdsZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXc319KSxXcy5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXM9ZnVuY3Rpb24odCl7aWYobnVsbD09PXQpcmV0dXJuIG5ldyBOO3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gV3MudW5pcXVlKGUpfSxXcy5lbnZlbG9wZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEMsbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZShpKX1yZXR1cm4gZX0sV3MudW5pcXVlPWZ1bmN0aW9uKHQpe3ZhciBlPUguY29weURlZXAodCk7dXQuc29ydChlKTt2YXIgbj1uZXcgTihlLCExKTtyZXR1cm4gbn0sV3MudG9WZXJ0aWNlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmFkZChuZXcgVHMoaSkpfXJldHVybiBlfSxlKGpzLnByb3RvdHlwZSx7Y3JlYXRlU2l0ZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuY29uc3RyYWludFZlcnRleE1hcC5jb250YWluc0tleShpKXx8ZS5hZGQobmV3IFBzKGkpKX1yZXR1cm4gZX0sY3JlYXRlOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMuc3ViZGl2KXJldHVybiBudWxsO3ZhciB0PVdzLmVudmVsb3BlKHRoaXMuc2l0ZUNvb3JkcyksZT1uZXcgSTtudWxsIT09dGhpcy5jb25zdHJhaW50TGluZXMmJih0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmNvbnN0cmFpbnRMaW5lcy5nZXRFbnZlbG9wZUludGVybmFsKCkpLHRoaXMuY3JlYXRlVmVydGljZXModGhpcy5jb25zdHJhaW50TGluZXMpLGU9anMuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKHRoaXMuY29uc3RyYWludExpbmVzKSk7dmFyIG49dGhpcy5jcmVhdGVTaXRlVmVydGljZXModGhpcy5zaXRlQ29vcmRzKSxpPW5ldyBIcyhuLHRoaXMudG9sZXJhbmNlKTtpLnNldENvbnN0cmFpbnRzKGUsbmV3IEkodGhpcy5jb25zdHJhaW50VmVydGV4TWFwLnZhbHVlcygpKSksaS5mb3JtSW5pdGlhbERlbGF1bmF5KCksaS5lbmZvcmNlQ29uc3RyYWludHMoKSx0aGlzLnN1YmRpdj1pLmdldFN1YmRpdmlzaW9uKCl9LHNldFRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLnRvbGVyYW5jZT10fSxzZXRDb25zdHJhaW50czpmdW5jdGlvbih0KXt0aGlzLmNvbnN0cmFpbnRMaW5lcz10fSxzZXRTaXRlczpmdW5jdGlvbih0KXt0aGlzLnNpdGVDb29yZHM9V3MuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfSxnZXRFZGdlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRFZGdlcyh0KX0sZ2V0U3ViZGl2aXNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdn0sZ2V0VHJpYW5nbGVzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX0sY3JlYXRlVmVydGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0Q29vcmRpbmF0ZXMoKSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPW5ldyBQcyhlW25dKTt0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXAucHV0KGVbbl0saSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqc319KSxqcy5jcmVhdGVDb25zdHJhaW50U2VnbWVudHM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPWtuLmdldExpbmVzKHQpLG49bmV3IEksaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtqcy5jcmVhdGVDb25zdHJhaW50U2VnbWVudHMocixuKX1yZXR1cm4gbn1pZigyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9cy5nZXRDb29yZGluYXRlcygpLGk9MTtpPGEubGVuZ3RoO2krKylvLmFkZChuZXcgVnMoYVtpLTFdLGFbaV0pKX0sZShLcy5wcm90b3R5cGUse2NyZWF0ZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnN1YmRpdilyZXR1cm4gbnVsbDt2YXIgdD1Xcy5lbnZlbG9wZSh0aGlzLnNpdGVDb29yZHMpO3RoaXMuZGlhZ3JhbUVudj10O3ZhciBlPU1hdGgubWF4KHRoaXMuZGlhZ3JhbUVudi5nZXRXaWR0aCgpLHRoaXMuZGlhZ3JhbUVudi5nZXRIZWlnaHQoKSk7dGhpcy5kaWFncmFtRW52LmV4cGFuZEJ5KGUpLG51bGwhPT10aGlzLmNsaXBFbnYmJnRoaXMuZGlhZ3JhbUVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5jbGlwRW52KTt2YXIgbj1Xcy50b1ZlcnRpY2VzKHRoaXMuc2l0ZUNvb3Jkcyk7dGhpcy5zdWJkaXY9bmV3IEZzKHQsdGhpcy50b2xlcmFuY2UpO3ZhciBpPW5ldyBPcyh0aGlzLnN1YmRpdik7aS5pbnNlcnRTaXRlcyhuKX0sZ2V0RGlhZ3JhbTpmdW5jdGlvbih0KXt0aGlzLmNyZWF0ZSgpO3ZhciBlPXRoaXMuc3ViZGl2LmdldFZvcm9ub2lEaWFncmFtKHQpO3JldHVybiBLcy5jbGlwR2VvbWV0cnlDb2xsZWN0aW9uKGUsdGhpcy5kaWFncmFtRW52KX0sc2V0VG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMudG9sZXJhbmNlPXR9LHNldFNpdGVzOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zaXRlQ29vcmRzPVdzLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHYpKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5zaXRlQ29vcmRzPVdzLnVuaXF1ZShILnRvQ29vcmRpbmF0ZUFycmF5KGUpKX19LHNldENsaXBFbnZlbG9wZTpmdW5jdGlvbih0KXt0aGlzLmNsaXBFbnY9dH0sZ2V0U3ViZGl2aXNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS3N9fSksS3MuY2xpcEdlb21ldHJ5Q29sbGVjdGlvbj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KGUpLGk9bmV3IEkscj0wO3I8dC5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXt2YXIgcz10LmdldEdlb21ldHJ5TihyKSxvPW51bGw7ZS5jb250YWlucyhzLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/bz1zOmUuaW50ZXJzZWN0cyhzLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJihvPW4uaW50ZXJzZWN0aW9uKHMpLG8uc2V0VXNlckRhdGEocy5nZXRVc2VyRGF0YSgpKSksbnVsbD09PW98fG8uaXNFbXB0eSgpfHxpLmFkZChvKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheShpKSl9O3ZhciBEbz1PYmplY3QuZnJlZXplKHtDb25mb3JtaW5nRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpqcyxEZWxhdW5heVRyaWFuZ3VsYXRpb25CdWlsZGVyOldzLFZvcm9ub2lEaWFncmFtQnVpbGRlcjpLc30pO2UoWnMucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBac319KSxacy51bmlvbj1mdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBpaS5jcmVhdGVFbXB0eVJlc3VsdChpaS5VTklPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9cmV0dXJuIHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxzaS5vdmVybGF5T3AodCxlLGlpLlVOSU9OKX0sZShCLnByb3RvdHlwZSx7ZXF1YWxzVG9wbzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuZXF1YWxzKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9Zci5yZWxhdGUodGhpcyx0KS5pc0VxdWFscyh0aGlzLmdldERpbWVuc2lvbigpLHQuZ2V0RGltZW5zaW9uKCkpOiExfSx1bmlvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBqci51bmlvbih0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBacy51bmlvbih0aGlzLHQpfX0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiBscy5pc1ZhbGlkKHRoaXMpfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7aWYodGhpcy5pc0VtcHR5KCl8fHQuaXNFbXB0eSgpKXJldHVybiBpaS5jcmVhdGVFbXB0eVJlc3VsdChpaS5JTlRFUlNFQ1RJT04sdGhpcyx0LHRoaXMuZmFjdG9yeSk7aWYodGhpcy5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXt2YXIgZT10O3JldHVybiBobi5tYXAodGhpcyx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTWFwT3BdfSxtYXA6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKGUpfX0pfXJldHVybiB0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksc2kub3ZlcmxheU9wKHRoaXMsdCxpaS5JTlRFUlNFQ1RJT04pfSxjb3ZlcnM6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLmNvdmVycyh0aGlzLHQpfSxjb3ZlcmVkQnk6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLmNvdmVyZWRCeSh0aGlzLHQpfSx0b3VjaGVzOmZ1bmN0aW9uKHQpe3JldHVybiBZci50b3VjaGVzKHRoaXMsdCl9LGludGVyc2VjdHM6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLmludGVyc2VjdHModGhpcyx0KX0sd2l0aGluOmZ1bmN0aW9uKHQpe3JldHVybiBZci53aXRoaW4odGhpcyx0KX0sb3ZlcmxhcHM6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLm92ZXJsYXBzKHRoaXMsdCl9LGRpc2pvaW50OmZ1bmN0aW9uKHQpe3JldHVybiBZci5kaXNqb2ludCh0aGlzLHQpfSxjcm9zc2VzOmZ1bmN0aW9uKHQpe3JldHVybiBZci5jcm9zc2VzKHRoaXMsdCl9LGJ1ZmZlcjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHNyLmJ1ZmZlck9wKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gc3IuYnVmZmVyT3AodGhpcyxlLG4pfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07cmV0dXJuIHNyLmJ1ZmZlck9wKHRoaXMsaSxyLHMpfX0sY29udmV4SHVsbDpmdW5jdGlvbigpe3JldHVybiBuZXcgbWUodGhpcykuZ2V0Q29udmV4SHVsbCgpfSxyZWxhdGU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxlPUFycmF5KHQpLG49MDt0Pm47bisrKWVbbl09YXJndW1lbnRzW25dO3JldHVybiBZci5yZWxhdGUuYXBwbHkoWXIsW3RoaXNdLmNvbmNhdChlKSl9LGdldENlbnRyb2lkOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2ludCgpO3ZhciB0PWdlLmdldENlbnRyb2lkKHRoaXMpO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCx0aGlzKX0sZ2V0SW50ZXJpb3JQb2ludDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9pbnQoKTt2YXIgdD1udWxsLGU9dGhpcy5nZXREaW1lbnNpb24oKTtpZigwPT09ZSl7dmFyIG49bmV3IGxpKHRoaXMpO3Q9bi5nZXRJbnRlcmlvclBvaW50KCl9ZWxzZSBpZigxPT09ZSl7dmFyIG49bmV3IHVpKHRoaXMpO3Q9bi5nZXRJbnRlcmlvclBvaW50KCl9ZWxzZXt2YXIgbj1uZXcgb2kodGhpcyk7dD1uLmdldEludGVyaW9yUG9pbnQoKX1yZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsdGhpcyl9LHN5bURpZmZlcmVuY2U6ZnVuY3Rpb24odCl7aWYodGhpcy5pc0VtcHR5KCl8fHQuaXNFbXB0eSgpKXtpZih0aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLlNZTURJRkZFUkVOQ0UsdGhpcyx0LHRoaXMuZmFjdG9yeSk7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpO2lmKHQuaXNFbXB0eSgpKXJldHVybiB0aGlzLmNvcHkoKX1yZXR1cm4gdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSx0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHNpLm92ZXJsYXlPcCh0aGlzLHQsaWkuU1lNRElGRkVSRU5DRSl9LGNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfSx0b1RleHQ6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgc2U7cmV0dXJuIHQud3JpdGUodGhpcyl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dGhpcy50b1RleHQoKX0sY29udGFpbnM6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLmNvbnRhaW5zKHRoaXMsdCl9LGRpZmZlcmVuY2U6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2lpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLkRJRkZFUkVOQ0UsdGhpcyx0LHRoaXMuZmFjdG9yeSk6dC5pc0VtcHR5KCk/dGhpcy5jb3B5KCk6KHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSxzaS5vdmVybGF5T3AodGhpcyx0LGlpLkRJRkZFUkVOQ0UpKX0saXNTaW1wbGU6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgR2kodGhpcyk7cmV0dXJuIHQuaXNTaW1wbGUoKX0saXNXaXRoaW5EaXN0YW5jZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4gbj5lPyExOmhyLmlzV2l0aGluRGlzdGFuY2UodGhpcyx0LGUpfSxkaXN0YW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gaHIuZGlzdGFuY2UodGhpcyx0KX0saXNFcXVpdmFsZW50Q2xhc3M6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0Q2xhc3MoKT09PXQuZ2V0Q2xhc3MoKX19KTt2YXIgQW89XCIxLjEuMiAoMjQ4ZGFiOClcIjt0LnZlcnNpb249QW8sdC5hbGdvcml0aG09Y28sdC5kZW5zaWZ5PWZvLHQuZGlzc29sdmU9Z28sdC5nZW9tPWxvLHQuaW5kZXg9bW8sdC5pbz1Jbyx0Lm5vZGluZz1Obyx0Lm9wZXJhdGlvbj1Pbyx0LnByZWNpc2lvbj1fbyx0LnNpbXBsaWZ5PU1vLHQudHJpYW5ndWxhdGU9RG99KTtcbiIsIid1c2Ugc3RyaWN0JztcbihmdW5jdGlvbiAoZmFjdG9yeSwgd2luZG93KSB7XG4gICAgLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlKi9cblxuICAgIC8vIGRlZmluZSBhbiBBTUQgbW9kdWxlIHRoYXQgcmVsaWVzIG9uICdsZWFmbGV0J1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnbGVhZmxldCddLCBmYWN0b3J5KTtcblxuXG4gICAgLy8gZGVmaW5lIGEgQ29tbW9uIEpTIG1vZHVsZSB0aGF0IHJlbGllcyBvbiAnbGVhZmxldCdcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnbGVhZmxldCcpKTtcbiAgICB9XG5cbiAgICAvLyBhdHRhY2ggeW91ciBwbHVnaW4gdG8gdGhlIGdsb2JhbCAnTCcgdmFyaWFibGVcbiAgICBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTCl7XG4gICAgICAgIGZhY3Rvcnkod2luZG93LkwpO1xuICAgIH1cblxufShmdW5jdGlvbiAoTCkge1xuICAgIEwuRWRpdGFibGUgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuICAgICAgICBzdGF0aWNzOiB7XG4gICAgICAgICAgICBGT1JXQVJEOiAxLFxuICAgICAgICAgICAgQkFDS1dBUkQ6IC0xXG4gICAgICAgIH0sXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgekluZGV4OiAxMDAwLFxuICAgICAgICAgICAgcG9seWdvbkNsYXNzOiBMLlBvbHlnb24sXG4gICAgICAgICAgICBwb2x5bGluZUNsYXNzOiBMLlBvbHlsaW5lLFxuICAgICAgICAgICAgbWFya2VyQ2xhc3M6IEwuTWFya2VyLFxuICAgICAgICAgICAgcmVjdGFuZ2xlQ2xhc3M6IEwuUmVjdGFuZ2xlLFxuICAgICAgICAgICAgY2lyY2xlQ2xhc3M6IEwuQ2lyY2xlLFxuICAgICAgICAgICAgZHJhd2luZ0NTU0NsYXNzOiAnbGVhZmxldC1lZGl0YWJsZS1kcmF3aW5nJyxcbiAgICAgICAgICAgIGRyYXdpbmdDdXJzb3I6ICdjcm9zc2hhaXInXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyID0gdGhpcy5jcmVhdGVFZGl0TGF5ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNMYXllciA9IHRoaXMuY3JlYXRlRmVhdHVyZXNMYXllcigpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlID0gdGhpcy5jcmVhdGVMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUgPSB0aGlzLmNyZWF0ZUxpbmVHdWlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcmVBbmRGb3J3YXJkOiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICAgICAgZSA9IGUgfHwge307XG4gICAgICAgICAgICBlLmVkaXRUb29scyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmZpcmUodHlwZSwgZSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5maXJlKHR5cGUsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUxpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBMLmV4dGVuZCh7ZGFzaEFycmF5OiAnNSwxMCcsIHdlaWdodDogMSwgaW50ZXJhY3RpdmU6IGZhbHNlfSwgdGhpcy5vcHRpb25zLmxpbmVHdWlkZU9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIEwucG9seWxpbmUoW10sIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVZlcnRleEljb246IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gTC5Ccm93c2VyLnRvdWNoID8gbmV3IEwuRWRpdGFibGUuVG91Y2hWZXJ0ZXhJY29uKG9wdGlvbnMpIDogbmV3IEwuRWRpdGFibGUuVmVydGV4SWNvbihvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVFZGl0TGF5ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdExheWVyIHx8IG5ldyBMLkxheWVyR3JvdXAoKS5hZGRUbyh0aGlzLm1hcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRmVhdHVyZXNMYXllcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mZWF0dXJlc0xheWVyIHx8IG5ldyBMLkxheWVyR3JvdXAoKS5hZGRUbyh0aGlzLm1hcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZUZvcndhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLl9sYXRsbmdzWzFdID0gbGF0bG5nO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlQmFja3dhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2t3YXJkTGluZUd1aWRlLl9sYXRsbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMV0gPSBsYXRsbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW5jaG9yRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLl9sYXRsbmdzWzBdID0gbGF0bG5nO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUucmVkcmF3KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW5jaG9yQmFja3dhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMF0gPSBsYXRsbmc7XG4gICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLnJlZHJhdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaEZvcndhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmFkZExheWVyKHRoaXMuZm9yd2FyZExpbmVHdWlkZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoQmFja3dhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmFkZExheWVyKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaEZvcndhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5zZXRMYXRMbmdzKFtdKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMuZm9yd2FyZExpbmVHdWlkZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoQmFja3dhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuc2V0TGF0TG5ncyhbXSk7XG4gICAgICAgICAgICB0aGlzLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzLmJhY2t3YXJkTGluZUd1aWRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBibG9ja0V2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSGFjazogZm9yY2UgbWFwIG5vdCB0byBsaXN0ZW4gdG8gb3RoZXIgbGF5ZXJzIGV2ZW50cyB3aGlsZSBkcmF3aW5nLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vbGRUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkVGFyZ2V0cyA9IHRoaXMubWFwLl90YXJnZXRzO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLl90YXJnZXRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5ibG9ja0V2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29sZFRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCwgYnV0IGtlZXAgdGFyZ2V0cyBjcmVhdGVkIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuX3RhcmdldHMgPSBMLmV4dGVuZCh0aGlzLm1hcC5fdGFyZ2V0cywgdGhpcy5fb2xkVGFyZ2V0cyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29sZFRhcmdldHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVnaXN0ZXJGb3JEcmF3aW5nOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZ0VkaXRvcikgdGhpcy51bnJlZ2lzdGVyRm9yRHJhd2luZyh0aGlzLl9kcmF3aW5nRWRpdG9yKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZWRpdG9yLm9uRHJhd2luZ01vdXNlTW92ZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgICB0aGlzLm1hcC5vbignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93biwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1hcC5vbignbW91c2V1cCcsIHRoaXMub25Nb3VzZXVwLCB0aGlzKTtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLm1hcC5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMuZHJhd2luZ0NTU0NsYXNzKTtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdE1hcEN1cnNvciA9IHRoaXMubWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yO1xuICAgICAgICAgICAgdGhpcy5tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSB0aGlzLm9wdGlvbnMuZHJhd2luZ0N1cnNvcjtcbiAgICAgICAgfSxcblxuICAgICAgICB1bnJlZ2lzdGVyRm9yRHJhd2luZzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdGhpcy51bmJsb2NrRXZlbnRzKCk7XG4gICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5tYXAuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLmRyYXdpbmdDU1NDbGFzcyk7XG4gICAgICAgICAgICB0aGlzLm1hcC5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9IHRoaXMuZGVmYXVsdE1hcEN1cnNvcjtcbiAgICAgICAgICAgIGVkaXRvciA9IGVkaXRvciB8fCB0aGlzLl9kcmF3aW5nRWRpdG9yO1xuICAgICAgICAgICAgaWYgKCFlZGl0b3IpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubWFwLm9mZignbW91c2Vtb3ZlIHRvdWNobW92ZScsIGVkaXRvci5vbkRyYXdpbmdNb3VzZU1vdmUsIGVkaXRvcik7XG4gICAgICAgICAgICB0aGlzLm1hcC5vZmYoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZWRvd24sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5tYXAub2ZmKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNldXAsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGVkaXRvciAhPT0gdGhpcy5fZHJhd2luZ0VkaXRvcikgcmV0dXJuO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2RyYXdpbmdFZGl0b3I7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLl9kcmF3aW5nKSBlZGl0b3IuY2FuY2VsRHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2Vkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VEb3duID0gZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdFZGl0b3Iub25EcmF3aW5nTW91c2VEb3duKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2V1cDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZURvd24pIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gTC5wb2ludCh0aGlzLl9tb3VzZURvd24ub3JpZ2luYWxFdmVudC5jbGllbnRYLCB0aGlzLl9tb3VzZURvd24ub3JpZ2luYWxFdmVudC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBMLnBvaW50KGUub3JpZ2luYWxFdmVudC5jbGllbnRYLCBlLm9yaWdpbmFsRXZlbnQuY2xpZW50WSkuZGlzdGFuY2VUbyhvcmlnaW4pO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZSkgPCA5ICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSB0aGlzLl9kcmF3aW5nRWRpdG9yLm9uRHJhd2luZ0NsaWNrKGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5fZHJhd2luZ0VkaXRvci5vbkRyYXdpbmdNb3VzZVVwKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW91c2VEb3duID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJhd2luZ0VkaXRvciAmJiB0aGlzLl9kcmF3aW5nRWRpdG9yLmRyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wRHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyRm9yRHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbW1pdERyYXdpbmc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdpbmdFZGl0b3IpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdFZGl0b3IuY29tbWl0RHJhd2luZyhlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb25uZWN0Q3JlYXRlZFRvTWFwOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzTGF5ZXIuYWRkTGF5ZXIobGF5ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0UG9seWxpbmU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5jcmVhdGVQb2x5bGluZShbXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBsaW5lLmVuYWJsZUVkaXQodGhpcy5tYXApLm5ld1NoYXBlKGxhdGxuZyk7XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydFBvbHlnb246IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5jcmVhdGVQb2x5Z29uKFtdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHBvbHlnb24uZW5hYmxlRWRpdCh0aGlzLm1hcCkubmV3U2hhcGUobGF0bG5nKTtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0TWFya2VyOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBsYXRsbmcgPSBsYXRsbmcgfHwgdGhpcy5tYXAuZ2V0Q2VudGVyKCkuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmNyZWF0ZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbWFya2VyLmVuYWJsZUVkaXQodGhpcy5tYXApLnN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydFJlY3RhbmdsZTogZnVuY3Rpb24obGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY29ybmVyID0gbGF0bG5nIHx8IEwubGF0TG5nKFswLCAwXSk7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKGNvcm5lciwgY29ybmVyKTtcbiAgICAgICAgICAgIHZhciByZWN0YW5nbGUgPSB0aGlzLmNyZWF0ZVJlY3RhbmdsZShib3VuZHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmVjdGFuZ2xlLmVuYWJsZUVkaXQodGhpcy5tYXApLnN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydENpcmNsZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgbGF0bG5nID0gbGF0bG5nIHx8IHRoaXMubWFwLmdldENlbnRlcigpLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgY2lyY2xlID0gdGhpcy5jcmVhdGVDaXJjbGUobGF0bG5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNpcmNsZS5lbmFibGVFZGl0KHRoaXMubWFwKS5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnRIb2xlOiBmdW5jdGlvbiAoZWRpdG9yLCBsYXRsbmcpIHtcbiAgICAgICAgICAgIGVkaXRvci5uZXdIb2xlKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTGF5ZXI6IGZ1bmN0aW9uIChrbGFzcywgbGF0bG5ncywgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoe2VkaXRPcHRpb25zOiB7ZWRpdFRvb2xzOiB0aGlzfX0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGxheWVyID0gbmV3IGtsYXNzKGxhdGxuZ3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6Y3JlYXRlZCcsIHtsYXllcjogbGF5ZXJ9KTtcbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQb2x5bGluZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKG9wdGlvbnMgJiYgb3B0aW9ucy5wb2x5bGluZUNsYXNzIHx8IHRoaXMub3B0aW9ucy5wb2x5bGluZUNsYXNzLCBsYXRsbmdzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQb2x5Z29uOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLnBvbHlnb25DbGFzcyB8fCB0aGlzLm9wdGlvbnMucG9seWdvbkNsYXNzLCBsYXRsbmdzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJDbGFzcyB8fCB0aGlzLm9wdGlvbnMubWFya2VyQ2xhc3MsIGxhdGxuZywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUmVjdGFuZ2xlOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihvcHRpb25zICYmIG9wdGlvbnMucmVjdGFuZ2xlQ2xhc3MgfHwgdGhpcy5vcHRpb25zLnJlY3RhbmdsZUNsYXNzLCBib3VuZHMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUNpcmNsZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLmNpcmNsZUNsYXNzIHx8IHRoaXMub3B0aW9ucy5jaXJjbGVDbGFzcywgbGF0bG5nLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLmV4dGVuZChMLkVkaXRhYmxlLCB7XG5cbiAgICAgICAgbWFrZUNhbmNlbGxhYmxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZS5fY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICAgICAgZWRpdFRvb2xzQ2xhc3M6IEwuRWRpdGFibGVcbiAgICB9KTtcblxuICAgIEwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLndoZW5SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0VG9vbHMgPSBuZXcgdGhpcy5vcHRpb25zLmVkaXRUb29sc0NsYXNzKHRoaXMsIHRoaXMub3B0aW9ucy5lZGl0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlZlcnRleEljb24gPSBMLkRpdkljb24uZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBpY29uU2l6ZTogbmV3IEwuUG9pbnQoOCwgOClcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlRvdWNoVmVydGV4SWNvbiA9IEwuRWRpdGFibGUuVmVydGV4SWNvbi5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCgyMCwgMjApXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cbiAgICBMLkVkaXRhYmxlLlZlcnRleE1hcmtlciA9IEwuTWFya2VyLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LXZlcnRleC1pY29uJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MsIGVkaXRvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIHRoaXMuX2xhdGxuZywgYmVjYXVzZSBvbiBkcmFnIExlYWZsZXQgcmVwbGFjZSBpdCB3aGlsZVxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBrZWVwIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIHRoaXMubGF0bG5nID0gbGF0bG5nO1xuICAgICAgICAgICAgdGhpcy5sYXRsbmdzID0gbGF0bG5ncztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmljb24gPSB0aGlzLmVkaXRvci50b29scy5jcmVhdGVWZXJ0ZXhJY29uKHtjbGFzc05hbWU6IHRoaXMub3B0aW9ucy5jbGFzc05hbWV9KTtcbiAgICAgICAgICAgIHRoaXMubGF0bG5nLl9fdmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5hZGRMYXllcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4T2Zmc2V0KGVkaXRvci50b29scy5fbGFzdFpJbmRleCArIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgdGhpcy5vbignZHJhZycsIHRoaXMub25EcmFnKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5vbignZHJhZ2VuZCcsIHRoaXMub25EcmFnRW5kKTtcbiAgICAgICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdtb3VzZWRvd24gdG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICAgICAgdGhpcy5hZGRNaWRkbGVNYXJrZXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZGRsZU1hcmtlcikgdGhpcy5taWRkbGVNYXJrZXIuZGVsZXRlKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5sYXRsbmcuX192ZXJ0ZXg7XG4gICAgICAgICAgICB0aGlzLm9mZignZHJhZycsIHRoaXMub25EcmFnKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdkcmFnZW5kJywgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51KTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24gdG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckRyYWcoZSk7XG4gICAgICAgICAgICB2YXIgaWNvblBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9pY29uKSxcbiAgICAgICAgICAgICAgICBsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuICAgICAgICAgICAgdGhpcy5sYXRsbmcudXBkYXRlKGxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRsbmcgPSB0aGlzLmxhdGxuZzsgIC8vIFB1c2ggYmFjayB0byBMZWFmbGV0IG91ciByZWZlcmVuY2UuXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWRkbGVNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pZGRsZU1hcmtlci51cGRhdGVMYXRMbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lm1pZGRsZU1hcmtlcikge1xuICAgICAgICAgICAgICAgIG5leHQubWlkZGxlTWFya2VyLnVwZGF0ZUxhdExuZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJEcmFnU3RhcnQoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJEcmFnRW5kKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckNsaWNrKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2V1cDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQuc3RvcChlKTtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm1hcC5maXJlKCdtb3VzZXVwJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Db250ZXh0TWVudTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyQ29udGV4dE1lbnUoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlck1vdXNlRG93bihlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7ICAvLyBDb21wdXRlIGJlZm9yZSBjaGFuZ2luZyBsYXRsbmdcbiAgICAgICAgICAgIHRoaXMubGF0bG5ncy5zcGxpY2UodGhpcy5nZXRJbmRleCgpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4RGVsZXRlZCh7bGF0bG5nOiB0aGlzLmxhdGxuZywgdmVydGV4OiB0aGlzfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGF0bG5ncy5sZW5ndGgpIHRoaXMuZWRpdG9yLmRlbGV0ZVNoYXBlKHRoaXMubGF0bG5ncyk7XG4gICAgICAgICAgICBpZiAobmV4dCkgbmV4dC5yZXNldE1pZGRsZU1hcmtlcigpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXRsbmdzLmluZGV4T2YodGhpcy5sYXRsbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExhc3RJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF0bG5ncy5sZW5ndGggLSAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXRsbmdzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0luZGV4ID0gaW5kZXggLSAxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIHRoaXMuZWRpdG9yLkNMT1NFRCkgcHJldmlvdXNJbmRleCA9IHRoaXMuZ2V0TGFzdEluZGV4KCk7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmxhdGxuZ3NbcHJldmlvdXNJbmRleF07XG4gICAgICAgICAgICBpZiAocHJldmlvdXMpIHJldHVybiBwcmV2aW91cy5fX3ZlcnRleDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXROZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXRsbmdzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuZ2V0TGFzdEluZGV4KCkgJiYgdGhpcy5lZGl0b3IuQ0xPU0VEKSBuZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmxhdGxuZ3NbbmV4dEluZGV4XTtcbiAgICAgICAgICAgIGlmIChuZXh0KSByZXR1cm4gbmV4dC5fX3ZlcnRleDtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5oYXNNaWRkbGVNYXJrZXJzKCkpIHJldHVybjtcbiAgICAgICAgICAgIHByZXZpb3VzID0gcHJldmlvdXMgfHwgdGhpcy5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzICYmICF0aGlzLm1pZGRsZU1hcmtlcikgdGhpcy5taWRkbGVNYXJrZXIgPSB0aGlzLmVkaXRvci5hZGRNaWRkbGVNYXJrZXIocHJldmlvdXMsIHRoaXMsIHRoaXMubGF0bG5ncywgdGhpcy5lZGl0b3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZE1pZGRsZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3IuaGFzTWlkZGxlTWFya2VycygpKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmdldFByZXZpb3VzKCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE1pZGRsZU1hcmtlcihwcmV2aW91cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBuZXh0LnJlc2V0TWlkZGxlTWFya2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXRNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZGRsZU1hcmtlcikgdGhpcy5taWRkbGVNYXJrZXIuZGVsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLmFkZE1pZGRsZU1hcmtlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNwbGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLnNwbGl0U2hhcGUpIHJldHVybjsgIC8vIE9ubHkgZm9yIFBvbHlsaW5lRWRpdG9yXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zcGxpdFNoYXBlKHRoaXMubGF0bG5ncywgdGhpcy5nZXRJbmRleCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5jb250aW51ZUJhY2t3YXJkKSByZXR1cm47ICAvLyBPbmx5IGZvciBQb2x5bGluZUVkaXRvclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB0aGlzLmVkaXRvci5jb250aW51ZUJhY2t3YXJkKHRoaXMubGF0bG5ncyk7XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5nZXRMYXN0SW5kZXgoKSkgdGhpcy5lZGl0b3IuY29udGludWVGb3J3YXJkKHRoaXMubGF0bG5ncyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5tZXJnZU9wdGlvbnMoe1xuICAgICAgICB2ZXJ0ZXhNYXJrZXJDbGFzczogTC5FZGl0YWJsZS5WZXJ0ZXhNYXJrZXJcbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUuTWlkZGxlTWFya2VyID0gTC5NYXJrZXIuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtbWlkZGxlLWljb24nLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBsYXRsbmdzLCBlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgIHRoaXMubGF0bG5ncyA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuY29tcHV0ZUxhdExuZygpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX29wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pY29uID0gdGhpcy5lZGl0b3IudG9vbHMuY3JlYXRlVmVydGV4SWNvbih7Y2xhc3NOYW1lOiB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lfSk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRWaXNpYmlsaXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFBvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5sZWZ0LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgcmlnaHRQb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRoaXMucmlnaHQubGF0bG5nKSxcbiAgICAgICAgICAgICAgICBzaXplID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLmljb25TaXplKTtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9pbnQuZGlzdGFuY2VUbyhyaWdodFBvaW50KSA8IHNpemUueCAqIDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcGFjaXR5KHRoaXMuX29wYWNpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3BhY2l0eSgwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGF0TG5nKHRoaXMuY29tcHV0ZUxhdExuZygpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXB1dGVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0UG9pbnQgPSB0aGlzLmVkaXRvci5tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLmxlZnQubGF0bG5nKSxcbiAgICAgICAgICAgICAgICByaWdodFBvaW50ID0gdGhpcy5lZGl0b3IubWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5yaWdodC5sYXRsbmcpLFxuICAgICAgICAgICAgICAgIHkgPSAobGVmdFBvaW50LnkgKyByaWdodFBvaW50LnkpIC8gMixcbiAgICAgICAgICAgICAgICB4ID0gKGxlZnRQb2ludC54ICsgcmlnaHRQb2ludC54KSAvIDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IubWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3gsIHldKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQub24odGhpcy5faWNvbiwgJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93biwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub24oJ3pvb21lbmQnLCB0aGlzLnNldFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yaWdodC5taWRkbGVNYXJrZXI7XG4gICAgICAgICAgICBMLkRvbUV2ZW50Lm9mZih0aGlzLl9pY29uLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCB0aGlzLm9uTW91c2VEb3duLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLnNldFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2ljb24pLFxuICAgICAgICAgICAgICAgIGxhdGxuZyA9IHRoaXMuZWRpdG9yLm1hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG4gICAgICAgICAgICBlID0ge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgbGF0bG5nOiBsYXRsbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPT09IDApIHJldHVybjtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25NaWRkbGVNYXJrZXJNb3VzZURvd24oZSk7XG4gICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmxhdGxuZ3Muc3BsaWNlKHRoaXMuaW5kZXgoKSwgMCwgZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLl9pY29uO1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuZWRpdG9yLmFkZFZlcnRleE1hcmtlcihlLmxhdGxuZywgdGhpcy5sYXRsbmdzKTtcbiAgICAgICAgICAgIC8qIEhhY2sgdG8gd29ya2Fyb3VuZCBicm93c2VyIG5vdCBmaXJpbmcgdG91Y2hlbmQgd2hlbiBlbGVtZW50IGlzIG5vIG1vcmUgb24gRE9NICovXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbWFya2VyLl9pY29uLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobWFya2VyLl9pY29uKTtcbiAgICAgICAgICAgIG1hcmtlci5faWNvbiA9IGljb247XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobWFya2VyLl9pY29uKTtcbiAgICAgICAgICAgIG1hcmtlci5faW5pdEljb24oKTtcbiAgICAgICAgICAgIG1hcmtlci5faW5pdEludGVyYWN0aW9uKCk7XG4gICAgICAgICAgICBtYXJrZXIuc2V0T3BhY2l0eSgxKTtcbiAgICAgICAgICAgIC8qIEVuZCBoYWNrICovXG4gICAgICAgICAgICAvLyBUcmFuc2ZlciBvbmdvaW5nIGRyYWdnaW5nIHRvIHJlYWwgbWFya2VyXG4gICAgICAgICAgICBMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIG1hcmtlci5kcmFnZ2luZy5fZHJhZ2dhYmxlLl9vbkRvd24oZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5lZGl0TGF5ZXIucmVtb3ZlTGF5ZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhdGxuZ3MuaW5kZXhPZih0aGlzLnJpZ2h0LmxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5tZXJnZU9wdGlvbnMoe1xuICAgICAgICBtaWRkbGVNYXJrZXJDbGFzczogTC5FZGl0YWJsZS5NaWRkbGVNYXJrZXJcbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuZWRpdG9yID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyID0gbmV3IEwuTGF5ZXJHcm91cCgpO1xuICAgICAgICAgICAgdGhpcy50b29scyA9IHRoaXMub3B0aW9ucy5lZGl0VG9vbHMgfHwgbWFwLmVkaXRUb29scztcbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHRoaXMudG9vbHMuZWRpdExheWVyLmFkZExheWVyKHRoaXMuZWRpdExheWVyKTtcbiAgICAgICAgICAgIHRoaXMub25FbmFibGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLm9uKCdyZW1vdmUnLCB0aGlzLmRpc2FibGUsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLm9mZigncmVtb3ZlJywgdGhpcy5kaXNhYmxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzLmVkaXRMYXllcik7XG4gICAgICAgICAgICB0aGlzLm9uRGlzYWJsZSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2VuYWJsZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZykgdGhpcy5jYW5jZWxEcmF3aW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLl9kcmF3aW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc01pZGRsZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25zLnNraXBNaWRkbGVNYXJrZXJzICYmICF0aGlzLnRvb2xzLm9wdGlvbnMuc2tpcE1pZGRsZU1hcmtlcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZUFuZEZvcndhcmQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgICAgICBlID0gZSB8fCB7fTtcbiAgICAgICAgICAgIGUubGF5ZXIgPSB0aGlzLmZlYXR1cmU7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuZmlyZSh0eXBlLCBlKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuZmlyZUFuZEZvcndhcmQodHlwZSwgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmVuYWJsZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZGlzYWJsZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRWRpdGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZWRpdGluZycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uU3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOnN0YXJ0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FbmREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmVuZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FuY2VsRHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzpjYW5jZWwnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNvbW1pdERyYXdpbmc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmNvbW1pdCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6bW91c2Vkb3duJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6bW91c2V1cCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0RHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3aW5nKSB0aGlzLl9kcmF3aW5nID0gTC5FZGl0YWJsZS5GT1JXQVJEO1xuICAgICAgICAgICAgdGhpcy50b29scy5yZWdpc3RlckZvckRyYXdpbmcodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uU3RhcnREcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0RHJhd2luZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25Db21taXREcmF3aW5nKGUpO1xuICAgICAgICAgICAgdGhpcy5lbmREcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FuY2VsRHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5vbkNhbmNlbERyYXdpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kRHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMudW5yZWdpc3RlckZvckRyYXdpbmcodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uRW5kRHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ0NsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRyYXdpbmcpIHJldHVybjtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzpjbGljaycsIGUpO1xuICAgICAgICAgICAgaWYgKGUuX2NhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHRoaXMuY29ubmVjdChlKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0RyYXdpbmdDbGljayhlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0Nvbm5lY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhc0xheWVyKHRoaXMuZmVhdHVyZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29ubmVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuY29ubmVjdENyZWF0ZWRUb01hcCh0aGlzLmZlYXR1cmUpO1xuICAgICAgICAgICAgdGhpcy50b29scy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5lZGl0TGF5ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6bW92ZScsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3ZlKGUpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUuTWFya2VyRWRpdG9yID0gTC5FZGl0YWJsZS5CYXNlRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkgdGhpcy5lbmFibGVEcmFnZ2luZygpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmZlYXR1cmUub24oJ2FkZCcsIHRoaXMuZW5hYmxlRHJhZ2dpbmcsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLm9uKCdkcmFnc3RhcnQnLCB0aGlzLm9uRWRpdGluZywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUub24oJ2RyYWcnLCB0aGlzLm9uTW92ZSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUuZHJhZ2dpbmcpIHRoaXMuZmVhdHVyZS5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLm9uRWRpdGluZywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUub2ZmKCdkcmFnJywgdGhpcy5vbk1vdmUsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5hYmxlRHJhZ2dpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlTW92ZS5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcpIHRoaXMuZmVhdHVyZS5zZXRMYXRMbmcoZS5sYXRsbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByb2Nlc3NEcmF3aW5nQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmNsaWNrZWQnLCBlKTtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0RHJhd2luZyhlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb25uZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gT24gdG91Y2gsIHRoZSBsYXRsbmcgaGFzIG5vdCBiZWVuIHVwZGF0ZWQgYmVjYXVzZSB0aGVyZSBpc1xuICAgICAgICAgICAgLy8gbm8gbW91c2Vtb3ZlLlxuICAgICAgICAgICAgaWYgKGUpIHRoaXMuZmVhdHVyZS5fbGF0bG5nID0gZS5sYXRsbmc7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IgPSBMLkVkaXRhYmxlLkJhc2VFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICBDTE9TRUQ6IGZhbHNlLFxuICAgICAgICBNSU5fVkVSVEVYOiAyLFxuXG4gICAgICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRWZXJ0ZXhNYXJrZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdFZlcnRleE1hcmtlcnM6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldExhdExuZ3MoKTtcbiAgICAgICAgICAgIGlmIChMLlBvbHlsaW5lLl9mbGF0KGxhdGxuZ3MpKSB0aGlzLmFkZFZlcnRleE1hcmtlcnMobGF0bG5ncyk7XG4gICAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykgdGhpcy5pbml0VmVydGV4TWFya2VycyhsYXRsbmdzW2ldKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlLmdldExhdExuZ3MoKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRWZXJ0ZXhNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50b29scy5vcHRpb25zLnZlcnRleE1hcmtlckNsYXNzKGxhdGxuZywgbGF0bG5ncywgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVmVydGV4TWFya2VyczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVmVydGV4TWFya2VyKGxhdGxuZ3NbaV0sIGxhdGxuZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZnJlc2hWZXJ0ZXhNYXJrZXJzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5nZXREZWZhdWx0TGF0TG5ncygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGF0bG5nc1tpXS5fX3ZlcnRleC51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgbGF0bG5ncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLnRvb2xzLm9wdGlvbnMubWlkZGxlTWFya2VyQ2xhc3MobGVmdCwgcmlnaHQsIGxhdGxuZ3MsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLm1ha2VDYW5jZWxsYWJsZShlKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpjbGljaycsIGUpO1xuICAgICAgICAgICAgaWYgKGUuX2NhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9vbHMuZHJhd2luZygpICYmIHRoaXMudG9vbHMuX2RyYXdpbmdFZGl0b3IgIT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGUudmVydGV4LmdldEluZGV4KCksIGNvbW1pdDtcbiAgICAgICAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQuY3RybEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJDdHJsQ2xpY2soZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmVydGV4TWFya2VyQWx0Q2xpY2soZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJTaGlmdENsaWNrKGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJNZXRhS2V5Q2xpY2soZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBlLnZlcnRleC5nZXRMYXN0SW5kZXgoKSAmJiB0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5NSU5fVkVSVEVYIC0gMSkgY29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5CQUNLV0FSRCAmJiB0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoID49IHRoaXMuTUlOX1ZFUlRFWCkge1xuICAgICAgICAgICAgICAgIGNvbW1pdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwICYmIHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCAmJiB0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoID49IHRoaXMuTUlOX1ZFUlRFWCAmJiB0aGlzLkNMT1NFRCkge1xuICAgICAgICAgICAgICAgIGNvbW1pdCA9IHRydWU7ICAvLyBBbGxvdyB0byBjbG9zZSBvbiBmaXJzdCBwb2ludCBhbHNvIGZvciBwb2x5Z29uc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmVydGV4UmF3TWFya2VyQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6Y2xpY2tlZCcsIGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1pdCkgdGhpcy5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4UmF3TWFya2VyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6cmF3Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy52ZXJ0ZXhDYW5CZURlbGV0ZWQoZS52ZXJ0ZXgpKSByZXR1cm47XG4gICAgICAgICAgICBlLnZlcnRleC5kZWxldGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICB2ZXJ0ZXhDYW5CZURlbGV0ZWQ6IGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0ZXgubGF0bG5ncy5sZW5ndGggPiB0aGlzLk1JTl9WRVJURVg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhEZWxldGVkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRlbGV0ZWQnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckN0cmxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpjdHJsY2xpY2snLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlclNoaWZ0Q2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6c2hpZnRjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyTWV0YUtleUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4Om1ldGFrZXljbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyQWx0Q2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6YWx0Y2xpY2snLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmNvbnRleHRtZW51JywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6bW91c2Vkb3duJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25NaWRkbGVNYXJrZXJNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTptaWRkbGVtYXJrZXI6bW91c2Vkb3duJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJEcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbk1vdmUoZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9ib3VuZHMpIHRoaXMuZXh0ZW5kQm91bmRzKGUpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRyYWcnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpkcmFnc3RhcnQnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZ2VuZCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldERyYXduTGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXduTGF0TG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5nZXREZWZhdWx0TGF0TG5ncygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0RHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3bkxhdExuZ3MpIHRoaXMuc2V0RHJhd25MYXRMbmdzKCk7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLnN0YXJ0RHJhd2luZy5jYWxsKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0RHJhd2luZ0ZvcndhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmF0dGFjaEZvcndhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmRldGFjaEZvcndhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuZGV0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3bkxhdExuZ3MgJiYgdGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCA8IHRoaXMuTUlOX1ZFUlRFWCkgdGhpcy5kZWxldGVTaGFwZSh0aGlzLl9kcmF3bkxhdExuZ3MpO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5lbmREcmF3aW5nLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZHJhd25MYXRMbmdzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgdGhpcy5fZHJhd25MYXRMbmdzLnB1c2gobGF0bG5nKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5fZHJhd25MYXRMbmdzLnVuc2hpZnQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5hZGRWZXJ0ZXhNYXJrZXIobGF0bG5nLCB0aGlzLl9kcmF3bkxhdExuZ3MpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV3UG9pbnRGb3J3YXJkOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICB0aGlzLmFkZExhdExuZyhsYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy50b29scy5hbmNob3JGb3J3YXJkTGluZUd1aWRlKGxhdGxuZyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudG9vbHMuYmFja3dhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmFuY2hvckJhY2t3YXJkTGluZUd1aWRlKGxhdGxuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV3UG9pbnRCYWNrd2FyZDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5hZGRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUobGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwdXNoOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZykgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0wuRWRpdGFibGUuUGF0aEVkaXRvci5wdXNoIGV4cGVjdCBhIHZhaWxkIGxhdGxuZyBhcyBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgICAgICBlbHNlIHRoaXMubmV3UG9pbnRCYWNrd2FyZChsYXRsbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUxhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgbGF0bG5nLl9fdmVydGV4LmRlbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCA8PSAxKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgbGF0bG5nO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgbGF0bG5nID0gdGhpcy5fZHJhd25MYXRMbmdzW3RoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGVsc2UgbGF0bG5nID0gdGhpcy5fZHJhd25MYXRMbmdzWzBdO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIHRoaXMudG9vbHMuYW5jaG9yRm9yd2FyZExpbmVHdWlkZSh0aGlzLl9kcmF3bkxhdExuZ3NbdGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy50b29scy5hbmNob3JGb3J3YXJkTGluZUd1aWRlKHRoaXMuX2RyYXduTGF0TG5nc1swXSk7XG4gICAgICAgICAgICByZXR1cm4gbGF0bG5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByb2Nlc3NEcmF3aW5nQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS52ZXJ0ZXggJiYgZS52ZXJ0ZXguZWRpdG9yID09PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEKSB0aGlzLm5ld1BvaW50Rm9yd2FyZChlLmxhdGxuZyk7XG4gICAgICAgICAgICBlbHNlIHRoaXMubmV3UG9pbnRCYWNrd2FyZChlLmxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmNsaWNrZWQnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlTW92ZS5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLm1vdmVGb3J3YXJkTGluZUd1aWRlKGUubGF0bG5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLm1vdmVCYWNrd2FyZExpbmVHdWlkZShlLmxhdGxuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLnJlZHJhdygpO1xuICAgICAgICAgICAgdGhpcy5vbkVkaXRpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBuZXdTaGFwZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5hZGROZXdFbXB0eVNoYXBlKCk7XG4gICAgICAgICAgICBpZiAoIXNoYXBlKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhzaGFwZVswXSB8fCBzaGFwZSk7ICAvLyBQb2x5Z29uIG9yIHBvbHlsaW5lXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ0ZvcndhcmQoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnNoYXBlOm5ldycsIHtzaGFwZTogc2hhcGV9KTtcbiAgICAgICAgICAgIGlmIChsYXRsbmcpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgbGF0bG5ncykge1xuICAgICAgICAgICAgdmFyIGUgPSB7c2hhcGU6IHNoYXBlfTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6c2hhcGU6ZGVsZXRlJywgZSk7XG4gICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBzaGFwZSA9IHRoaXMuX2RlbGV0ZVNoYXBlKHNoYXBlLCBsYXRsbmdzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuc3VyZU5vdEZsYXQpIHRoaXMuZW5zdXJlTm90RmxhdCgpOyAgLy8gUG9seWdvbi5cbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5zZXRMYXRMbmdzKHRoaXMuZ2V0TGF0TG5ncygpKTsgIC8vIEZvcmNlIGJvdW5kcyByZXNldC5cbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6c2hhcGU6ZGVsZXRlZCcsIHtzaGFwZTogc2hhcGV9KTtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGVsZXRlU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgbGF0bG5ncykge1xuICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5nZXRMYXRMbmdzKCk7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wbGFjZURlbGV0ZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsZWQgd2hlbiBkZWxldGluZyBhIGZsYXQgbGF0bG5nc1xuICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IGxhdGxuZ3Muc3BsaWNlKDAsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzcGxpY2VEZWxldGUgPSBmdW5jdGlvbiAobGF0bG5ncywgc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGVkIHdoZW4gcmVtb3ZpbmcgYSBsYXRsbmdzIGluc2lkZSBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBsYXRsbmdzLnNwbGljZShsYXRsbmdzLmluZGV4T2Yoc2hhcGUpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXRsbmdzLmxlbmd0aCkgc2VsZi5fZGVsZXRlU2hhcGUobGF0bG5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhdGxuZ3MgPT09IHNoYXBlKSByZXR1cm4gaW5wbGFjZURlbGV0ZShsYXRsbmdzLCBzaGFwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGF0bG5nc1tpXSA9PT0gc2hhcGUpIHJldHVybiBzcGxpY2VEZWxldGUobGF0bG5ncywgc2hhcGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhdGxuZ3NbaV0uaW5kZXhPZihzaGFwZSkgIT09IC0xKSByZXR1cm4gc3BsaWNlRGVsZXRlKGxhdGxuZ3NbaV0sIHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVTaGFwZUF0OiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmZlYXR1cmUuc2hhcGVBdChsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKHNoYXBlKSByZXR1cm4gdGhpcy5kZWxldGVTaGFwZShzaGFwZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXBwZW5kU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFwZShzaGFwZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlcGVuZFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhcGUoc2hhcGUsIDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluc2VydFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUsIGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZU11bHRpKCk7XG4gICAgICAgICAgICBzaGFwZSA9IHRoaXMuZm9ybWF0U2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIGluZGV4ID0gdGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5zcGxpY2UoaW5kZXgsIDAsIHNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0ZW5kQm91bmRzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9ib3VuZHMuZXh0ZW5kKGUudmVydGV4LmxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5Qb2x5bGluZUVkaXRvciA9IEwuRWRpdGFibGUuUGF0aEVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgIHN0YXJ0RHJhd2luZ0JhY2t3YXJkOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZyA9IEwuRWRpdGFibGUuQkFDS1dBUkQ7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZyhsYXRsbmdzKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYXR0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250aW51ZUJhY2t3YXJkOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2luZygpKSByZXR1cm47XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhsYXRsbmdzKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUobGF0bG5nc1swXSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ0JhY2t3YXJkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGludWVGb3J3YXJkOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2luZygpKSByZXR1cm47XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhsYXRsbmdzKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yRm9yd2FyZExpbmVHdWlkZShsYXRsbmdzW2xhdGxuZ3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmdGb3J3YXJkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGVmYXVsdExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmZlYXR1cmUuX2xhdGxuZ3M7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoIHx8IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMLkxhdExuZykgcmV0dXJuIGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIHJldHVybiB0aGlzLmdldERlZmF1bHRMYXRMbmdzKGxhdGxuZ3NbMF0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuc3VyZU11bHRpOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCAmJiBMLlBvbHlsaW5lLl9mbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5ncykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MgPSBbdGhpcy5mZWF0dXJlLl9sYXRsbmdzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGROZXdFbXB0eVNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXRTaGFwZTogZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoTC5Qb2x5bGluZS5fZmxhdChzaGFwZSkpIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlWzBdKSByZXR1cm4gdGhpcy5mb3JtYXRTaGFwZShzaGFwZVswXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BsaXRTaGFwZTogZnVuY3Rpb24gKHNoYXBlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFpbmRleCB8fCBpbmRleCA+PSBzaGFwZS5sZW5ndGggLSAxKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmVuc3VyZU11bHRpKCk7XG4gICAgICAgICAgICB2YXIgc2hhcGVJbmRleCA9IHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5pbmRleE9mKHNoYXBlKTtcbiAgICAgICAgICAgIGlmIChzaGFwZUluZGV4ID09PSAtMSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gc2hhcGUuc2xpY2UoMCwgaW5kZXggKyAxKSxcbiAgICAgICAgICAgICAgICBzZWNvbmQgPSBzaGFwZS5zbGljZShpbmRleCk7XG4gICAgICAgICAgICAvLyBXZSBkZWFsIHdpdGggcmVmZXJlbmNlLCB3ZSBkb24ndCB3YW50IHR3aWNlIHRoZSBzYW1lIGxhdGxuZyBhcm91bmQuXG4gICAgICAgICAgICBzZWNvbmRbMF0gPSBMLmxhdExuZyhzZWNvbmRbMF0ubGF0LCBzZWNvbmRbMF0ubG5nLCBzZWNvbmRbMF0uYWx0KTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5zcGxpY2Uoc2hhcGVJbmRleCwgMSwgZmlyc3QsIHNlY29uZCk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlBvbHlnb25FZGl0b3IgPSBMLkVkaXRhYmxlLlBhdGhFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICBDTE9TRUQ6IHRydWUsXG4gICAgICAgIE1JTl9WRVJURVg6IDMsXG5cbiAgICAgICAgc3RhcnREcmF3aW5nRm9yd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5zdGFydERyYXdpbmdGb3J3YXJkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmF0dGFjaEJhY2t3YXJkTGluZUd1aWRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTmV3RW1wdHlIb2xlOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZU5vdEZsYXQoKTtcbiAgICAgICAgICAgIHZhciBsYXRsbmdzID0gdGhpcy5mZWF0dXJlLnNoYXBlQXQobGF0bG5nKTtcbiAgICAgICAgICAgIGlmICghbGF0bG5ncykgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGhvbGVzID0gW107XG4gICAgICAgICAgICBsYXRsbmdzLnB1c2goaG9sZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGhvbGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5ld0hvbGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHZhciBob2xlcyA9IHRoaXMuYWRkTmV3RW1wdHlIb2xlKGxhdGxuZyk7XG4gICAgICAgICAgICBpZiAoIWhvbGVzKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhob2xlcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ0ZvcndhcmQoKTtcbiAgICAgICAgICAgIGlmIChsYXRsbmcpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTmV3RW1wdHlTaGFwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgdGhpcy5mZWF0dXJlLl9sYXRsbmdzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVNdWx0aTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgTC5Qb2x5bGluZS5fZmxhdCh0aGlzLmZlYXR1cmUuX2xhdGxuZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmdzID0gW3RoaXMuZmVhdHVyZS5fbGF0bG5nc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5zdXJlTm90RmxhdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoIHx8IEwuUG9seWxpbmUuX2ZsYXQodGhpcy5mZWF0dXJlLl9sYXRsbmdzKSkgdGhpcy5mZWF0dXJlLl9sYXRsbmdzID0gW3RoaXMuZmVhdHVyZS5fbGF0bG5nc107XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmVydGV4Q2FuQmVEZWxldGVkOiBmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5mZWF0dXJlLnBhcmVudFNoYXBlKHZlcnRleC5sYXRsbmdzKSxcbiAgICAgICAgICAgICAgICBpZHggPSBMLlV0aWwuaW5kZXhPZihwYXJlbnQsIHZlcnRleC5sYXRsbmdzKTtcbiAgICAgICAgICAgIGlmIChpZHggPiAwKSByZXR1cm4gdHJ1ZTsgIC8vIEhvbGVzIGNhbiBiZSB0b3RhbGx5IGRlbGV0ZWQgd2l0aG91dCByZW1vdmluZyB0aGUgbGF5ZXIgaXRzZWxmLlxuICAgICAgICAgICAgcmV0dXJuIEwuRWRpdGFibGUuUGF0aEVkaXRvci5wcm90b3R5cGUudmVydGV4Q2FuQmVEZWxldGVkLmNhbGwodGhpcywgdmVydGV4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREZWZhdWx0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoKSB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MucHVzaChbXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlLl9sYXRsbmdzWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIC8vIFtbMSwgMl0sIFszLCA0XV0gPT4gbXVzdCBiZSBuZXN0ZWRcbiAgICAgICAgICAgIC8vIFtdID0+IG11c3QgYmUgbmVzdGVkXG4gICAgICAgICAgICAvLyBbW11dID0+IGlzIGFscmVhZHkgbmVzdGVkXG4gICAgICAgICAgICBpZiAoTC5Qb2x5bGluZS5fZmxhdChzaGFwZSkgJiYgKCFzaGFwZVswXSB8fCBzaGFwZVswXS5sZW5ndGggIT09IDApKSByZXR1cm4gW3NoYXBlXTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUuUmVjdGFuZ2xlRWRpdG9yID0gTC5FZGl0YWJsZS5QYXRoRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgQ0xPU0VEOiB0cnVlLFxuICAgICAgICBNSU5fVkVSVEVYOiA0LFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNraXBNaWRkbGVNYXJrZXJzOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0ZW5kQm91bmRzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZS52ZXJ0ZXguZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICBvcHBvc2l0ZUluZGV4ID0gKGluZGV4ICsgMikgJSA0LFxuICAgICAgICAgICAgICAgIG9wcG9zaXRlID0gZS52ZXJ0ZXgubGF0bG5nc1tvcHBvc2l0ZUluZGV4XSxcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoZS5sYXRsbmcsIG9wcG9zaXRlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRzKGJvdW5kcyk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hWZXJ0ZXhNYXJrZXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZURvd24uY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgdmFyIGxhdGxuZ3MgPSB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgICAgICAvLyBMLlBvbHlnb24uX2NvbnZlcnRMYXRMbmdzIHJlbW92ZXMgbGFzdCBsYXRsbmcgaWYgaXQgZXF1YWxzIGZpcnN0IHBvaW50LFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgdGhlIGNhc2UgaGVyZSBhcyBhbGwgbGF0bG5ncyBhcmUgWzAsIDBdXG4gICAgICAgICAgICBpZiAobGF0bG5ncy5sZW5ndGggPT09IDMpIGxhdGxuZ3MucHVzaChlLmxhdGxuZyk7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKGUubGF0bG5nLCBlLmxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcyhib3VuZHMpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICAvLyBTdG9wIGRyYWdnaW5nIG1hcC5cbiAgICAgICAgICAgIHRoaXMubWFwLmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uVXAoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIC8vIE5vdyB0cmFuc2ZlciBvbmdvaW5nIGRyYWcgYWN0aW9uIHRvIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICAgICAgICAgICAgLy8gU2hvdWxkIHdlIHJlZmluZSB3aGljaCBjb3JuZSB3aWxsIGhhbmRsZSB0aGUgZHJhZyBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGRyYWcgZGlyZWN0aW9uP1xuICAgICAgICAgICAgbGF0bG5nc1szXS5fX3ZlcnRleC5kcmFnZ2luZy5fZHJhZ2dhYmxlLl9vbkRvd24oZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREZWZhdWx0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXRsbmdzIHx8IHRoaXMuZmVhdHVyZS5fbGF0bG5nc1swXTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fYm91bmRzID0gYm91bmRzO1xuICAgICAgICAgICAgdmFyIGxhdGxuZ3MgPSB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCksXG4gICAgICAgICAgICAgICAgbmV3TGF0bG5ncyA9IHRoaXMuZmVhdHVyZS5fYm91bmRzVG9MYXRMbmdzKGJvdW5kcyk7XG4gICAgICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYXRsbmdzW2ldLnVwZGF0ZShuZXdMYXRsbmdzW2ldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5DaXJjbGVFZGl0b3IgPSBMLkVkaXRhYmxlLlBhdGhFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICBNSU5fVkVSVEVYOiAyLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNraXBNaWRkbGVNYXJrZXJzOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgZmVhdHVyZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwLCBmZWF0dXJlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZyA9IHRoaXMuY29tcHV0ZVJlc2l6ZUxhdExuZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXB1dGVSZXNpemVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFdoaWxlIGNpcmNsZSBpcyBub3QgYWRkZWQgdG8gdGhlIG1hcCwgX3JhZGl1cyBpcyBub3Qgc2V0LlxuICAgICAgICAgICAgdmFyIGRlbHRhID0gKHRoaXMuZmVhdHVyZS5fcmFkaXVzIHx8IHRoaXMuZmVhdHVyZS5fbVJhZGl1cykgKiBNYXRoLmNvcyhNYXRoLlBJIC8gNCksXG4gICAgICAgICAgICAgICAgcG9pbnQgPSB0aGlzLm1hcC5wcm9qZWN0KHRoaXMuZmVhdHVyZS5fbGF0bG5nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcC51bnByb2plY3QoW3BvaW50LnggKyBkZWx0YSwgcG9pbnQueSAtIGRlbHRhXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlUmVzaXplTGF0TG5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVMYXRMbmcudXBkYXRlKHRoaXMuY29tcHV0ZVJlc2l6ZUxhdExuZygpKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy5fX3ZlcnRleC51cGRhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZmVhdHVyZS5fbGF0bG5nLCB0aGlzLl9yZXNpemVMYXRMbmddO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXRMbmdzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJEcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudmVydGV4LmdldEluZGV4KCkgPT09IDEpIHRoaXMucmVzaXplKGUpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLnVwZGF0ZVJlc2l6ZUxhdExuZyhlKTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuUGF0aEVkaXRvci5wcm90b3R5cGUub25WZXJ0ZXhNYXJrZXJEcmFnLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuZmVhdHVyZS5fbGF0bG5nLmRpc3RhbmNlVG8oZS5sYXRsbmcpXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuc2V0UmFkaXVzKHJhZGl1cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZURvd24uY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy51cGRhdGUoZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmcudXBkYXRlKGUubGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICAgICAgLy8gU3RvcCBkcmFnZ2luZyBtYXAuXG4gICAgICAgICAgICB0aGlzLm1hcC5kcmFnZ2luZy5fZHJhZ2dhYmxlLl9vblVwKGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAvLyBOb3cgdHJhbnNmZXIgb25nb2luZyBkcmFnIGFjdGlvbiB0byB0aGUgcmFkaXVzIGhhbmRsZXIuXG4gICAgICAgICAgICB0aGlzLl9yZXNpemVMYXRMbmcuX192ZXJ0ZXguZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25Eb3duKGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fbGF0bG5nLnVwZGF0ZShlLmxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2xhdGxuZy5fX3ZlcnRleC51cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICB2YXIgRWRpdGFibGVNaXhpbiA9IHtcblxuICAgICAgICBjcmVhdGVFZGl0b3I6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIG1hcCA9IG1hcCB8fCB0aGlzLl9tYXA7XG4gICAgICAgICAgICB2YXIgS2xhc3MgPSB0aGlzLm9wdGlvbnMuZWRpdG9yQ2xhc3MgfHwgdGhpcy5nZXRFZGl0b3JDbGFzcyhtYXApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLbGFzcyhtYXAsIHRoaXMsIHRoaXMub3B0aW9ucy5lZGl0T3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5hYmxlRWRpdDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvcikgdGhpcy5jcmVhdGVFZGl0b3IobWFwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5lbmFibGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlZGl0RW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yICYmIHRoaXMuZWRpdG9yLl9lbmFibGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc2FibGVFZGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZUVkaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVFZGl0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkVkaXRhYmxlQWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IpIHRoaXMuZW5hYmxlRWRpdCgpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgTC5Qb2x5bGluZS5pbmNsdWRlKEVkaXRhYmxlTWl4aW4pO1xuICAgIEwuUG9seWdvbi5pbmNsdWRlKEVkaXRhYmxlTWl4aW4pO1xuICAgIEwuTWFya2VyLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgTC5SZWN0YW5nbGUuaW5jbHVkZShFZGl0YWJsZU1peGluKTtcbiAgICBMLkNpcmNsZS5pbmNsdWRlKEVkaXRhYmxlTWl4aW4pO1xuXG4gICAgTC5Qb2x5bGluZS5pbmNsdWRlKHtcblxuICAgICAgICBnZXRFZGl0b3JDbGFzczogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIChtYXAgJiYgbWFwLm9wdGlvbnMucG9seWxpbmVFZGl0b3JDbGFzcykgPyBtYXAub3B0aW9ucy5wb2x5bGluZUVkaXRvckNsYXNzIDogTC5FZGl0YWJsZS5Qb2x5bGluZUVkaXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzaGFwZUF0OiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gaGF2ZSB0aG9zZSBjYXNlczpcbiAgICAgICAgICAgIC8vIC0gbGF0bG5ncyBhcmUganVzdCBhIGZsYXQgYXJyYXkgb2YgbGF0bG5ncywgdXNlIHRoaXNcbiAgICAgICAgICAgIC8vIC0gbGF0bG5ncyBpcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgbG9vcCBvdmVyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBudWxsO1xuICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fbGF0bG5ncztcbiAgICAgICAgICAgIGlmICghbGF0bG5ncy5sZW5ndGgpIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKEwuUG9seWxpbmUuX2ZsYXQobGF0bG5ncykgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3MpKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykgaWYgKHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzW2ldKSkgcmV0dXJuIGxhdGxuZ3NbaV07XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJbkxhdExuZ3M6IGZ1bmN0aW9uIChsLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpLCBrLCBsZW4sIHBhcnQgPSBbXSwgcCxcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3MsIHBhcnQsIHRoaXMuX3B4Qm91bmRzKTtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0WzBdO1xuICAgICAgICAgICAgcCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBwYXJ0Lmxlbmd0aCwgayA9IDA7IGkgPCBsZW47IGsgPSBpKyspIHtcblxuICAgICAgICAgICAgICAgIGlmIChMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtpXSkgPD0gdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5Qb2x5Z29uLmluY2x1ZGUoe1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKG1hcCAmJiBtYXAub3B0aW9ucy5wb2x5Z29uRWRpdG9yQ2xhc3MpID8gbWFwLm9wdGlvbnMucG9seWdvbkVkaXRvckNsYXNzIDogTC5FZGl0YWJsZS5Qb2x5Z29uRWRpdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNoYXBlQXQ6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBoYXZlIHRob3NlIGNhc2VzOlxuICAgICAgICAgICAgLy8gLSBsYXRsbmdzIGFyZSBqdXN0IGEgZmxhdCBhcnJheSBvZiBsYXRsbmdzLCB1c2UgdGhpc1xuICAgICAgICAgICAgLy8gLSBsYXRsbmdzIGlzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB0aGlzIGlzIGEgc2ltcGxlIHBvbHlnb24gKG1heWJlIHdpdGggaG9sZXMpLCB1c2UgdGhlIGZpcnN0XG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGFycmF5cywgdGhpcyBpcyBhIG11bHRpLCBsb29wIG92ZXJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG51bGw7XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9sYXRsbmdzO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzLmxlbmd0aCkgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgZWxzZSBpZiAoTC5Qb2x5bGluZS5fZmxhdChsYXRsbmdzKSAmJiB0aGlzLmlzSW5MYXRMbmdzKGxhdGxuZywgbGF0bG5ncykpIHNoYXBlID0gbGF0bG5ncztcbiAgICAgICAgICAgIGVsc2UgaWYgKEwuUG9seWxpbmUuX2ZsYXQobGF0bG5nc1swXSkgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3NbMF0pKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykgaWYgKHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzW2ldWzBdKSkgcmV0dXJuIGxhdGxuZ3NbaV07XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJbkxhdExuZ3M6IGZ1bmN0aW9uIChsLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2UsIGwxLCBsMiwgaiwgaywgbGVuMjtcblxuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMiA9IGxhdGxuZ3MubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gICAgICAgICAgICAgICAgbDEgPSBsYXRsbmdzW2pdO1xuICAgICAgICAgICAgICAgIGwyID0gbGF0bG5nc1trXTtcblxuICAgICAgICAgICAgICAgIGlmICgoKGwxLmxhdCA+IGwubGF0KSAhPT0gKGwyLmxhdCA+IGwubGF0KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChsLmxuZyA8IChsMi5sbmcgLSBsMS5sbmcpICogKGwubGF0IC0gbDEubGF0KSAvIChsMi5sYXQgLSBsMS5sYXQpICsgbDEubG5nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJlbnRTaGFwZTogZnVuY3Rpb24gKHNoYXBlLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9sYXRsbmdzO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaWR4ID0gTC5VdGlsLmluZGV4T2YobGF0bG5ncywgc2hhcGUpO1xuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHJldHVybiBsYXRsbmdzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gTC5VdGlsLmluZGV4T2YobGF0bG5nc1tpXSwgc2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSByZXR1cm4gbGF0bG5nc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLk1hcmtlci5pbmNsdWRlKHtcblxuICAgICAgICBnZXRFZGl0b3JDbGFzczogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIChtYXAgJiYgbWFwLm9wdGlvbnMubWFya2VyRWRpdG9yQ2xhc3MpID8gbWFwLm9wdGlvbnMubWFya2VyRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLk1hcmtlckVkaXRvcjtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLlJlY3RhbmdsZS5pbmNsdWRlKHtcblxuICAgICAgICBnZXRFZGl0b3JDbGFzczogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIChtYXAgJiYgbWFwLm9wdGlvbnMucmVjdGFuZ2xlRWRpdG9yQ2xhc3MpID8gbWFwLm9wdGlvbnMucmVjdGFuZ2xlRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLlJlY3RhbmdsZUVkaXRvcjtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkNpcmNsZS5pbmNsdWRlKHtcblxuICAgICAgICBnZXRFZGl0b3JDbGFzczogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIChtYXAgJiYgbWFwLm9wdGlvbnMuY2lyY2xlRWRpdG9yQ2xhc3MpID8gbWFwLm9wdGlvbnMuY2lyY2xlRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLkNpcmNsZUVkaXRvcjtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICB2YXIga2VlcEVkaXRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgeW91IGNhbiByZW1vdmUvcmVhZGQgYW4gZWRpdGFibGUgbGF5ZXIuXG4gICAgICAgIHRoaXMub24oJ2FkZCcsIHRoaXMuX29uRWRpdGFibGVBZGQpO1xuICAgIH07XG4gICAgTC5NYXJrZXIuYWRkSW5pdEhvb2soa2VlcEVkaXRhYmxlKTtcbiAgICBMLlBvbHlsaW5lLmFkZEluaXRIb29rKGtlZXBFZGl0YWJsZSk7XG5cbiAgICBMLkxhdExuZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICB0aGlzLmxhdCA9IGxhdGxuZy5sYXQ7XG4gICAgICAgIHRoaXMubG5nID0gbGF0bG5nLmxuZztcbiAgICB9XG5cbn0sIHdpbmRvdykpO1xuIiwiLypcbiBMZWFmbGV0IDEuMC4wLXJjLjIsIGEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwcy4gaHR0cDovL2xlYWZsZXRqcy5jb21cbiAoYykgMjAxMC0yMDE1IFZsYWRpbWlyIEFnYWZvbmtpbiwgKGMpIDIwMTAtMjAxMSBDbG91ZE1hZGVcbiovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG52YXIgTCA9IHtcclxuXHR2ZXJzaW9uOiBcIjEuMC4wLXJjLjJcIlxyXG59O1xyXG5cclxuZnVuY3Rpb24gZXhwb3NlKCkge1xyXG5cdHZhciBvbGRMID0gd2luZG93Lkw7XHJcblxyXG5cdEwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHdpbmRvdy5MID0gb2xkTDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdHdpbmRvdy5MID0gTDtcclxufVxyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgZm9yIE5vZGUgbW9kdWxlIHBhdHRlcm4gbG9hZGVycywgaW5jbHVkaW5nIEJyb3dzZXJpZnlcclxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEw7XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBhcyBhbiBBTUQgbW9kdWxlXHJcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0ZGVmaW5lKEwpO1xyXG59XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBhcyBhIGdsb2JhbCBMIHZhcmlhYmxlLCBzYXZpbmcgdGhlIG9yaWdpbmFsIEwgdG8gcmVzdG9yZSBsYXRlciBpZiBuZWVkZWRcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ZXhwb3NlKCk7XHJcbn1cclxuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbkwuVXRpbCA9IHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG5cdC8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAoZGVzdCkge1xyXG5cdFx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRcdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG5cdFx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcblx0XHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGVzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuXHRjcmVhdGU6IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHRcdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEYoKTtcclxuXHRcdH07XHJcblx0fSkoKSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG5cdC8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuXHQvLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG5cdGJpbmQ6IGZ1bmN0aW9uIChmbiwgb2JqKSB7XHJcblx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5cdFx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWdpbmcgaXQgb25lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdC5cclxuXHRzdGFtcDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrTC5VdGlsLmxhc3RJZDtcclxuXHRcdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0XHQvKmVzbGludC1lbmFibGUgKi9cclxuXHR9LFxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuXHQvLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5cdGxhc3RJZDogMCxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG5cdC8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG5cdC8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcblx0Ly8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG5cdC8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuXHQvLyBIYXMgYW4gYEwuYmluZGAgc2hvcnRjdXQuXHJcblx0dGhyb3R0bGU6IGZ1bmN0aW9uIChmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG5cdFx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRcdGxvY2sgPSBmYWxzZTtcclxuXHRcdFx0aWYgKGFyZ3MpIHtcclxuXHRcdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdFx0YXJncyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuXHRcdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gd3JhcHBlckZuO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuXHQvLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcblx0Ly8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcblx0d3JhcE51bTogZnVuY3Rpb24gKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcblx0XHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcblx0XHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0XHQgICAgZCA9IG1heCAtIG1pbjtcclxuXHRcdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG5cdGZhbHNlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBkaWdpdHM/OiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB0byBgZGlnaXRzYCBkZWNpbWFscywgb3IgdG8gNSBkZWNpbWFscyBieSBkZWZhdWx0LlxyXG5cdGZvcm1hdE51bTogZnVuY3Rpb24gKG51bSwgZGlnaXRzKSB7XHJcblx0XHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIGRpZ2l0cyB8fCA1KTtcclxuXHRcdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuXHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuXHR0cmltOiBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcblx0Ly8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5cdHNwbGl0V29yZHM6IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRcdHJldHVybiBMLlV0aWwudHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqOiBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCk6IE9iamVjdFxyXG5cdC8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XHJcblx0XHRcdG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBMLlV0aWwuY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdFx0fVxyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBvYmoub3B0aW9ucztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcblx0Ly8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG5cdC8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuXHQvLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG5cdC8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuXHRnZXRQYXJhbVN0cmluZzogZnVuY3Rpb24gKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuXHQvLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG5cdC8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG5cdC8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5cdHRlbXBsYXRlOiBmdW5jdGlvbiAoc3RyLCBkYXRhKSB7XHJcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoTC5VdGlsLnRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHRlbXBsYXRlUmU6IC9cXHsgKihbXFx3X1xcLV0rKSAqXFx9L2csXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuXHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkuaXNBcnJheV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheSlcclxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG5cdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuXHRpbmRleE9mOiBmdW5jdGlvbiAoYXJyYXksIGVsKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9LFxyXG5cclxuXHQvLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcblx0Ly8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcblx0Ly8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcblx0Ly8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5cdGVtcHR5SW1hZ2VVcmw6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9J1xyXG59O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHQvLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuXHRmdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0XHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxuXHR9XHJcblxyXG5cdHZhciBsYXN0VGltZSA9IDA7XHJcblxyXG5cdC8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuXHRmdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHRcdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0XHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRcdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG5cdH1cclxuXHJcblx0dmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcixcclxuXHQgICAgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHQgICAgICAgICAgICAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcblx0Ly8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG5cdC8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcblx0Ly8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG5cdC8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuXHQvLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuXHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSA9IGZ1bmN0aW9uIChmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0XHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRcdGZuLmNhbGwoY29udGV4dCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBMLmJpbmQoZm4sIGNvbnRleHQpKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuXHQvLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuXHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRpZiAoaWQpIHtcclxuXHRcdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHRcdH1cclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLy8gc2hvcnRjdXRzIGZvciBtb3N0IHVzZWQgdXRpbGl0eSBmdW5jdGlvbnNcclxuTC5leHRlbmQgPSBMLlV0aWwuZXh0ZW5kO1xyXG5MLmJpbmQgPSBMLlV0aWwuYmluZDtcclxuTC5zdGFtcCA9IEwuVXRpbC5zdGFtcDtcclxuTC5zZXRPcHRpb25zID0gTC5VdGlsLnNldE9wdGlvbnM7XHJcblxuXG5cblxyXG4vLyBAY2xhc3MgQ2xhc3NcclxuLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG5MLkNsYXNzID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5MLkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IEwuVXRpbC5jcmVhdGUocGFyZW50UHJvdG8pO1xyXG5cdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG5cdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuXHQvLyBpbmhlcml0IHBhcmVudCdzIHN0YXRpY3NcclxuXHRmb3IgKHZhciBpIGluIHRoaXMpIHtcclxuXHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09ICdwcm90b3R5cGUnKSB7XHJcblx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcblx0XHRMLmV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcblx0XHRkZWxldGUgcHJvcHMuc3RhdGljcztcclxuXHR9XHJcblxyXG5cdC8vIG1peCBpbmNsdWRlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRpZiAocHJvcHMuaW5jbHVkZXMpIHtcclxuXHRcdEwuVXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuXHR9XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoTC5VdGlsLmNyZWF0ZShwcm90by5vcHRpb25zKSwgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRMLmV4dGVuZChwcm90bywgcHJvcHMpO1xyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcblx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4vLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5MLkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRMLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5MLkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0TC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4vLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG5MLkNsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdHZhciBpbml0ID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbkwuRXZlbnRlZCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuXHJcblx0ICovXHJcblx0b2ZmOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKCF0eXBlcykge1xyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcblx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzOiB7fSxcclxuXHRcdFx0XHRjb3VudDogMFxyXG5cdFx0XHR9O1xyXG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjb250ZXh0SWQgPSBjb250ZXh0ICYmIGNvbnRleHQgIT09IHRoaXMgJiYgTC5zdGFtcChjb250ZXh0KSxcclxuXHRcdCAgICBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH07XHJcblxyXG5cdFx0aWYgKCFjb250ZXh0SWQpIHtcclxuXHRcdFx0Y29udGV4dElkID0gJ25vX2NvbnRleHQnO1xyXG5cdFx0XHRuZXdMaXN0ZW5lci5jdHggPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm4gYXJyYXkgZm9yIGNvbnRleHRcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0eXBlTGlzdGVuZXJzLmxpc3RlbmVyc1tjb250ZXh0SWRdO1xyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gW107XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF0gPSBsaXN0ZW5lcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbikge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3RlbmVycy5wdXNoKG5ld0xpc3RlbmVyKTtcclxuXHRcdHR5cGVMaXN0ZW5lcnMuY291bnQrKztcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzLFxyXG5cdFx0ICAgIGNvbnRleHRJZCxcclxuXHRcdCAgICBsaXN0ZW5lcnMsXHJcblx0XHQgICAgaSxcclxuXHRcdCAgICBsZW47XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3Agc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdGlmICh0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0Zm9yIChjb250ZXh0SWQgaW4gdHlwZUxpc3RlbmVycy5saXN0ZW5lcnMpIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF07XHJcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb250ZXh0SWQgPSBjb250ZXh0ICYmIGNvbnRleHQgIT09IHRoaXMgJiYgTC5zdGFtcChjb250ZXh0KTtcclxuXHRcdGlmICghY29udGV4dElkKSB7XHJcblx0XHRcdGNvbnRleHRJZCA9ICdub19jb250ZXh0JztcclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0eXBlTGlzdGVuZXJzLmxpc3RlbmVyc1tjb250ZXh0SWRdO1xyXG5cdFx0aWYgKGxpc3RlbmVycykge1xyXG5cclxuXHRcdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChsLmZuID09PSBmbikge1xyXG5cclxuXHRcdFx0XHRcdC8vIHNldCB0aGUgcmVtb3ZlZCBsaXN0ZW5lciB0byBub29wIHNvIHRoYXQncyBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRcdGwuZm4gPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHRcdHR5cGVMaXN0ZW5lcnMuY291bnQtLTtcclxuXHJcblx0XHRcdFx0XHRpZiAobGVuID4gMSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuX2lzRmlyaW5nKSB7XHJcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdFx0XHRcdHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF0gPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0XHRcdFx0XHR0eXBlTGlzdGVuZXJzLmxpc3RlbmVyc1tjb250ZXh0SWRdLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGFuIGRhdGFcclxuXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG5cdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBtaWdodCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudCA9IEwuVXRpbC5leHRlbmQoe30sIGRhdGEsIHt0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0aWYgKHR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHR0aGlzLl9pc0ZpcmluZyA9IHRydWU7XHJcblxyXG5cdFx0XHRcdC8vIGVhY2ggY29udGV4dFxyXG5cdFx0XHRcdGZvciAodmFyIGNvbnRleHRJZCBpbiB0eXBlTGlzdGVuZXJzLmxpc3RlbmVycykge1xyXG5cdFx0XHRcdFx0dmFyIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gZWFjaCBmbiBpbiBjb250ZXh0XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0XHRsLmZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5faXNGaXJpbmcgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIHByb3BhZ2F0ZSkge1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKHR5cGVMaXN0ZW5lcnMgJiYgdHlwZUxpc3RlbmVycy5jb3VudCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IEwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbTC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tMLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIEwuZXh0ZW5kKHtsYXllcjogZS50YXJnZXR9LCBlKSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBwcm90byA9IEwuRXZlbnRlZC5wcm90b3R5cGU7XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbnByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5vbjtcclxuXHJcbi8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4vLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG8uY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IHByb3RvLm9mZjtcclxuXHJcbi8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbnByb3RvLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gcHJvdG8ub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5wcm90by5maXJlRXZlbnQgPSBwcm90by5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxucHJvdG8uaGFzRXZlbnRMaXN0ZW5lcnMgPSBwcm90by5saXN0ZW5zO1xyXG5cclxuTC5NaXhpbiA9IHtFdmVudHM6IHByb3RvfTtcclxuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxyXG5cdCAgICBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcblxyXG5cdCAgICBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3csXHJcblxyXG5cdCAgICB3ZWJraXQgICAgPSB1YS5pbmRleE9mKCd3ZWJraXQnKSAhPT0gLTEsXHJcblx0ICAgIHBoYW50b21qcyA9IHVhLmluZGV4T2YoJ3BoYW50b20nKSAhPT0gLTEsXHJcblx0ICAgIGFuZHJvaWQyMyA9IHVhLnNlYXJjaCgnYW5kcm9pZCBbMjNdJykgIT09IC0xLFxyXG5cdCAgICBjaHJvbWUgICAgPSB1YS5pbmRleE9mKCdjaHJvbWUnKSAhPT0gLTEsXHJcblx0ICAgIGdlY2tvICAgICA9IHVhLmluZGV4T2YoJ2dlY2tvJykgIT09IC0xICAmJiAhd2Via2l0ICYmICF3aW5kb3cub3BlcmEgJiYgIWllLFxyXG5cclxuXHQgICAgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwLFxyXG5cclxuXHQgICAgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1YS5pbmRleE9mKCdtb2JpbGUnKSAhPT0gLTEsXHJcblx0ICAgIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudCxcclxuXHQgICAgcG9pbnRlciA9IHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyLFxyXG5cclxuXHQgICAgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gZG9jLnN0eWxlKSxcclxuXHQgICAgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMyxcclxuXHQgICAgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gZG9jLnN0eWxlLFxyXG5cdCAgICBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBkb2Muc3R5bGU7XHJcblxyXG5cclxuXHR2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHBvaW50ZXIgfHwgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XHJcblx0XHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG5cdEwuQnJvd3NlciA9IHtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgaWU6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcblx0XHRpZTogaWUsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG5cdFx0aWVsdDk6IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG5cdFx0ZWRnZTogJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCksXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcblx0XHR3ZWJraXQ6IHdlYmtpdCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG5cdFx0Z2Vja286IGdlY2tvLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxuXHRcdGFuZHJvaWQ6IHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcblx0XHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuXHRcdGNocm9tZTogY2hyb21lLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG5cdFx0c2FmYXJpOiAhY2hyb21lICYmIHVhLmluZGV4T2YoJ3NhZmFyaScpICE9PSAtMSxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdpbjogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuXHRcdHdpbjogd2luLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdGllM2Q6IGllM2QsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRnZWNrbzNkOiBnZWNrbzNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG5cdFx0b3BlcmExMjogb3BlcmExMixcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRhbnkzZDogIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b21qcyxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGU6IG1vYmlsZSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlV2Via2l0OiBtb2JpbGUgJiYgd2Via2l0LFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZSAmJiB3ZWJraXQzZCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlT3BlcmE6IG1vYmlsZSAmJiB3aW5kb3cub3BlcmEsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlR2Vja286IG1vYmlsZSAmJiBnZWNrbyxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG5cdFx0dG91Y2g6ICEhdG91Y2gsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcblx0XHRtc1BvaW50ZXI6ICEhbXNQb2ludGVyLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcblx0XHRwb2ludGVyOiAhIXBvaW50ZXIsXHJcblxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4uXHJcblx0XHRyZXRpbmE6ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMVxyXG5cdH07XHJcblxyXG59KCkpO1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLlBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHJvdW5kKSB7XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufTtcclxuXHJcbkwuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQoTC5wb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdChMLnBvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG5cdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcblx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcblx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG5cdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcblx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5MLnBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBMLlBvaW50KSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKEwuVXRpbC5pc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeFswXSwgeFsxXSk7XHJcblx0fVxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5LCByb3VuZCk7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBCb3VuZHNcclxuICogQGFrYSBMLkJvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkJvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gTC5wb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5ib3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5Cb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gTC5ib3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSBMLmJvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcblx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHRvcExlZnQ6IFBvaW50LCBib3R0b21SaWdodDogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvb3JkaW5hdGVzICh1c3VhbGx5IHRvcC1sZWZ0IGFuZCBib3R0b20tcmlnaHQgY29ybmVycykuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIHBvaW50cyBpdCBjb250YWluc1xyXG5MLmJvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Cb3VuZHMoYSwgYik7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBuZXcgTC5UcmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbkwuVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59O1xyXG5cclxuTC5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyByZWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyByZWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5MLkRvbVV0aWwgPSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcblx0Ly8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuXHRnZXQ6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuXHQvLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcclxuXHJcblx0XHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0XHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5cdGNyZWF0ZTogZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblxyXG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0XHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdGlmIChwYXJlbnQpIHtcclxuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuXHRlbXB0eTogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZHJlbiBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuXHR0b0Zyb250OiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdGVsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkcmVuIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmFjayBmcm9tIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuXHR0b0JhY2s6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuXHRoYXNDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHRcdH1cclxuXHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcblx0Ly8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHZhciBjbGFzc2VzID0gTC5VdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICghTC5Eb21VdGlsLmhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gTC5Eb21VdGlsLmdldENsYXNzKGVsKTtcclxuXHRcdFx0TC5Eb21VdGlsLnNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG5cdC8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0Q2xhc3MoZWwsIEwuVXRpbC50cmltKCgnICcgKyBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcblx0Ly8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5cdHNldENsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5cdGdldENsYXNzOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcblx0Ly8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcblx0Ly8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcclxuXHJcblx0XHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5fc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NldE9wYWNpdHlJRTogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xyXG5cdFx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdFx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHRcdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdFx0aWYgKGZpbHRlcikge1xyXG5cdFx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG5cdC8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuXHQvLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG5cdC8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5cdHRlc3RQcm9wOiBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcblx0Ly8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcblx0Ly8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcblx0c2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHRcdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IEwuUG9pbnQoMCwgMCk7XHJcblxyXG5cdFx0ZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPVxyXG5cdFx0XHQoTC5Ccm93c2VyLmllM2QgP1xyXG5cdFx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcblx0Ly8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuXHQvLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCwgcG9pbnQpIHsgLy8gKEhUTUxFbGVtZW50LCBQb2ludFssIEJvb2xlYW5dKVxyXG5cclxuXHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdFx0Lyplc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0XHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRcdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IEwuUG9pbnQoMCwgMCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0Ly8gcHJlZml4IHN0eWxlIHByb3BlcnR5IG5hbWVzXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG5cdC8vIFZlbmRvci1wcmVmaXhlZCBmcmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5cdEwuRG9tVXRpbC5UUkFOU0ZPUk0gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcblxyXG5cdC8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuXHQvLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcblx0Ly8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG5cdC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZS5cclxuXHR2YXIgdHJhbnNpdGlvbiA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG5cdFx0XHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcblx0TC5Eb21VdGlsLlRSQU5TSVRJT05fRU5EID1cclxuXHRcdFx0dHJhbnNpdGlvbiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IHRyYW5zaXRpb24gPT09ICdPVHJhbnNpdGlvbicgPyB0cmFuc2l0aW9uICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcblx0Ly8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuXHQvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG5cdC8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuXHQvLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG5cdC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuXHRpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH07XHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH07XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG5cdFx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdFx0dGhpcy5fdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSB0aGlzLl91c2VyU2VsZWN0O1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl91c2VyU2VsZWN0O1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG5cdC8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuXHQvLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuXHRMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcblx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcblx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuXHQvLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG5cdC8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuXHQvLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcblx0TC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuXHRcdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdFx0TC5Eb21VdGlsLnJlc3RvcmVPdXRsaW5lKCk7XHJcblx0XHR0aGlzLl9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcblx0XHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCBMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUsIHRoaXMpO1xyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcblx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuXHRMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5fb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IHRoaXMuX291dGxpbmVTdHlsZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9vdXRsaW5lRWxlbWVudDtcclxuXHRcdGRlbGV0ZSB0aGlzLl9vdXRsaW5lU3R5bGU7XHJcblx0XHRMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdrZXlkb3duJywgTC5Eb21VdGlsLnJlc3RvcmVPdXRsaW5lLCB0aGlzKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cblxuXG4vKiBAY2xhc3MgTGF0TG5nXHJcbiAqIEBha2EgTC5MYXRMbmdcclxuICpcclxuICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTGF0TG5nID0gZnVuY3Rpb24gKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufTtcclxuXHJcbkwuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmosIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0b2JqID0gTC5sYXRMbmcob2JqKTtcclxuXHJcblx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuXHRcdHJldHVybiBtYXJnaW4gPD0gKG1heE1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMS4wRS05IDogbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IChmb3IgZGVidWdnaW5nIHB1cnBvc2VzKS5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEwuQ1JTLkVhcnRoLmRpc3RhbmNlKHRoaXMsIEwubGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkNSUy5FYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnNgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gTC5sYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5MLmxhdExuZyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChMLlV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkxhdExuZyhhLCBiLCBjKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHNvdXRoV2VzdCA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIG5vcnRoRWFzdCA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKHNvdXRoV2VzdCwgbm9ydGhFYXN0KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5MYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoc291dGhXZXN0LCBub3J0aEVhc3QpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFzb3V0aFdlc3QpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gbm9ydGhFYXN0ID8gW3NvdXRoV2VzdCwgbm9ydGhFYXN0XSA6IHNvdXRoV2VzdDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKEwubGF0TG5nKG9iaikgfHwgTC5sYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMLkxhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IEwuTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBiaWdnZXIgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHBlcmNlbnRhZ2UgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTC5MYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5sYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhzb3V0aFdlc3Q6IExhdExuZywgbm9ydGhFYXN0OiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgc291dGgtd2VzdCBhbmQgbm9ydGgtZWFzdCBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuTC5sYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHNlY3Rpb25cclxuICogTGVhZmxldCBjb21lcyB3aXRoIGEgc2V0IG9mIGFscmVhZHkgZGVmaW5lZCBQcm9qZWN0aW9ucyBvdXQgb2YgdGhlIGJveDpcclxuICpcclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gKlxyXG4gKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICogbGF0aXR1ZGUuIEFsc28gc3VpdGFibGUgZm9yIGZsYXQgd29ybGRzLCBlLmcuIGdhbWUgbWFwcy4gVXNlZCBieSB0aGVcclxuICogYEVQU0c6MzM5NWAgYW5kIGBTaW1wbGVgIENSUy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24gPSB7fTtcclxuXHJcbkwuUHJvamVjdGlvbi5Mb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogTC5ib3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxufTtcclxuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuXHRSOiA2Mzc4MTM3LFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuXHRcdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IDYzNzgxMzcgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIEwuYm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG5cdH0pKClcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIENSU1xyXG4gKiBAYWthIEwuQ1JTXHJcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICovXHJcblxyXG5MLkNSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZ3RvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIEwuYm91bmRzKG1pbiwgbWF4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMTogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuXHQvLyBAcHJvcGVydHkgY29kZTogU3RyaW5nXHJcblx0Ly8gU3RhbmRhcmQgY29kZSBuYW1lIG9mIHRoZSBDUlMgcGFzc2VkIGludG8gV01TIHNlcnZpY2VzIChlLmcuIGAnRVBTRzozODU3J2ApXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExuZzogTnVtYmVyW11cclxuXHQvLyBBbiBhcnJheSBvZiB0d28gbnVtYmVycyBkZWZpbmluZyB3aGV0aGVyIHRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZSBheGlzXHJcblx0Ly8gd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgYXhpcy5cclxuXHJcblx0Ly8gd3JhcExuZzogW21pbiwgbWF4XSxcclxuXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuXHQvLyBAcHJvcGVydHkgaW5maW5pdGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBMLlV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBMLlV0aWwud3JhcE51bShsYXRsbmcubGF0LCB0aGlzLndyYXBMYXQsIHRydWUpIDogbGF0bG5nLmxhdCxcclxuXHRcdCAgICBhbHQgPSBsYXRsbmcuYWx0O1xyXG5cclxuXHRcdHJldHVybiBMLmxhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5TaW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAqL1xuXG5MLkNSUy5TaW1wbGUgPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLkxvbkxhdCxcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcblxuXG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5FYXJ0aFxuICpcbiAqIFNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgQ1JTIHRoYXQgYXJlIGdsb2JhbCBzdWNoIHRoYXQgdGhleSBjb3ZlciB0aGUgZWFydGguXG4gKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBtZXRlcnMuXG4gKi9cblxuTC5DUlMuRWFydGggPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcblx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcblx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcblx0Ly8gc2VlIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuXHRSOiA2MzcxMDAwLFxuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcblx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuXHRcdCAgICBhID0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQyKSArXG5cdFx0ICAgICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MoKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkKTtcblxuXHRcdHJldHVybiB0aGlzLlIgKiBNYXRoLmFjb3MoTWF0aC5taW4oYSwgMSkpO1xuXHR9XG59KTtcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxuTC5DUlMuRVBTRzM4NTcgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gbmV3IEwuVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5MLkNSUy5FUFNHOTAwOTEzID0gTC5leHRlbmQoe30sIEwuQ1JTLkVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHNDMyNiA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5Mb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbn0pO1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbkwuTWFwID0gTC5FdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogTC5DUlMuRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gT3ZlcnJpZGVzIGFueSBgbWluWm9vbWAgb3B0aW9uIHNldCBvbiBtYXAgbGF5ZXJzLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gT3ZlcnJpZGVzIGFueSBgbWF4Wm9vbWAgb3B0aW9uIHNldCBvbiBtYXAgbGF5ZXJzLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgd2hlbiBoZSB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gTC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcoTC5sYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG5cdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdC8vIHJlcGxhY2VkIGJ5IGFuaW1hdGlvbi1wb3dlcmVkIGltcGxlbWVudGF0aW9uIGluIE1hcC5QYW5BbmltYXRpb24uanNcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb207XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoTC5sYXRMbmcoY2VudGVyKSwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHpvb20gb2YgdGhlIG1hcC5cclxuXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIEluY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChMLkJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoTC5Ccm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBMLlBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0X2dldEJvdW5kc0NlbnRlclpvb206IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSBMLnBvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gTC5wb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcblx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuXHRcdHpvb20gPSAodHlwZW9mIG9wdGlvbnMubWF4Wm9vbSA9PT0gJ251bWJlcicpID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zOiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7IC8vIChQb2ludClcclxuXHRcdC8vIHJlcGxhY2VkIHdpdGggYW5pbWF0ZWQgcGFuQnkgaW4gTWFwLlBhbkFuaW1hdGlvbi5qc1xyXG5cdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHJcblx0XHR0aGlzLl9yYXdQYW5CeShMLnBvaW50KG9mZnNldCkpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIEwubGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9QYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gTC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBUT0RPIGhhbmRsZXIuYWRkVG9cclxuXHQvLyBUT0RPIEFwcHJvcGlhdGUgZG9jcyBzZWN0aW9uP1xyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcblx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG5cdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDcmVhdGVzIGEgbmV3IFttYXAgcGFuZV0oI21hcC1wYW5lKSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSxcclxuXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZHJlbiBvZiBgY29udGFpbmVyYCwgb3JcclxuXHQvLyBhcyBhIGNoaWxkcmVuIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcblx0Y3JlYXRlUGFuZTogZnVuY3Rpb24gKG5hbWUsIGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcblx0XHQgICAgcGFuZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmIChuYW1lKSB7XHJcblx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IEwucG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRoaXMucHJvamVjdChzZSwgem9vbSkuc3VidHJhY3QodGhpcy5wcm9qZWN0KG53LCB6b29tKSksXHJcblx0XHQgICAgc25hcCA9IEwuQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblxyXG5cdFx0dmFyIHNjYWxlID0gTWF0aC5taW4oc2l6ZS54IC8gYm91bmRzU2l6ZS54LCBzaXplLnkgLyBib3VuZHNTaXplLnkpO1xyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgTC5Qb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEwuQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcblx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcblx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludChMLmxhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyhMLnBvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IEwucG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KEwubGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuXHQvLyBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyhMLmxhdExuZyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG5cdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZShMLmxhdExuZyhsYXRsbmcxKSwgTC5sYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiBMLnBvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiBMLnBvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KEwucG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KEwubGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHRjb250YWluZXIuX2xlYWZsZXQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEwuQnJvd3Nlci5hbnkzZDtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEwuQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEwuQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBMLkRvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgTC5Qb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0Ly8gQHBhbmUgdGlsZVBhbmU6IEhUTUxFbGVtZW50ID0gMjAwXHJcblx0XHQvLyBQYW5lIGZvciBgR3JpZExheWVyYHMgYW5kIGBUaWxlTGF5ZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0aWxlUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgb3ZlcmxheVBhbmU6IEhUTUxFbGVtZW50ID0gNDAwXHJcblx0XHQvLyBQYW5lIGZvciB2ZWN0b3Igb3ZlcmxheXMgKGBQYXRoYHMpLCBsaWtlIGBQb2x5bGluZWBzIGFuZCBgUG9seWdvbmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcblx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIHRvb2x0aXAuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgTC5Qb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHRcdHpvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cHJlcmVzZXQnKTtcclxuXHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cdFx0dGhpc1xyXG5cdFx0XHQuX21vdmVTdGFydCh6b29tQ2hhbmdlZClcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZXRlYWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLCBpbmNsdWRpbmcgem9vbVxyXG5cdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGV0ZWFkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLCBpbmNsdWRpbmcgcGFuIGFuZFxyXG5cdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaGFzIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXHJcblx0XHQvLyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG5cdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcblx0XHRpZiAoIUwuRG9tRXZlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tMLnN0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbic7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0TC5Eb21FdmVudFtvbk9mZl0odGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0TC5Eb21FdmVudFtvbk9mZl0od2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0dGhpc1tvbk9mZl0oJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG5cdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpbmRFdmVudFRhcmdldHM6IGZ1bmN0aW9uIChlLCB0eXBlKSB7XHJcblx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxyXG5cdFx0ICAgIHRhcmdldCxcclxuXHRcdCAgICBpc0hvdmVyID0gdHlwZSA9PT0gJ21vdXNlb3V0JyB8fCB0eXBlID09PSAnbW91c2VvdmVyJyxcclxuXHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXHJcblx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcblx0XHR3aGlsZSAoc3JjKSB7XHJcblx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldHNbTC5zdGFtcChzcmMpXTtcclxuXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiAhZS5fc2ltdWxhdGVkICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyICYmICFMLkRvbUV2ZW50Ll9pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG5cdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIEwuRG9tRXZlbnQuX2lzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkge1xyXG5cdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgTC5Eb21FdmVudC5fc2tpcHBlZChlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZSA9PT0gJ2tleXByZXNzJyAmJiBlLmtleUNvZGUgPT09IDEzID8gJ2NsaWNrJyA6IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZShlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgdGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IEwuVXRpbC5leHRlbmQoe30sIGUpO1xyXG5cdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCB0YXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZS5fc3RvcHBlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcblx0XHR0YXJnZXRzID0gKHRhcmdldHMgfHwgW10pLmNvbmNhdCh0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpKTtcclxuXHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldCBpbnN0YW5jZW9mIEwuTWFya2VyO1xyXG5cdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG5cdFx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5ub25CdWJibGluZ0V2ZW50cyAmJiBMLlV0aWwuaW5kZXhPZih0YXJnZXRzW2ldLm9wdGlvbnMubm9uQnViYmxpbmdFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IEwuUG9pbnQoMCwgMCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgTC5Cb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG5cdFx0aWYgKG9mZnNldC5yb3VuZCgpLmVxdWFscyhbMCwgMF0pKSB7XHJcblx0XHRcdHJldHVybiBjZW50ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgTC5Cb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IEwuYm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBMLkJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbkwubWFwID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcChpZCwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuTWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuTC5MYXllciA9IEwuRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnb3ZlcmxheVBhbmUnXG5cdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cdFx0bm9uQnViYmxpbmdFdmVudHM6IFtdICAvLyBBcnJheSBvZiBldmVudHMgdGhhdCBzaG91bGQgbm90IGJlIGJ1YmJsZWQgdG8gRE9NIHBhcmVudHMgKGxpa2UgdGhlIG1hcClcblx0fSxcblxuXHQvKiBAc2VjdGlvblxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcblx0ICpcblx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcblx0ICogQWRkcyB0aGUgbGF5ZXIgdG8gdGhlIGdpdmVuIG1hcFxuXHQgKi9cblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tMLnN0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW0wuc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcblx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gKiBAdW5pbmhlcml0YWJsZVxuICpcbiAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAqXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICpcbiAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICpcbiAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICpcbiAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcFxuICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gKlxuICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAqXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gKi9cbkwuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gTC5zdGFtcChsYXllcik7XG5cdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cblx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIuZ2V0QXR0cmlidXRpb24gJiYgdGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdHRoaXMuYXR0cmlidXRpb25Db250cm9sLnJlbW92ZUF0dHJpYnV0aW9uKGxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcblx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuXHRcdH1cblxuXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKEwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XG5cdH0sXG5cblx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHQgKiBgYGBcblx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG5cdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKEwuVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tMLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gTC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIFRha2VzIGludG8gYWNjb3VudCB0aGF0IEVhcnRoIGlzIGEgZ2VvaWQsIG5vdCBhIHBlcmZlY3Qgc3BoZXJlLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbi5NZXJjYXRvciA9IHtcclxuXHRSOiA2Mzc4MTM3LFxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuXHRib3VuZHM6IEwuYm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcblx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHMzM5NSA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjMzOTUnLFxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5NZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIEwuUHJvamVjdGlvbi5NZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiBuZXcgTC5UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXG5cblxuLypcbiAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLkdyaWRMYXllclxuICpcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAqXG4gKlxuICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAqICAgICAgICAgdmFyIGVycm9yO1xuICpcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvblxuICovXG5cblxuTC5HcmlkTGF5ZXIgPSBMLkxheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG5cdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuXHRcdHRpbGVTaXplOiAyNTYsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gSWYgYGZhbHNlYCwgbmV3IHRpbGVzIGFyZSBsb2FkZWQgZHVyaW5nIHBhbm5pbmcsIG90aGVyd2lzZSBvbmx5IGFmdGVyIGl0IChmb3IgYmV0dGVyIHBlcmZvcm1hbmNlKS4gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBvdGhlcndpc2UgYGZhbHNlYC5cblx0XHR1cGRhdGVXaGVuSWRsZTogTC5Ccm93c2VyLm1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBkZXNjcmliZXMgdGhlIGxheWVyIGRhdGEsIGUuZy4gXCLCqSBNYXBib3hcIi5cblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgdGhhdCB0aWxlcyB3aWxsIGJlIGxvYWRlZCBhdC4gQnkgZGVmYXVsdCB0aGUgZW50aXJlIG1hcC5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHRoYXQgdGlsZXMgd2lsbCBiZSBsb2FkZWQgYXQuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG5cdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdEwuRG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBTdHJpbmdcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cblx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcblx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG5cdFx0fTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG5cdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG5cdFx0XHRcdHRoaXMuX29uTW92ZSA9IEwuVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBgR3JpZExheWVyYC5cblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQG1ldGhvZCBnZXRUaWxlU2l6ZTogUG9pbnRcblx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG5cdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG5cdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBMLlBvaW50ID8gcyA6IG5ldyBMLlBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSkgeyByZXR1cm47IH1cblxuXHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7IHdpbGxQcnVuZSA9IHRydWU7IH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXIgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuXHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHRpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG5cdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cblx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRMLlV0aWwuZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdH1cblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG5cdFx0dGhpcy5fdGlsZVpvb20gPSBudWxsO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgTC5Qb2ludCgreDIsICt5Mik7XG5cdFx0Y29vcmRzMi56ID0gK3oyO1xuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcblx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IEwuUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgTC5Cb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBMLkJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMoTC5wb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IEwuUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXRzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG5cdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG5cdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcblx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG5cdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdHJldHVybiBMLmxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcblx0fSxcblxuXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG5cdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cblx0XHQgICAgbncgPSBtYXAud3JhcExhdExuZyhtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSksXG5cdFx0ICAgIHNlID0gbWFwLndyYXBMYXRMbmcobWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueikpO1xuXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhudywgc2UpO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcblx0XHQgICAgY29vcmRzID0gbmV3IEwuUG9pbnQoK2tbMF0sICtrWzFdKTtcblx0XHRjb29yZHMueiA9ICtrWzJdO1xuXHRcdHJldHVybiBjb29yZHM7XG5cdH0sXG5cblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IEwuVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHQvLyB3aXRob3V0IHRoaXMgaGFjaywgdGlsZXMgZGlzYXBwZWFyIGFmdGVyIHpvb20gb24gQ2hyb21lIGZvciBBbmRyb2lkXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuXHRcdGlmIChMLkJyb3dzZXIuYW5kcm9pZCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMykge1xuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cblx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKEwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAoZXJyKSB7XG5cdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcblx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHR9XG5cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG5cdFx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IEwuUG9pbnQoXG5cdFx0XHR0aGlzLl93cmFwWCA/IEwuVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gTC5VdGlsLndyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBMLkJvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcblx0fSxcblxuXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuTC5ncmlkTGF5ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuR3JpZExheWVyKG9wdGlvbnMpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS50aWxlLm9zbS5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2Jhcid9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICpcclxuICogYGBgXHJcbiAqICdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgQDJ4IHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbkwuVGlsZUxheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXHJcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxyXG5cdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxyXG5cdFx0bWF4TmF0aXZlWm9vbTogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvICcnLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRvcHRpb25zID0gTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBMLkJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcblx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cdFx0XHRcdG9wdGlvbnMubWF4Wm9vbS0tO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG5cdFx0XHRcdG9wdGlvbnMubWluWm9vbSsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcGlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbih0aWxlLCAnbG9hZCcsIEwuYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRpbGUsICdlcnJvcicsIEwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcclxuXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qXHJcblx0XHQgQWx0IHRhZyBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIHRvIGtlZXAgc2NyZWVuIHJlYWRlcnMgZnJvbSByZWFkaW5nIFVSTCBhbmQgZm9yIGNvbXBsaWFuY2UgcmVhc29uc1xyXG5cdFx0IGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9INjdcclxuXHRcdCovXHJcblx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuXHQvLyBAdW5pbmhlcml0YWJsZVxyXG5cdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcblx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRyOiBMLkJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTC5VdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgTC5leHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KEwuYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgdGlsZVNpemUgPSBMLkdyaWRMYXllci5wcm90b3R5cGUuZ2V0VGlsZVNpemUuY2FsbCh0aGlzKSxcclxuXHRcdCAgICB6b29tID0gdGhpcy5fdGlsZVpvb20gKyB0aGlzLm9wdGlvbnMuem9vbU9mZnNldCxcclxuXHRcdCAgICB6b29tTiA9IHRoaXMub3B0aW9ucy5tYXhOYXRpdmVab29tO1xyXG5cclxuXHRcdC8vIGluY3JlYXNlIHRpbGUgc2l6ZSB3aGVuIG92ZXJzY2FsaW5nXHJcblx0XHRyZXR1cm4gem9vbU4gIT09IG51bGwgJiYgem9vbSA+IHpvb21OID9cclxuXHRcdFx0XHR0aWxlU2l6ZS5kaXZpZGVCeShtYXAuZ2V0Wm9vbVNjYWxlKHpvb21OLCB6b29tKSkucm91bmQoKSA6XHJcblx0XHRcdFx0dGlsZVNpemU7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX3RpbGVab29tO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBvcHRpb25zLm1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHpvb20gKz0gb3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb20gIT09IG51bGwgPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heE5hdGl2ZVpvb20pIDogem9vbTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdHRpbGUuc3JjID0gTC5VdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRpbGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlbGF5ZXIodXJsVGVtcGxhdGU6IFN0cmluZywgb3B0aW9ucz86IFRpbGVMYXllciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGBVUkwgdGVtcGxhdGVgIGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5cclxuTC50aWxlTGF5ZXIgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLlRpbGVMYXllci5XTVMgPSBMLlRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHA6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG5cdFx0bGF5ZXJzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcblx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuXHRcdHZlcnNpb246ICcxLjEuMSdcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG5cdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcblx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHR2YXIgd21zUGFyYW1zID0gTC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG5cdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB3bXNQYXJhbXMuaGVpZ2h0ID0gb3B0aW9ucy50aWxlU2l6ZSAqIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBMLkJyb3dzZXIucmV0aW5hID8gMiA6IDEpO1xyXG5cclxuXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcblx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuXHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XHJcblxyXG5cdFx0TC5UaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKSxcclxuXHRcdCAgICBudyA9IHRoaXMuX2Nycy5wcm9qZWN0KHRpbGVCb3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgIHNlID0gdGhpcy5fY3JzLnByb2plY3QodGlsZUJvdW5kcy5nZXRTb3V0aEVhc3QoKSksXHJcblxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBMLkNSUy5FUFNHNDMyNiA/XHJcblx0XHRcdCAgICBbc2UueSwgbncueCwgbncueSwgc2UueF0gOlxyXG5cdFx0XHQgICAgW253LngsIHNlLnksIHNlLngsIG53LnldKS5qb2luKCcsJyksXHJcblxyXG5cdFx0ICAgIHVybCA9IEwuVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0TC5VdGlsLmdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuXHRcdFx0KHRoaXMub3B0aW9ucy51cHBlcmNhc2UgPyAnJkJCT1g9JyA6ICcmYmJveD0nKSArIGJib3g7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBNZXJnZXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzIGFuZCByZS1yZXF1ZXN0cyB0aWxlcyBvbiB0aGUgY3VycmVudCBzY3JlZW4gKHVubGVzcyBgbm9SZWRyYXdgIHdhcyBzZXQgdG8gdHJ1ZSkuXHJcblx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuXHRcdEwuZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5MLnRpbGVMYXllci53bXMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlRpbGVMYXllci5XTVModXJsLCBvcHRpb25zKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cDovL3d3dy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkltYWdlT3ZlcmxheSA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIEltYWdlT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGltYWdlIG92ZXJsYXkgd2lsbCBlbWl0IFttb3VzZSBldmVudHNdKCNpbnRlcmFjdGl2ZS1sYXllcikgd2hlbiBjbGlja2VkIG9yIGhvdmVyZWQuXHJcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxyXG5cdFx0Ly8gQW4gb3B0aW9uYWwgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgXHJcblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gJycuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkoKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdEwuRG9tVXRpbC50b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvQmFjayh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2ltZycsXHJcblx0XHRcdFx0J2xlYWZsZXQtaW1hZ2UtbGF5ZXIgJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnbGVhZmxldC16b29tLWFuaW1hdGVkJyA6ICcnKSk7XHJcblxyXG5cdFx0aW1nLm9uc2VsZWN0c3RhcnQgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdGltZy5vbmxvYWQgPSBMLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCksIGUuem9vbSwgZS5jZW50ZXIpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgYm91bmRzID0gbmV3IEwuQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5MLmltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5JbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKi9cclxuXHJcbkwuSWNvbiA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG5cdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpemUgPSBMLnBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IEwucG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcblx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiBMLkJyb3dzZXIucmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbkwuaWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkljb24ob3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8qXG4gKiBMLkljb24uRGVmYXVsdCBpcyB0aGUgYmx1ZSBtYXJrZXIgaWNvbiB1c2VkIGJ5IGRlZmF1bHQgaW4gTGVhZmxldC5cbiAqL1xuXG5MLkljb24uRGVmYXVsdCA9IEwuSWNvbi5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcblx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dmFyIGtleSA9IG5hbWUgKyAnVXJsJztcblxuXHRcdGlmICh0aGlzLm9wdGlvbnNba2V5XSkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xuXHRcdH1cblxuXHRcdHZhciBwYXRoID0gTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoO1xuXG5cdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkblxcJ3QgYXV0b2RldGVjdCBMLkljb24uRGVmYXVsdC5pbWFnZVBhdGgsIHNldCBpdCBtYW51YWxseS4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aCArICcvbWFya2VyLScgKyBuYW1lICsgKEwuQnJvd3Nlci5yZXRpbmEgJiYgbmFtZSA9PT0gJ2ljb24nID8gJy0yeCcgOiAnJykgKyAnLnBuZyc7XG5cdH1cbn0pO1xuXG5MLkljb24uRGVmYXVsdC5pbWFnZVBhdGggPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSxcblx0ICAgIGxlYWZsZXRSZSA9IC9bXFwvXl1sZWFmbGV0W1xcLVxcLl9dPyhbXFx3XFwtXFwuX10qKVxcLmpzXFw/Py87XG5cblx0dmFyIGksIGxlbiwgc3JjLCBwYXRoO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHNjcmlwdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRzcmMgPSBzY3JpcHRzW2ldLnNyYyB8fCAnJztcblxuXHRcdGlmIChzcmMubWF0Y2gobGVhZmxldFJlKSkge1xuXHRcdFx0cGF0aCA9IHNyYy5zcGxpdChsZWFmbGV0UmUpWzBdO1xuXHRcdFx0cmV0dXJuIChwYXRoID8gcGF0aCArICcvJyA6ICcnKSArICdpbWFnZXMnO1xuXHRcdH1cblx0fVxufSgpKTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTWFya2VyID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGNsYXNzIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi4gU2V0IHRvIG5ldyBgTC5JY29uLkRlZmF1bHQoKWAgYnkgZGVmYXVsdC5cclxuXHRcdGljb246IG5ldyBMLkljb24uRGVmYXVsdCgpLFxyXG5cclxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgY2FuIGJlIHRhYmJlZCB0byB3aXRoIGEga2V5Ym9hcmQgYW5kIGNsaWNrZWQgYnkgcHJlc3NpbmcgZW50ZXIuXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRpdGxlOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXHJcblx0XHR0aXRsZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9uSG92ZXI6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcclxuXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG5cdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ21hcmtlclBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcblx0XHQvLyBGSVhNRTogc2hhZG93UGFuZSBpcyBubyBsb25nZXIgYSB2YWxpZCBvcHRpb25cclxuXHRcdG5vbkJ1YmJsaW5nRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5kcmFnZ2luZy5yZW1vdmVIb29rcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0ICAgIGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbHQpIHtcclxuXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgnc2hhZG93UGFuZScpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcclxuXHJcblx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMuX2ljb24uc3R5bGUuekluZGV4ID0gdGhpcy5fekluZGV4ICsgb2Zmc2V0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKG9wdCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XHJcblxyXG5cdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbnRlcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKEwuSGFuZGxlci5NYXJrZXJEcmFnKSB7XHJcblx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG5cdFx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG5cdFx0XHRcdGRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpO1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IEwuSGFuZGxlci5NYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbkwubWFya2VyID0gZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5NYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufTtcclxuXG5cblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbkwuRGl2SWNvbiA9IEwuSWNvbi5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cblx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG5cdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdHZhciBiZ1BvcyA9IEwucG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG5cdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC1iZ1Bvcy54KSArICdweCAnICsgKC1iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZGl2SWNvbihvcHRpb25zOiBEaXZJY29uIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5MLmRpdkljb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuRGl2SWNvbihvcHRpb25zKTtcbn07XG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5MLkRpdk92ZXJsYXkgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uIFVzZWZ1bCB0byBjb250cm9sIHRoZSBhbmNob3JcclxuXHRcdC8vIG9mIHRoZSBwb3B1cCB3aGVuIG9wZW5pbmcgaXQgb24gc29tZSBvdmVybGF5cy5cclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgcG9wdXAgb24gem9vbS4gRGlzYWJsZSBpdCBpZiB5b3UgaGF2ZVxyXG5cdFx0Ly8gcHJvYmxlbXMgd2l0aCBGbGFzaCBjb250ZW50IGluc2lkZSBwb3B1cHMuXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdwb3B1cFBhbmUnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKEwuRG9tVXRpbC5yZW1vdmUsIEwuRG9tVXRpbCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiBwb3B1cC5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4uXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBwb3B1cC4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBwb3B1cC5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBBbGlhcyBmb3IgW2dldENvbnRlbnQoKV0oI3BvcHVwLWdldGNvbnRlbnQpXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIHBvcHVwIGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIHBvcHVwIGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBwb3B1cCBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdEwuRG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gTC5wb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuTC5Qb3B1cCA9IEwuRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAgKHNldCBnbG9iYWxseSBieVxyXG5cdFx0Ly8gdGhlIE1hcCdzIFtjbG9zZVBvcHVwT25DbGlja10oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uKS5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS4gVGhlIHNhbWUgYXMgYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdEwuRGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0gTC5EaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRpZiAoJ2Nsb3NlT25DbGljaycgaW4gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLFxyXG5cdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG5cdFx0XHQnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcclxuXHJcblx0XHRcdEwuRG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIHRoaXMuX29uQ2xvc2VCdXR0b25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKVxyXG5cdFx0XHQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKVxyXG5cdFx0XHQub24od3JhcHBlciwgJ2NvbnRleHRtZW51JywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4gfHwgKHRoaXMuX21hcC5fcGFuQW5pbSAmJiB0aGlzLl9tYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IEwuUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRsYXllclBvcy5fYWRkKEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX2Nsb3NlKCk7XHJcblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuXHRcdHJldHVybiBMLnBvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yID8gdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcigpIDogWzAsIDBdKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuLy8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG5MLnBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdHJldHVybiBuZXcgTC5Qb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBMLlBvcHVwKSkge1xyXG5cdFx0XHRwb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Qb3B1cCgpO1xuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xuICogYGBgXG4gKlxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXG4gKi9cblxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xuTC5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRQb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258UG9wdXAsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Qb3B1cCkge1xuXHRcdFx0TC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XG5cdFx0XHR0aGlzLm9uKHtcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHR0aGlzLm9mZih7XG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpY2VkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXIpKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcblx0XHRcdGxheWVyID0gdGhpcztcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkge1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFsYXRsbmcpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX21hcCkge1xuXHRcdFx0Ly8gc2V0IHBvcHVwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgcG9wdXAgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxuXHRcdFx0dGhpcy5fcG9wdXAudXBkYXRlKCk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXAsIGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMuX3BvcHVwLl9jbG9zZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb3B1cC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XG5cdH0sXG5cblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcHJldmVudCBtYXAgY2xpY2tcblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XG5cdFx0Ly8gb3BlbiB0aGUgcG9wdXAgYXQgdGhlIG5ldyBsb2NhdGlvblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuUGF0aCkge1xuXHRcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXllciB8fCBlLnRhcmdldCwgZS5sYXRsbmcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XG5cdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxuXHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApICYmIHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IGxheWVyKSB7XG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcGVuUG9wdXAobGF5ZXIsIGUubGF0bG5nKTtcblx0XHR9XG5cdH0sXG5cblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xuXHR9XG59KTtcblxuXG5cbi8qXHJcbiAqIFBvcHVwIGV4dGVuc2lvbiB0byBMLk1hcmtlciwgYWRkaW5nIHBvcHVwLXJlbGF0ZWQgbWV0aG9kcy5cclxuICovXHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yIHx8IFswLCAwXTtcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXRpbmc6XG4gKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzYsIC02XSwgYmVjYXVzZSB0aGUgdG9vbHRpcFxuICogICB0aXAgaXMgNnB4IHdpZHRoIGFuZCBoZWlnaHQuIFJlbWVtYmVyIHRvIGNoYW5nZSB0aGlzIHZhbHVlIGlmIHlvdSBvdmVycmlkZVxuICogICB0aGUgdGlwIGluIENTUy5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5MLlRvb2x0aXAgPSBMLkRpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCg2LCAtNilcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLiBVcGRhdGUgaXQgaWYgeW91IGN1c3RvbWl6ZSB0aGVcblx0XHQvLyB0b29sdGlwIHRpcCBpbiBDU1MuXG5cdFx0b2Zmc2V0OiBbNiwgLTZdLFxuXG5cdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG5cdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcC5jbG9zZVRvb2x0aXAodGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG5cdFx0ICAgIHRvb2x0aXBQb2ludCA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChwb3MpLFxuXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG5cdFx0ICAgIHRvb2x0aXBIZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuXHRcdCAgICBvZmZzZXQgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuXHRcdGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRwb3MgPSBwb3MuYWRkKEwucG9pbnQoLXRvb2x0aXBXaWR0aCAvIDIsIC10b29sdGlwSGVpZ2h0ICsgb2Zmc2V0LnkgKyBhbmNob3IueSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KEwucG9pbnQodG9vbHRpcFdpZHRoIC8gMiwgb2Zmc2V0LnkpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdChMLnBvaW50KHRvb2x0aXBXaWR0aCAvIDIsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyB8fCBkaXJlY3Rpb24gPT09ICdhdXRvJyAmJiB0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdyaWdodCc7XG5cdFx0XHRwb3MgPSBwb3MuYWRkKFtvZmZzZXQueCArIGFuY2hvci54LCBhbmNob3IueSAtIHRvb2x0aXBIZWlnaHQgLyAyXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0Jztcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdChMLnBvaW50KG9mZnNldC54ICsgdG9vbHRpcFdpZHRoICsgYW5jaG9yLngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkpKTtcblx0XHR9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSwgb2Zmc2V0O1xuXHRcdGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0KSB7XG5cdFx0XHRvZmZzZXQgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xuXHRcdFx0cG9zID0gcG9zLmFkZChvZmZzZXQpO1xuXHRcdH1cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIEwucG9pbnQodGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIFRvb2x0aXAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG5MLnRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgTC5Ub29sdGlwKG9wdGlvbnMsIHNvdXJjZSk7XG59O1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuTC5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdGlmICghKHRvb2x0aXAgaW5zdGFuY2VvZiBMLlRvb2x0aXApKSB7XG5cdFx0XHR0b29sdGlwID0gbmV3IEwuVG9vbHRpcChvcHRpb25zKS5zZXRDb250ZW50KHRvb2x0aXApO1xuXHRcdH1cblxuXHRcdGlmIChsYXRsbmcpIHtcblx0XHRcdHRvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIodG9vbHRpcCkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKHRvb2x0aXApO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA/OiBUb29sdGlwKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIodG9vbHRpcCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn0pO1xuXG5cblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTC5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Nlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIEwuVG9vbHRpcCkge1xuXHRcdFx0TC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgb3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwID0gTC50b29sdGlwKG9wdGlvbnMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7IHRoaXMub3BlblRvb2x0aXAoKTsgfVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpY2VkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyKSkge1xuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XG5cdFx0XHRsYXllciA9IHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5GZWF0dXJlR3JvdXApIHtcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbGF0bG5nKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBzb3VyY2UgdG8gdGhpcyBsYXllclxuXHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgdG9vbHRpcCAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcblx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5fY2xvc2UoKTtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG5cblxuXG4vKlxyXG4gKiBUb29sdGlwIGV4dGVuc2lvbiB0byBMLk1hcmtlciwgYWRkaW5nIHRvb2x0aXAtcmVsYXRlZCBtZXRob2RzLlxyXG4gKi9cclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yIHx8IFswLCAwXTtcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkxheWVyR3JvdXAgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGxheWVycykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgZ3JvdXAuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIoaWQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBsYXllciBpbiB0aGlzLl9sYXllcnMgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gISFsYXllciAmJiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzIHx8IHRoaXMuZ2V0TGF5ZXJJZChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludm9rZShtZXRob2ROYW1lOiBTdHJpbmcsIOKApik6IHRoaXNcclxuXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcblx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG5cdC8vIGltcGxlbWVudCBgbWV0aG9kTmFtZWAuXHJcblx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWFwLmFkZExheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXJzLnB1c2godGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gTC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzOiBMYXllcltdKVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMuXHJcbkwubGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTGF5ZXJHcm91cChsYXllcnMpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgYWxzbyBoYXMgbW91c2UgZXZlbnRzIChwcm9wYWdhdGVkIGZyb20gbWVtYmVycyBvZiB0aGUgZ3JvdXApIGFuZCBhIHNoYXJlZCBiaW5kUG9wdXAgbWV0aG9kLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkZlYXR1cmVHcm91cCA9IEwuTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVyczogTGF5ZXJbXSlcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMuXHJcbkwuZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxufTtcclxuXG5cblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKi9cblxuTC5SZW5kZXJlciA9IEwuTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0TC5zdGFtcCh0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXQsXG5cdFx0XHR6b29tOiB0aGlzLl9vblpvb20sXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGVcblx0XHR9O1xuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX29uQW5pbVpvb207XG5cdFx0fVxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uQW5pbVpvb206IGZ1bmN0aW9uIChldikge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybShldi5jZW50ZXIsIGV2Lnpvb20pO1xuXHR9LFxuXG5cdF9vblpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcblx0fSxcblxuXHRfdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcblx0XHQgICAgcG9zaXRpb24gPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1cGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHR2YXIgcCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nLFxuXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcblx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTC5Cb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG5cblxuTC5NYXAuaW5jbHVkZSh7XG5cdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cblx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcblx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcblx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGlmICghcmVuZGVyZXIpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG5cdFx0XHQvLyBCeSBkZWZhdWx0LCBhbGwgYFBhdGhgcyBhcmUgcmVuZGVyZWQgaW4gYSBgU1ZHYCByZW5kZXJlci5cblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBMLmNhbnZhcygpKSB8fCBMLnN2ZygpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IChMLlNWRyAmJiBMLnN2Zyh7cGFuZTogbmFtZX0pKSB8fCAoTC5DYW52YXMgJiYgTC5jYW52YXMoe3BhbmU6IG5hbWV9KSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fVxufSk7XG5cblxuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbkwuUGF0aCA9IEwuTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWVcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcblx0XHQvLyBiZWZvcmUgdGhpcy5nZXRFdmVudHMuXG5cdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR6b29tZW5kOiB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZHJlbiBjbGFzc2VzXG5cdFx0dGhpcy5fcHJvamVjdCgpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9jbGlja1RvbGVyYW5jZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArIChMLkJyb3dzZXIudG91Y2ggPyAxMCA6IDApO1xuXHR9XG59KTtcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuTC5MaW5lVXRpbCA9IHtcclxuXHJcblx0Ly8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcblx0Ly8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcblx0Ly8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuXHQvLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG5cdC8vIFtEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG5cdC8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuXHQvLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcblx0Ly8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuXHQvLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwOi8vbW91cm5lci5naXRodWIuY29tL3NpbXBsaWZ5LWpzLykuXHJcblx0c2ltcGxpZnk6IGZ1bmN0aW9uIChwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0XHQvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0XHRwb2ludHMgPSB0aGlzLl9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0Ly8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0XHRwb2ludHMgPSB0aGlzLl9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5cdHBvaW50VG9TZWdtZW50RGlzdGFuY2U6ICBmdW5jdGlvbiAocCwgcDEsIHAyKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcblx0Y2xvc2VzdFBvaW50T25TZWdtZW50OiBmdW5jdGlvbiAocCwgcDEsIHAyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuXHRfc2ltcGxpZnlEUDogZnVuY3Rpb24gKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0XHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHRcdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG5cdFx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHRcdG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcblx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0XHR2YXIgaSxcclxuXHRcdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuXHRcdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld1BvaW50cztcclxuXHR9LFxyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXA6IGZ1bmN0aW9uIChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuXHRcdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdFx0ICAgIGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdFx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdFx0c3FEaXN0ID0gdGhpcy5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdFx0dGhpcy5fc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdFx0dGhpcy5fc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuXHRfcmVkdWNlUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdFx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdFx0cHJldiA9IGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuXHQvLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcblx0Ly8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG5cdC8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuXHQvLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG5cdGNsaXBTZWdtZW50OiBmdW5jdGlvbiAoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuXHRcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gdGhpcy5fbGFzdENvZGUgOiB0aGlzLl9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0XHQgICAgY29kZUIgPSB0aGlzLl9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdFx0Ly8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0XHR0aGlzLl9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gb3RoZXIgY2FzZXNcclxuXHRcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0XHRwID0gdGhpcy5fZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0bmV3Q29kZSA9IHRoaXMuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRcdGEgPSBwO1xyXG5cdFx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRiID0gcDtcclxuXHRcdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0RWRnZUludGVyc2VjdGlvbjogZnVuY3Rpb24gKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHRcdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHRcdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeCwgeTtcclxuXHJcblx0XHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdFx0eSA9IG1heC55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdFx0eSA9IG1pbi55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdFx0eCA9IG1heC54O1xyXG5cdFx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHRcdHggPSBtaW4ueDtcclxuXHRcdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5LCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0X2dldEJpdENvZGU6IGZ1bmN0aW9uIChwLCBib3VuZHMpIHtcclxuXHRcdHZhciBjb2RlID0gMDtcclxuXHJcblx0XHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdFx0Y29kZSB8PSAxO1xyXG5cdFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdFx0Y29kZSB8PSAyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGNvZGUgfD0gNDtcclxuXHRcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0XHRjb2RlIHw9IDg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvZGU7XHJcblx0fSxcclxuXHJcblx0Ly8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcblx0X3NxRGlzdDogZnVuY3Rpb24gKHAxLCBwMikge1xyXG5cdFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0XHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuXHRfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uIChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdFx0dmFyIHggPSBwMS54LFxyXG5cdFx0ICAgIHkgPSBwMS55LFxyXG5cdFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0XHQgICAgZHkgPSBwMi55IC0geSxcclxuXHRcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHRcdCAgICB0O1xyXG5cclxuXHRcdGlmIChkb3QgPiAwKSB7XHJcblx0XHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0XHR5ID0gcDIueTtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZHggPSBwLnggLSB4O1xyXG5cdFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBMLlBvaW50KHgsIHkpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbLTEyMi42OCwgNDUuNTFdLFxuICogXHRbLTEyMi40MywgMzcuNzddLFxuICogXHRbLTExOC4yLCAzNC4wNF1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbLTEyMi42OCwgNDUuNTFdLFxuICogXHQgWy0xMjIuNDMsIDM3Ljc3XSxcbiAqIFx0IFstMTE4LjIsIDM0LjA0XV0sXG4gKiBcdFtbLTczLjkxLCA0MC43OF0sXG4gKiBcdCBbLTg3LjYyLCA0MS44M10sXG4gKiBcdCBbLTk2LjcyLCAzMi43Nl1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuTC5Qb2x5bGluZSA9IEwuUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IEwuTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRcdCAgICBwMSwgcDI7XG5cblx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcblx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cblx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcblx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWluUG9pbnQpIHtcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblBvaW50O1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5bGluZSBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cblx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IEwuUG9seWxpbmUuX2ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gTC5sYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgTC5Cb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgTC5Qb2ludCh3LCB3KTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0cHhCb3VuZHMubWluLl9zdWJ0cmFjdChwKTtcblx0XHRcdHB4Qm91bmRzLm1heC5fYWRkKHApO1xuXHRcdFx0dGhpcy5fcHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHR9XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTC5MYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTC5MaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTC5MaW5lVXRpbC5zaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5MLnBvbHlsaW5lID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLlBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufTtcblxuTC5Qb2x5bGluZS5fZmxhdCA9IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdC8vIHRydWUgaWYgaXQncyBhIGZsYXQgYXJyYXkgb2YgbGF0bG5nczsgZmFsc2UgaWYgbmVzdGVkXG5cdHJldHVybiAhTC5VdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbkwuUG9seVV0aWwgPSB7fTtcclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnZW1hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBlcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuTC5Qb2x5VXRpbC5jbGlwUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcblx0ICAgIGksIGosIGssXHJcblx0ICAgIGEsIGIsXHJcblx0ICAgIGxlbiwgZWRnZSwgcCxcclxuXHQgICAgbHUgPSBMLkxpbmVVdGlsO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IGx1Ll9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gbHUuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1stMTExLjAzLCA0MV0sWy0xMTEuMDQsIDQ1XSxbLTEwNC4wNSwgNDVdLFstMTA0LjA1LCA0MV1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWy0xMTEuMDMsIDQxXSxbLTExMS4wNCwgNDVdLFstMTA0LjA1LCA0NV0sWy0xMDQuMDUsIDQxXV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1stMTA4LjU4LDM3LjI5XSxbLTEwOC41OCw0MC43MV0sWy0xMDIuNTAsNDAuNzFdLFstMTAyLjUwLDM3LjI5XV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1stMTExLjAzLCA0MV0sWy0xMTEuMDQsIDQ1XSxbLTEwNC4wNSwgNDVdLFstMTA0LjA1LCA0MV1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1stMTA4LjU4LDM3LjI5XSxbLTEwOC41OCw0MC43MV0sWy0xMDIuNTAsNDAuNzFdLFstMTAyLjUwLDM3LjI5XV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1stMTA5LjA1LCAzN10sWy0xMDkuMDMsIDQxXSxbLTEwMi4wNSwgNDFdLFstMTAyLjA0LCAzN10sWy0xMDkuMDUsIDM4XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbkwuUG9seWdvbiA9IEwuUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXIsXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRhcmVhID0geCA9IHkgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbal07XG5cblx0XHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xuXHRcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcblx0XHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XG5cdFx0XHRhcmVhICs9IGYgKiAzO1xuXHRcdH1cblxuXHRcdGlmIChhcmVhID09PSAwKSB7XG5cdFx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cblx0XHRcdGNlbnRlciA9IHBvaW50c1swXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGNlbnRlcik7XG5cdH0sXG5cblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBMLlBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTC5MYXRMbmcgJiYgcmVzdWx0WzBdLmVxdWFscyhyZXN1bHRbbGVuIC0gMV0pKSB7XG5cdFx0XHRyZXN1bHQucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0TC5Qb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcblx0XHRpZiAoTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcblx0XHR9XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgTC5Qb2ludCh3LCB3KTtcblxuXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcblx0XHRib3VuZHMgPSBuZXcgTC5Cb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBMLlBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5MLnBvbHlnb24gPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn07XG5cblxuXG4vKlxuICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAqL1xuXG4vKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGFrYSBMLlJldGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG5MLlJlY3RhbmdsZSA9IEwuUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0TC5Qb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSk7XG5cdH0sXG5cblx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdGxhdExuZ0JvdW5kcyA9IEwubGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XG5cdFx0cmV0dXJuIFtcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuXHRcdF07XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucmVjdGFuZ2xlKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbkwucmVjdGFuZ2xlID0gZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59O1xuXG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVNYXJrZXJcbiAqIEBha2EgTC5DaXJjbGVNYXJrZXJcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjaXJjbGUgb2YgYSBmaXhlZCBzaXplIHdpdGggcmFkaXVzIHNwZWNpZmllZCBpbiBwaXhlbHMuIEV4dGVuZHMgYFBhdGhgLlxuICovXG5cbkwuQ2lyY2xlTWFya2VyID0gTC5QYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge2xhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fSxcblxuXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuXHRcdEwuUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgTC5Cb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuTC5jaXJjbGVNYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5DaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbn07XG5cblxuXG4vKlxuICogQGNsYXNzIENpcmNsZVxuICogQGFrYSBMLkNpcmNsZVxuICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICpcbiAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCAyMDApLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5MLkNpcmNsZSA9IEwuQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBMLlBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBMLkNSUy5FYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEwuQ1JTLkVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBNYXRoLm1heChNYXRoLnJvdW5kKHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueCksIDEpO1xuXHRcdFx0dGhpcy5fcmFkaXVzWSA9IE1hdGgubWF4KE1hdGgucm91bmQocC55IC0gdG9wLnkpLCAxKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuTC5jaXJjbGUgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5DaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn07XG5cblxuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN2ZyksIFNWRyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gKiB0aGlzIGNhc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuc3ZnKCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuTC5TVkcgPSBMLlJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IEwuUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy56b29tc3RhcnQgPSB0aGlzLl9vblpvb21TdGFydDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5TVkcuY3JlYXRlKCdzdmcnKTtcblxuXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdHRoaXMuX3Jvb3RHcm91cCA9IEwuU1ZHLmNyZWF0ZSgnZycpO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290R3JvdXApO1xuXHR9LFxuXG5cdF9vblpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIERyYWctdGhlbi1waW5jaCBpbnRlcmFjdGlvbnMgbWlnaHQgbWVzcyB1cCB0aGUgY2VudGVyIGFuZCB6b29tLlxuXHRcdC8vIEluIHRoaXMgY2FzZSwgdGhlIGVhc2llc3Qgd2F5IHRvIHByZXZlbnQgdGhpcyBpcyByZS1kbyB0aGUgcmVuZGVyZXJcblx0XHQvLyAgIGJvdW5kcyBhbmQgcGFkZGluZyB3aGVuIHRoZSB6b29taW5nIHN0YXJ0cy5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gTC5TVkcuY3JlYXRlKCdwYXRoJyk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgb3B0aW9ucy53ZWlnaHQpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBvcHRpb25zLmRhc2hPZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5Jywgb3B0aW9ucy5maWxsT3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIEwuU1ZHLnBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICByID0gbGF5ZXIuX3JhZGl1cyxcblx0XHQgICAgcjIgPSBsYXllci5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuXHRcdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9Gcm9udChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoKTtcblx0fVxufSk7XG5cblxuLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuTC5leHRlbmQoTC5TVkcsIHtcblx0Ly8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG5cdC8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuXHQvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuXHQvLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5cdGNyZWF0ZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xuXHR9LFxuXG5cdC8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuXHQvLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG5cdC8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcblx0cG9pbnRzVG9QYXRoOiBmdW5jdGlvbiAocmluZ3MsIGNsb3NlZCkge1xuXHRcdHZhciBzdHIgPSAnJyxcblx0XHQgICAgaSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRcdHN0ciArPSBjbG9zZWQgPyAoTC5Ccm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0XHR9XG5cblx0XHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRcdHJldHVybiBzdHIgfHwgJ00wIDAnO1xuXHR9XG59KTtcblxuLy8gQG5hbWVzcGFjZSBCcm93c2VyOyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuTC5Ccm93c2VyLnN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBMLlNWRy5jcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xuXG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuc3ZnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIEwuQnJvd3Nlci5zdmcgfHwgTC5Ccm93c2VyLnZtbCA/IG5ldyBMLlNWRyhvcHRpb25zKSA6IG51bGw7XG59O1xuXG5cblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluIHRoaXMgY2FzZS5cbiAqXG4gKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIEJyb3dzZXI7IEBwcm9wZXJ0eSB2bWw6IEJvb2xlYW5cbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cbkwuQnJvd3Nlci52bWwgPSAhTC5Ccm93c2VyLnN2ZyAmJiAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcblxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcblxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xuXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0oKSk7XG5cbi8vIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5MLlNWRy5pbmNsdWRlKCFMLkJyb3dzZXIudm1sID8ge30gOiB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSBMLlNWRy5jcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IEwuU1ZHLmNyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zLFxuXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG5cdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuXHRcdGNvbnRhaW5lci5maWxsZWQgPSAhIW9wdGlvbnMuZmlsbDtcblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0aWYgKCFzdHJva2UpIHtcblx0XHRcdFx0c3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSA9IEwuU1ZHLmNyZWF0ZSgnc3Ryb2tlJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gTC5VdGlsLmlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gTC5TVkcuY3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn0pO1xuXG5pZiAoTC5Ccm93c2VyLnZtbCkge1xuXHRMLlNWRy5jcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSkoKTtcbn1cblxuXG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbkwuQ2FudmFzID0gTC5SZW5kZXJlci5leHRlbmQoe1xuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCBMLlV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3VzZU1vdmUsIDMyLCB0aGlzKSwgdGhpcylcblx0XHRcdC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpXG5cdFx0XHQub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cblx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9kcmF3bkxheWVycyA9IHt9O1xuXG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gTC5Ccm93c2VyLnJldGluYSA/IDIgOiAxO1xuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChMLkJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbTC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IEwuVXRpbC5mYWxzZUZuLFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcmVtb3ZlZCA9IHRydWU7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IGxheWVyLl9weEJvdW5kcztcblx0XHR0aGlzLl9kcmF3KHRydWUpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX2RyYXcoKTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KCcsJyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChOdW1iZXIocGFydHNbaV0pKTtcblx0XHRcdH1cblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgTC5Cb3VuZHMoKTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblxuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0dGhpcy5fZHJhdyh0cnVlKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcblx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbiAoY2xlYXIpIHtcblx0XHR0aGlzLl9jbGVhciA9IGNsZWFyO1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCwgYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xlYXIgJiYgbGF5ZXIuX3JlbW92ZWQpIHtcblx0XHRcdFx0ZGVsZXRlIGxheWVyLl9yZW1vdmVkO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IGxheWVyLl9yYWRpdXMsXG5cdFx0ICAgIHMgPSAobGF5ZXIuX3JhZGl1c1kgfHwgcikgLyByO1xuXG5cdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBjbGVhciA9IHRoaXMuX2NsZWFyLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjbGVhciA/ICdkZXN0aW5hdGlvbi1vdXQnIDogJ3NvdXJjZS1vdmVyJztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IGNsZWFyID8gMSA6IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IGNsZWFyID8gMSA6IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0Ly8gaWYgY2xlYXJpbmcgc2hhcGUsIGRvIGl0IHdpdGggdGhlIHByZXZpb3VzbHkgZHJhd24gbGluZSB3aWR0aFxuXHRcdFx0bGF5ZXIuX3ByZXZXZWlnaHQgPSBjdHgubGluZVdpZHRoID0gY2xlYXIgPyBsYXllci5fcHJldldlaWdodCArIDEgOiBvcHRpb25zLndlaWdodDtcblxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllcnMgPSBbXSwgbGF5ZXI7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSAmJiAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcblx0XHRcdFx0TC5Eb21FdmVudC5fZmFrZVN0b3AoZSk7XG5cdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGxheWVycy5sZW5ndGgpICB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQobGF5ZXJzLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlLCBwb2ludCk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcblx0XHRpZiAobGF5ZXIgJiYgKGUudHlwZSA9PT0gJ21vdXNlb3V0JyB8fCAhbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSkge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG5cdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0dmFyIGlkLCBsYXllcjtcblxuXHRcdGZvciAoaWQgaW4gdGhpcy5fZHJhd25MYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fZHJhd25MYXllcnNbaWRdO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2hvdmVyZWRMYXllcikge1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFt0aGlzLl9ob3ZlcmVkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdC8vIFRPRE8gX2JyaW5nVG9Gcm9udCAmIF9icmluZ1RvQmFjaywgcHJldHR5IHRyaWNreVxuXG5cdF9icmluZ1RvRnJvbnQ6IEwuVXRpbC5mYWxzZUZuLFxuXHRfYnJpbmdUb0JhY2s6IEwuVXRpbC5mYWxzZUZuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBCcm93c2VyOyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuTC5Ccm93c2VyLmNhbnZhcyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XG59KCkpO1xuXG4vLyBAbmFtZXNwYWNlIENhbnZhc1xuLy8gQGZhY3RvcnkgTC5jYW52YXMob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5MLmNhbnZhcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBMLkJyb3dzZXIuY2FudmFzID8gbmV3IEwuQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn07XG5cbkwuUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuXHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0aWYgKCF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRpZiAoTC5MaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbkwuUG9seWdvbi5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocCkge1xuXHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuXHRpZiAoIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cblx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcblx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2Vcblx0cmV0dXJuIGluc2lkZSB8fCBMLlBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xufTtcblxuTC5DaXJjbGVNYXJrZXIucHJvdG90eXBlLl9jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHApIHtcblx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcbn07XG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgR2VvSlNPTlxyXG4gKiBAYWthIEwuR2VvSlNPTlxyXG4gKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZ2VvSnNvbihkYXRhLCB7XHJcbiAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gKiBcdH1cclxuICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAqIH0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuR2VvSlNPTiA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcblx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcblx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB7fVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcblx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIHNob3cgYSBmZWF0dXJlIG9yIG5vdC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzaG93IGFsbCBmZWF0dXJlczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHRydWU7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiBMYXllclxyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IEwuVXRpbC5pc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBMLkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBMLkdlb0pTT04uYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyICk6IExheWVyXHJcblx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG5cdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKHt9LCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcblx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IExheWVyXHJcblx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuXHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuXHRcdH1cclxuXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG5cdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxyXG5MLmV4dGVuZChMLkdlb0pTT04sIHtcclxuXHQvLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG5cdC8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuXHQvLyBbYHBvaW50VG9MYXllcmBdKCNnZW9qc29uLXBvaW50dG9sYXllcikgYW5kL29yIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuXHQvLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuXHRnZW9tZXRyeVRvTGF5ZXI6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHRcdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuXHRcdCAgICBsYXllcnMgPSBbXSxcclxuXHRcdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdFx0ICAgIGNvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IHRoaXMuY29vcmRzVG9MYXRMbmcsXHJcblx0XHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdFx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdFx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0XHRsYXRsbmcgPSBjb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTC5NYXJrZXIobGF0bG5nKTtcclxuXHJcblx0XHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0XHRsYXllcnMucHVzaChwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBMLk1hcmtlcihsYXRsbmcpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdFx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0XHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Y2FzZSAnUG9seWdvbic6XHJcblx0XHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGxheWVyID0gdGhpcy5nZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdFx0aWYgKGxheWVyKSB7XHJcblx0XHRcdFx0XHRsYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuXHQvLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG5cdC8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5cdGNvb3Jkc1RvTGF0TG5nOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcblx0Ly8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxyXG5cdC8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuXHQvLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcblx0Y29vcmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAoY29vcmRzLCBsZXZlbHNEZWVwLCBjb29yZHNUb0xhdExuZykge1xyXG5cdFx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdCAgICAgICAgdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0ICAgICAgICAoY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsYXRsbmdzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZyk6IEFycmF5XHJcblx0Ly8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcblx0bGF0TG5nVG9Db29yZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHRcdFtsYXRsbmcubG5nLCBsYXRsbmcubGF0LCBsYXRsbmcuYWx0XSA6XHJcblx0XHRcdFx0W2xhdGxuZy5sbmcsIGxhdGxuZy5sYXRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4pOiBBcnJheVxyXG5cdC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcblx0Ly8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG5cdGxhdExuZ3NUb0Nvb3JkczogZnVuY3Rpb24gKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCkge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRcdEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCkgOlxyXG5cdFx0XHRcdEwuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG5cdFx0XHRjb29yZHMucHVzaChjb29yZHNbMF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblx0fSxcclxuXHJcblx0Z2V0RmVhdHVyZTogZnVuY3Rpb24gKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG5cdFx0XHRcdEwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0XHRcdEwuR2VvSlNPTi5hc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcblx0Ly8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcblx0YXNGZWF0dXJlOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XHJcblx0XHRcdHJldHVybiBnZW9qc29uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0cHJvcGVydGllczoge30sXHJcblx0XHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogTC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCkpXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkwuQ2lyY2xlLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5MLkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcbkwuUG9seWxpbmUucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgbXVsdGkgPSAhTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcblx0dmFyIGNvb3JkcyA9IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCk7XHJcblxyXG5cdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuTC5Qb2x5Z29uLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIGhvbGVzID0gIUwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5ncyksXHJcblx0ICAgIG11bHRpID0gaG9sZXMgJiYgIUwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdHZhciBjb29yZHMgPSBMLkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUpO1xyXG5cclxuXHRpZiAoIWhvbGVzKSB7XHJcblx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdH0pO1xyXG59O1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MLkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTigpLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEdlb21ldHJ5Q29sbGVjdGlvbmApLlxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0ICAgIGpzb25zID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTigpO1xyXG5cdFx0XHRcdGpzb25zLnB1c2goaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBqc29uLmdlb21ldHJ5IDogTC5HZW9KU09OLmFzRmVhdHVyZShqc29uKSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHA6Ly9nZW9qc29uLm9yZy9nZW9qc29uLXNwZWMuaHRtbCkgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbi8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbkwuZ2VvSlNPTiA9IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn07XHJcbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbkwuZ2VvSnNvbiA9IEwuZ2VvSlNPTjtcclxuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG5cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbkwuRG9tRXZlbnQgPSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuXHQvLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG5cdC8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcblx0Ly8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdG9uOiBmdW5jdGlvbiAob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb24ob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCxcclxuXHQvLyBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgRE9NIGV2ZW50IGZyb20gdGhlIGVsZW1lbnQuXHJcblx0Ly8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG5cdC8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdG9mZjogZnVuY3Rpb24gKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZihvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBpZCA9IHR5cGUgKyBMLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgTC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0XHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRcdHRoaXMuYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiB0aGlzLmFkZERvdWJsZVRhcExpc3RlbmVyKSB7XHJcblx0XHRcdHRoaXMuYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRcdGlmIChMLkRvbUV2ZW50Ll9pc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snICYmIEwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIEwuRG9tRXZlbnQuX2ZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0b2JqW2V2ZW50c0tleV0gPSBvYmpbZXZlbnRzS2V5XSB8fCB7fTtcclxuXHRcdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHR2YXIgaWQgPSB0eXBlICsgTC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIEwuc3RhbXAoY29udGV4dCkgOiAnJyksXHJcblx0XHQgICAgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcblx0XHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiB0aGlzLnJlbW92ZURvdWJsZVRhcExpc3RlbmVyKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcblx0XHRcdFx0XHR0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6XHJcblx0XHRcdFx0XHR0eXBlID09PSAnbW91c2VsZWF2ZScgPyAnbW91c2VvdXQnIDogdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcblx0Ly8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcblx0Ly8gYGBganNcclxuXHQvLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcblx0Ly8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuXHRcdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdEwuRG9tRXZlbnQuX3NraXBwZWQoZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcblx0Ly8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnbW91c2V3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuXHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnQub24oZWwsICdtb3VzZXdoZWVsJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcblx0Ly8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkb3VibGVjbGljaydgLFxyXG5cdC8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuXHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgc3RvcCA9IEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24oZWwsIEwuRHJhZ2dhYmxlLlNUQVJULmpvaW4oJyAnKSwgc3RvcCk7XHJcblxyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnQub24oZWwsIHtcclxuXHRcdFx0Y2xpY2s6IEwuRG9tRXZlbnQuX2Zha2VTdG9wLFxyXG5cdFx0XHRkYmxjbGljazogc3RvcFxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuXHQvLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcblx0Ly8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG5cdC8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcblx0Ly8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHN0b3AoZXYpOiB0aGlzXHJcblx0Ly8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5cdHN0b3A6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudFxyXG5cdFx0XHQucHJldmVudERlZmF1bHQoZSlcclxuXHRcdFx0LnN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuXHQvLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBgY29udGFpbmVyYCBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5cdGdldE1vdXNlUG9zaXRpb246IGZ1bmN0aW9uIChlLCBjb250YWluZXIpIHtcclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0XHRlLmNsaWVudFggLSByZWN0LmxlZnQgLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuXHRcdFx0ZS5jbGllbnRZIC0gcmVjdC50b3AgLSBjb250YWluZXIuY2xpZW50VG9wKTtcclxuXHR9LFxyXG5cclxuXHQvLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG5cdC8vIGFuZCBGaXJlZm94IHNjcm9sbHMgZGV2aWNlIHBpeGVscywgbm90IENTUyBwaXhlbHNcclxuXHRfd2hlZWxQeEZhY3RvcjogKEwuQnJvd3Nlci53aW4gJiYgTC5Ccm93c2VyLmNocm9tZSkgPyAyIDpcclxuXHQgICAgICAgICAgICAgICAgTC5Ccm93c2VyLmdlY2tvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG5cdCAgICAgICAgICAgICAgICAxLFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuXHQvLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNld2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG5cdC8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG5cdC8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcblx0Ly8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuXHRnZXRXaGVlbERlbHRhOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIChMLkJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG5cdFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyBMLkRvbUV2ZW50Ll93aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0XHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHRcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG5cdFx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHRcdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHRcdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcblx0XHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdFx0ICAgICAgIDA7XHJcblx0fSxcclxuXHJcblx0X3NraXBFdmVudHM6IHt9LFxyXG5cclxuXHRfZmFrZVN0b3A6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBmYWtlcyBzdG9wUHJvcGFnYXRpb24gYnkgc2V0dGluZyBhIHNwZWNpYWwgZXZlbnQgZmxhZywgY2hlY2tlZC9yZXNldCB3aXRoIEwuRG9tRXZlbnQuX3NraXBwZWQoZSlcclxuXHRcdEwuRG9tRXZlbnQuX3NraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0X3NraXBwZWQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2tpcHBlZCA9IHRoaXMuX3NraXBFdmVudHNbZS50eXBlXTtcclxuXHRcdC8vIHJlc2V0IHdoZW4gY2hlY2tpbmcsIGFzIGl0J3Mgb25seSB1c2VkIGluIG1hcCBjb250YWluZXIgYW5kIHByb3BhZ2F0ZXMgb3V0c2lkZSBvZiB0aGUgbWFwXHJcblx0XHR0aGlzLl9za2lwRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcclxuXHRcdHJldHVybiBza2lwcGVkO1xyXG5cdH0sXHJcblxyXG5cdC8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG5cdF9pc0V4dGVybmFsVGFyZ2V0OiBmdW5jdGlvbiAoZWwsIGUpIHtcclxuXHJcblx0XHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0XHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHRoaXMgaXMgYSBob3JyaWJsZSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyBpbiBBbmRyb2lkIHdoZXJlIGEgc2luZ2xlIHRvdWNoIHRyaWdnZXJzIHR3byBjbGljayBldmVudHNcclxuXHRfZmlsdGVyQ2xpY2s6IGZ1bmN0aW9uIChlLCBoYW5kbGVyKSB7XHJcblx0XHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCkpLFxyXG5cdFx0ICAgIGVsYXBzZWQgPSBMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgJiYgKHRpbWVTdGFtcCAtIEwuRG9tRXZlbnQuX2xhc3RDbGljayk7XHJcblxyXG5cdFx0Ly8gYXJlIHRoZXkgY2xvc2VyIHRvZ2V0aGVyIHRoYW4gNTAwbXMgeWV0IG1vcmUgdGhhbiAxMDBtcz9cclxuXHRcdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdFx0Ly8gb24gdGhlIHNhbWUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmYXIgZmFzdGVyO1xyXG5cdFx0Ly8gb3IgY2hlY2sgaWYgY2xpY2sgaXMgc2ltdWxhdGVkIG9uIHRoZSBlbGVtZW50LCBhbmQgaWYgaXQgaXMsIHJlamVjdCBhbnkgbm9uLXNpbXVsYXRlZCBldmVudHNcclxuXHJcblx0XHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fbGFzdENsaWNrID0gdGltZVN0YW1wO1xyXG5cclxuXHRcdGhhbmRsZXIoZSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9uYF0oI2RvbWV2ZW50LW9uKVxyXG5MLkRvbUV2ZW50LmFkZExpc3RlbmVyID0gTC5Eb21FdmVudC5vbjtcclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vZmZgXSgjZG9tZXZlbnQtb2ZmKVxyXG5MLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyID0gTC5Eb21FdmVudC5vZmY7XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQGFrYSBMLkRyYWdnYWJsZVxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBBIGNsYXNzIGZvciBtYWtpbmcgRE9NIGVsZW1lbnRzIGRyYWdnYWJsZSAoaW5jbHVkaW5nIHRvdWNoIHN1cHBvcnQpLlxyXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGVsZW1lbnRUb0RyYWcpO1xyXG4gKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuRHJhZ2dhYmxlID0gTC5FdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcblx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcblx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG5cdH0sXHJcblxyXG5cdHN0YXRpY3M6IHtcclxuXHRcdFNUQVJUOiBMLkJyb3dzZXIudG91Y2ggPyBbJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ10gOiBbJ21vdXNlZG93biddLFxyXG5cdFx0RU5EOiB7XHJcblx0XHRcdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxyXG5cdFx0XHRwb2ludGVyZG93bjogJ3RvdWNoZW5kJyxcclxuXHRcdFx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG5cdFx0fSxcclxuXHRcdE1PVkU6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2Vtb3ZlJyxcclxuXHRcdFx0dG91Y2hzdGFydDogJ3RvdWNobW92ZScsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRcdFx0TVNQb2ludGVyRG93bjogJ3RvdWNobW92ZSdcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lOiBCb29sZWFuKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG5cdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcblx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIEwuRHJhZ2dhYmxlLlNUQVJULmpvaW4oJyAnKSwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG5cdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHRMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0cnVlOyAgLy8gUHJldmVudCBkcmFnZ2luZyBtdWx0aXBsZSBvYmplY3RzIGF0IG9uY2UuXHJcblxyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG5cdFx0dGhpcy5maXJlKCdkb3duJyk7XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0XHQub24oZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbZS50eXBlXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKVxyXG5cdFx0XHQub24oZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLkVORFtlLnR5cGVdLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG5ld1BvaW50ID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3UG9pbnQuc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcblx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHRpZiAoKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpICYmICh0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlKSkge1xyXG5cdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG5cdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG5cdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdFRhcmdldCkge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBMLkRyYWdnYWJsZS5NT1ZFKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQub2ZmKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5NT1ZFW2ldLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHRcdFx0Lm9mZihkb2N1bWVudCwgTC5EcmFnZ2FibGUuRU5EW2ldLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHRcdFx0Ly8gZW5zdXJlIGRyYWcgaXMgbm90IGZpcmVkIGFmdGVyIGRyYWdlbmRcclxuXHRcdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0XHRMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG5MLkhhbmRsZXIgPSBMLkNsYXNzLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmFkZEhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcblx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuXHR9XG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZGlzYWJsZWQsIHNob3VsZCByZW1vdmUgdGhlIGV2ZW50IGhvb2tzIGFkZGVkIHByZXZpb3VzbHkuXG59KTtcblxuXG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIUwuQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG5MLk1hcC5EcmFnID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdFx0ZG93bjogdGhpcy5fb25Eb3duLFxuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAuX3N0b3AoKTtcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcblx0XHRcdHZhciBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IEwuYm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdGlmICh0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbi8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIEwuTWFwLkRyYWcpO1xuXG5cblxuLypcbiAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuTC5NYXAuRG91YmxlQ2xpY2tab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgTC5NYXAuRG91YmxlQ2xpY2tab29tKTtcblxuXG5cbi8qXG4gKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNld2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxuTC5NYXAuU2Nyb2xsV2hlZWxab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IEwuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xuXHR9LFxuXG5cdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG5cdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG5cdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG5cdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4vLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgTC5NYXAuU2Nyb2xsV2hlZWxab29tKTtcblxuXG5cbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICovXHJcblxyXG5MLmV4dGVuZChMLkRvbUV2ZW50LCB7XHJcblxyXG5cdF90b3VjaHN0YXJ0OiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogTC5Ccm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcmRvd24nIDogJ3RvdWNoc3RhcnQnLFxyXG5cdF90b3VjaGVuZDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBMLkJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVydXAnIDogJ3RvdWNoZW5kJyxcclxuXHJcblx0Ly8gaW5zcGlyZWQgYnkgWmVwdG8gdG91Y2ggY29kZSBieSBUaG9tYXMgRnVjaHNcclxuXHRhZGREb3VibGVUYXBMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcclxuXHRcdHZhciBsYXN0LCB0b3VjaCxcclxuXHRcdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHRcdCAgICBkZWxheSA9IDI1MDtcclxuXHJcblx0XHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xyXG5cdFx0XHR2YXIgY291bnQ7XHJcblxyXG5cdFx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRjb3VudCA9IEwuRG9tRXZlbnQuX3BvaW50ZXJzQ291bnQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY291bnQgPiAxKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdFx0dmFyIG5vdyA9IERhdGUubm93KCksXHJcblx0XHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0XHR0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblx0XHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0XHRsYXN0ID0gbm93O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XHJcblx0XHRcdGlmIChkb3VibGVUYXAgJiYgIXRvdWNoLmNhbmNlbEJ1YmJsZSkge1xyXG5cdFx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdFx0dmFyIG5ld1RvdWNoID0ge30sXHJcblx0XHRcdFx0XHQgICAgcHJvcCwgaTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGkgaW4gdG91Y2gpIHtcclxuXHRcdFx0XHRcdFx0cHJvcCA9IHRvdWNoW2ldO1xyXG5cdFx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKHRvdWNoKSA6IHByb3A7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0b3VjaCA9IG5ld1RvdWNoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b3VjaC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRcdFx0XHRoYW5kbGVyKHRvdWNoKTtcclxuXHRcdFx0XHRsYXN0ID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaHN0YXJ0ID0gdGhpcy5fdG91Y2hzdGFydCxcclxuXHRcdCAgICB0b3VjaGVuZCA9IHRoaXMuX3RvdWNoZW5kO1xyXG5cclxuXHRcdG9ialtwcmUgKyB0b3VjaHN0YXJ0ICsgaWRdID0gb25Ub3VjaFN0YXJ0O1xyXG5cdFx0b2JqW3ByZSArIHRvdWNoZW5kICsgaWRdID0gb25Ub3VjaEVuZDtcclxuXHRcdG9ialtwcmUgKyAnZGJsY2xpY2snICsgaWRdID0gaGFuZGxlcjtcclxuXHJcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0b3VjaHN0YXJ0LCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRvdWNoZW5kLCBvblRvdWNoRW5kLCBmYWxzZSk7XHJcblxyXG5cdFx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgKG5vdGFibHksIGNocm9tZSBvbiB3aW4xMCArIHRvdWNoc2NyZWVuICsgbW91c2UpLFxyXG5cdFx0Ly8gdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIHRvdWNoZW5kL3BvaW50ZXJ1cCBldmVudHMgYnV0IGRvZXMgZmlyZVxyXG5cdFx0Ly8gbmF0aXZlIGRibGNsaWNrcy4gU2VlICM0MTI3LlxyXG5cdFx0aWYgKCFMLkJyb3dzZXIuZWRnZSkge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIGlkKSB7XHJcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXHJcblx0XHQgICAgdG91Y2hzdGFydCA9IG9ialtwcmUgKyB0aGlzLl90b3VjaHN0YXJ0ICsgaWRdLFxyXG5cdFx0ICAgIHRvdWNoZW5kID0gb2JqW3ByZSArIHRoaXMuX3RvdWNoZW5kICsgaWRdLFxyXG5cdFx0ICAgIGRibGNsaWNrID0gb2JqW3ByZSArICdkYmxjbGljaycgKyBpZF07XHJcblxyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fdG91Y2hzdGFydCwgdG91Y2hzdGFydCwgZmFsc2UpO1xyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fdG91Y2hlbmQsIHRvdWNoZW5kLCBmYWxzZSk7XHJcblx0XHRpZiAoIUwuQnJvd3Nlci5lZGdlKSB7XHJcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxuTC5leHRlbmQoTC5Eb21FdmVudCwge1xuXG5cdFBPSU5URVJfRE9XTjogICBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nLFxuXHRQT0lOVEVSX01PVkU6ICAgTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJyxcblx0UE9JTlRFUl9VUDogICAgIEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnLFxuXHRQT0lOVEVSX0NBTkNFTDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnLFxuXHRUQUdfV0hJVEVfTElTVDogWydJTlBVVCcsICdTRUxFQ1QnLCAnT1BUSU9OJ10sXG5cblx0X3BvaW50ZXJzOiB7fSxcblx0X3BvaW50ZXJzQ291bnQ6IDAsXG5cblx0Ly8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuXHQvLyByZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5cdGFkZFBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0XHR0aGlzLl9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaWQpIHtcblx0XHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZFBvaW50ZXJTdGFydDogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgb25Eb3duID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJiBlLnBvaW50ZXJUeXBlICE9PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFKSB7XG5cdFx0XHRcdC8vIEluIElFMTEsIHNvbWUgdG91Y2ggZXZlbnRzIG5lZWRzIHRvIGZpcmUgZm9yIGZvcm0gY29udHJvbHMsIG9yXG5cdFx0XHRcdC8vIHRoZSBjb250cm9scyB3aWxsIHN0b3Agd29ya2luZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBvZiB0YWcgbmFtZXMgdGhhdFxuXHRcdFx0XHQvLyBuZWVkIHRoZXNlIGV2ZW50cy4gRm9yIG90aGVyIHRhcmdldCB0YWdzLCB3ZSBwcmV2ZW50IGRlZmF1bHQgb24gdGhlIGV2ZW50LlxuXHRcdFx0XHRpZiAodGhpcy5UQUdfV0hJVEVfTElTVC5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIDwgMCkge1xuXHRcdFx0XHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRvYmpbJ19sZWFmbGV0X3RvdWNoc3RhcnQnICsgaWRdID0gb25Eb3duO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuXHRcdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuXHRcdGlmICghdGhpcy5fcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0XHR2YXIgcG9pbnRlclVwID0gTC5iaW5kKHRoaXMuX2dsb2JhbFBvaW50ZXJVcCwgdGhpcyk7XG5cblx0XHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudEVsZW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfRE9XTiwgTC5iaW5kKHRoaXMuX2dsb2JhbFBvaW50ZXJEb3duLCB0aGlzKSwgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfTU9WRSwgTC5iaW5kKHRoaXMuX2dsb2JhbFBvaW50ZXJNb3ZlLCB0aGlzKSwgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIHBvaW50ZXJVcCwgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBwb2ludGVyVXAsIHRydWUpO1xuXG5cdFx0XHR0aGlzLl9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRfZ2xvYmFsUG9pbnRlckRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0XHR0aGlzLl9wb2ludGVyc0NvdW50Kys7XG5cdH0sXG5cblx0X2dsb2JhbFBvaW50ZXJNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRcdHRoaXMuX3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdFx0fVxuXHR9LFxuXG5cdF9nbG9iYWxQb2ludGVyVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcblx0XHR0aGlzLl9wb2ludGVyc0NvdW50LS07XG5cdH0sXG5cblx0X2hhbmRsZVBvaW50ZXI6IGZ1bmN0aW9uIChlLCBoYW5kbGVyKSB7XG5cdFx0ZS50b3VjaGVzID0gW107XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9wb2ludGVycykge1xuXHRcdFx0ZS50b3VjaGVzLnB1c2godGhpcy5fcG9pbnRlcnNbaV0pO1xuXHRcdH1cblx0XHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdFx0aGFuZGxlcihlKTtcblx0fSxcblxuXHRfYWRkUG9pbnRlck1vdmU6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIG9uTW92ZSA9IEwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdFx0Ly8gZG9uJ3QgZmlyZSB0b3VjaCBtb3ZlcyB3aGVuIG1vdXNlIGlzbid0IGRvd25cblx0XHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSAmJiBlLmJ1dHRvbnMgPT09IDApIHsgcmV0dXJuOyB9XG5cblx0XHRcdHRoaXMuX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRvYmpbJ19sZWFmbGV0X3RvdWNobW92ZScgKyBpZF0gPSBvbk1vdmU7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xuXHR9LFxuXG5cdF9hZGRQb2ludGVyRW5kOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBvblVwID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0b2JqWydfbGVhZmxldF90b3VjaGVuZCcgKyBpZF0gPSBvblVwO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgb25VcCwgZmFsc2UpO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIG9uVXAsIGZhbHNlKTtcblx0fVxufSk7XG5cblxuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cblx0dG91Y2hab29tOiBMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbkwuTWFwLlRvdWNoWm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXG5cdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cblx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyAmJiAoXG5cdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuXHRcdFx0KHRoaXMuX3pvb20gPiBtYXAuZ2V0TWF4Wm9vbSgpICYmIHNjYWxlID4gMSkpKSB7XG5cdFx0XHR0aGlzLl96b29tID0gbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0TGF0TG5nO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgZGVsdGEgZnJvbSBwaW5jaCB0byBjZW50ZXIsIHNvIGNlbnRlckxhdExuZyBpcyBkZWx0YSBhcHBsaWVkIHRvIGluaXRpYWwgcGluY2hMYXRMbmdcblx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkgeyByZXR1cm47IH1cblx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC51bnByb2plY3QobWFwLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZywgdGhpcy5fem9vbSkuc3VidHJhY3QoZGVsdGEpLCB0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRtYXAuX21vdmVTdGFydCh0cnVlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdHZhciBtb3ZlRm4gPSBMLmJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9KTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKG1vdmVGbiwgdGhpcywgdHJ1ZSk7XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKVxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiBzbmFwWm9vbSBpcyBvZmYsIHNvIHNuYXBab29tIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuc25hcFpvb20pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgTC5NYXAuVG91Y2hab29tKTtcblxuXG5cbi8qXG4gKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdGFwOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBFbmFibGVzIG1vYmlsZSBoYWNrcyBmb3Igc3VwcG9ydGluZyBpbnN0YW50IHRhcHMgKGZpeGluZyAyMDBtcyBjbGlja1xuXHQvLyBkZWxheSBvbiBpT1MvQW5kcm9pZCkgYW5kIHRvdWNoIGhvbGRzIChmaXJlZCBhcyBgY29udGV4dG1lbnVgIGV2ZW50cykuXG5cdHRhcDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5MLk1hcC5UYXAgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG5cdFx0Ly8gaWYgdG91Y2hpbmcgYSBsaW5rLCBoaWdobGlnaHQgaXRcblx0XHRpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vblVwKCk7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpLCAxMDAwKTtcblxuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlZG93bicsIGZpcnN0KTtcblxuXHRcdEwuRG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZW1vdmUnLCBmaXJzdCk7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblx0XHRlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgPSB0cnVlO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG5cdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG5cdFx0ICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSxcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcDogSGFuZGxlclxuLy8gTW9iaWxlIHRvdWNoIGhhY2tzIChxdWljayB0YXAgYW5kIHRvdWNoIGhvbGQpIGhhbmRsZXIuXG5pZiAoTC5Ccm93c2VyLnRvdWNoICYmICFMLkJyb3dzZXIucG9pbnRlcikge1xuXHRMLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBMLk1hcC5UYXApO1xufVxuXG5cblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG5cdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRib3hab29tOiB0cnVlXG59KTtcblxuTC5NYXAuQm94Wm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IEwuRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2JveCk7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdEwuRG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcblxuXHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogTC5Eb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgTC5NYXAuQm94Wm9vbSk7XG5cblxuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcblx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcblx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG5cdGtleWJvYXJkOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcblx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG5cdGtleWJvYXJkUGFuRGVsdGE6IDgwXG59KTtcblxuTC5NYXAuS2V5Ym9hcmQgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0TC5Eb21FdmVudC5vbihjb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2Zmc2V0O1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cblx0XHRcdGlmIChtYXAuX3BhbkFuaW0gJiYgbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG5cdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRvZmZzZXQgPSBMLnBvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcblx0XHRcdH1cblxuXHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cblx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcblx0XHRcdFx0bWFwLnBhbkluc2lkZUJvdW5kcyhtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcblx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBMLk1hcC5LZXlib2FyZCk7XG5cblxuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuICovXG5cbkwuSGFuZGxlci5NYXJrZXJEcmFnID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5kaXNhYmxlKCk7XG5cblx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuY2xvc2VQb3B1cCgpXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG5cdFx0fVxuXG5cdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG5cblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG5cdFx0bWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXHR9XG59KTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sXHJcbiAqIEBha2EgTC5Db250cm9sXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLmNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwXHJcblx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcFxyXG5cdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcblx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcblx0XHQgICAgICAgICAgICBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuWm9vbSA9IEwuQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnKydcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRleHQ6ICcrJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICctJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnLScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tT3V0VGV4dCwgb3B0aW9ucy56b29tT3V0VGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vbihsaW5rLCAnbW91c2Vkb3duIGRibGNsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBMLkNvbnRyb2wuWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG5MLmNvbnRyb2wuem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuWm9vbShvcHRpb25zKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGFrYSBMLkNvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wgYWxsb3dzIHlvdSB0byBkaXNwbGF5IGF0dHJpYnV0aW9uIGRhdGEgaW4gYSBzbWFsbCB0ZXh0IGJveCBvbiBhIG1hcC4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2BhdHRyaWJ1dGlvbkNvbnRyb2xgIG9wdGlvbl0oI21hcC1hdHRyaWJ1dGlvbmNvbnRyb2wpIHRvIGBmYWxzZWAsIGFuZCBpdCBmZXRjaGVzIGF0dHJpYnV0aW9uIHRleHRzIGZyb20gbGF5ZXJzIHdpdGggdGhlIFtgZ2V0QXR0cmlidXRpb25gIG1ldGhvZF0oI2xheWVyLWdldGF0dHJpYnV0aW9uKSBhdXRvbWF0aWNhbGx5LiBFeHRlbmRzIENvbnRyb2wuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sLkF0dHJpYnV0aW9uID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmcgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdGlmIChMLkRvbUV2ZW50KSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHRleHQgYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCdWZWN0b3IgZGF0YSAmY29weTsgTWFwYm94J2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBMLkNvbnRyb2wuQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbC5cclxuTC5jb250cm9sLmF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcclxuXG5cblxuLypcbiAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gKiBAYWthIEwuQ29udHJvbC5TY2FsZVxuICogQGluaGVyaXRzIENvbnRyb2xcbiAqXG4gKiBBIHNpbXBsZSBzY2FsZSBjb250cm9sIHRoYXQgc2hvd3MgdGhlIHNjYWxlIG9mIHRoZSBjdXJyZW50IGNlbnRlciBvZiBzY3JlZW4gaW4gbWV0cmljIChtL2ttKSBhbmQgaW1wZXJpYWwgKG1pL2Z0KSBzeXN0ZW1zLiBFeHRlbmRzIGBDb250cm9sYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuTC5Db250cm9sLlNjYWxlID0gTC5Db250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5MLmNvbnRyb2wuc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5TY2FsZShvcHRpb25zKTtcbn07XG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHA6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLmh0bWwpKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5MLkNvbnRyb2wuTGF5ZXJzID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciBvciB0b3VjaC5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoTC5zdGFtcChsYXllcikpO1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9mb3JtLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9mb3JtLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fZm9ybSwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fZm9ybSwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcblx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHRpZiAoIUwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmb3JtID0gdGhpcy5fZm9ybSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2Zvcm0nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHRpZiAoIUwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuZXhwYW5kLFxyXG5cdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuXHJcblx0XHRcdGlmIChMLkJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBMLkRvbUV2ZW50LnN0b3ApXHJcblx0XHRcdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHdvcmsgYXJvdW5kIGZvciBGaXJlZm94IEFuZHJvaWQgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjAzM1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGZvcm0sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpLCAwKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblx0XHRcdC8vIFRPRE8ga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIGZvcm0pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBmb3JtKTtcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBmb3JtKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIEwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzLnB1c2goe1xyXG5cdFx0XHRsYXllcjogbGF5ZXIsXHJcblx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdG92ZXJsYXk6IG92ZXJsYXlcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRMLkRvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0TC5Eb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoTC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG5cdFx0ICAgIGlucHV0O1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzJywgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IEwuc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9mb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLFxyXG5cdFx0ICAgIGlucHV0LCBsYXllciwgaGFzTGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aGFzTGF5ZXIgPSB0aGlzLl9tYXAuaGFzTGF5ZXIobGF5ZXIpO1xyXG5cclxuXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQgJiYgIWhhc0xheWVyKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkICYmIGhhc0xheWVyKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0Rpc2FibGVkTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fZm9ybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKSxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmNvbGxhcHNlKCk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbkwuY29udHJvbC5sYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5MYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICogZngucnVuKGVsLCBbMzAwLCA1MDBdLCAwLjUpO1xuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAqIENyZWF0ZXMgYSBgUG9zQW5pbWF0aW9uYCBvYmplY3QuXG4gKlxuICovXG5cbkwuUG9zQW5pbWF0aW9uID0gTC5FdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcblx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuXHQvLyBkdXJhdGlvbiBpbiBzZWNvbmRzIChgMC4yNWAgYnkgZGVmYXVsdCkgYW5kIGVhc2luZyBsaW5lYXJpdHkgZmFjdG9yICgzcmRcblx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdHRoaXMuX3N0ZXAoKTtcblx0fSxcblxuXHRfc3RlcDogZnVuY3Rpb24gKHJvdW5kKSB7XG5cdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdCAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICogMTAwMDtcblxuXHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcblx0XHRpZiAocm91bmQpIHtcblx0XHRcdHBvcy5fcm91bmQoKTtcblx0XHR9XG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG5cblxuXG4vKlxuICogRXh0ZW5kcyBMLk1hcCB0byBoYW5kbGUgcGFubmluZyBhbmltYXRpb25zLlxuICovXG5cbkwuTWFwLmluY2x1ZGUoe1xuXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKEwubGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dGhpcy5fc3RvcCgpO1xuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XG5cblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBMLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBMLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcblxuXHRcdFx0aWYgKG1vdmVkKSB7XG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xuXHRcdG9mZnNldCA9IEwucG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0XHR9XG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XG5cdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG5cblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXG5cdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XG5cblx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XG5cdH0sXG5cblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2Zsb29yKCk7XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuXG5cbi8qXG4gKiBFeHRlbmRzIEwuTWFwIHRvIGhhbmRsZSB6b29tIGFuaW1hdGlvbnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxuXHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXG5cdHpvb21BbmltYXRpb246IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XG5cdC8vIFdvbid0IGFuaW1hdGUgem9vbSBpZiB0aGUgem9vbSBkaWZmZXJlbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cblx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNFxufSk7XG5cbnZhciB6b29tQW5pbWF0ZWQgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiBMLkJyb3dzZXIuYW55M2QgJiYgIUwuQnJvd3Nlci5tb2JpbGVPcGVyYTtcblxuaWYgKHpvb21BbmltYXRlZCkge1xuXG5cdEwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcblxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblxuXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XG5cblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fcHJveHksIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcblx0XHR9XG5cdH0pO1xufVxuXG5MLk1hcC5pbmNsdWRlKCF6b29tQW5pbWF0ZWQgPyB7fSA6IHtcblxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xuXG5cdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHByb3AgPSBMLkRvbVV0aWwuVFJBTlNGT1JNLFxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHByb3h5LnN0eWxlW3Byb3BdO1xuXG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHByb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xuXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xuXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXG5cdFx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybShwcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xuXHR9LFxuXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xuXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpc1xuXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUpXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xuXHRcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IHRydWU7XG5cblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XG5cblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcblx0XHR9XG5cblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcblx0XHQvLyBGaXJlZCBvbiBldmVyeSBmcmFtZSBvZiBhIHpvb20gYW5pbWF0aW9uXG5cdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcblx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0em9vbTogem9vbSxcblx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxuXHRcdH0pO1xuXG5cdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xuXHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xuXHR9LFxuXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xuXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xuXG5cdFx0Ly8gVGhpcyBhbmltIGZyYW1lIHNob3VsZCBwcmV2ZW50IGFuIG9ic2N1cmUgaU9TIHdlYmtpdCB0aWxlIGxvYWRpbmcgcmFjZSBjb25kaXRpb24uXG5cdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcblx0XHR9LCB0aGlzKTtcblx0fVxufSk7XG5cblxuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxuTC5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vUGFuIG9wdGlvbnMpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxuXHQvLyBwYW4tem9vbSBhbmltYXRpb24uXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RvcCgpO1xuXG5cdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcblx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcblxuXHRcdHRhcmdldENlbnRlciA9IEwubGF0TG5nKHRhcmdldENlbnRlcik7XG5cdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XG5cblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXG5cdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxuXHRcdCAgICByaG8gPSAxLjQyLFxuXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xuXG5cdFx0ZnVuY3Rpb24gcihpKSB7XG5cdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxuXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xuXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXG5cdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XG5cblx0XHRcdHJldHVybiBsb2c7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxuXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XG5cblx0XHR2YXIgcjAgPSByKDApO1xuXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cblx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxuXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cblxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcblx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcblxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xuXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcblxuXHRcdFx0aWYgKHQgPD0gMSkge1xuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMuX21vdmUoXG5cdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXNcblx0XHRcdFx0XHQuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKVxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSk7XG5cblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uIGxpa2UgW2BmbHlUb2BdKCNtYXAtZmx5dG8pLFxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XG5cdH1cbn0pO1xuXG5cblxuLypcclxuICogUHJvdmlkZXMgTC5NYXAgd2l0aCBjb252ZW5pZW50IHNob3J0Y3V0cyBmb3IgdXNpbmcgYnJvd3NlciBnZW9sb2NhdGlvbiBmZWF0dXJlcy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG5cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xyXG5cdF9kZWZhdWx0TG9jYXRlT3B0aW9uczoge1xyXG5cdFx0dGltZW91dDogMTAwMDAsXHJcblx0XHR3YXRjaDogZmFsc2VcclxuXHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG5cdFx0Ly8gbWF4aW11bUFnZTogMFxyXG5cdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG5cdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxyXG5cdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcblx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG5cdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cclxuXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcblx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBMLmV4dGVuZCh7fSwgdGhpcy5fZGVmYXVsdExvY2F0ZU9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0ICAgIG9uRXJyb3IgPSBMLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG5cdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG5cdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTC5MYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5KSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG5cdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9XHJcbn0pO1xyXG5cblxuXG59KHdpbmRvdywgZG9jdW1lbnQpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYWZsZXQtc3JjLm1hcCIsIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxudmFyIHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgcm9vdCA9IHRoaXM7XG59XG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlcicpO1xudmFyIHJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cbnZhciByZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlcXVlc3QnKS5iaW5kKG51bGwsIFJlcXVlc3QpO1xuXG4vKipcbiAqIERldGVybWluZSBYSFIuXG4gKi9cblxucmVxdWVzdC5nZXRYSFIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XG4gICAgICAmJiAoIXJvb3QubG9jYXRpb24gfHwgJ2ZpbGU6JyAhPSByb290LmxvY2F0aW9uLnByb3RvY29sXG4gICAgICAgICAgfHwgIXJvb3QuQWN0aXZlWE9iamVjdCkpIHtcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJCcm93c2VyLW9ubHkgdmVyaXNvbiBvZiBzdXBlcmFnZW50IGNvdWxkIG5vdCBmaW5kIFhIUlwiKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAobnVsbCAhPSBvYmpba2V5XSkge1xuICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgb2JqW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBmb3IodmFyIHN1YmtleSBpbiB2YWwpIHtcbiAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXkgKyAnWycgKyBzdWJrZXkgKyAnXScsIHZhbFtzdWJrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxuIHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4gLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICB2YXIgcGFpcjtcbiAgdmFyIHBvcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgcG9zID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKHBvcyA9PSAtMSkge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyKV0gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKDAsIHBvcykpXSA9XG4gICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAnYXBwbGljYXRpb24veG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbiByZXF1ZXN0LnNlcmlhbGl6ZSA9IHtcbiAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG4gfTtcblxuIC8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgZmllbGRzID0ge307XG4gIHZhciBpbmRleDtcbiAgdmFyIGxpbmU7XG4gIHZhciBmaWVsZDtcbiAgdmFyIHZhbDtcblxuICBsaW5lcy5wb3AoKTsgLy8gdHJhaWxpbmcgQ1JMRlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG1pbWVgIGlzIGpzb24gb3IgaGFzICtqc29uIHN0cnVjdHVyZWQgc3ludGF4IHN1ZmZpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzSlNPTihtaW1lKSB7XG4gIHJldHVybiAvW1xcLytdanNvblxcYi8udGVzdChtaW1lKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHR5cGUoc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5zaGlmdCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyYW1zKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyksXG4gICAgICAgIGtleSA9IHBhcnRzLnNoaWZ0KCksXG4gICAgICAgIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZWAgd2l0aCB0aGUgZ2l2ZW4gYHhocmAuXG4gKlxuICogIC0gc2V0IGZsYWdzICgub2ssIC5lcnJvciwgZXRjKVxuICogIC0gcGFyc2UgaGVhZGVyXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcbiAqXG4gKiAgICAgIHJlcXVlc3QgPSBzdXBlcmFnZW50O1xuICpcbiAqICBXZSBjYW4gdXNlIHRoZSBwcm9taXNlLWxpa2UgQVBJLCBvciBwYXNzIGNhbGxiYWNrczpcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJywgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5zZW5kKClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnBvc3QoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIE9yIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbmdsZSBjYWxsIGZvciBzaW1wbGUgY2FzZXM6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2UocmVxLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdGhpcy5fc2V0U3RhdHVzUHJvcGVydGllcyh0aGlzLnhoci5zdGF0dXMpO1xuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuICB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gIHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpO1xuICB0aGlzLmJvZHkgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnXG4gICAgPyB0aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgOiBudWxsO1xufVxuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3NldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xuICAvLyBjb250ZW50LXR5cGVcbiAgdmFyIGN0ID0gdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICB0aGlzLnR5cGUgPSB0eXBlKGN0KTtcblxuICAvLyBwYXJhbXNcbiAgdmFyIG9iaiA9IHBhcmFtcyhjdCk7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHRoaXNba2V5XSA9IG9ialtrZXldO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fcGFyc2VCb2R5ID0gZnVuY3Rpb24oc3RyKXtcbiAgdmFyIHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3NldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cblxuICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgLy8gYmFzaWNzXG4gIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgID8gdGhpcy50b0Vycm9yKClcbiAgICA6IGZhbHNlO1xuXG4gIC8vIHN1Z2FyXG4gIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXM7XG4gIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlO1xuICAgICAgLy8gaXNzdWUgIzY3NTogcmV0dXJuIHRoZSByYXcgcmVzcG9uc2UgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGVyci5yYXdSZXNwb25zZSA9IHNlbGYueGhyICYmIHNlbGYueGhyLnJlc3BvbnNlVGV4dCA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG4gICAgICAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGVyci5zdGF0dXNDb2RlID0gc2VsZi54aHIgJiYgc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICB2YXIgbmV3X2VycjtcbiAgICB0cnkge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPCAyMDAgfHwgcmVzLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgICAgbmV3X2Vyci5vcmlnaW5hbCA9IGVycjtcbiAgICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgbmV3X2VyciA9IGU7IC8vICM5ODUgdG91Y2hpbmcgcmVzIG1heSBjYXVzZSBJTlZBTElEX1NUQVRFX0VSUiBvbiBvbGQgQW5kcm9pZFxuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYHJlcXVlc3RCYXNlYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcbmZvciAodmFyIGtleSBpbiByZXF1ZXN0QmFzZSkge1xuICBSZXF1ZXN0LnByb3RvdHlwZVtrZXldID0gcmVxdWVzdEJhc2Vba2V5XTtcbn1cblxuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgcmVzcG9uc2VUeXBlIHRvIGB2YWxgLiBQcmVzZW50bHkgdmFsaWQgcmVzcG9uc2VUeXBlcyBhcmUgJ2Jsb2InIGFuZFxuICogJ2FycmF5YnVmZmVyJy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5yZXNwb25zZVR5cGUoJ2Jsb2InKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0FjY2VwdCcsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQXV0aG9yaXphdGlvbiBmaWVsZCB2YWx1ZSB3aXRoIGB1c2VyYCBhbmQgYHBhc3NgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aCAndHlwZScgcHJvcGVydHkgJ2F1dG8nIG9yICdiYXNpYycgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnYmFzaWMnXG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICB2YXIgc3RyID0gYnRvYSh1c2VyICsgJzonICsgcGFzcyk7XG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgc3RyKTtcbiAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXI7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzcztcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuKlxuKiBFeGFtcGxlczpcbipcbiogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4qICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4qIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuKiBAYXBpIHB1YmxpY1xuKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBmaWxlbmFtZWAuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKCdjb250ZW50JywgbmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIGZpbGVuYW1lKXtcbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIGZpbGVuYW1lIHx8IGZpbGUubmFtZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgZm4oZXJyLCByZXMpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB4LWRvbWFpbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcm9zc0RvbWFpbkVycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuXG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICBlcnIudXJsID0gdGhpcy51cmw7XG5cbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9IH50aGlzLnVybC5pbmRleE9mKCc/JylcbiAgICAgID8gJyYnICsgcXVlcnlcbiAgICAgIDogJz8nICsgcXVlcnk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5pdGlhdGUgcmVxdWVzdCwgaW52b2tpbmcgY2FsbGJhY2sgYGZuKHJlcylgXG4gKiB3aXRoIGFuIGluc3RhbmNlb2YgYFJlc3BvbnNlYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGhyID0gdGhpcy54aHIgPSByZXF1ZXN0LmdldFhIUigpO1xuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gIHZhciBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gc3RhdGUgY2hhbmdlXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgdmFyIHN0YXR1cztcbiAgICB0cnkgeyBzdGF0dXMgPSB4aHIuc3RhdHVzIH0gY2F0Y2goZSkgeyBzdGF0dXMgPSAwOyB9XG5cbiAgICBpZiAoMCA9PSBzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0KSByZXR1cm4gc2VsZi5fdGltZW91dEVycm9yKCk7XG4gICAgICBpZiAoc2VsZi5fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHNlbGYuY3Jvc3NEb21haW5FcnJvcigpO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uKGUpe1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgIH1cbiAgICBlLmRpcmVjdGlvbiA9ICdkb3dubG9hZCc7XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHhoci51cGxvYWQgJiYgdGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gQWNjZXNzaW5nIHhoci51cGxvYWQgZmFpbHMgaW4gSUUgZnJvbSBhIHdlYiB3b3JrZXIsIHNvIGp1c3QgcHJldGVuZCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICB9XG5cbiAgLy8gdGltZW91dFxuICBpZiAodGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYudGltZWRvdXQgPSB0cnVlO1xuICAgICAgc2VsZi5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgdGhpcy5fYXBwZW5kUXVlcnlTdHJpbmcoKTtcblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUsIHRoaXMudXNlcm5hbWUsIHRoaXMucGFzc3dvcmQpO1xuICB9IGVsc2Uge1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0YC5cbiAqL1xuXG5yZXF1ZXN0LlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdHRVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIE9QVElPTlMgcXVlcnkgdG8gYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0Lm9wdGlvbnMgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVsKHVybCwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbnJlcXVlc3RbJ2RlbCddID0gZGVsO1xucmVxdWVzdFsnZGVsZXRlJ10gPSBkZWw7XG5cbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4iLCIvKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuLyoqXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKXtcbiAgdGhpcy5fdGltZW91dCA9IDA7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0IHRvIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50aW1lb3V0ID0gZnVuY3Rpb24gdGltZW91dChtcyl7XG4gIHRoaXMuX3RpbWVvdXQgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdFxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqL1xuXG5leHBvcnRzLnRoZW4gPSBmdW5jdGlvbiB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCl7XG4gICAgICBzZWxmLmVuZChmdW5jdGlvbihlcnIsIHJlcyl7XG4gICAgICAgIGlmIChlcnIpIGlubmVyUmVqZWN0KGVycik7IGVsc2UgaW5uZXJSZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZnVsbGZpbGxlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xufVxuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cbmV4cG9ydHMuZ2V0SGVhZGVyID0gZXhwb3J0cy5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuZXhwb3J0cy51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICogcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICB0aGlzLnJlcSAmJiB0aGlzLnJlcS5hYm9ydCgpOyAvLyBub2RlXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlZGlyZWN0cyA9IGZ1bmN0aW9uKG4pe1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnRvSlNPTiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyXG4gIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIFRPRE86IGZ1dHVyZSBwcm9vZiwgbW92ZSB0byBjb21wb2VudCBsYW5kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIHZhciBzdHIgPSB7fS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IEJsb2JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEZvcm1EYXRhXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBvYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIC8vIG1lcmdlXG4gIGlmIChvYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghb2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gZGVmYXVsdCB0byBqc29uXG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIi8vIFRoZSBub2RlIGFuZCBicm93c2VyIG1vZHVsZXMgZXhwb3NlIHZlcnNpb25zIG9mIHRoaXMgd2l0aCB0aGVcbi8vIGFwcHJvcHJpYXRlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGJvdW5kIGFzIGZpcnN0IGFyZ3VtZW50XG4vKipcbiAqIElzc3VlIGEgcmVxdWVzdDpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXF1ZXN0KCdHRVQnLCAnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJywgY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHVybCBvciBjYWxsYmFja1xuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVxdWVzdChSZXF1ZXN0Q29uc3RydWN0b3IsIG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcignR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMiA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0Q29uc3RydWN0b3IoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcihtZXRob2QsIHVybCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUaW55UXVldWU7XG5cbmZ1bmN0aW9uIFRpbnlRdWV1ZShkYXRhLCBjb21wYXJlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRpbnlRdWV1ZSkpIHJldHVybiBuZXcgVGlueVF1ZXVlKGRhdGEsIGNvbXBhcmUpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCBbXTtcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5jb21wYXJlID0gY29tcGFyZSB8fCBkZWZhdWx0Q29tcGFyZTtcblxuICAgIGlmIChkYXRhKSBmb3IgKHZhciBpID0gTWF0aC5mbG9vcih0aGlzLmxlbmd0aCAvIDIpOyBpID49IDA7IGktLSkgdGhpcy5fZG93bihpKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cblxuVGlueVF1ZXVlLnByb3RvdHlwZSA9IHtcblxuICAgIHB1c2g6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKGl0ZW0pO1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB0aGlzLl91cCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH0sXG5cbiAgICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuZGF0YVswXTtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5kYXRhW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgIHRoaXMuZGF0YS5wb3AoKTtcbiAgICAgICAgdGhpcy5fZG93bigwKTtcbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9LFxuXG4gICAgcGVlazogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzBdO1xuICAgIH0sXG5cbiAgICBfdXA6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gTWF0aC5mbG9vcigocG9zIC0gMSkgLyAyKTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlKGRhdGFbcG9zXSwgZGF0YVtwYXJlbnRdKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzd2FwKGRhdGEsIHBhcmVudCwgcG9zKTtcbiAgICAgICAgICAgICAgICBwb3MgPSBwYXJlbnQ7XG5cbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZG93bjogZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmUsXG4gICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSAyICogcG9zICsgMSxcbiAgICAgICAgICAgICAgICByaWdodCA9IGxlZnQgKyAxLFxuICAgICAgICAgICAgICAgIG1pbiA9IHBvcztcblxuICAgICAgICAgICAgaWYgKGxlZnQgPCBsZW4gJiYgY29tcGFyZShkYXRhW2xlZnRdLCBkYXRhW21pbl0pIDwgMCkgbWluID0gbGVmdDtcbiAgICAgICAgICAgIGlmIChyaWdodCA8IGxlbiAmJiBjb21wYXJlKGRhdGFbcmlnaHRdLCBkYXRhW21pbl0pIDwgMCkgbWluID0gcmlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChtaW4gPT09IHBvcykgcmV0dXJuO1xuXG4gICAgICAgICAgICBzd2FwKGRhdGEsIG1pbiwgcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IG1pbjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHN3YXAoZGF0YSwgaSwgaikge1xuICAgIHZhciB0bXAgPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBkYXRhW2pdO1xuICAgIGRhdGFbal0gPSB0bXA7XG59XG4iLCJ2YXIgc2lnbmVkQXJlYSA9IHJlcXVpcmUoJy4vc2lnbmVkX2FyZWEnKTtcblxuLyoqXG4gKiBAcGFyYW0gIHtTd2VlcEV2ZW50fSBlMVxuICogQHBhcmFtICB7U3dlZXBFdmVudH0gZTJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzd2VlcEV2ZW50c0NvbXAoZTEsIGUyKSB7XG4gIHZhciBwMSA9IGUxLnBvaW50O1xuICB2YXIgcDIgPSBlMi5wb2ludDtcblxuICAvLyBEaWZmZXJlbnQgeC1jb29yZGluYXRlXG4gIGlmIChwMVswXSA+IHAyWzBdKSByZXR1cm4gMTtcbiAgaWYgKHAxWzBdIDwgcDJbMF0pIHJldHVybiAtMTtcblxuICAvLyBEaWZmZXJlbnQgcG9pbnRzLCBidXQgc2FtZSB4LWNvb3JkaW5hdGVcbiAgLy8gRXZlbnQgd2l0aCBsb3dlciB5LWNvb3JkaW5hdGUgaXMgcHJvY2Vzc2VkIGZpcnN0XG4gIGlmIChwMVsxXSAhPT0gcDJbMV0pIHJldHVybiBwMVsxXSA+IHAyWzFdID8gMSA6IC0xO1xuXG4gIHJldHVybiBzcGVjaWFsQ2FzZXMoZTEsIGUyLCBwMSwgcDIpO1xufTtcblxuXG5mdW5jdGlvbiBzcGVjaWFsQ2FzZXMoZTEsIGUyLCBwMSwgcDIpIHtcbiAgLy8gU2FtZSBjb29yZGluYXRlcywgYnV0IG9uZSBpcyBhIGxlZnQgZW5kcG9pbnQgYW5kIHRoZSBvdGhlciBpc1xuICAvLyBhIHJpZ2h0IGVuZHBvaW50LiBUaGUgcmlnaHQgZW5kcG9pbnQgaXMgcHJvY2Vzc2VkIGZpcnN0XG4gIGlmIChlMS5sZWZ0ICE9PSBlMi5sZWZ0KVxuICAgIHJldHVybiBlMS5sZWZ0ID8gMSA6IC0xO1xuXG4gIC8vIFNhbWUgY29vcmRpbmF0ZXMsIGJvdGggZXZlbnRzXG4gIC8vIGFyZSBsZWZ0IGVuZHBvaW50cyBvciByaWdodCBlbmRwb2ludHMuXG4gIC8vIG5vdCBjb2xsaW5lYXJcbiAgaWYgKHNpZ25lZEFyZWEgKHAxLCBlMS5vdGhlckV2ZW50LnBvaW50LCBlMi5vdGhlckV2ZW50LnBvaW50KSAhPT0gMCkge1xuICAgIC8vIHRoZSBldmVudCBhc3NvY2lhdGUgdG8gdGhlIGJvdHRvbSBzZWdtZW50IGlzIHByb2Nlc3NlZCBmaXJzdFxuICAgIHJldHVybiAoIWUxLmlzQmVsb3coZTIub3RoZXJFdmVudC5wb2ludCkpID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiAoIWUxLmlzU3ViamVjdCAmJiBlMi5pc1N1YmplY3QpID8gMSA6IC0xO1xuICAvL3JldHVybiBlMS5pc1N1YmplY3QgPyAtMSA6IDE7XG59IiwidmFyIHNpZ25lZEFyZWEgICAgPSByZXF1aXJlKCcuL3NpZ25lZF9hcmVhJyk7XG52YXIgY29tcGFyZUV2ZW50cyA9IHJlcXVpcmUoJy4vY29tcGFyZV9ldmVudHMnKTtcbnZhciBlcXVhbHMgICAgICAgID0gcmVxdWlyZSgnLi9lcXVhbHMnKTtcblxuXG4vKipcbiAqIEBwYXJhbSAge1N3ZWVwRXZlbnR9IGxlMVxuICogQHBhcmFtICB7U3dlZXBFdmVudH0gbGUyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcGFyZVNlZ21lbnRzKGxlMSwgbGUyKSB7XG4gIGlmIChsZTEgPT09IGxlMikgcmV0dXJuIDA7XG5cbiAgLy8gU2VnbWVudHMgYXJlIG5vdCBjb2xsaW5lYXJcbiAgaWYgKHNpZ25lZEFyZWEobGUxLnBvaW50LCBsZTEub3RoZXJFdmVudC5wb2ludCwgbGUyLnBvaW50KSAhPT0gMCB8fFxuICAgIHNpZ25lZEFyZWEobGUxLnBvaW50LCBsZTEub3RoZXJFdmVudC5wb2ludCwgbGUyLm90aGVyRXZlbnQucG9pbnQpICE9PSAwKSB7XG5cbiAgICAvLyBJZiB0aGV5IHNoYXJlIHRoZWlyIGxlZnQgZW5kcG9pbnQgdXNlIHRoZSByaWdodCBlbmRwb2ludCB0byBzb3J0XG4gICAgaWYgKGVxdWFscyhsZTEucG9pbnQsIGxlMi5wb2ludCkpIHJldHVybiBsZTEuaXNCZWxvdyhsZTIub3RoZXJFdmVudC5wb2ludCkgPyAtMSA6IDE7XG5cbiAgICAvLyBEaWZmZXJlbnQgbGVmdCBlbmRwb2ludDogdXNlIHRoZSBsZWZ0IGVuZHBvaW50IHRvIHNvcnRcbiAgICBpZiAobGUxLnBvaW50WzBdID09PSBsZTIucG9pbnRbMF0pIHJldHVybiBsZTEucG9pbnRbMV0gPCBsZTIucG9pbnRbMV0gPyAtMSA6IDE7XG5cbiAgICAvLyBoYXMgdGhlIGxpbmUgc2VnbWVudCBhc3NvY2lhdGVkIHRvIGUxIGJlZW4gaW5zZXJ0ZWRcbiAgICAvLyBpbnRvIFMgYWZ0ZXIgdGhlIGxpbmUgc2VnbWVudCBhc3NvY2lhdGVkIHRvIGUyID9cbiAgICBpZiAoY29tcGFyZUV2ZW50cyhsZTEsIGxlMikgPT09IDEpIHJldHVybiBsZTIuaXNBYm92ZShsZTEucG9pbnQpID8gLTEgOiAxO1xuXG4gICAgLy8gVGhlIGxpbmUgc2VnbWVudCBhc3NvY2lhdGVkIHRvIGUyIGhhcyBiZWVuIGluc2VydGVkXG4gICAgLy8gaW50byBTIGFmdGVyIHRoZSBsaW5lIHNlZ21lbnQgYXNzb2NpYXRlZCB0byBlMVxuICAgIHJldHVybiBsZTEuaXNCZWxvdyhsZTIucG9pbnQpID8gLTEgOiAxO1xuICB9XG5cbiAgLy8gU2VnbWVudHMgYXJlIGNvbGxpbmVhclxuICBpZiAobGUxLmlzU3ViamVjdCAhPT0gbGUyLmlzU3ViamVjdCkgcmV0dXJuIChsZTEuaXNTdWJqZWN0ICYmICFsZTIuaXNTdWJqZWN0KSA/IDEgOiAtMTtcblxuICAvLyBKdXN0IGEgY29uc2lzdGVudCBjcml0ZXJpb24gaXMgdXNlZFxuICBpZiAoZXF1YWxzKGxlMS5wb2ludCwgbGUyLnBvaW50KSkgcmV0dXJuIDA7XG5cbiAgcmV0dXJuIGNvbXBhcmVFdmVudHMobGUxLCBsZTIpID09PSAxID8gMSA6IC0xO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcbiAgTk9STUFMOiAgICAgICAgICAgICAgIDAsIFxuICBOT05fQ09OVFJJQlVUSU5HOiAgICAgMSwgXG4gIFNBTUVfVFJBTlNJVElPTjogICAgICAyLCBcbiAgRElGRkVSRU5UX1RSQU5TSVRJT046IDNcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgcmV0dXJuIHAxWzBdID09PSBwMlswXSAmJiBwMVsxXSA9PT0gcDJbMV07XG59OyIsInZhciBJTlRFUlNFQ1RJT04gICAgPSAwO1xudmFyIFVOSU9OICAgICAgICAgICA9IDE7XG52YXIgRElGRkVSRU5DRSAgICAgID0gMjtcbnZhciBYT1IgICAgICAgICAgICAgPSAzO1xuXG52YXIgRU1QVFkgICAgICAgICAgID0gW107XG5cbnZhciBlZGdlVHlwZSAgICAgICAgPSByZXF1aXJlKCcuL2VkZ2VfdHlwZScpO1xuXG52YXIgUXVldWUgICAgICAgICAgID0gcmVxdWlyZSgndGlueXF1ZXVlJyk7XG52YXIgVHJlZSAgICAgICAgICAgID0gcmVxdWlyZSgnYmludHJlZXMnKS5SQlRyZWU7XG52YXIgU3dlZXBFdmVudCAgICAgID0gcmVxdWlyZSgnLi9zd2VlcF9ldmVudCcpO1xuXG52YXIgY29tcGFyZUV2ZW50cyAgID0gcmVxdWlyZSgnLi9jb21wYXJlX2V2ZW50cycpO1xudmFyIGNvbXBhcmVTZWdtZW50cyA9IHJlcXVpcmUoJy4vY29tcGFyZV9zZWdtZW50cycpO1xudmFyIGludGVyc2VjdGlvbiAgICA9IHJlcXVpcmUoJy4vc2VnbWVudF9pbnRlcnNlY3Rpb24nKTtcbnZhciBlcXVhbHMgICAgICAgICAgPSByZXF1aXJlKCcuL2VxdWFscycpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQHBhcmFtICB7PEFycmF5LjxOdW1iZXI+fSBzMVxuICogQHBhcmFtICB7PEFycmF5LjxOdW1iZXI+fSBzMlxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgICBpc1N1YmplY3RcbiAqIEBwYXJhbSAge1F1ZXVlfSAgICAgICAgICAgZXZlbnRRdWV1ZVxuICogQHBhcmFtICB7QXJyYXkuPE51bWJlcj59ICBiYm94XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KHMxLCBzMiwgaXNTdWJqZWN0LCBldmVudFF1ZXVlLCBiYm94KSB7XG4gIC8vIFBvc3NpYmxlIGRlZ2VuZXJhdGUgY29uZGl0aW9uLlxuICBpZiAoZXF1YWxzKHMxLCBzMikpIHJldHVybjtcblxuICB2YXIgZTEgPSBuZXcgU3dlZXBFdmVudChzMSwgZmFsc2UsIHVuZGVmaW5lZCwgaXNTdWJqZWN0KTtcbiAgdmFyIGUyID0gbmV3IFN3ZWVwRXZlbnQoczIsIGZhbHNlLCBlMSwgICAgICAgIGlzU3ViamVjdCk7XG4gIGUxLm90aGVyRXZlbnQgPSBlMjtcblxuICBpZiAoY29tcGFyZUV2ZW50cyhlMSwgZTIpID4gMCkge1xuICAgIGUyLmxlZnQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGUxLmxlZnQgPSB0cnVlO1xuICB9XG5cbiAgYmJveFswXSA9IG1pbihiYm94WzBdLCBzMVswXSk7XG4gIGJib3hbMV0gPSBtaW4oYmJveFsxXSwgczFbMV0pO1xuICBiYm94WzJdID0gbWF4KGJib3hbMl0sIHMxWzBdKTtcbiAgYmJveFszXSA9IG1heChiYm94WzNdLCBzMVsxXSk7XG5cbiAgLy8gUHVzaGluZyBpdCBzbyB0aGUgcXVldWUgaXMgc29ydGVkIGZyb20gbGVmdCB0byByaWdodCxcbiAgLy8gd2l0aCBvYmplY3Qgb24gdGhlIGxlZnQgaGF2aW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5LlxuICBldmVudFF1ZXVlLnB1c2goZTEpO1xuICBldmVudFF1ZXVlLnB1c2goZTIpO1xufVxuXG5cbmZ1bmN0aW9uIHByb2Nlc3NQb2x5Z29uKHBvbHlnb24sIGlzU3ViamVjdCwgcXVldWUsIGJib3gpIHtcbiAgdmFyIGksIGxlbjtcbiAgaWYgKHR5cGVvZiBwb2x5Z29uWzBdWzBdID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBwcm9jZXNzU2VnbWVudChwb2x5Z29uW2ldLCBwb2x5Z29uW2kgKyAxXSwgaXNTdWJqZWN0LCBxdWV1ZSwgYmJveCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHByb2Nlc3NQb2x5Z29uKHBvbHlnb25baV0sIGlzU3ViamVjdCwgcXVldWUsIGJib3gpO1xuICAgIH1cbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZpbGxRdWV1ZShzdWJqZWN0LCBjbGlwcGluZywgc2Jib3gsIGNiYm94KSB7XG4gIHZhciBldmVudFF1ZXVlID0gbmV3IFF1ZXVlKG51bGwsIGNvbXBhcmVFdmVudHMpO1xuXG4gIHByb2Nlc3NQb2x5Z29uKHN1YmplY3QsICB0cnVlLCAgZXZlbnRRdWV1ZSwgc2Jib3gpO1xuICBwcm9jZXNzUG9seWdvbihjbGlwcGluZywgZmFsc2UsIGV2ZW50UXVldWUsIGNiYm94KTtcblxuICByZXR1cm4gZXZlbnRRdWV1ZTtcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlRmllbGRzKGV2ZW50LCBwcmV2LCBzd2VlcExpbmUsIG9wZXJhdGlvbikge1xuICAvLyBjb21wdXRlIGluT3V0IGFuZCBvdGhlckluT3V0IGZpZWxkc1xuICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgIGV2ZW50LmluT3V0ICAgICAgPSBmYWxzZTtcbiAgICBldmVudC5vdGhlckluT3V0ID0gdHJ1ZTtcblxuICAvLyBwcmV2aW91cyBsaW5lIHNlZ21lbnQgaW4gc3dlZXBsaW5lIGJlbG9uZ3MgdG8gdGhlIHNhbWUgcG9seWdvblxuICB9IGVsc2UgaWYgKGV2ZW50LmlzU3ViamVjdCA9PT0gcHJldi5pc1N1YmplY3QpIHtcbiAgICBldmVudC5pbk91dCAgICAgID0gIXByZXYuaW5PdXQ7XG4gICAgZXZlbnQub3RoZXJJbk91dCA9IHByZXYub3RoZXJJbk91dDtcblxuICAvLyBwcmV2aW91cyBsaW5lIHNlZ21lbnQgaW4gc3dlZXBsaW5lIGJlbG9uZ3MgdG8gdGhlIGNsaXBwaW5nIHBvbHlnb25cbiAgfSBlbHNlIHtcbiAgICBldmVudC5pbk91dCAgICAgID0gIXByZXYub3RoZXJJbk91dDtcbiAgICBldmVudC5vdGhlckluT3V0ID0gcHJldi5pc1ZlcnRpY2FsKCkgPyAhcHJldi5pbk91dCA6IHByZXYuaW5PdXQ7XG4gIH1cblxuICAvLyBjb21wdXRlIHByZXZJblJlc3VsdCBmaWVsZFxuICBpZiAocHJldikge1xuICAgIGV2ZW50LnByZXZJblJlc3VsdCA9ICghaW5SZXN1bHQocHJldiwgb3BlcmF0aW9uKSB8fCBwcmV2LmlzVmVydGljYWwoKSkgP1xuICAgICAgIHByZXYucHJldkluUmVzdWx0IDogcHJldjtcbiAgfVxuICAvLyBjaGVjayBpZiB0aGUgbGluZSBzZWdtZW50IGJlbG9uZ3MgdG8gdGhlIEJvb2xlYW4gb3BlcmF0aW9uXG4gIGV2ZW50LmluUmVzdWx0ID0gaW5SZXN1bHQoZXZlbnQsIG9wZXJhdGlvbik7XG59XG5cblxuZnVuY3Rpb24gaW5SZXN1bHQoZXZlbnQsIG9wZXJhdGlvbikge1xuICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlIGVkZ2VUeXBlLk5PUk1BTDpcbiAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgIGNhc2UgSU5URVJTRUNUSU9OOlxuICAgICAgICAgIHJldHVybiAhZXZlbnQub3RoZXJJbk91dDtcbiAgICAgICAgY2FzZSBVTklPTjpcbiAgICAgICAgICByZXR1cm4gZXZlbnQub3RoZXJJbk91dDtcbiAgICAgICAgY2FzZSBESUZGRVJFTkNFOlxuICAgICAgICAgIHJldHVybiAoZXZlbnQuaXNTdWJqZWN0ICYmIGV2ZW50Lm90aGVySW5PdXQpIHx8XG4gICAgICAgICAgICAgICAgICghZXZlbnQuaXNTdWJqZWN0ICYmICFldmVudC5vdGhlckluT3V0KTtcbiAgICAgICAgY2FzZSBYT1I6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgY2FzZSBlZGdlVHlwZS5TQU1FX1RSQU5TSVRJT046XG4gICAgICByZXR1cm4gb3BlcmF0aW9uID09PSBJTlRFUlNFQ1RJT04gfHwgb3BlcmF0aW9uID09PSBVTklPTjtcbiAgICBjYXNlIGVkZ2VUeXBlLkRJRkZFUkVOVF9UUkFOU0lUSU9OOlxuICAgICAgcmV0dXJuIG9wZXJhdGlvbiA9PT0gRElGRkVSRU5DRTtcbiAgICBjYXNlIGVkZ2VUeXBlLk5PTl9DT05UUklCVVRJTkc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtICB7U3dlZXBFdmVudH0gc2UxXG4gKiBAcGFyYW0gIHtTd2VlcEV2ZW50fSBzZTJcbiAqIEBwYXJhbSAge1F1ZXVlfSAgICAgIHF1ZXVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHBvc3NpYmxlSW50ZXJzZWN0aW9uKHNlMSwgc2UyLCBxdWV1ZSkge1xuICAvLyB0aGF0IGRpc2FsbG93cyBzZWxmLWludGVyc2VjdGluZyBwb2x5Z29ucyxcbiAgLy8gZGlkIGNvc3QgdXMgaGFsZiBhIGRheSwgc28gSSdsbCBsZWF2ZSBpdFxuICAvLyBvdXQgb2YgcmVzcGVjdFxuICAvLyBpZiAoc2UxLmlzU3ViamVjdCA9PT0gc2UyLmlzU3ViamVjdCkgcmV0dXJuO1xuXG4gIHZhciBpbnRlciA9IGludGVyc2VjdGlvbihcbiAgICBzZTEucG9pbnQsIHNlMS5vdGhlckV2ZW50LnBvaW50LFxuICAgIHNlMi5wb2ludCwgc2UyLm90aGVyRXZlbnQucG9pbnRcbiAgKTtcblxuICB2YXIgbmludGVyc2VjdGlvbnMgPSBpbnRlciA/IGludGVyLmxlbmd0aCA6IDA7XG4gIGlmIChuaW50ZXJzZWN0aW9ucyA9PT0gMCkgcmV0dXJuIDA7IC8vIG5vIGludGVyc2VjdGlvblxuXG4gIC8vIHRoZSBsaW5lIHNlZ21lbnRzIGludGVyc2VjdCBhdCBhbiBlbmRwb2ludCBvZiBib3RoIGxpbmUgc2VnbWVudHNcbiAgaWYgKChuaW50ZXJzZWN0aW9ucyA9PT0gMSkgJiZcbiAgICAgIChlcXVhbHMoc2UxLnBvaW50LCBzZTIucG9pbnQpIHx8XG4gICAgICAgZXF1YWxzKHNlMS5vdGhlckV2ZW50LnBvaW50LCBzZTIub3RoZXJFdmVudC5wb2ludCkpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAobmludGVyc2VjdGlvbnMgPT09IDIgJiYgc2UxLmlzU3ViamVjdCA9PT0gc2UyLmlzU3ViamVjdCkge1xuICAgIGNvbnNvbGUud2FybihzZTEucG9pbnQsIHNlMS5vdGhlckV2ZW50LnBvaW50LCBzZTIucG9pbnQsIHNlMi5vdGhlckV2ZW50LnBvaW50KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VkZ2VzIG9mIHRoZSBzYW1lIHBvbHlnb24gb3ZlcmxhcCcpO1xuICB9XG5cbiAgLy8gVGhlIGxpbmUgc2VnbWVudHMgYXNzb2NpYXRlZCB0byBzZTEgYW5kIHNlMiBpbnRlcnNlY3RcbiAgaWYgKG5pbnRlcnNlY3Rpb25zID09PSAxKSB7XG5cbiAgICAvLyBpZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGlzIG5vdCBhbiBlbmRwb2ludCBvZiBzZTFcbiAgICBpZiAoIWVxdWFscyhzZTEucG9pbnQsIGludGVyWzBdKSAmJiAhZXF1YWxzKHNlMS5vdGhlckV2ZW50LnBvaW50LCBpbnRlclswXSkpIHtcbiAgICAgIGRpdmlkZVNlZ21lbnQoc2UxLCBpbnRlclswXSwgcXVldWUpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgbm90IGFuIGVuZHBvaW50IG9mIHNlMlxuICAgIGlmICghZXF1YWxzKHNlMi5wb2ludCwgaW50ZXJbMF0pICYmICFlcXVhbHMoc2UyLm90aGVyRXZlbnQucG9pbnQsIGludGVyWzBdKSkge1xuICAgICAgZGl2aWRlU2VnbWVudChzZTIsIGludGVyWzBdLCBxdWV1ZSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gVGhlIGxpbmUgc2VnbWVudHMgYXNzb2NpYXRlZCB0byBzZTEgYW5kIHNlMiBvdmVybGFwXG4gIHZhciBldmVudHMgICAgICAgID0gW107XG4gIHZhciBsZWZ0Q29pbmNpZGUgID0gZmFsc2U7XG4gIHZhciByaWdodENvaW5jaWRlID0gZmFsc2U7XG5cbiAgaWYgKGVxdWFscyhzZTEucG9pbnQsIHNlMi5wb2ludCkpIHtcbiAgICBsZWZ0Q29pbmNpZGUgPSB0cnVlOyAvLyBsaW5rZWRcbiAgfSBlbHNlIGlmIChjb21wYXJlRXZlbnRzKHNlMSwgc2UyKSA9PT0gMSkge1xuICAgIGV2ZW50cy5wdXNoKHNlMiwgc2UxKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMucHVzaChzZTEsIHNlMik7XG4gIH1cblxuICBpZiAoZXF1YWxzKHNlMS5vdGhlckV2ZW50LnBvaW50LCBzZTIub3RoZXJFdmVudC5wb2ludCkpIHtcbiAgICByaWdodENvaW5jaWRlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjb21wYXJlRXZlbnRzKHNlMS5vdGhlckV2ZW50LCBzZTIub3RoZXJFdmVudCkgPT09IDEpIHtcbiAgICBldmVudHMucHVzaChzZTIub3RoZXJFdmVudCwgc2UxLm90aGVyRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cy5wdXNoKHNlMS5vdGhlckV2ZW50LCBzZTIub3RoZXJFdmVudCk7XG4gIH1cblxuICBpZiAoKGxlZnRDb2luY2lkZSAmJiByaWdodENvaW5jaWRlKSB8fCBsZWZ0Q29pbmNpZGUpIHtcbiAgICAvLyBib3RoIGxpbmUgc2VnbWVudHMgYXJlIGVxdWFsIG9yIHNoYXJlIHRoZSBsZWZ0IGVuZHBvaW50XG4gICAgc2UxLnR5cGUgPSBlZGdlVHlwZS5OT05fQ09OVFJJQlVUSU5HO1xuICAgIHNlMi50eXBlID0gKHNlMS5pbk91dCA9PT0gc2UyLmluT3V0KSA/XG4gICAgICBlZGdlVHlwZS5TQU1FX1RSQU5TSVRJT04gOlxuICAgICAgZWRnZVR5cGUuRElGRkVSRU5UX1RSQU5TSVRJT047XG5cbiAgICBpZiAobGVmdENvaW5jaWRlICYmICFyaWdodENvaW5jaWRlKSB7XG4gICAgICBkaXZpZGVTZWdtZW50KGV2ZW50c1syXS5vdGhlckV2ZW50LCBldmVudHNbMV0ucG9pbnQsIHF1ZXVlKTtcbiAgICB9XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICAvLyB0aGUgbGluZSBzZWdtZW50cyBzaGFyZSB0aGUgcmlnaHQgZW5kcG9pbnRcbiAgaWYgKHJpZ2h0Q29pbmNpZGUpIHtcbiAgICBkaXZpZGVTZWdtZW50KGV2ZW50c1swXSwgZXZlbnRzWzFdLnBvaW50LCBxdWV1ZSk7XG4gICAgcmV0dXJuIDM7XG4gIH1cblxuICAvLyBubyBsaW5lIHNlZ21lbnQgaW5jbHVkZXMgdG90YWxseSB0aGUgb3RoZXIgb25lXG4gIGlmIChldmVudHNbMF0gIT09IGV2ZW50c1szXS5vdGhlckV2ZW50KSB7XG4gICAgZGl2aWRlU2VnbWVudChldmVudHNbMF0sIGV2ZW50c1sxXS5wb2ludCwgcXVldWUpO1xuICAgIGRpdmlkZVNlZ21lbnQoZXZlbnRzWzFdLCBldmVudHNbMl0ucG9pbnQsIHF1ZXVlKTtcbiAgICByZXR1cm4gMztcbiAgfVxuXG4gIC8vIG9uZSBsaW5lIHNlZ21lbnQgaW5jbHVkZXMgdGhlIG90aGVyIG9uZVxuICBkaXZpZGVTZWdtZW50KGV2ZW50c1swXSwgZXZlbnRzWzFdLnBvaW50LCBxdWV1ZSk7XG4gIGRpdmlkZVNlZ21lbnQoZXZlbnRzWzNdLm90aGVyRXZlbnQsIGV2ZW50c1syXS5wb2ludCwgcXVldWUpO1xuXG4gIHJldHVybiAzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtICB7U3dlZXBFdmVudH0gc2VcbiAqIEBwYXJhbSAge0FycmF5LjxOdW1iZXI+fSBwXG4gKiBAcGFyYW0gIHtRdWV1ZX0gcXVldWVcbiAqIEByZXR1cm4ge1F1ZXVlfVxuICovXG5mdW5jdGlvbiBkaXZpZGVTZWdtZW50KHNlLCBwLCBxdWV1ZSkgIHtcbiAgdmFyIHIgPSBuZXcgU3dlZXBFdmVudChwLCBmYWxzZSwgc2UsICAgICAgICAgICAgc2UuaXNTdWJqZWN0KTtcbiAgdmFyIGwgPSBuZXcgU3dlZXBFdmVudChwLCB0cnVlLCAgc2Uub3RoZXJFdmVudCwgc2UuaXNTdWJqZWN0KTtcblxuICAvLyBhdm9pZCBhIHJvdW5kaW5nIGVycm9yLiBUaGUgbGVmdCBldmVudCB3b3VsZCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHJpZ2h0IGV2ZW50XG4gIGlmIChjb21wYXJlRXZlbnRzKGwsIHNlLm90aGVyRXZlbnQpID4gMCkge1xuICAgIHNlLm90aGVyRXZlbnQubGVmdCA9IHRydWU7XG4gICAgbC5sZWZ0ID0gZmFsc2U7XG4gIH1cblxuICAvLyBhdm9pZCBhIHJvdW5kaW5nIGVycm9yLiBUaGUgbGVmdCBldmVudCB3b3VsZCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHJpZ2h0IGV2ZW50XG4gIC8vIGlmIChjb21wYXJlRXZlbnRzKHNlLCByKSA+IDApIHt9XG5cbiAgc2Uub3RoZXJFdmVudC5vdGhlckV2ZW50ID0gbDtcbiAgc2Uub3RoZXJFdmVudCA9IHI7XG5cbiAgcXVldWUucHVzaChsKTtcbiAgcXVldWUucHVzaChyKTtcblxuICByZXR1cm4gcXVldWU7XG59XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLWRlYnVnZ2VyICovXG5mdW5jdGlvbiBpdGVyYXRvckVxdWFscyhpdDEsIGl0Mikge1xuICByZXR1cm4gaXQxLl9jdXJzb3IgPT09IGl0Mi5fY3Vyc29yO1xufVxuXG5cbmZ1bmN0aW9uIF9yZW5kZXJTd2VlcExpbmUoc3dlZXBMaW5lLCBwb3MsIGV2ZW50KSB7XG4gIHZhciBtYXAgPSB3aW5kb3cubWFwO1xuICBpZiAoIW1hcCkgcmV0dXJuO1xuICBpZiAod2luZG93LnN3cykgd2luZG93LnN3cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICBtYXAucmVtb3ZlTGF5ZXIocCk7XG4gIH0pO1xuICB3aW5kb3cuc3dzID0gW107XG4gIHN3ZWVwTGluZS5lYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcG9seSA9IEwucG9seWxpbmUoW2UucG9pbnQuc2xpY2UoKS5yZXZlcnNlKCksIGUub3RoZXJFdmVudC5wb2ludC5zbGljZSgpLnJldmVyc2UoKV0sIHsgY29sb3I6ICdncmVlbicgfSkuYWRkVG8obWFwKTtcbiAgICB3aW5kb3cuc3dzLnB1c2gocG9seSk7XG4gIH0pO1xuXG4gIGlmICh3aW5kb3cudnQpIG1hcC5yZW1vdmVMYXllcih3aW5kb3cudnQpO1xuICB2YXIgdiA9IHBvcy5zbGljZSgpO1xuICB2YXIgYiA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgd2luZG93LnZ0ID0gTC5wb2x5bGluZShbW2IuZ2V0Tm9ydGgoKSwgdlswXV0sIFtiLmdldFNvdXRoKCksIHZbMF1dXSwge2NvbG9yOiAnZ3JlZW4nLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuXG4gIGlmICh3aW5kb3cucHMpIG1hcC5yZW1vdmVMYXllcih3aW5kb3cucHMpO1xuICB3aW5kb3cucHMgPSBMLnBvbHlsaW5lKFtldmVudC5wb2ludC5zbGljZSgpLnJldmVyc2UoKSwgZXZlbnQub3RoZXJFdmVudC5wb2ludC5zbGljZSgpLnJldmVyc2UoKV0sIHtjb2xvcjogJ2JsYWNrJywgd2VpZ2h0OiA5LCBvcGFjaXR5OiAwLjR9KS5hZGRUbyhtYXApO1xuICBkZWJ1Z2dlcjtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLWRlYnVnZ2VyICovXG5cblxuZnVuY3Rpb24gc3ViZGl2aWRlU2VnbWVudHMoZXZlbnRRdWV1ZSwgc3ViamVjdCwgY2xpcHBpbmcsIHNiYm94LCBjYmJveCwgb3BlcmF0aW9uKSB7XG4gIHZhciBzb3J0ZWRFdmVudHMgPSBbXTtcbiAgdmFyIHByZXYsIG5leHQ7XG5cbiAgdmFyIHN3ZWVwTGluZSA9IG5ldyBUcmVlKGNvbXBhcmVTZWdtZW50cyk7XG4gIHZhciBzb3J0ZWRFdmVudHMgPSBbXTtcblxuICB2YXIgcmlnaHRib3VuZCA9IG1pbihzYmJveFsyXSwgY2Jib3hbMl0pO1xuXG4gIHZhciBwcmV2LCBuZXh0O1xuXG4gIHdoaWxlIChldmVudFF1ZXVlLmxlbmd0aCkge1xuICAgIHZhciBldmVudCA9IGV2ZW50UXVldWUucG9wKCk7XG4gICAgc29ydGVkRXZlbnRzLnB1c2goZXZlbnQpO1xuXG4gICAgLy8gb3B0aW1pemF0aW9uIGJ5IGJib3hlcyBmb3IgaW50ZXJzZWN0aW9uIGFuZCBkaWZmZXJlbmNlIGdvZXMgaGVyZVxuICAgIGlmICgob3BlcmF0aW9uID09PSBJTlRFUlNFQ1RJT04gJiYgZXZlbnQucG9pbnRbMF0gPiByaWdodGJvdW5kKSB8fFxuICAgICAgICAob3BlcmF0aW9uID09PSBESUZGRVJFTkNFICAgJiYgZXZlbnQucG9pbnRbMF0gPiBzYmJveFsyXSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChldmVudC5sZWZ0KSB7XG4gICAgICBzd2VlcExpbmUuaW5zZXJ0KGV2ZW50KTtcbiAgICAgIC8vIF9yZW5kZXJTd2VlcExpbmUoc3dlZXBMaW5lLCBldmVudC5wb2ludCwgZXZlbnQpO1xuXG4gICAgICBuZXh0ID0gc3dlZXBMaW5lLmZpbmRJdGVyKGV2ZW50KTtcbiAgICAgIHByZXYgPSBzd2VlcExpbmUuZmluZEl0ZXIoZXZlbnQpO1xuICAgICAgZXZlbnQuaXRlcmF0b3IgPSBzd2VlcExpbmUuZmluZEl0ZXIoZXZlbnQpO1xuXG4gICAgICBpZiAocHJldi5kYXRhKCkgIT09IHN3ZWVwTGluZS5taW4oKSkge1xuICAgICAgICBwcmV2LnByZXYoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYgPSBzd2VlcExpbmUuZmluZEl0ZXIoc3dlZXBMaW5lLm1heCgpKTtcbiAgICAgICAgcHJldi5uZXh0KCk7XG4gICAgICB9XG4gICAgICBuZXh0Lm5leHQoKTtcblxuICAgICAgY29tcHV0ZUZpZWxkcyhldmVudCwgcHJldi5kYXRhKCksIHN3ZWVwTGluZSwgb3BlcmF0aW9uKTtcblxuICAgICAgaWYgKG5leHQuZGF0YSgpKSB7XG4gICAgICAgIGlmIChwb3NzaWJsZUludGVyc2VjdGlvbihldmVudCwgbmV4dC5kYXRhKCksIGV2ZW50UXVldWUpID09PSAyKSB7XG4gICAgICAgICAgY29tcHV0ZUZpZWxkcyhldmVudCwgcHJldi5kYXRhKCksIHN3ZWVwTGluZSwgb3BlcmF0aW9uKTtcbiAgICAgICAgICBjb21wdXRlRmllbGRzKGV2ZW50LCBuZXh0LmRhdGEoKSwgc3dlZXBMaW5lLCBvcGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2LmRhdGEoKSkge1xuICAgICAgICBpZiAocG9zc2libGVJbnRlcnNlY3Rpb24ocHJldi5kYXRhKCksIGV2ZW50LCBldmVudFF1ZXVlKSA9PT0gMikge1xuICAgICAgICAgIHZhciBwcmV2cHJldiA9IHN3ZWVwTGluZS5maW5kSXRlcihwcmV2LmRhdGEoKSk7XG4gICAgICAgICAgaWYgKHByZXZwcmV2LmRhdGEoKSAhPT0gc3dlZXBMaW5lLm1pbigpKSB7XG4gICAgICAgICAgICBwcmV2cHJldi5wcmV2KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZwcmV2ID0gc3dlZXBMaW5lLmZpbmRJdGVyKHN3ZWVwTGluZS5tYXgoKSk7XG4gICAgICAgICAgICBwcmV2cHJldi5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB1dGVGaWVsZHMocHJldi5kYXRhKCksIHByZXZwcmV2LmRhdGEoKSwgc3dlZXBMaW5lLCBvcGVyYXRpb24pO1xuICAgICAgICAgIGNvbXB1dGVGaWVsZHMoZXZlbnQsIHByZXYuZGF0YSgpLCBzd2VlcExpbmUsIG9wZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQgPSBldmVudC5vdGhlckV2ZW50O1xuICAgICAgbmV4dCA9IHN3ZWVwTGluZS5maW5kSXRlcihldmVudCk7XG4gICAgICBwcmV2ID0gc3dlZXBMaW5lLmZpbmRJdGVyKGV2ZW50KTtcblxuICAgICAgLy8gX3JlbmRlclN3ZWVwTGluZShzd2VlcExpbmUsIGV2ZW50Lm90aGVyRXZlbnQucG9pbnQsIGV2ZW50KTtcblxuICAgICAgaWYgKCEocHJldiAmJiBuZXh0KSkgY29udGludWU7XG5cbiAgICAgIGlmIChwcmV2LmRhdGEoKSAhPT0gc3dlZXBMaW5lLm1pbigpKSB7XG4gICAgICAgIHByZXYucHJldigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldiA9IHN3ZWVwTGluZS5maW5kSXRlcihzd2VlcExpbmUubWF4KCkpO1xuICAgICAgICBwcmV2Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIG5leHQubmV4dCgpO1xuICAgICAgc3dlZXBMaW5lLnJlbW92ZShldmVudCk7XG5cbiAgICAgIC8vX3JlbmRlclN3ZWVwTGluZShzd2VlcExpbmUsIGV2ZW50Lm90aGVyRXZlbnQucG9pbnQsIGV2ZW50KTtcblxuICAgICAgaWYgKG5leHQuZGF0YSgpICYmIHByZXYuZGF0YSgpKSB7XG4gICAgICAgIHBvc3NpYmxlSW50ZXJzZWN0aW9uKHByZXYuZGF0YSgpLCBuZXh0LmRhdGEoKSwgZXZlbnRRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzb3J0ZWRFdmVudHM7XG59XG5cblxuZnVuY3Rpb24gc3dhcCAoYXJyLCBpLCBuKSB7XG4gIHZhciB0ZW1wID0gYXJyW2ldO1xuICBhcnJbaV0gPSBhcnJbbl07XG4gIGFycltuXSA9IHRlbXA7XG59XG5cblxuZnVuY3Rpb24gY2hhbmdlT3JpZW50YXRpb24oY29udG91cikge1xuICByZXR1cm4gY29udG91ci5yZXZlcnNlKCk7XG59XG5cblxuZnVuY3Rpb24gaXNBcnJheSAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuXG5mdW5jdGlvbiBhZGRIb2xlKGNvbnRvdXIsIGlkeCkge1xuICBpZiAoIWlzQXJyYXkoY29udG91clswXVswXSkpIHtcbiAgICBjb250b3VyID0gW2NvbnRvdXJdO1xuICB9XG4gIGNvbnRvdXJbaWR4XSA9IFtdO1xuICByZXR1cm4gY29udG91cjtcbn1cblxuXG5mdW5jdGlvbiBjb25uZWN0RWRnZXMoc29ydGVkRXZlbnRzKSB7XG4gIC8vIGNvcHkgdGhlIGV2ZW50cyBpbiB0aGUgcmVzdWx0IHBvbHlnb24gdG8gcmVzdWx0RXZlbnRzIGFycmF5XG4gIHZhciByZXN1bHRFdmVudHMgPSBbXTtcbiAgdmFyIGV2ZW50LCBpLCBsZW47XG5cbiAgZm9yIChpID0gMCwgbGVuID0gc29ydGVkRXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZXZlbnQgPSBzb3J0ZWRFdmVudHNbaV07XG4gICAgaWYgKChldmVudC5sZWZ0ICYmIGV2ZW50LmluUmVzdWx0KSB8fFxuICAgICAgKCFldmVudC5sZWZ0ICYmIGV2ZW50Lm90aGVyRXZlbnQub3RoZXJFdmVudC5pblJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgIHJlc3VsdEV2ZW50cy5wdXNoKGV2ZW50Lm90aGVyRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIER1ZSB0byBvdmVybGFwcGluZyBlZGdlcyB0aGUgcmVzdWx0RXZlbnRzIGFycmF5IGNhbiBiZSBub3Qgd2hvbGx5IHNvcnRlZFxuICB2YXIgc29ydGVkID0gZmFsc2U7XG4gIHdoaWxlICghc29ydGVkKSB7XG4gICAgc29ydGVkID0gdHJ1ZTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZXN1bHRFdmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICgoaSArIDEpIDwgbGVuICYmXG4gICAgICAgIGNvbXBhcmVFdmVudHMocmVzdWx0RXZlbnRzW2ldLCByZXN1bHRFdmVudHNbaSArIDFdKSA9PT0gMSkge1xuICAgICAgICBzd2FwKHJlc3VsdEV2ZW50cywgaSwgaSArIDEpO1xuICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwLCBsZW4gPSByZXN1bHRFdmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHRFdmVudHNbaV0ucG9zID0gaTtcbiAgICBpZiAoIXJlc3VsdEV2ZW50c1tpXS5sZWZ0KSB7XG4gICAgICB2YXIgdGVtcCA9IHJlc3VsdEV2ZW50c1tpXS5wb3M7XG4gICAgICByZXN1bHRFdmVudHNbaV0ucG9zID0gcmVzdWx0RXZlbnRzW2ldLm90aGVyRXZlbnQucG9zO1xuICAgICAgcmVzdWx0RXZlbnRzW2ldLm90aGVyRXZlbnQucG9zID0gdGVtcDtcbiAgICB9XG4gIH1cblxuICAvLyBcImZhbHNlXCItZmlsbGVkIGFycmF5XG4gIHZhciBwcm9jZXNzZWQgPSBBcnJheShyZXN1bHRFdmVudHMubGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHZhciBkZXB0aCAgPSBbXTtcbiAgdmFyIGhvbGVPZiA9IFtdO1xuICB2YXIgaXNIb2xlID0ge307XG5cbiAgZm9yIChpID0gMCwgbGVuID0gcmVzdWx0RXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHByb2Nlc3NlZFtpXSkgY29udGludWU7XG5cbiAgICB2YXIgY29udG91ciA9IFtdO1xuICAgIHJlc3VsdC5wdXNoKGNvbnRvdXIpO1xuXG4gICAgdmFyIGNvbnRvdXJJZCA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgIGRlcHRoLnB1c2goMCk7XG4gICAgaG9sZU9mLnB1c2goLTEpO1xuXG5cbiAgICBpZiAocmVzdWx0RXZlbnRzW2ldLnByZXZJblJlc3VsdCkge1xuICAgICAgdmFyIGxvd2VyQ29udG91cklkID0gcmVzdWx0RXZlbnRzW2ldLnByZXZJblJlc3VsdC5jb250b3VySWQ7XG4gICAgICBpZiAoIXJlc3VsdEV2ZW50c1tpXS5wcmV2SW5SZXN1bHQucmVzdWx0SW5PdXQpIHtcbiAgICAgICAgYWRkSG9sZShyZXN1bHRbbG93ZXJDb250b3VySWRdLCBjb250b3VySWQpO1xuICAgICAgICBob2xlT2ZbY29udG91cklkXSA9IGxvd2VyQ29udG91cklkO1xuICAgICAgICBkZXB0aFtjb250b3VySWRdICA9IGRlcHRoW2xvd2VyQ29udG91cklkXSArIDE7XG4gICAgICAgIGlzSG9sZVtjb250b3VySWRdID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNIb2xlW2xvd2VyQ29udG91cklkXSkge1xuICAgICAgICBhZGRIb2xlKHJlc3VsdFtob2xlT2ZbbG93ZXJDb250b3VySWRdXSwgY29udG91cklkKTtcbiAgICAgICAgaG9sZU9mW2NvbnRvdXJJZF0gPSBob2xlT2ZbbG93ZXJDb250b3VySWRdO1xuICAgICAgICBkZXB0aFtjb250b3VySWRdICA9IGRlcHRoW2xvd2VyQ29udG91cklkXTtcbiAgICAgICAgaXNIb2xlW2NvbnRvdXJJZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwb3MgPSBpO1xuICAgIHZhciBpbml0aWFsID0gcmVzdWx0RXZlbnRzW2ldLnBvaW50O1xuICAgIGNvbnRvdXIucHVzaChpbml0aWFsKTtcblxuICAgIHRyeSB7XG4gICAgd2hpbGUgKCFlcXVhbHMocmVzdWx0RXZlbnRzW3Bvc10ub3RoZXJFdmVudC5wb2ludCwgaW5pdGlhbCkpIHtcbiAgICAgIHByb2Nlc3NlZFtwb3NdID0gdHJ1ZTtcblxuICAgICAgaWYgKHJlc3VsdEV2ZW50c1twb3NdLmxlZnQpIHtcbiAgICAgICAgcmVzdWx0RXZlbnRzW3Bvc10ucmVzdWx0SW5PdXQgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0RXZlbnRzW3Bvc10uY29udG91cklkICAgPSBjb250b3VySWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRFdmVudHNbcG9zXS5vdGhlckV2ZW50LnJlc3VsdEluT3V0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0RXZlbnRzW3Bvc10ub3RoZXJFdmVudC5jb250b3VySWQgICA9IGNvbnRvdXJJZDtcbiAgICAgIH1cblxuICAgICAgcG9zID0gcmVzdWx0RXZlbnRzW3Bvc10ucG9zO1xuICAgICAgcHJvY2Vzc2VkW3Bvc10gPSB0cnVlO1xuXG4gICAgICBjb250b3VyLnB1c2gocmVzdWx0RXZlbnRzW3Bvc10ucG9pbnQpO1xuICAgICAgcG9zID0gbmV4dFBvcyhwb3MsIHJlc3VsdEV2ZW50cywgcHJvY2Vzc2VkKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzZWRbcG9zXSA9IHByb2Nlc3NlZFtyZXN1bHRFdmVudHNbcG9zXS5wb3NdID0gdHJ1ZTtcbiAgICByZXN1bHRFdmVudHNbcG9zXS5vdGhlckV2ZW50LnJlc3VsdEluT3V0ID0gdHJ1ZTtcbiAgICByZXN1bHRFdmVudHNbcG9zXS5vdGhlckV2ZW50LmNvbnRvdXJJZCAgID0gY29udG91cklkO1xuXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2cocG9zIHx8IDAsIHJlc3VsdEV2ZW50cywgcmVzdWx0RXZlbnRzLmxlbmd0aCwgZSk7XG4gICAgfVxuXG4gICAgLy8gZGVwdGggaXMgZXZlblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBpZiAoZGVwdGhbY29udG91cklkXSAmIDEpIHtcbiAgICAgIGNoYW5nZU9yaWVudGF0aW9uKGNvbnRvdXIpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc1xuICogQHBhcmFtICB7QXJyYXkuPFN3ZWVwRXZlbnQ+fSByZXN1bHRFdmVudHNcbiAqIEBwYXJhbSAge0FycmF5LjxCb29sZWFuPn0gICAgcHJvY2Vzc2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG5leHRQb3MocG9zLCByZXN1bHRFdmVudHMsIHByb2Nlc3NlZCkge1xuICB2YXIgbmV3UG9zID0gcG9zICsgMTtcbiAgd2hpbGUgKG5ld1BvcyA8IHJlc3VsdEV2ZW50cy5sZW5ndGhcbiAgICAmJiBlcXVhbHMocmVzdWx0RXZlbnRzW25ld1Bvc10ucG9pbnQsIHJlc3VsdEV2ZW50c1twb3NdLnBvaW50KSkge1xuICAgIGlmICghcHJvY2Vzc2VkW25ld1Bvc10pIHtcbiAgICAgIHJldHVybiBuZXdQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BvcyA9IG5ld1BvcyArIDE7XG4gICAgfVxuICB9XG5cbiAgbmV3UG9zID0gcG9zIC0gMTtcblxuICB3aGlsZSAocHJvY2Vzc2VkW25ld1Bvc10pIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgLSAxO1xuICB9XG4gIHJldHVybiBuZXdQb3M7XG59XG5cblxuZnVuY3Rpb24gdHJpdmlhbE9wZXJhdGlvbihzdWJqZWN0LCBjbGlwcGluZywgb3BlcmF0aW9uKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICBpZiAoc3ViamVjdC5sZW5ndGggKiBjbGlwcGluZy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAob3BlcmF0aW9uID09PSBJTlRFUlNFQ1RJT04pIHtcbiAgICAgIHJlc3VsdCA9IEVNUFRZO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSBESUZGRVJFTkNFKSB7XG4gICAgICByZXN1bHQgPSBzdWJqZWN0O1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSBVTklPTiB8fCBvcGVyYXRpb24gPT09IFhPUikge1xuICAgICAgcmVzdWx0ID0gKHN1YmplY3QubGVuZ3RoID09PSAwKSA/IGNsaXBwaW5nIDogc3ViamVjdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBjb21wYXJlQkJveGVzKHN1YmplY3QsIGNsaXBwaW5nLCBzYmJveCwgY2Jib3gsIG9wZXJhdGlvbikge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgaWYgKHNiYm94WzBdID4gY2Jib3hbMl0gfHxcbiAgICAgIGNiYm94WzBdID4gc2Jib3hbMl0gfHxcbiAgICAgIHNiYm94WzFdID4gY2Jib3hbM10gfHxcbiAgICAgIGNiYm94WzFdID4gc2Jib3hbM10pIHtcbiAgICBpZiAob3BlcmF0aW9uID09PSBJTlRFUlNFQ1RJT04pIHtcbiAgICAgIHJlc3VsdCA9IEVNUFRZO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSBESUZGRVJFTkNFKSB7XG4gICAgICByZXN1bHQgPSBzdWJqZWN0O1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSBVTklPTiB8fCBvcGVyYXRpb24gPT09IFhPUikge1xuICAgICAgcmVzdWx0ID0gc3ViamVjdC5jb25jYXQoY2xpcHBpbmcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGJvb2xlYW4oc3ViamVjdCwgY2xpcHBpbmcsIG9wZXJhdGlvbikge1xuICB2YXIgdHJpdmlhbCA9IHRyaXZpYWxPcGVyYXRpb24oc3ViamVjdCwgY2xpcHBpbmcsIG9wZXJhdGlvbik7XG4gIGlmICh0cml2aWFsKSB7XG4gICAgcmV0dXJuIHRyaXZpYWwgPT09IEVNUFRZID8gbnVsbCA6IHRyaXZpYWw7XG4gIH1cbiAgdmFyIHNiYm94ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICB2YXIgY2Jib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgdmFyIGV2ZW50UXVldWUgPSBmaWxsUXVldWUoc3ViamVjdCwgY2xpcHBpbmcsIHNiYm94LCBjYmJveCk7XG5cbiAgdHJpdmlhbCA9IGNvbXBhcmVCQm94ZXMoc3ViamVjdCwgY2xpcHBpbmcsIHNiYm94LCBjYmJveCwgb3BlcmF0aW9uKTtcbiAgaWYgKHRyaXZpYWwpIHtcbiAgICByZXR1cm4gdHJpdmlhbCA9PT0gRU1QVFkgPyBudWxsIDogdHJpdmlhbDtcbiAgfVxuICB2YXIgc29ydGVkRXZlbnRzID0gc3ViZGl2aWRlU2VnbWVudHMoZXZlbnRRdWV1ZSwgc3ViamVjdCwgY2xpcHBpbmcsIHNiYm94LCBjYmJveCwgb3BlcmF0aW9uKTtcbiAgcmV0dXJuIGNvbm5lY3RFZGdlcyhzb3J0ZWRFdmVudHMpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYm9vbGVhbjtcblxuXG5tb2R1bGUuZXhwb3J0cy51bmlvbiA9IGZ1bmN0aW9uKHN1YmplY3QsIGNsaXBwaW5nKSB7XG4gIHJldHVybiBib29sZWFuKHN1YmplY3QsIGNsaXBwaW5nLCBVTklPTik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLmRpZmYgPSBmdW5jdGlvbihzdWJqZWN0LCBjbGlwcGluZykge1xuICByZXR1cm4gYm9vbGVhbihzdWJqZWN0LCBjbGlwcGluZywgRElGRkVSRU5DRSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLnhvciA9IGZ1bmN0aW9uKHN1YmplY3QsIGNsaXBwaW5nKSB7XG4gIHJldHVybiBib29sZWFuKHN1YmplY3QsIGNsaXBwaW5nLCBYT1IpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihzdWJqZWN0LCBjbGlwcGluZykge1xuICByZXR1cm4gYm9vbGVhbihzdWJqZWN0LCBjbGlwcGluZywgSU5URVJTRUNUSU9OKTtcbn07XG5cblxuLyoqXG4gKiBAZW51bSB7TnVtYmVyfVxuICovXG5tb2R1bGUuZXhwb3J0cy5vcGVyYXRpb25zID0ge1xuICBJTlRFUlNFQ1RJT046IElOVEVSU0VDVElPTixcbiAgRElGRkVSRU5DRTogICBESUZGRVJFTkNFLFxuICBVTklPTjogICAgICAgIFVOSU9OLFxuICBYT1I6ICAgICAgICAgIFhPUlxufTtcblxuXG4vLyBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMuZmlsbFF1ZXVlICAgICAgICAgICAgPSBmaWxsUXVldWU7XG5tb2R1bGUuZXhwb3J0cy5jb21wdXRlRmllbGRzICAgICAgICA9IGNvbXB1dGVGaWVsZHM7XG5tb2R1bGUuZXhwb3J0cy5zdWJkaXZpZGVTZWdtZW50cyAgICA9IHN1YmRpdmlkZVNlZ21lbnRzO1xubW9kdWxlLmV4cG9ydHMuZGl2aWRlU2VnbWVudCAgICAgICAgPSBkaXZpZGVTZWdtZW50O1xubW9kdWxlLmV4cG9ydHMucG9zc2libGVJbnRlcnNlY3Rpb24gPSBwb3NzaWJsZUludGVyc2VjdGlvbjtcbiIsInZhciBFUFNJTE9OID0gMWUtOTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgbWFnbml0dWRlIG9mIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzIChpZiB3ZSBwcmV0ZW5kXG4gKiB0aGV5J3JlIGluIHRocmVlIGRpbWVuc2lvbnMpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgRmlyc3QgdmVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gYiBTZWNvbmQgdmVjdG9yXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge051bWJlcn0gVGhlIG1hZ25pdHVkZSBvZiB0aGUgY3Jvc3MgcHJvZHVjdFxuICovXG5mdW5jdGlvbiBrcm9zc1Byb2R1Y3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgRmlyc3QgdmVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gYiBTZWNvbmQgdmVjdG9yXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge051bWJlcn0gVGhlIGRvdCBwcm9kdWN0XG4gKi9cbmZ1bmN0aW9uIGRvdFByb2R1Y3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgaW50ZXJzZWN0aW9uIChpZiBhbnkpIGJldHdlZW4gdHdvIGxpbmUgc2VnbWVudHMgYSBhbmQgYiwgZ2l2ZW4gdGhlXG4gKiBsaW5lIHNlZ21lbnRzJyBlbmQgcG9pbnRzIGExLCBhMiBhbmQgYjEsIGIyLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIFNjaG5laWRlciBhbmQgRWJlcmx5LlxuICogaHR0cDovL3d3dy5jaW1lYy5vcmcuYXIvfm5jYWx2by9TY2huZWlkZXJfRWJlcmx5LnBkZlxuICogUGFnZSAyNDQuXG4gKlxuICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gYTEgcG9pbnQgb2YgZmlyc3QgbGluZVxuICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gYTIgcG9pbnQgb2YgZmlyc3QgbGluZVxuICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gYjEgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj59IGIyIHBvaW50IG9mIHNlY29uZCBsaW5lXG4gKiBAcGFyYW0ge0Jvb2xlYW49fSAgICAgICBub0VuZHBvaW50VG91Y2ggd2hldGhlciB0byBza2lwIHNpbmdsZSB0b3VjaHBvaW50c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZWFuaW5nIGNvbm5lY3RlZCBzZWdtZW50cykgYXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxOdW1iZXI+PnxOdWxsfSBJZiB0aGUgbGluZXMgaW50ZXJzZWN0LCB0aGUgcG9pbnQgb2ZcbiAqIGludGVyc2VjdGlvbi4gSWYgdGhleSBvdmVybGFwLCB0aGUgdHdvIGVuZCBwb2ludHMgb2YgdGhlIG92ZXJsYXBwaW5nIHNlZ21lbnQuXG4gKiBPdGhlcndpc2UsIG51bGwuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYTEsIGEyLCBiMSwgYjIsIG5vRW5kcG9pbnRUb3VjaCkge1xuICAvLyBUaGUgYWxnb3JpdGhtIGV4cGVjdHMgb3VyIGxpbmVzIGluIHRoZSBmb3JtIFAgKyBzZCwgd2hlcmUgUCBpcyBhIHBvaW50LFxuICAvLyBzIGlzIG9uIHRoZSBpbnRlcnZhbCBbMCwgMV0sIGFuZCBkIGlzIGEgdmVjdG9yLlxuICAvLyBXZSBhcmUgcGFzc2VkIHR3byBwb2ludHMuIFAgY2FuIGJlIHRoZSBmaXJzdCBwb2ludCBvZiBlYWNoIHBhaXIuIFRoZVxuICAvLyB2ZWN0b3IsIHRoZW4sIGNvdWxkIGJlIHRob3VnaHQgb2YgYXMgdGhlIGRpc3RhbmNlIChpbiB4IGFuZCB5IGNvbXBvbmVudHMpXG4gIC8vIGZyb20gdGhlIGZpcnN0IHBvaW50IHRvIHRoZSBzZWNvbmQgcG9pbnQuXG4gIC8vIFNvIGZpcnN0LCBsZXQncyBtYWtlIG91ciB2ZWN0b3JzOlxuICB2YXIgdmEgPSBbYTJbMF0gLSBhMVswXSwgYTJbMV0gLSBhMVsxXV07XG4gIHZhciB2YiA9IFtiMlswXSAtIGIxWzBdLCBiMlsxXSAtIGIxWzFdXTtcbiAgLy8gV2UgYWxzbyBkZWZpbmUgYSBmdW5jdGlvbiB0byBjb252ZXJ0IGJhY2sgdG8gcmVndWxhciBwb2ludCBmb3JtOlxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGFycm93LWJvZHktc3R5bGUgKi9cblxuICBmdW5jdGlvbiB0b1BvaW50KHAsIHMsIGQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgcFswXSArIHMgKiBkWzBdLFxuICAgICAgcFsxXSArIHMgKiBkWzFdXG4gICAgXTtcbiAgfVxuXG4gIC8qIGVzbGludC1lbmFibGUgYXJyb3ctYm9keS1zdHlsZSAqL1xuXG4gIC8vIFRoZSByZXN0IGlzIHByZXR0eSBtdWNoIGEgc3RyYWlnaHQgcG9ydCBvZiB0aGUgYWxnb3JpdGhtLlxuICB2YXIgZSA9IFtiMVswXSAtIGExWzBdLCBiMVsxXSAtIGExWzFdXTtcbiAgdmFyIGtyb3NzID0ga3Jvc3NQcm9kdWN0KHZhLCB2Yik7XG4gIHZhciBzcXJLcm9zcyA9IGtyb3NzICoga3Jvc3M7XG4gIHZhciBzcXJMZW5BID0gZG90UHJvZHVjdCh2YSwgdmEpO1xuICB2YXIgc3FyTGVuQiA9IGRvdFByb2R1Y3QodmIsIHZiKTtcblxuICAvLyBDaGVjayBmb3IgbGluZSBpbnRlcnNlY3Rpb24uIFRoaXMgd29ya3MgYmVjYXVzZSBvZiB0aGUgcHJvcGVydGllcyBvZiB0aGVcbiAgLy8gY3Jvc3MgcHJvZHVjdCAtLSBzcGVjaWZpY2FsbHksIHR3byB2ZWN0b3JzIGFyZSBwYXJhbGxlbCBpZiBhbmQgb25seSBpZiB0aGVcbiAgLy8gY3Jvc3MgcHJvZHVjdCBpcyB0aGUgMCB2ZWN0b3IuIFRoZSBmdWxsIGNhbGN1bGF0aW9uIGludm9sdmVzIHJlbGF0aXZlIGVycm9yXG4gIC8vIHRvIGFjY291bnQgZm9yIHBvc3NpYmxlIHZlcnkgc21hbGwgbGluZSBzZWdtZW50cy4gU2VlIFNjaG5laWRlciAmIEViZXJseVxuICAvLyBmb3IgZGV0YWlscy5cbiAgaWYgKHNxcktyb3NzID4gRVBTSUxPTiAqIHNxckxlbkEgKiBzcXJMZW5CKSB7XG4gICAgLy8gSWYgdGhleSdyZSBub3QgcGFyYWxsZWwsIHRoZW4gKGJlY2F1c2UgdGhlc2UgYXJlIGxpbmUgc2VnbWVudHMpIHRoZXlcbiAgICAvLyBzdGlsbCBtaWdodCBub3QgYWN0dWFsbHkgaW50ZXJzZWN0LiBUaGlzIGNvZGUgY2hlY2tzIHRoYXQgdGhlXG4gICAgLy8gaW50ZXJzZWN0aW9uIHBvaW50IG9mIHRoZSBsaW5lcyBpcyBhY3R1YWxseSBvbiBib3RoIGxpbmUgc2VnbWVudHMuXG4gICAgdmFyIHMgPSBrcm9zc1Byb2R1Y3QoZSwgdmIpIC8ga3Jvc3M7XG4gICAgaWYgKHMgPCAwIHx8IHMgPiAxKSB7XG4gICAgICAvLyBub3Qgb24gbGluZSBzZWdtZW50IGFcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdCA9IGtyb3NzUHJvZHVjdChlLCB2YSkgLyBrcm9zcztcbiAgICBpZiAodCA8IDAgfHwgdCA+IDEpIHtcbiAgICAgIC8vIG5vdCBvbiBsaW5lIHNlZ21lbnQgYlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBub0VuZHBvaW50VG91Y2ggPyBudWxsIDogW3RvUG9pbnQoYTEsIHMsIHZhKV07XG4gIH1cblxuICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoaXMgcG9pbnQsIHRoZW4gdGhlIGxpbmVzIGFyZSBlaXRoZXIgcGFyYWxsZWwgb3IgdGhlXG4gIC8vIHNhbWUsIGJ1dCB0aGUgc2VnbWVudHMgY291bGQgb3ZlcmxhcCBwYXJ0aWFsbHkgb3IgZnVsbHksIG9yIG5vdCBhdCBhbGwuXG4gIC8vIFNvIHdlIG5lZWQgdG8gZmluZCB0aGUgb3ZlcmxhcCwgaWYgYW55LiBUbyBkbyB0aGF0LCB3ZSBjYW4gdXNlIGUsIHdoaWNoIGlzXG4gIC8vIHRoZSAodmVjdG9yKSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHR3byBpbml0aWFsIHBvaW50cy4gSWYgdGhpcyBpcyBwYXJhbGxlbFxuICAvLyB3aXRoIHRoZSBsaW5lIGl0c2VsZiwgdGhlbiB0aGUgdHdvIGxpbmVzIGFyZSB0aGUgc2FtZSBsaW5lLCBhbmQgdGhlcmUgd2lsbFxuICAvLyBiZSBvdmVybGFwLlxuICB2YXIgc3FyTGVuRSA9IGRvdFByb2R1Y3QoZSwgZSk7XG4gIGtyb3NzID0ga3Jvc3NQcm9kdWN0KGUsIHZhKTtcbiAgc3FyS3Jvc3MgPSBrcm9zcyAqIGtyb3NzO1xuXG4gIGlmIChzcXJLcm9zcyA+IEVQU0lMT04gKiBzcXJMZW5BICogc3FyTGVuRSkge1xuICAgIC8vIExpbmVzIGFyZSBqdXN0IHBhcmFsbGVsLCBub3QgdGhlIHNhbWUuIE5vIG92ZXJsYXAuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2EgPSBkb3RQcm9kdWN0KHZhLCBlKSAvIHNxckxlbkE7XG4gIHZhciBzYiA9IHNhICsgZG90UHJvZHVjdCh2YSwgdmIpIC8gc3FyTGVuQTtcbiAgdmFyIHNtaW4gPSBNYXRoLm1pbihzYSwgc2IpO1xuICB2YXIgc21heCA9IE1hdGgubWF4KHNhLCBzYik7XG5cbiAgLy8gdGhpcyBpcywgZXNzZW50aWFsbHksIHRoZSBGaW5kSW50ZXJzZWN0aW9uIGFjdGluZyBvbiBmbG9hdHMgZnJvbVxuICAvLyBTY2huZWlkZXIgJiBFYmVybHksIGp1c3QgaW5saW5lZCBpbnRvIHRoaXMgZnVuY3Rpb24uXG4gIGlmIChzbWluIDw9IDEgJiYgc21heCA+PSAwKSB7XG5cbiAgICAvLyBvdmVybGFwIG9uIGFuIGVuZCBwb2ludFxuICAgIGlmIChzbWluID09PSAxKSB7XG4gICAgICByZXR1cm4gbm9FbmRwb2ludFRvdWNoID8gbnVsbCA6IFt0b1BvaW50KGExLCBzbWluID4gMCA/IHNtaW4gOiAwLCB2YSldO1xuICAgIH1cblxuICAgIGlmIChzbWF4ID09PSAwKSB7XG4gICAgICByZXR1cm4gbm9FbmRwb2ludFRvdWNoID8gbnVsbCA6IFt0b1BvaW50KGExLCBzbWF4IDwgMSA/IHNtYXggOiAxLCB2YSldO1xuICAgIH1cblxuICAgIGlmIChub0VuZHBvaW50VG91Y2ggJiYgc21pbiA9PT0gMCAmJiBzbWF4ID09PSAxKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIFRoZXJlJ3Mgb3ZlcmxhcCBvbiBhIHNlZ21lbnQgLS0gdHdvIHBvaW50cyBvZiBpbnRlcnNlY3Rpb24uIFJldHVybiBib3RoLlxuICAgIHJldHVybiBbXG4gICAgICB0b1BvaW50KGExLCBzbWluID4gMCA/IHNtaW4gOiAwLCB2YSksXG4gICAgICB0b1BvaW50KGExLCBzbWF4IDwgMSA/IHNtYXggOiAxLCB2YSksXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbiIsIi8qKlxuICogU2lnbmVkIGFyZWEgb2YgdGhlIHRyaWFuZ2xlIChwMCwgcDEsIHAyKVxuICogQHBhcmFtICB7QXJyYXkuPE51bWJlcj59IHAwXG4gKiBAcGFyYW0gIHtBcnJheS48TnVtYmVyPn0gcDFcbiAqIEBwYXJhbSAge0FycmF5LjxOdW1iZXI+fSBwMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNpZ25lZEFyZWEocDAsIHAxLCBwMikge1xuICByZXR1cm4gKHAwWzBdIC0gcDJbMF0pICogKHAxWzFdIC0gcDJbMV0pIC0gKHAxWzBdIC0gcDJbMF0pICogKHAwWzFdIC0gcDJbMV0pO1xufTtcbiIsInZhciBzaWduZWRBcmVhID0gcmVxdWlyZSgnLi9zaWduZWRfYXJlYScpO1xudmFyIEVkZ2VUeXBlICAgPSByZXF1aXJlKCcuL2VkZ2VfdHlwZScpO1xuXG5cbi8qKlxuICogU3dlZXBsaW5lIGV2ZW50XG4gKlxuICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gIHBvaW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgbGVmdFxuICogQHBhcmFtIHtTd2VlcEV2ZW50PX0gICAgIG90aGVyRXZlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICBpc1N1YmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBlZGdlVHlwZVxuICovXG5mdW5jdGlvbiBTd2VlcEV2ZW50KHBvaW50LCBsZWZ0LCBvdGhlckV2ZW50LCBpc1N1YmplY3QsIGVkZ2VUeXBlKSB7XG5cbiAgLyoqXG4gICAqIElzIGxlZnQgZW5kcG9pbnQ/XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5sZWZ0ID0gbGVmdDtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxOdW1iZXI+fVxuICAgKi9cbiAgdGhpcy5wb2ludCA9IHBvaW50O1xuXG4gIC8qKlxuICAgKiBPdGhlciBlZGdlIHJlZmVyZW5jZVxuICAgKiBAdHlwZSB7U3dlZXBFdmVudH1cbiAgICovXG4gIHRoaXMub3RoZXJFdmVudCA9IG90aGVyRXZlbnQ7XG5cbiAgLyoqXG4gICAqIEJlbG9uZ3MgdG8gc291cmNlIG9yIGNsaXBwaW5nIHBvbHlnb25cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzU3ViamVjdCA9IGlzU3ViamVjdDtcblxuICAvKipcbiAgICogRWRnZSBjb250cmlidXRpb24gdHlwZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdGhpcy50eXBlID0gZWRnZVR5cGUgfHwgRWRnZVR5cGUuTk9STUFMO1xuXG5cbiAgLyoqXG4gICAqIEluLW91dCB0cmFuc2l0aW9uIGZvciB0aGUgc3dlZXBsaW5lIGNyb3NzaW5nIHBvbHlnb25cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmluT3V0ID0gZmFsc2U7XG5cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLm90aGVySW5PdXQgPSBmYWxzZTtcblxuICAvKipcbiAgICogUHJldmlvdXMgZXZlbnQgaW4gcmVzdWx0P1xuICAgKiBAdHlwZSB7U3dlZXBFdmVudH1cbiAgICovXG4gIHRoaXMucHJldkluUmVzdWx0ID0gbnVsbDtcblxuICAvKipcbiAgICogRG9lcyBldmVudCBiZWxvbmcgdG8gcmVzdWx0P1xuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaW5SZXN1bHQgPSBmYWxzZTtcblxuXG4gIC8vIGNvbm5lY3Rpb24gc3RlcFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMucmVzdWx0SW5PdXQgPSBmYWxzZTtcbn1cblxuXG5Td2VlcEV2ZW50LnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogQHBhcmFtICB7QXJyYXkuPE51bWJlcj59ICBwXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0JlbG93OiBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdCA/XG4gICAgICBzaWduZWRBcmVhICh0aGlzLnBvaW50LCB0aGlzLm90aGVyRXZlbnQucG9pbnQsIHApID4gMCA6XG4gICAgICBzaWduZWRBcmVhICh0aGlzLm90aGVyRXZlbnQucG9pbnQsIHRoaXMucG9pbnQsIHApID4gMDtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtBcnJheS48TnVtYmVyPn0gIHBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQWJvdmU6IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gIXRoaXMuaXNCZWxvdyhwKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNWZXJ0aWNhbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRbMF0gPT09IHRoaXMub3RoZXJFdmVudC5wb2ludFswXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTd2VlcEV2ZW50O1xuIl19
