(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
L.BooleanControl = L.Control.extend({
  options: {
    position: 'topright'
  },

  onAdd: function(map) {
    var container = this._container = L.DomUtil.create('div', 'leaflet-bar');
    this._container.style.background = '#ffffff';
    this._container.style.padding = '10px';
    container.innerHTML = [
      '<form>',
        '<ul style="list-style:none; padding-left: 0">',
          '<li>','<label>', '<input type="radio" name="op" value="0" checked />',  ' Intersection', '</label>', '</li>',
          '<li>','<label>', '<input type="radio" name="op" value="1" />',  ' Union', '</label>', '</li>',
          '<li>','<label>', '<input type="radio" name="op" value="2" />',  ' Difference', '</label>', '</li>',
          '<li>','<label>', '<input type="radio" name="op" value="3" />',  ' Xor', '</label>', '</li>',
        '</ul>',
        '<input type="submit" value="Run">', '<input name="clear" type="button" value="Clear layers">',
      '</form>'].join('');
    var form = container.querySelector('form');
    L.DomEvent
      .on(form, 'submit', function (evt) {
        L.DomEvent.stop(evt);
        var radios = Array.prototype.slice.call(
          form.querySelectorAll('input[type=radio]'));
        for (var i = 0, len = radios.length; i < len; i++) {
          if (radios[i].checked) {
            this.options.callback(parseInt(radios[i].value));
            break;
          }
        }
      }, this)
      .on(form['clear'], 'click', function(evt) {
        L.DomEvent.stop(evt);
        this.options.clear();
      }, this);

    L.DomEvent
      .disableClickPropagation(this._container)
      .disableScrollPropagation(this._container);
    return this._container;
  }

});
},{}],2:[function(require,module,exports){
L.Coordinates = L.Control.extend({
  options: {
    position: 'bottomright'
  },

  onAdd: function(map) {
    this._container = L.DomUtil.create('div', 'leaflet-bar');
    this._container.style.background = '#ffffff';
    map.on('mousemove', this._onMouseMove, this);
    return this._container;
  },

  _onMouseMove: function(e) {
    this._container.innerHTML = '<span style="padding: 5px">' +
      e.latlng.lng.toFixed(3) + ', ' + e.latlng.lat.toFixed(3) + '</span>';
  }

});
},{}],3:[function(require,module,exports){
var L = require('leaflet');
var LeafletEditable = require('leaflet-editable');
require('./coordinates');
require('./polygoncontrol');
require('./booleanopcontrol');
var martinez = require('../../');
//var martinez = require('../../dist/martinez.min');
var xhr = require('superagent');
// var turf = require('turf');
var jsts = window.jsts = require('jsts');

var mode = /geo/.test(window.location.hash) ? 'geo' : 'orthogonal';

console.log(mode);

var path = '../test/fixtures/';
var file = mode === 'geo' ? 'asia.json' : 'horseshoe.json';



var div = document.createElement('div');
div.id = 'image-map';
div.style.width = div.style.height = '100%';
document.body.appendChild(div);

// create the slippy map
var map = window.map = L.map('image-map', {
  minZoom: 1,
  maxZoom: 20,
  center: [0, 0],
  zoom: 1,
  crs: mode === 'geo' ? L.CRS.EPSG4326 : L.CRS.Simple,
  editable: true
});

map.addControl(new L.NewPolygonControl({
  callback: map.editTools.startPolygon
}));
map.addControl(new L.Coordinates());
map.addControl(new L.BooleanControl({
  callback: run,
  clear: clear
}));

var drawnItems = window.drawnItems = L.geoJson().addTo(map);

function loadData(path) {
  console.log(path);
  // var two_triangles = require('../../test/fixtures/two_shapes.json');
  // var oneInside = require('../../test/fixtures/one_inside.json');
  // var twoPointedTriangles = require('../../test/fixtures/two_pointed_triangles.json');
  // var selfIntersecting = require('../../test/fixtures/self_intersecting.json');
  // var holes = require('../../test/fixtures/hole_hole.json');
  //var data =  require('../../test/fixtures/indonesia.json');
  xhr
    .get(path)
    .set('Accept', 'application/json')
    .end(function(e, r) {
      if (!e) {
        drawnItems.addData(r.body);
        map.fitBounds(drawnItems.getBounds().pad(0.05), { animate: false });
      }
    });
}

function clear() {
  drawnItems.clearLayers();
  results.clearLayers();
}

var reader = new jsts.io.GeoJSONReader();
var writer = new jsts.io.GeoJSONWriter();


function run (op) {
  var layers = drawnItems.getLayers();
  if (layers.length < 2) return;
  var subject = layers[0].toGeoJSON();
  var clipping = layers[1].toGeoJSON();

  console.log('input', subject, clipping, op);

  subject = JSON.parse(JSON.stringify(subject));
  clipping = JSON.parse(JSON.stringify(clipping));


  console.time('martinez');
  var result = martinez(subject.geometry.coordinates, clipping.geometry.coordinates, op);
  console.timeEnd('martinez');

  console.time('jsts');
  var s = reader.read(subject);
  var c = reader.read(clipping);
  var res = writer.write(s.geometry.intersection(c.geometry));

  console.timeEnd('jsts');

  //console.log('result', result, res);

  results.clearLayers();
  results.addData({
    'type': 'Feature',
    'geometry': {
      'type': 'Polygon',
      'coordinates': result
    }
  });
}

//drawnItems.addData(oneInside);
//drawnItems.addData(twoPointedTriangles);
//drawnItems.addData(selfIntersecting);
//drawnItems.addData(holes);
//drawnItems.addData(data);

map.on('editable:created', function(evt) {
  drawnItems.addLayer(evt.layer);
  evt.layer.on('click', function(e) {
    if ((e.originalEvent.ctrlKey || e.originalEvent.metaKey) && this.editEnabled()) {
      this.editor.newHole(e.latlng);
    }
  });
});

var results = window.results = L.geoJson(null, {
  style: function(feature) {
    return {
      color: 'red',
      weight: 1
    };
  }
}).addTo(map);

loadData(path + file);

},{"../../":5,"./booleanopcontrol":1,"./coordinates":2,"./polygoncontrol":4,"jsts":11,"leaflet":13,"leaflet-editable":12,"superagent":14}],4:[function(require,module,exports){
L.EditControl = L.Control.extend({

  options: {
    position: 'topleft',
    callback: null,
    kind: '',
    html: ''
  },

  onAdd: function (map) {
    var container = L.DomUtil.create('div', 'leaflet-control leaflet-bar'),
        link = L.DomUtil.create('a', '', container);

    link.href = '#';
    link.title = 'Create a new ' + this.options.kind;
    link.innerHTML = this.options.html;
    L.DomEvent.on(link, 'click', L.DomEvent.stop)
              .on(link, 'click', function () {
                window.LAYER = this.options.callback.call(map.editTools);
              }, this);

    return container;
  }

});

L.NewPolygonControl = L.EditControl.extend({
  options: {
    position: 'topleft',
    kind: 'polygon',
    html: 'â–°'
  }
});
},{}],5:[function(require,module,exports){
module.exports = require('./src/index');

},{"./src/index":23}],6:[function(require,module,exports){
module.exports = {
    RBTree: require('./lib/rbtree'),
    BinTree: require('./lib/bintree')
};

},{"./lib/bintree":7,"./lib/rbtree":8}],7:[function(require,module,exports){

var TreeBase = require('./treebase');

function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}

Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};

Node.prototype.set_child = function(dir, val) {
    if(dir) {
        this.right = val;
    }
    else {
        this.left = val;
    }
};

function BinTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}

BinTree.prototype = new TreeBase();

// returns true if inserted, false if duplicate
BinTree.prototype.insert = function(data) {
    if(this._root === null) {
        // empty tree
        this._root = new Node(data);
        this.size++;
        return true;
    }

    var dir = 0;

    // setup
    var p = null; // parent
    var node = this._root;

    // search down
    while(true) {
        if(node === null) {
            // insert new node at the bottom
            node = new Node(data);
            p.set_child(dir, node);
            ret = true;
            this.size++;
            return true;
        }

        // stop if found
        if(this._comparator(node.data, data) === 0) {
            return false;
        }

        dir = this._comparator(node.data, data) < 0;

        // update helpers
        p = node;
        node = node.get_child(dir);
    }
};

// returns true if removed, false if not found
BinTree.prototype.remove = function(data) {
    if(this._root === null) {
        return false;
    }

    var head = new Node(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var found = null; // found item
    var dir = 1;

    while(node.get_child(dir) !== null) {
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;

        if(cmp === 0) {
            found = node;
        }
    }

    if(found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));

        this._root = head.right;
        this.size--;
        return true;
    }
    else {
        return false;
    }
};

module.exports = BinTree;


},{"./treebase":9}],8:[function(require,module,exports){

var TreeBase = require('./treebase');

function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
    this.red = true;
}

Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};

Node.prototype.set_child = function(dir, val) {
    if(dir) {
        this.right = val;
    }
    else {
        this.left = val;
    }
};

function RBTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}

RBTree.prototype = new TreeBase();

// returns true if inserted, false if duplicate
RBTree.prototype.insert = function(data) {
    var ret = false;

    if(this._root === null) {
        // empty tree
        this._root = new Node(data);
        ret = true;
        this.size++;
    }
    else {
        var head = new Node(undefined); // fake tree root

        var dir = 0;
        var last = 0;

        // setup
        var gp = null; // grandparent
        var ggp = head; // grand-grand-parent
        var p = null; // parent
        var node = this._root;
        ggp.right = this._root;

        // search down
        while(true) {
            if(node === null) {
                // insert new node at the bottom
                node = new Node(data);
                p.set_child(dir, node);
                ret = true;
                this.size++;
            }
            else if(is_red(node.left) && is_red(node.right)) {
                // color flip
                node.red = true;
                node.left.red = false;
                node.right.red = false;
            }

            // fix red violation
            if(is_red(node) && is_red(p)) {
                var dir2 = ggp.right === gp;

                if(node === p.get_child(last)) {
                    ggp.set_child(dir2, single_rotate(gp, !last));
                }
                else {
                    ggp.set_child(dir2, double_rotate(gp, !last));
                }
            }

            var cmp = this._comparator(node.data, data);

            // stop if found
            if(cmp === 0) {
                break;
            }

            last = dir;
            dir = cmp < 0;

            // update helpers
            if(gp !== null) {
                ggp = gp;
            }
            gp = p;
            p = node;
            node = node.get_child(dir);
        }

        // update root
        this._root = head.right;
    }

    // make root black
    this._root.red = false;

    return ret;
};

// returns true if removed, false if not found
RBTree.prototype.remove = function(data) {
    if(this._root === null) {
        return false;
    }

    var head = new Node(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var gp = null; // grand parent
    var found = null; // found item
    var dir = 1;

    while(node.get_child(dir) !== null) {
        var last = dir;

        // update helpers
        gp = p;
        p = node;
        node = node.get_child(dir);

        var cmp = this._comparator(data, node.data);

        dir = cmp > 0;

        // save found node
        if(cmp === 0) {
            found = node;
        }

        // push the red node down
        if(!is_red(node) && !is_red(node.get_child(dir))) {
            if(is_red(node.get_child(!dir))) {
                var sr = single_rotate(node, dir);
                p.set_child(last, sr);
                p = sr;
            }
            else if(!is_red(node.get_child(!dir))) {
                var sibling = p.get_child(!last);
                if(sibling !== null) {
                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
                        // color flip
                        p.red = false;
                        sibling.red = true;
                        node.red = true;
                    }
                    else {
                        var dir2 = gp.right === p;

                        if(is_red(sibling.get_child(last))) {
                            gp.set_child(dir2, double_rotate(p, last));
                        }
                        else if(is_red(sibling.get_child(!last))) {
                            gp.set_child(dir2, single_rotate(p, last));
                        }

                        // ensure correct coloring
                        var gpc = gp.get_child(dir2);
                        gpc.red = true;
                        node.red = true;
                        gpc.left.red = false;
                        gpc.right.red = false;
                    }
                }
            }
        }
    }

    // replace and remove if found
    if(found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this.size--;
    }

    // update root and make it black
    this._root = head.right;
    if(this._root !== null) {
        this._root.red = false;
    }

    return found !== null;
};

function is_red(node) {
    return node !== null && node.red;
}

function single_rotate(root, dir) {
    var save = root.get_child(!dir);

    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);

    root.red = true;
    save.red = false;

    return save;
}

function double_rotate(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
}

module.exports = RBTree;

},{"./treebase":9}],9:[function(require,module,exports){

function TreeBase() {}

// removes all nodes from the tree
TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
};

// returns node data if found, null otherwise
TreeBase.prototype.find = function(data) {
    var res = this._root;

    while(res !== null) {
        var c = this._comparator(data, res.data);
        if(c === 0) {
            return res.data;
        }
        else {
            res = res.get_child(c > 0);
        }
    }

    return null;
};

// returns iterator to node if found, null otherwise
TreeBase.prototype.findIter = function(data) {
    var res = this._root;
    var iter = this.iterator();

    while(res !== null) {
        var c = this._comparator(data, res.data);
        if(c === 0) {
            iter._cursor = res;
            return iter;
        }
        else {
            iter._ancestors.push(res);
            res = res.get_child(c > 0);
        }
    }

    return null;
};

// Returns an iterator to the tree node at or immediately after the item
TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;

    while(cur !== null) {
        var c = cmp(item, cur.data);
        if(c === 0) {
            iter._cursor = cur;
            return iter;
        }
        iter._ancestors.push(cur);
        cur = cur.get_child(c > 0);
    }

    for(var i=iter._ancestors.length - 1; i >= 0; --i) {
        cur = iter._ancestors[i];
        if(cmp(item, cur.data) < 0) {
            iter._cursor = cur;
            iter._ancestors.length = i;
            return iter;
        }
    }

    iter._ancestors.length = 0;
    return iter;
};

// Returns an iterator to the tree node immediately after the item
TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;

    while(iter.data() !== null && cmp(iter.data(), item) === 0) {
        iter.next();
    }

    return iter;
};

// returns null if tree is empty
TreeBase.prototype.min = function() {
    var res = this._root;
    if(res === null) {
        return null;
    }

    while(res.left !== null) {
        res = res.left;
    }

    return res.data;
};

// returns null if tree is empty
TreeBase.prototype.max = function() {
    var res = this._root;
    if(res === null) {
        return null;
    }

    while(res.right !== null) {
        res = res.right;
    }

    return res.data;
};

// returns a null iterator
// call next() or prev() to point to an element
TreeBase.prototype.iterator = function() {
    return new Iterator(this);
};

// calls cb on each node's data, in order
TreeBase.prototype.each = function(cb) {
    var it=this.iterator(), data;
    while((data = it.next()) !== null) {
        cb(data);
    }
};

// calls cb on each node's data, in reverse order
TreeBase.prototype.reach = function(cb) {
    var it=this.iterator(), data;
    while((data = it.prev()) !== null) {
        cb(data);
    }
};


function Iterator(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
}

Iterator.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
};

// if null-iterator, returns first node
// otherwise, returns next node
Iterator.prototype.next = function() {
    if(this._cursor === null) {
        var root = this._tree._root;
        if(root !== null) {
            this._minNode(root);
        }
    }
    else {
        if(this._cursor.right === null) {
            // no greater node in subtree, go up to parent
            // if coming from a right child, continue up the stack
            var save;
            do {
                save = this._cursor;
                if(this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                }
                else {
                    this._cursor = null;
                    break;
                }
            } while(this._cursor.right === save);
        }
        else {
            // get the next node from the subtree
            this._ancestors.push(this._cursor);
            this._minNode(this._cursor.right);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};

// if null-iterator, returns last node
// otherwise, returns previous node
Iterator.prototype.prev = function() {
    if(this._cursor === null) {
        var root = this._tree._root;
        if(root !== null) {
            this._maxNode(root);
        }
    }
    else {
        if(this._cursor.left === null) {
            var save;
            do {
                save = this._cursor;
                if(this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                }
                else {
                    this._cursor = null;
                    break;
                }
            } while(this._cursor.left === save);
        }
        else {
            this._ancestors.push(this._cursor);
            this._maxNode(this._cursor.left);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};

Iterator.prototype._minNode = function(start) {
    while(start.left !== null) {
        this._ancestors.push(start);
        start = start.left;
    }
    this._cursor = start;
};

Iterator.prototype._maxNode = function(start) {
    while(start.right !== null) {
        this._ancestors.push(start);
        start = start.right;
    }
    this._cursor = start;
};

module.exports = TreeBase;


},{}],10:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],11:[function(require,module,exports){
// JSTS. See https://github.com/bjornharrtell/jsts
// Licenses:
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.jsts=t.jsts||{})}(this,function(t){"use strict";function e(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}function n(){}function i(){}function r(){}function s(){}function o(){}function a(){}function u(){}function l(t){this.message=t}function h(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}function c(){if(0===arguments.length)l.call(this);else if(1===arguments.length){var t=arguments[0];l.call(this,t)}}function f(){}function g(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.call(this,0,0);else if(1===arguments.length){var t=arguments[0];g.call(this,t.x,t.y,t.z)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];g.call(this,e,n,g.NULL_ORDINATE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.x=i,this.y=r,this.z=s}}function d(){if(this.dimensionsToTest=2,0===arguments.length)d.call(this,2);else if(1===arguments.length){var t=arguments[0];if(2!==t&&3!==t)throw new i("only 2 or 3 dimensions may be specified");this.dimensionsToTest=t}}function p(){}function v(){}function m(t){this.message=t||""}function y(){}function x(t){this.message=t||""}function E(t){this.message=t||""}function I(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function N(){if(I.apply(this),0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.ensureCapacity(e.length),this.add(e,n)}}function C(){if(this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.init(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];this.init(r,s,o,a)}}function S(){}function w(){S.call(this,"Projective point not representable on the Cartesian plane.")}function L(){}function R(t,e){return t.interfaces_&&t.interfaces_().indexOf(e)>-1}function T(){}function P(t){this.str=t}function b(t){this.value=t}function O(){}function _(){if(this.hi=0,this.lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.init(t)}else if(arguments[0]instanceof _){var e=arguments[0];this.init(e)}else if("string"==typeof arguments[0]){var n=arguments[0];_.call(this,_.parse(n))}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.init(i,r)}}function M(){}function D(){}function A(){}function F(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var e=arguments[0],n=arguments[1];this.x=e,this.y=n,this.w=1}else if(arguments[0]instanceof F&&arguments[1]instanceof F){var i=arguments[0],r=arguments[1];this.x=i.y*r.w-r.y*i.w,this.y=r.x*i.w-i.x*r.w,this.w=i.x*r.y-r.x*i.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1];this.x=s.y-o.y,this.y=o.x-s.x,this.w=s.x*o.y-o.x*s.y}}else if(3===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2];this.x=a,this.y=u,this.w=l}else if(4===arguments.length){var h=arguments[0],c=arguments[1],f=arguments[2],d=arguments[3],p=h.y-c.y,v=c.x-h.x,m=h.x*c.y-c.x*h.y,y=f.y-d.y,x=d.x-f.x,E=f.x*d.y-d.x*f.y;this.x=v*E-x*m,this.y=y*m-p*E,this.w=p*x-y*v}}function G(){}function q(){}function B(){this.envelope=null,this.factory=null,this.SRID=null,this.userData=null;var t=arguments[0];this.factory=t,this.SRID=t.getSRID()}function z(){}function V(){}function k(){}function Y(){}function U(){}function X(){}function H(){}function W(){}function j(){}function K(){}function Z(){}function Q(){}function J(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function $(t){return null==t?$s:t.color}function tt(t){return null==t?null:t.parent}function et(t,e){null!==t&&(t.color=e)}function nt(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}function st(){}function ot(){}function at(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function ut(){}function lt(){}function ht(){}function ct(){}function ft(){this.geometries=null;var t=arguments[0],e=arguments[1];if(B.call(this,e),null===t&&(t=[]),B.hasNullElements(t))throw new i("geometries must not contain null elements");this.geometries=t}function gt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function dt(){if(this.geom=null,this.geomFact=null,this.bnRule=null,this.endpointMap=null,1===arguments.length){var t=arguments[0];dt.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.geom=e,this.geomFact=e.getFactory(),this.bnRule=n}}function pt(){this.count=null}function vt(){}function mt(){}function yt(){}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}function St(){this.points=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function wt(){}function Lt(){this.coordinates=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function Rt(){}function Tt(){this.shell=null,this.holes=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(B.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),B.hasNullElements(e))throw new i("holes must not contain null elements");if(t.isEmpty()&&B.hasNonEmptyElements(e))throw new i("shell is empty but holes are not");this.shell=t,this.holes=e}function Pt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function bt(){if(arguments[0]instanceof g&&arguments[1]instanceof ie){var t=arguments[0],e=arguments[1];bt.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(R(arguments[0],D)&&arguments[1]instanceof ie){var n=arguments[0],i=arguments[1];St.call(this,n,i),this.validateConstruction()}}function Ot(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function _t(){if(this.factory=null,this.isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.factory=t}}function Mt(){}function Dt(){}function At(){}function Ft(){}function Gt(){if(this.dimension=3,this.coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];Gt.call(this,t,3)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.coordinates=new Array(e).fill(null);for(var n=0;e>n;n++)this.coordinates[n]=new g}else if(R(arguments[0],D)){var i=arguments[0];if(null===i)return this.coordinates=new Array(0).fill(null),null;this.dimension=i.getDimension(),this.coordinates=new Array(i.size()).fill(null);for(var n=0;n<this.coordinates.length;n++)this.coordinates[n]=i.getCoordinateCopy(n)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var r=arguments[0],s=arguments[1];this.coordinates=r,this.dimension=s,null===r&&(this.coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var o=arguments[0],a=arguments[1];this.coordinates=new Array(o).fill(null),this.dimension=a;for(var n=0;o>n;n++)this.coordinates[n]=new g}}function qt(){}function Bt(t,e){return t===e||t!==t&&e!==e}function zt(t,e){function n(t){return this&&this.constructor===n?(this._keys=[],this._values=[],this._itp=[],this.objectOnly=e,void(t&&Vt.call(this,t))):new n(t)}return e||io(t,"size",{get:Jt}),t.constructor=n,n.prototype=t,n}function Vt(t){this.add?t.forEach(this.add,this):t.forEach(function(t){this.set(t[0],t[1])},this)}function kt(t){return this.has(t)&&(this._keys.splice(no,1),this._values.splice(no,1),this._itp.forEach(function(t){no<t[0]&&t[0]--})),no>-1}function Yt(t){return this.has(t)?this._values[no]:void 0}function Ut(t,e){if(this.objectOnly&&e!==Object(e))throw new TypeError("Invalid value used as weak collection key");if(e!==e||0===e)for(no=t.length;no--&&!Bt(t[no],e););else no=t.indexOf(e);return no>-1}function Xt(t){return Ut.call(this,this._keys,t)}function Ht(t,e){return this.has(t)?this._values[no]=e:this._values[this._keys.push(t)-1]=e,this}function Wt(){(this._keys||0).length=this._values.length=0}function jt(){return Qt(this._itp,this._keys)}function Kt(){return Qt(this._itp,this._values)}function Zt(){return Qt(this._itp,this._keys,this._values)}function Qt(t,e,n){var i=[0],r=!1;return t.push(i),{next:function(){var s,o=i[0];return!r&&o<e.length?(s=n?[e[o],n[o]]:e[o],i[0]++):(r=!0,t.splice(t.indexOf(i),1)),{done:r,value:s}}}}function Jt(){return this._values.length}function $t(t,e){for(var n=this.entries();;){var i=n.next();if(i.done)break;t.call(e,i.value[1],i.value[0],this)}}function te(){this.map_=new so}function ee(){if(this.modelType=null,this.scale=null,0===arguments.length)this.modelType=ee.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ne){var t=arguments[0];this.modelType=t,t===ee.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var e=arguments[0];this.modelType=ee.FIXED,this.setScale(e)}else if(arguments[0]instanceof ee){var n=arguments[0];this.modelType=n.modelType,this.scale=n.scale}}function ne(){this.name=null;var t=arguments[0];this.name=t,ne.nameToTypeMap.put(t,this)}function ie(){if(this.precisionModel=null,this.coordinateSequenceFactory=null,this.SRID=null,0===arguments.length)ie.call(this,new ee,0);else if(1===arguments.length){if(R(arguments[0],G)){var t=arguments[0];ie.call(this,new ee,0,t)}else if(arguments[0]instanceof ee){var e=arguments[0];ie.call(this,e,0,ie.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];ie.call(this,n,i,ie.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.precisionModel=r,this.coordinateSequenceFactory=o,this.SRID=s}}function re(t){this.geometryFactory=t||new ie}function se(t){this.parser=new re(t)}function oe(){this.result=null,this.inputLines=Array(2).fill().map(function(){return Array(2)}),this.intPt=new Array(2).fill(null),this.intLineIndex=null,this._isProper=null,this.pa=null,this.pb=null,this.precisionModel=null,this.intPt[0]=new g,this.intPt[1]=new g,this.pa=this.intPt[0],this.pb=this.intPt[1],this.result=0}function ae(){oe.apply(this)}function ue(){}function le(){this.p=null,this.crossingCount=0,this.isPointOnSegment=!1;var t=arguments[0];this.p=t}function he(){}function ce(){if(this.p0=null,this.p1=null,0===arguments.length)ce.call(this,new g,new g);else if(1===arguments.length){var t=arguments[0];ce.call(this,t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0=e,this.p1=n}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];ce.call(this,new g(i,r),new g(s,o))}}function fe(){if(this.matrix=null,0===arguments.length)this.matrix=Array(3).fill().map(function(){return Array(3)}),this.setAll(lt.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){var t=arguments[0];fe.call(this),this.set(t)}else if(arguments[0]instanceof fe){var e=arguments[0];fe.call(this),this.matrix[L.INTERIOR][L.INTERIOR]=e.matrix[L.INTERIOR][L.INTERIOR],this.matrix[L.INTERIOR][L.BOUNDARY]=e.matrix[L.INTERIOR][L.BOUNDARY],this.matrix[L.INTERIOR][L.EXTERIOR]=e.matrix[L.INTERIOR][L.EXTERIOR],this.matrix[L.BOUNDARY][L.INTERIOR]=e.matrix[L.BOUNDARY][L.INTERIOR],this.matrix[L.BOUNDARY][L.BOUNDARY]=e.matrix[L.BOUNDARY][L.BOUNDARY],this.matrix[L.BOUNDARY][L.EXTERIOR]=e.matrix[L.BOUNDARY][L.EXTERIOR],this.matrix[L.EXTERIOR][L.INTERIOR]=e.matrix[L.EXTERIOR][L.INTERIOR],this.matrix[L.EXTERIOR][L.BOUNDARY]=e.matrix[L.EXTERIOR][L.BOUNDARY],this.matrix[L.EXTERIOR][L.EXTERIOR]=e.matrix[L.EXTERIOR][L.EXTERIOR]}}function ge(){this.areaBasePt=null,this.triangleCent3=new g,this.areasum2=0,this.cg3=new g,this.lineCentSum=new g,this.totalLength=0,this.ptCount=0,this.ptCentSum=new g;var t=arguments[0];this.areaBasePt=null,this.add(t)}function de(t){this.message=t||""}function pe(){this.array_=[]}function ve(){this.treeSet=new at,this.list=new I}function me(){if(this.geomFactory=null,this.inputPts=null,1===arguments.length){var t=arguments[0];me.call(this,me.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputPts=ve.filterCoordinates(e),this.geomFactory=n}}function ye(){this.origin=null;var t=arguments[0];this.origin=t}function xe(){this.inputGeom=null,this.factory=null,this.pruneEmptyGeometry=!0,this.preserveGeometryCollectionType=!0,this.preserveCollections=!1,this.preserveType=!1}function Ee(){if(this.snapTolerance=0,this.srcPts=null,this.seg=new ce,this.allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof St&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];Ee.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1];this.srcPts=n,this._isClosed=Ee.isClosed(n),this.snapTolerance=i}}function Ie(){this.srcGeom=null;var t=arguments[0];this.srcGeom=t}function Ne(){if(xe.apply(this),this.snapTolerance=null,this.snapPts=null,this.isSelfSnap=!1,2===arguments.length){var t=arguments[0],e=arguments[1];this.snapTolerance=t,this.snapPts=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.snapTolerance=n,this.snapPts=i,this.isSelfSnap=r}}function Ce(){this.isFirst=!0,this.commonMantissaBitsCount=53,this.commonBits=0,this.commonSignExp=null}function Se(){this.commonCoord=null,this.ccFilter=new we}function we(){this.commonBitsX=new Ce,this.commonBitsY=new Ce}function Le(){this.trans=null;var t=arguments[0];this.trans=t}function Re(){this.parent=null,this.atStart=null,this.max=null,this.index=null,this.subcollectionIterator=null;var t=arguments[0];this.parent=t,this.atStart=!0,this.index=0,this.max=t.getNumGeometries()}function Te(){if(this.boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this.isIn=null,this.numBoundaries=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];if(null===t)throw new i("Rule must be non-null");this.boundaryRule=t}}function Pe(){}function be(){}function Oe(){this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function _e(){}function Me(){this.bounds=null,this.item=null;var t=arguments[0],e=arguments[1];this.bounds=t,this.item=e}function De(){this._size=null,this.items=null,this._size=0,this.items=new I,this.items.add(null)}function Ae(){}function Fe(){}function Ge(){if(this.childBoundables=new I,this.bounds=null,this.level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.level=t}}function qe(){this.boundable1=null,this.boundable2=null,this._distance=null,this.itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.boundable1=t,this.boundable2=e,this.itemDistance=n,this._distance=this.distance()}function Be(){if(this.root=null,this.built=!1,this.itemBoundables=new I,this.nodeCapacity=null,0===arguments.length)Be.call(this,Be.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];f.isTrue(t>1,"Node capacity must be greater than 1"),this.nodeCapacity=t}}function ze(){}function Ve(){}function ke(){if(0===arguments.length)ke.call(this,ke.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];Be.call(this,t)}}function Ye(){var t=arguments[0];Ge.call(this,t)}function Ue(){}function Xe(){this.segString=null,this.coord=null,this.segmentIndex=null,this.segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.segString=t,this.coord=new g(e),this.segmentIndex=n,this.segmentOctant=i,this._isInterior=!e.equals2D(t.getCoordinate(n))}function He(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function We(){this.nodeList=null,this.edge=null,this.nodeIt=null,this.currNode=null,this.nextNode=null,this.currSegIndex=0;var t=arguments[0];this.nodeList=t,this.edge=t.getEdge(),this.nodeIt=t.iterator(),this.readNextNode()}function je(){}function Ke(){this.nodeList=new He(this),this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function Ze(){this.tempEnv1=new C,this.tempEnv2=new C,this.overlapSeg1=new ce,this.overlapSeg2=new ce}function Qe(){this.pts=null,this.start=null,this.end=null,this.env=null,this.context=null,this.id=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.pts=t,this.start=e,this.end=n,this.context=i}function Je(){}function $e(){}function tn(){}function en(){if(this.segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t)}}function nn(){if(this.monoChains=new I,this.index=new ke,this.idCounter=0,this.nodedSegStrings=null,this.nOverlaps=0,0===arguments.length);else if(1===arguments.length){var t=arguments[0];en.call(this,t)}}function rn(){Ze.apply(this),this.si=null;var t=arguments[0];this.si=t}function sn(){if(this.pt=null,1===arguments.length){var t=arguments[0];l.call(this,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];l.call(this,sn.msgWithCoord(e,n)),this.pt=new g(n)}}function on(){}function an(){this.findAllIntersections=!1,this.isCheckEndSegmentsOnly=!1,this.li=null,this.interiorIntersection=null,this.intSegments=null,this.intersections=new I,this.intersectionCount=0,this.keepIntersections=!0;var t=arguments[0];this.li=t,this.interiorIntersection=null}function un(){this.li=new ae,this.segStrings=null,this.findAllIntersections=!1,this.segInt=null,this._isValid=!0;var t=arguments[0];this.segStrings=t}function ln(){this.nv=null;var t=arguments[0];this.nv=new un(ln.toSegmentStrings(t))}function hn(){this.mapOp=null;var t=arguments[0];this.mapOp=t}function cn(){}function fn(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.init(1),this.location[cn.ON]=e}else if(arguments[0]instanceof fn){var n=arguments[0];if(this.init(n.location.length),null!==n)for(var i=0;i<this.location.length;i++)this.location[i]=n.location[i]}}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.init(3),this.location[cn.ON]=r,this.location[cn.LEFT]=s,this.location[cn.RIGHT]=o}}function gn(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var t=arguments[0];this.elt[0]=new fn(t),this.elt[1]=new fn(t)}else if(arguments[0]instanceof gn){var e=arguments[0];this.elt[0]=new fn(e.elt[0]),this.elt[1]=new fn(e.elt[1])}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.elt[0]=new fn(L.NONE),this.elt[1]=new fn(L.NONE),this.elt[n].setLocation(i)}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.elt[0]=new fn(r,s,o),this.elt[1]=new fn(r,s,o)}else if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3];this.elt[0]=new fn(L.NONE,L.NONE,L.NONE),this.elt[1]=new fn(L.NONE,L.NONE,L.NONE),this.elt[a].setLocations(u,l,h)}}function dn(){this.startDe=null,this.maxNodeDegree=-1,this.edges=new I,this.pts=new I,this.label=new gn(L.NONE),this.ring=null,this._isHole=null,this.shell=null,this.holes=new I,this.geometryFactory=null;var t=arguments[0],e=arguments[1];this.geometryFactory=e,this.computePoints(t),this.computeRing()}function pn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function vn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function mn(){if(this.label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.label=t}}function yn(){mn.apply(this),this.coord=null,this.edges=null;var t=arguments[0],e=arguments[1];this.coord=t,this.edges=e,this.label=new gn(0,L.NONE)}function xn(){this.nodeMap=new rt,this.nodeFact=null;var t=arguments[0];this.nodeFact=t}function En(){if(this.edge=null,this.label=null,this.node=null,this.p0=null,this.p1=null,this.dx=null,this.dy=null,this.quadrant=null,1===arguments.length){var t=arguments[0];this.edge=t}else if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];En.call(this,e,n,i,null)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];En.call(this,r),this.init(s,o),this.label=a}}function In(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this.sym=null,this.next=null,this.nextMin=null,this.edgeRing=null,this.minEdgeRing=null,this.depth=[0,-999,-999];var t=arguments[0],e=arguments[1];if(En.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{var n=t.getNumPoints()-1;this.init(t.getCoordinate(n),t.getCoordinate(n-1))}this.computeDirectedLabel()}function Nn(){}function Cn(){if(this.edges=new I,this.nodes=null,this.edgeEndList=new I,0===arguments.length)this.nodes=new xn(new Nn);else if(1===arguments.length){var t=arguments[0];this.nodes=new xn(t)}}function Sn(){this.geometryFactory=null,this.shellList=new I;var t=arguments[0];this.geometryFactory=t}function wn(){this.op=null,this.geometryFactory=null,this.ptLocator=null,this.lineEdgesList=new I,this.resultLineList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.op=t,this.geometryFactory=e,this.ptLocator=n}function Ln(){this.op=null,this.geometryFactory=null,this.resultPointList=new I;var t=arguments[0],e=arguments[1];arguments[2];this.op=t,this.geometryFactory=e}function Rn(){}function Tn(){this.geom=null;var t=arguments[0];this.geom=t}function Pn(){this.edgeMap=new rt,this.edgeList=null,this.ptInAreaLocation=[L.NONE,L.NONE]}function bn(){Pn.apply(this),this.resultAreaEdgeList=null,this.label=null,this.SCANNING_FOR_INCOMING=1,this.LINKING_TO_OUTGOING=2}function On(){Nn.apply(this)}function _n(){this.mce=null,this.chainIndex=null;var t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}function Mn(){if(this.label=null,this.xValue=null,this.eventType=null,this.insertEvent=null,this.deleteEventIndex=null,this.obj=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.eventType=Mn.DELETE,this.xValue=t,this.insertEvent=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.eventType=Mn.INSERT,this.label=n,this.xValue=i,this.obj=r}}function Dn(){}function An(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.properIntersectionPoint=null,this.li=null,this.includeProper=null,this.recordIsolated=null,this.isSelfIntersection=null,this.numIntersections=0,this.numTests=0,this.bdyNodes=null,this._isDone=!1,this.isDoneWhenProperInt=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.li=t,this.includeProper=e,this.recordIsolated=n}function Fn(){Dn.apply(this),this.events=new I,this.nOverlaps=null}function Gn(){this.min=r.POSITIVE_INFINITY,this.max=r.NEGATIVE_INFINITY}function qn(){}function Bn(){Gn.apply(this),this.item=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.min=t,this.max=e,this.item=n}function zn(){Gn.apply(this),this.node1=null,this.node2=null;var t=arguments[0],e=arguments[1];this.node1=t,this.node2=e,this.buildExtent(this.node1,this.node2)}function Vn(){this.leaves=new I,this.root=null,this.level=0}function kn(){if(this.lines=null,this.isForcedToLineString=!1,1===arguments.length){var t=arguments[0];this.lines=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.lines=e,this.isForcedToLineString=n}}function Yn(){this.items=new I}function Un(){this.index=null;var t=arguments[0];if(!R(t,Rt))throw new i("Argument must be Polygonal");this.index=new Hn(t)}function Xn(){this.counter=null;var t=arguments[0];this.counter=t}function Hn(){this.index=new Vn;var t=arguments[0];this.init(t)}function Wn(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n}function jn(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function Kn(){}function Zn(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new C,this.env2=new C;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}function Qn(){this.depth=Array(2).fill().map(function(){return Array(3)});for(var t=0;2>t;t++)for(var e=0;3>e;e++)this.depth[t][e]=Qn.NULL_VALUE}function Jn(){if(mn.apply(this),this.pts=null,this.env=null,this.eiList=new jn(this),this.name=null,this.mce=null,this._isIsolated=!0,this.depth=new Qn,this.depthDelta=0,1===arguments.length){var t=arguments[0];Jn.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pts=e,this.label=n}}function $n(){if(Cn.apply(this),this.parentGeom=null,this.lineEdgeMap=new te,this.boundaryNodeRule=null,this.useBoundaryDeterminationRule=!0,this.argIndex=null,this.boundaryNodes=null,this._hasTooFewPoints=!1,this.invalidPoint=null,this.areaPtLocator=null,this.ptLocator=new Te,2===arguments.length){var t=arguments[0],e=arguments[1];$n.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.argIndex=n,this.parentGeom=i,this.boundaryNodeRule=r,null!==i&&this.add(i)}}function ti(){if(this.li=new ae,this.resultPrecisionModel=null,this.arg=null,1===arguments.length){var t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this.arg=new Array(1).fill(null),this.arg[0]=new $n(0,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];ti.call(this,e,n,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];i.getPrecisionModel().compareTo(r.getPrecisionModel())>=0?this.setComputationPrecision(i.getPrecisionModel()):this.setComputationPrecision(r.getPrecisionModel()),this.arg=new Array(2).fill(null),this.arg[0]=new $n(0,i,s),this.arg[1]=new $n(1,r,s)}}function ei(){this.pts=null,this._orientation=null;var t=arguments[0];this.pts=t,this._orientation=ei.orientation(t)}function ni(){this.edges=new I,this.ocaMap=new rt}function ii(){this.ptLocator=new Te,this.geomFact=null,this.resultGeom=null,this.graph=null,this.edgeList=new ni,this.resultPolyList=new I,this.resultLineList=new I,this.resultPointList=new I;var t=arguments[0],e=arguments[1];ti.call(this,t,e),this.graph=new Cn(new On),this.geomFact=t.getFactory()}function ri(){this.geom=new Array(2).fill(null),this.snapTolerance=null,this.cbr=null;var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e,this.computeSnapTolerance()}function si(){this.geom=new Array(2).fill(null);var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e}function oi(){this.factory=null,this.interiorPoint=null,this.maxWidth=0;var t=arguments[0];this.factory=t.getFactory(),this.add(t)}function ai(){this.poly=null,this.centreY=null,this.hiY=r.MAX_VALUE,this.loY=-r.MAX_VALUE;var t=arguments[0];this.poly=t,this.hiY=t.getEnvelopeInternal().getMaxY(),this.loY=t.getEnvelopeInternal().getMinY(),this.centreY=oi.avg(this.loY,this.hiY)}function ui(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.addInterior(t),null===this.interiorPoint&&this.addEndpoints(t)}function li(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.add(t)}function hi(){}function ci(){this.p0=null,this.p1=null,this.p2=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}function fi(){this.input=null,this.extremalPts=null,this.centre=null,this.radius=0;var t=arguments[0];this.input=t}function gi(){if(this.inputGeom=null,this.isConvex=null,this.convexHullPts=null,this.minBaseSeg=new ce,this.minWidthPt=null,this.minPtIndex=null,this.minWidth=0,1===arguments.length){var t=arguments[0];gi.call(this,t,!1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isConvex=n}}function di(){this.inputGeom=null,this.distanceTolerance=null;var t=arguments[0];this.inputGeom=t}function pi(){xe.apply(this),this.distanceTolerance=null;var t=arguments[0];this.distanceTolerance=t}function vi(){this._orig=null,this._sym=null,this._next=null;var t=arguments[0];this._orig=t}function mi(){this._isMarked=!1;var t=arguments[0];vi.call(this,t)}function yi(){this.vertexMap=new te}function xi(){this._isStart=!1;var t=arguments[0];mi.call(this,t)}function Ei(){yi.apply(this)}function Ii(){this.result=null,this.factory=null,this.graph=null,this.lines=new I,this.nodeEdgeStack=new pe,this.ringStartEdge=null,this.graph=new Ei}function Ni(){this.items=new I,this.subnode=new Array(4).fill(null)}function Ci(){}function Si(t,e){var n,i,r,s,o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},a={32:8,64:11}[t];if(s||(n=0>e||0>1/e,isFinite(e)||(s=o[t],n&&(s.d+=1<<t/4-1),i=Math.pow(2,a)-1,r=0)),!s){for(i={32:127,64:1023}[t],r=Math.abs(e);r>=2;)i++,r/=2;for(;1>r&&i>0;)i--,r*=2;0>=i&&(r/=2),32===t&&i>254&&(s={d:n?255:127,c:128,b:0,a:0},i=Math.pow(2,a)-1,r=0)}return i}function wi(){this.pt=new g,this.level=0,this.env=null;var t=arguments[0];this.computeKey(t)}function Li(){Ni.apply(this),this.env=null,this.centrex=null,this.centrey=null,this.level=null;var t=arguments[0],e=arguments[1];this.env=t,this.level=e,this.centrex=(t.getMinX()+t.getMaxX())/2,this.centrey=(t.getMinY()+t.getMaxY())/2}function Ri(){}function Ti(){Ni.apply(this)}function Pi(){this.root=null,this.minExtent=1,this.root=new Ti}function bi(t){this.geometryFactory=t||new ie}function Oi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new bi(this.geometryFactory)}function _i(){this.parser=new bi(this.geometryFactory)}function Mi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new re(this.geometryFactory)}function Di(t){return[t.x,t.y]}function Ai(t){this.geometryFactory=t||new ie}function Fi(){if(this.noder=null,this.scaleFactor=null,this.offsetX=null,this.offsetY=null,this.isScaled=!1,2===arguments.length){var t=arguments[0],e=arguments[1];Fi.call(this,t,e,0,0)}else if(4===arguments.length){var n=arguments[0],i=arguments[1];arguments[2],arguments[3];this.noder=n,this.scaleFactor=i,this.isScaled=!this.isIntegerPrecision()}}function Gi(){if(this.inputGeom=null,this.isClosedEndpointsInInterior=!0,this.nonSimpleLocation=null,1===arguments.length){var t=arguments[0];this.inputGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isClosedEndpointsInInterior=!n.isInBoundary(2)}}function qi(){this.pt=null,this.isClosed=null,this.degree=null;var t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}function Bi(){if(this.quadrantSegments=Bi.DEFAULT_QUADRANT_SEGMENTS,this.endCapStyle=Bi.CAP_ROUND,this.joinStyle=Bi.JOIN_ROUND,this.mitreLimit=Bi.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this.simplifyFactor=Bi.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.setQuadrantSegments(e),this.setEndCapStyle(n)}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];this.setQuadrantSegments(i),this.setEndCapStyle(r),this.setJoinStyle(s),this.setMitreLimit(o)}}function zi(){this.minIndex=-1,this.minCoord=null,this.minDe=null,this.orientedDe=null}function Vi(){this.array_=[]}function ki(){this.finder=null,this.dirEdgeList=new I,this.nodes=new I,this.rightMostCoord=null,this.env=null,this.finder=new zi}function Yi(){this.inputLine=null,
this.distanceTol=null,this.isDeleted=null,this.angleOrientation=he.COUNTERCLOCKWISE;var t=arguments[0];this.inputLine=t}function Ui(){this.ptList=null,this.precisionModel=null,this.minimimVertexDistance=0,this.ptList=new I}function Xi(){this.maxCurveSegmentError=0,this.filletAngleQuantum=null,this.closingSegLengthFactor=1,this.segList=null,this.distance=0,this.precisionModel=null,this.bufParams=null,this.li=null,this.s0=null,this.s1=null,this.s2=null,this.seg0=new ce,this.seg1=new ce,this.offset0=new ce,this.offset1=new ce,this.side=0,this._hasNarrowConcaveAngle=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.precisionModel=t,this.bufParams=e,this.li=new ae,this.filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===Bi.JOIN_ROUND&&(this.closingSegLengthFactor=Xi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}function Hi(){this.distance=0,this.precisionModel=null,this.bufParams=null;var t=arguments[0],e=arguments[1];this.precisionModel=t,this.bufParams=e}function Wi(){this.subgraphs=null,this.seg=new ce,this.cga=new he;var t=arguments[0];this.subgraphs=t}function ji(){this.upwardSeg=null,this.leftDepth=null;var t=arguments[0],e=arguments[1];this.upwardSeg=new ce(t),this.leftDepth=e}function Ki(){this.inputGeom=null,this.distance=null,this.curveBuilder=null,this.curveList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.inputGeom=t,this.distance=e,this.curveBuilder=n}function Zi(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.hasInterior=!1,this.properIntersectionPoint=null,this.li=null,this.isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this.li=t}function Qi(){this.bufParams=null,this.workingPrecisionModel=null,this.workingNoder=null,this.geomFact=null,this.graph=null,this.edgeList=new ni;var t=arguments[0];this.bufParams=t}function Ji(){this.li=new ae,this.segStrings=null;var t=arguments[0];this.segStrings=t}function $i(){this.li=null,this.pt=null,this.originalPt=null,this.ptScaled=null,this.p0Scaled=null,this.p1Scaled=null,this.scaleFactor=null,this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,this.corner=new Array(4).fill(null),this.safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this.originalPt=t,this.pt=t,this.scaleFactor=e,this.li=n,0>=e)throw new i("Scale factor must be non-zero");1!==e&&(this.pt=new g(this.scale(t.x),this.scale(t.y)),this.p0Scaled=new g,this.p1Scaled=new g),this.initCorners(this.pt)}function tr(){this.tempEnv1=new C,this.selectedSegment=new ce}function er(){this.index=null;var t=arguments[0];this.index=t}function nr(){tr.apply(this),this.hotPixel=null,this.parentEdge=null,this.hotPixelVertexIndex=null,this._isNodeAdded=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.hotPixel=t,this.parentEdge=e,this.hotPixelVertexIndex=n}function ir(){this.li=null,this.interiorIntersections=null;var t=arguments[0];this.li=t,this.interiorIntersections=new I}function rr(){this.pm=null,this.li=null,this.scaleFactor=null,this.noder=null,this.pointSnapper=null,this.nodedSegStrings=null;var t=arguments[0];this.pm=t,this.li=new ae,this.li.setPrecisionModel(t),this.scaleFactor=t.getScale()}function sr(){if(this.argGeom=null,this.distance=null,this.bufParams=new Bi,this.resultGeometry=null,this.saveException=null,1===arguments.length){var t=arguments[0];this.argGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.argGeom=e,this.bufParams=n}}function or(){this.comps=null;var t=arguments[0];this.comps=t}function ar(){if(this.component=null,this.segIndex=null,this.pt=null,2===arguments.length){var t=arguments[0],e=arguments[1];ar.call(this,t,ar.INSIDE_AREA,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.component=n,this.segIndex=i,this.pt=r}}function ur(){this.pts=null;var t=arguments[0];this.pts=t}function lr(){this.locations=null;var t=arguments[0];this.locations=t}function hr(){if(this.geom=null,this.terminateDistance=0,this.ptLocator=new Te,this.minDistanceLocation=null,this.minDistance=r.MAX_VALUE,2===arguments.length){var t=arguments[0],e=arguments[1];hr.call(this,t,e,0)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],s=arguments[2];this.geom=new Array(2).fill(null),this.geom[0]=n,this.geom[1]=i,this.terminateDistance=s}}function cr(){this.factory=null,this.directedEdges=new I,this.coordinates=null;var t=arguments[0];this.factory=t}function fr(){this._isMarked=!1,this._isVisited=!1,this.data=null}function gr(){fr.apply(this),this.parentEdge=null,this.from=null,this.to=null,this.p0=null,this.p1=null,this.sym=null,this.edgeDirection=null,this.quadrant=null,this.angle=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.from=t,this.to=e,this.edgeDirection=i,this.p0=t.getCoordinate(),this.p1=n;var r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y;this.quadrant=Je.quadrant(r,s),this.angle=Math.atan2(s,r)}function dr(){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];gr.call(this,t,e,n,i)}function pr(){if(fr.apply(this),this.dirEdge=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}function vr(){this.outEdges=new I,this.sorted=!1}function mr(){if(fr.apply(this),this.pt=null,this.deStar=null,1===arguments.length){var t=arguments[0];mr.call(this,t,new vr)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pt=e,this.deStar=n}}function yr(){pr.apply(this),this.line=null;var t=arguments[0];this.line=t}function xr(){this.nodeMap=new rt}function Er(){this.edges=new J,this.dirEdges=new J,this.nodeMap=new xr}function Ir(){Er.apply(this)}function Nr(){this.graph=new Ir,this.mergedLineStrings=null,this.factory=null,this.edgeStrings=null}function Cr(){this.edgeRing=null,this.next=null,this.label=-1;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];gr.call(this,t,e,n,i)}function Sr(){pr.apply(this),this.line=null;var t=arguments[0];this.line=t}function wr(){this.factory=null,this.deList=new I,this.lowestEdge=null,this.ring=null,this.ringPts=null,this.holes=null,this.shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;var t=arguments[0];this.factory=t}function Lr(){}function Rr(){Er.apply(this),this.factory=null;var t=arguments[0];this.factory=t}function Tr(){if(this.lineStringAdder=new Pr(this),this.graph=null,this.dangles=new I,this.cutEdges=new I,this.invalidRingLines=new I,this.holeList=null,this.shellList=null,this.polyList=null,this.isCheckingRingsValid=!0,this.extractOnlyPolygonal=null,this.geomFactory=null,0===arguments.length)Tr.call(this,!1);else if(1===arguments.length){var t=arguments[0];this.extractOnlyPolygonal=t}}function Pr(){this.p=null;var t=arguments[0];this.p=t}function br(){}function Or(){if(this.edgeEnds=new I,1===arguments.length){var t=arguments[0];Or.call(this,null,t)}else if(2===arguments.length){var e=(arguments[0],arguments[1]);En.call(this,e.getEdge(),e.getCoordinate(),e.getDirectedCoordinate(),new gn(e.getLabel())),this.insert(e)}}function _r(){Pn.apply(this)}function Mr(){var t=arguments[0],e=arguments[1];yn.call(this,t,e)}function Dr(){Nn.apply(this)}function Ar(){this.li=new ae,this.ptLocator=new Te,this.arg=null,this.nodes=new xn(new Dr),this.im=null,this.isolatedEdges=new I,this.invalidPoint=null;var t=arguments[0];this.arg=t}function Fr(){this.rectEnv=null;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal()}function Gr(){this.li=new ae,this.rectEnv=null,this.diagUp0=null,this.diagUp1=null,this.diagDown0=null,this.diagDown1=null;var t=arguments[0];this.rectEnv=t,this.diagUp0=new g(t.getMinX(),t.getMinY()),this.diagUp1=new g(t.getMaxX(),t.getMaxY()),this.diagDown0=new g(t.getMinX(),t.getMaxY()),this.diagDown1=new g(t.getMaxX(),t.getMinY())}function qr(){this._isDone=!1}function Br(){this.rectangle=null,this.rectEnv=null;var t=arguments[0];this.rectangle=t,this.rectEnv=t.getEnvelopeInternal()}function zr(){qr.apply(this),this.rectEnv=null,this._intersects=!1;var t=arguments[0];this.rectEnv=t}function Vr(){qr.apply(this),this.rectSeq=null,this.rectEnv=null,this._containsPoint=!1;var t=arguments[0];this.rectSeq=t.getExteriorRing().getCoordinateSequence(),this.rectEnv=t.getEnvelopeInternal()}function kr(){qr.apply(this),this.rectEnv=null,this.rectIntersector=null,this.hasIntersection=!1,this.p0=new g,this.p1=new g;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal(),this.rectIntersector=new Gr(this.rectEnv)}function Yr(){if(this._relate=null,2===arguments.length){var t=arguments[0],e=arguments[1];ti.call(this,t,e),this._relate=new Ar(this.arg)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];ti.call(this,n,i,r),this._relate=new Ar(this.arg)}}function Ur(){this.geomFactory=null,this.skipEmpty=!1,this.inputGeoms=null;var t=arguments[0];this.geomFactory=Ur.extractFactory(t),this.inputGeoms=t}function Xr(){this.pointGeom=null,this.otherGeom=null,this.geomFact=null;var t=arguments[0],e=arguments[1];this.pointGeom=t,this.otherGeom=e,this.geomFact=e.getFactory()}function Hr(){this.sortIndex=-1,this.comps=null;var t=arguments[0],e=arguments[1];this.sortIndex=t,this.comps=e}function Wr(){this.inputPolys=null,this.geomFactory=null;var t=arguments[0];this.inputPolys=t,null===this.inputPolys&&(this.inputPolys=new I)}function jr(){if(this.polygons=new I,this.lines=new I,this.points=new I,this.geomFact=null,1===arguments.length){if(R(arguments[0],v)){var t=arguments[0];this.extract(t)}else if(arguments[0]instanceof B){var e=arguments[0];this.extract(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.geomFact=i,this.extract(n)}}function Kr(){this.geometryFactory=new ie,this.geomGraph=null,this.disconnectedRingcoord=null;var t=arguments[0];this.geomGraph=t}function Zr(){this.items=new I,this.subnode=[null,null]}function Qr(){if(this.min=null,this.max=null,0===arguments.length)this.min=0,this.max=0;else if(1===arguments.length){var t=arguments[0];this.init(t.min,t.max)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.init(e,n)}}function Jr(){this.pt=0,this.level=0,this.interval=null;var t=arguments[0];this.computeKey(t)}function $r(){Zr.apply(this),this.interval=null,this.centre=null,this.level=null;var t=arguments[0],e=arguments[1];this.interval=t,this.level=e,this.centre=(t.getMin()+t.getMax())/2}function ts(){Zr.apply(this)}function es(){this.root=null,this.minExtent=1,this.root=new ts}function ns(){}function is(){this.ring=null,this.tree=null,this.crossings=0,this.interval=new Qr;var t=arguments[0];this.ring=t,this.buildIndex()}function rs(){tr.apply(this),this.mcp=null,this.p=null;var t=arguments[0],e=arguments[1];this.mcp=t,this.p=e}function ss(){this.nodes=new xn(new Dr)}function os(){this.li=new ae,this.geomGraph=null,this.nodeGraph=new ss,this.invalidPoint=null;var t=arguments[0];this.geomGraph=t}function as(){this.graph=null,this.rings=new I,this.totalEnv=new C,this.index=null,this.nestedPt=null;var t=arguments[0];this.graph=t}function us(){if(this.errorType=null,this.pt=null,1===arguments.length){var t=arguments[0];us.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.errorType=e,null!==n&&(this.pt=n.copy())}}function ls(){this.parentGeometry=null,this.isSelfTouchingRingFormingHoleValid=!1,this.validErr=null;var t=arguments[0];this.parentGeometry=t}function hs(){_t.CoordinateOperation.apply(this),this.targetPM=null,this.removeCollapsed=!0;var t=arguments[0],e=arguments[1];this.targetPM=t,this.removeCollapsed=e}function cs(){this.targetPM=null,this.removeCollapsed=!0,this.changePrecisionModel=!1,this.isPointwise=!1;var t=arguments[0];this.targetPM=t}function fs(){this.pts=null,this.usePt=null,this.distanceTolerance=null,this.seg=new ce;var t=arguments[0];this.pts=t}function gs(){this.inputGeom=null,this.distanceTolerance=null,this.isEnsureValidTopology=!0;var t=arguments[0];this.inputGeom=t}function ds(){xe.apply(this),this.isEnsureValidTopology=!0,this.distanceTolerance=null;var t=arguments[0],e=arguments[1];this.isEnsureValidTopology=t,this.distanceTolerance=e}function ps(){if(this.parent=null,this.index=null,2===arguments.length){var t=arguments[0],e=arguments[1];ps.call(this,t,e,null,-1)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=arguments[3];ce.call(this,n,i),this.parent=r,this.index=s}}function vs(){if(this.parentLine=null,this.segs=null,this.resultSegs=new I,this.minimumSize=null,1===arguments.length){var t=arguments[0];vs.call(this,t,2)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.parentLine=e,this.minimumSize=n,this.init()}}function ms(){this.index=new Pi}function ys(){this.querySeg=null,this.items=new I;var t=arguments[0];this.querySeg=t}function xs(){this.li=new ae,this.inputIndex=new ms,this.outputIndex=new ms,this.line=null,this.linePts=null,this.distanceTolerance=0;var t=arguments[0],e=arguments[1];this.inputIndex=t,this.outputIndex=e}function Es(){this.inputIndex=new ms,this.outputIndex=new ms,this.distanceTolerance=0}function Is(){this.inputGeom=null,this.lineSimplifier=new Es,this.linestringMap=null;var t=arguments[0];this.inputGeom=t}function Ns(){xe.apply(this),this.linestringMap=null;var t=arguments[0];this.linestringMap=t}function Cs(){this.tps=null;var t=arguments[0];this.tps=t}function Ss(){this.seg=null,this.segLen=null,this.splitPt=null,this.minimumLen=0;var t=arguments[0];this.seg=t,this.segLen=t.getLength()}function ws(){}function Ls(){}function Rs(){}function Ts(){if(this.p=null,1===arguments.length){var t=arguments[0];this.p=new g(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p=new g(e,n)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.p=new g(i,r,s)}}function Ps(){this._isOnConstraint=null,this.constraint=null;var t=arguments[0];Ts.call(this,t)}function bs(){this._rot=null,this.vertex=null,this.next=null,this.data=null}function Os(){this.subdiv=null,this.isUsingTolerance=!1;var t=arguments[0];this.subdiv=t,this.isUsingTolerance=t.getTolerance()>0}function _s(){}function Ms(){this.subdiv=null,this.lastEdge=null;var t=arguments[0];this.subdiv=t,this.init()}function Ds(){if(this.seg=null,1===arguments.length){if("string"==typeof arguments[0]){var t=arguments[0];l.call(this,t)}else if(arguments[0]instanceof ce){var e=arguments[0];l.call(this,"Locate failed to converge (at edge: "+e+").  Possible causes include invalid Subdivision topology or very close sites"),this.seg=new ce(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];l.call(this,Ds.msgWithSpatial(n,i)),this.seg=new ce(i)}}function As(){}function Fs(){this.visitedKey=0,this.quadEdges=new I,this.startingEdge=null,this.tolerance=null,this.edgeCoincidenceTolerance=null,this.frameVertex=new Array(3).fill(null),this.frameEnv=null,this.locator=null,this.seg=new ce,this.triEdges=new Array(3).fill(null);var t=arguments[0],e=arguments[1];this.tolerance=e,this.edgeCoincidenceTolerance=e/Fs.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this.startingEdge=this.initSubdiv(),this.locator=new Ms(this)}function Gs(){}function qs(){this.triList=new I}function Bs(){this.triList=new I}function zs(){this.coordList=new N,this.triCoords=new I}function Vs(){if(this.ls=null,this.data=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.ls=new ce(t,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.ls=new ce(n,i),this.data=r}else if(6===arguments.length){var s=arguments[0],o=arguments[1],a=arguments[2],u=arguments[3],l=arguments[4],h=arguments[5];Vs.call(this,new g(s,o,a),new g(u,l,h))}else if(7===arguments.length){var c=arguments[0],f=arguments[1],d=arguments[2],p=arguments[3],v=arguments[4],m=arguments[5],y=arguments[6];Vs.call(this,new g(c,f,d),new g(p,v,m),y)}}function ks(){}function Ys(){if(this.p=null,this.data=null,this.left=null,this.right=null,this.count=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.p=new g(t),this.left=null,this.right=null,this.count=1,this.data=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.p=new g(n,i),this.left=null,this.right=null,this.count=1,this.data=r}}function Us(){if(this.root=null,this.numberOfNodes=null,this.tolerance=null,0===arguments.length)Us.call(this,0);else if(1===arguments.length){var t=arguments[0];this.tolerance=t}}function Xs(){this.tolerance=null,this.matchNode=null,this.matchDist=0,this.p=null;var t=arguments[0],e=arguments[1];this.p=t,this.tolerance=e}function Hs(){this.initialVertices=null,this.segVertices=null,this.segments=new I,this.subdiv=null,this.incDel=null,this.convexHull=null,this.splitFinder=new Ls,this.kdt=null,this.vertexFactory=null,this.computeAreaEnv=null,this.splitPt=null,this.tolerance=null;var t=arguments[0],e=arguments[1];this.initialVertices=new I(t),this.tolerance=e,this.kdt=new Us(e)}function Ws(){this.siteCoords=null,this.tolerance=0,this.subdiv=null}function js(){this.siteCoords=null,this.constraintLines=null,this.tolerance=0,this.subdiv=null,this.constraintVertexMap=new rt}function Ks(){this.siteCoords=null,this.tolerance=0,this.subdiv=null,this.clipEnv=null,this.diagramEnv=null}function Zs(){}Array.prototype.fill||(Array.prototype.fill=function(t){for(var e=Object(this),n=parseInt(e.length,10),i=arguments[1],r=parseInt(i,10)||0,s=0>r?Math.max(n+r,0):Math.min(r,n),o=arguments[2],a=void 0===o?n:parseInt(o,10)||0,u=0>a?Math.max(n+a,0):Math.min(a,n);u>s;s++)e[s]=t;return e}),Number.isFinite=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)},Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(t){return t!==t},Math.trunc=Math.trunc||function(t){return 0>t?Math.ceil(t):Math.floor(t)},e(n.prototype,{interfaces_:function(){return[]},getClass:function(){return n}}),n.equalsWithTolerance=function(t,e,n){return Math.abs(t-e)<=n},r.isNaN=function(t){return Number.isNaN(t)},r.doubleToLongBits=function(t){return t},r.longBitsToDouble=function(t){return t},r.isInfinite=function(t){return!Number.isFinite(t)},r.MAX_VALUE=Number.MAX_VALUE,h(c,l),e(c.prototype,{interfaces_:function(){return[]},getClass:function(){return c}}),e(f.prototype,{interfaces_:function(){return[]},getClass:function(){return f}}),f.shouldNeverReachHere=function(){if(0===arguments.length)f.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new c("Should never reach here"+(null!==t?": "+t:""))}},f.isTrue=function(){if(1===arguments.length){var t=arguments[0];f.isTrue(t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!e)throw null===n?new c:new c(n)}},f.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];f.equals(t,e,null)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(!i.equals(n))throw new c("Expected "+n+" but encountered "+i+(null!==r?": "+r:""))}},e(g.prototype,{setOrdinate:function(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new i("Invalid ordinate index: "+t)}},equals2D:function(){if(1===arguments.length){var t=arguments[0];return this.x!==t.x?!1:this.y===t.y}if(2===arguments.length){var e=arguments[0],i=arguments[1];return n.equalsWithTolerance(this.x,e.x,i)?!!n.equalsWithTolerance(this.y,e.y,i):!1}},getOrdinate:function(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new i("Invalid ordinate index: "+t)},equals3D:function(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||r.isNaN(this.z)&&r.isNaN(t.z))},equals:function(t){return t instanceof g?this.equals2D(t):!1},equalInZ:function(t,e){return n.equalsWithTolerance(this.z,t.z,e)},compareTo:function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0},clone:function(){try{var t=null;return t}catch(t){if(t instanceof CloneNotSupportedException)return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}finally{}},copy:function(){return new g(this)},toString:function(){return"("+this.x+", "+this.y+", "+this.z+")"},distance3D:function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)},distance:function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y)},setCoordinate:function(t){this.x=t.x,this.y=t.y,this.z=t.z},interfaces_:function(){return[s,o,u]},getClass:function(){return g}}),g.hashCode=function(){if(1===arguments.length){var t=arguments[0],e=r.doubleToLongBits(t);return Math.trunc(e^e>>>32)}},e(d.prototype,{compare:function(t,e){var n=t,i=e,r=d.compare(n.x,i.x);if(0!==r)return r;var s=d.compare(n.y,i.y);if(0!==s)return s;if(this.dimensionsToTest<=2)return 0;var o=d.compare(n.z,i.z);return o},interfaces_:function(){return[a]},getClass:function(){return d}}),d.compare=function(t,e){return e>t?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0},g.DimensionalComparator=d,g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=r.NaN,g.X=0,g.Y=1,g.Z=2,p.prototype.hasNext=function(){},p.prototype.next=function(){},p.prototype.remove=function(){},v.prototype.add=function(){},v.prototype.addAll=function(){},v.prototype.isEmpty=function(){},v.prototype.iterator=function(){},v.prototype.size=function(){},v.prototype.toArray=function(){},v.prototype.remove=function(){},m.prototype=new Error,m.prototype.name="IndexOutOfBoundsException",y.prototype=Object.create(v.prototype),y.prototype.constructor=y,y.prototype.get=function(){},y.prototype.set=function(){},y.prototype.isEmpty=function(){},x.prototype=new Error,x.prototype.name="NoSuchElementException",E.prototype=new Error,E.prototype.name="OperationNotSupported",I.prototype=Object.create(y.prototype),I.prototype.constructor=I,I.prototype.ensureCapacity=function(){},I.prototype.interfaces_=function(){return[y,v]},I.prototype.add=function(t){return this.array_.push(t),!0},I.prototype.clear=function(){this.array_=[]},I.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},I.prototype.set=function(t,e){var n=this.array_[t];return this.array_[t]=e,n},I.prototype.iterator=function(){return new Qs(this)},I.prototype.get=function(t){if(0>t||t>=this.size())throw new m;return this.array_[t]},I.prototype.isEmpty=function(){return 0===this.array_.length},I.prototype.size=function(){return this.array_.length},I.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},I.prototype.remove=function(t){for(var e=!1,n=0,i=this.array_.length;i>n;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e};var Qs=function(t){this.arrayList_=t,this.position_=0};Qs.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new x;return this.arrayList_.get(this.position_++)},Qs.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},Qs.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},Qs.prototype.remove=function(){throw new E},h(N,I),e(N.prototype,{getCoordinate:function(t){return this.get(t)},addAll:function(){if(2===arguments.length){for(var t=arguments[0],e=arguments[1],n=!1,i=t.iterator();i.hasNext();)this.add(i.next(),e),n=!0;return n}return I.prototype.addAll.apply(this,arguments)},clone:function t(){for(var t=I.prototype.clone.call(this),e=0;e<this.size();e++)t.add(e,this.get(e).copy());return t},toCoordinateArray:function(){return this.toArray(N.coordArrayType)},add:function(){if(1===arguments.length){var t=arguments[0];I.prototype.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var e=arguments[0],n=arguments[1];return this.add(e,n,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){var i=arguments[0],r=arguments[1];if(!r&&this.size()>=1){var s=this.get(this.size()-1);if(s.equals2D(i))return null}I.prototype.add.call(this,i)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],a=arguments[1];return this.add(o,a),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2];if(h)for(var c=0;c<u.length;c++)this.add(u[c],l);else for(var c=u.length-1;c>=0;c--)this.add(u[c],l);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){var f=arguments[0],d=arguments[1],p=arguments[2];if(!p){var v=this.size();if(v>0){if(f>0){var m=this.get(f-1);if(m.equals2D(d))return null}if(v>f){var y=this.get(f);if(y.equals2D(d))return null}}}I.prototype.add.call(this,f,d)}}else if(4===arguments.length){var x=arguments[0],E=arguments[1],N=arguments[2],C=arguments[3],S=1;N>C&&(S=-1);for(var c=N;c!==C;c+=S)this.add(x[c],E);return!0}},closeRing:function(){this.size()>0&&this.add(new g(this.get(0)),!1)},interfaces_:function(){return[]},getClass:function(){return N}}),N.coordArrayType=new Array(0).fill(null),e(C.prototype,{getArea:function(){return this.getWidth()*this.getHeight()},equals:function(t){if(!(t instanceof C))return!1;var e=t;return this.isNull()?e.isNull():this.maxx===e.getMaxX()&&this.maxy===e.getMaxY()&&this.minx===e.getMinX()&&this.miny===e.getMinY()},intersection:function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new C;var e=this.minx>t.minx?this.minx:t.minx,n=this.miny>t.miny?this.miny:t.miny,i=this.maxx<t.maxx?this.maxx:t.maxx,r=this.maxy<t.maxy?this.maxy:t.maxy;return new C(e,i,n,r)},isNull:function(){return this.maxx<this.minx},getMaxX:function(){return this.maxx},covers:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof C){var e=arguments[0];return this.isNull()||e.isNull()?!1:e.getMinX()>=this.minx&&e.getMaxX()<=this.maxx&&e.getMinY()>=this.miny&&e.getMaxY()<=this.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:n>=this.minx&&n<=this.maxx&&i>=this.miny&&i<=this.maxy}},intersects:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.isNull()||t.isNull()?!1:!(t.minx>this.maxx||t.maxx<this.minx||t.miny>this.maxy||t.maxy<this.miny)}if(arguments[0]instanceof g){var e=arguments[0];return this.intersects(e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:!(n>this.maxx||n<this.minx||i>this.maxy||i<this.miny)}},getMinY:function(){return this.miny},getMinX:function(){return this.minx},expandToInclude:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];if(e.isNull())return null;this.isNull()?(this.minx=e.getMinX(),this.maxx=e.getMaxX(),this.miny=e.getMinY(),this.maxy=e.getMaxY()):(e.minx<this.minx&&(this.minx=e.minx),e.maxx>this.maxx&&(this.maxx=e.maxx),e.miny<this.miny&&(this.miny=e.miny),e.maxy>this.maxy&&(this.maxy=e.maxy))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.isNull()?(this.minx=n,this.maxx=n,this.miny=i,this.maxy=i):(n<this.minx&&(this.minx=n),n>this.maxx&&(this.maxx=n),i<this.miny&&(this.miny=i),i>this.maxy&&(this.maxy=i))}},minExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return e>t?t:e},getWidth:function(){return this.isNull()?0:this.maxx-this.minx},compareTo:function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this.minx<e.minx?-1:this.minx>e.minx?1:this.miny<e.miny?-1:this.miny>e.miny?1:this.maxx<e.maxx?-1:this.maxx>e.maxx?1:this.maxy<e.maxy?-1:this.maxy>e.maxy?1:0},translate:function(t,e){return this.isNull()?null:void this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)},toString:function(){return"Env["+this.minx+" : "+this.maxx+", "+this.miny+" : "+this.maxy+"]"},setToNull:function(){this.minx=0,this.maxx=-1,this.miny=0,this.maxy=-1},getHeight:function(){return this.isNull()?0:this.maxy-this.miny},maxExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e},expandBy:function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this.minx-=e,this.maxx+=e,this.miny-=n,this.maxy+=n,(this.minx>this.maxx||this.miny>this.maxy)&&this.setToNull()}},contains:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.covers(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.covers(n,i)}},centre:function(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},init:function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.minx=e.minx,this.maxx=e.maxx,this.miny=e.miny,this.maxy=e.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];s>r?(this.minx=r,this.maxx=s):(this.minx=s,this.maxx=r),a>o?(this.miny=o,this.maxy=a):(this.miny=a,this.maxy=o)}},getMaxY:function(){return this.maxy},distance:function(t){if(this.intersects(t))return 0;var e=0;this.maxx<t.minx?e=t.minx-this.maxx:this.minx>t.maxx&&(e=this.minx-t.maxx);var n=0;return this.maxy<t.miny?n=t.miny-this.maxy:this.miny>t.maxy&&(n=this.miny-t.maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.minx),t=37*t+g.hashCode(this.maxx),t=37*t+g.hashCode(this.miny),t=37*t+g.hashCode(this.maxy)},interfaces_:function(){return[s,u]},getClass:function(){return C}}),C.intersects=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=Math.min(s.x,o.x),u=Math.max(s.x,o.x),l=Math.min(i.x,r.x),h=Math.max(i.x,r.x);return l>u?!1:a>h?!1:(a=Math.min(s.y,o.y),u=Math.max(s.y,o.y),l=Math.min(i.y,r.y),h=Math.max(i.y,r.y),l>u?!1:!(a>h))}},C.serialVersionUID=0x51845cd552189800,h(w,S),e(w.prototype,{interfaces_:function(){return[]},getClass:function(){return w}}),e(L.prototype,{interfaces_:function(){return[]},getClass:function(){return L}}),L.toLocationSymbol=function(t){switch(t){case L.EXTERIOR:return"e";case L.BOUNDARY:return"b";case L.INTERIOR:return"i";case L.NONE:return"-"}throw new i("Unknown location value: "+t)},L.INTERIOR=0,L.BOUNDARY=1,L.EXTERIOR=2,L.NONE=-1,e(T.prototype,{interfaces_:function(){return[]},getClass:function(){return T}}),T.log10=function(t){var e=Math.log(t);return r.isInfinite(e)?e:r.isNaN(e)?e:e/T.LOG_10},T.min=function(t,e,n,i){var r=t;return r>e&&(r=e),r>n&&(r=n),r>i&&(r=i),r},T.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];return e>t?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var i=arguments[0],r=arguments[1],s=arguments[2];return r>i?r:i>s?s:i}},T.wrap=function(t,e){return 0>t?e- -t%e:t%e},T.max=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=t;return e>i&&(i=e),n>i&&(i=n),i}if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],i=r;return s>i&&(i=s),o>i&&(i=o),a>i&&(i=a),i}},T.average=function(t,e){
return(t+e)/2},T.LOG_10=Math.log(10),P.prototype.append=function(t){this.str+=t},P.prototype.setCharAt=function(t,e){return this.str.substr(0,t)+e+this.str.substr(t+1)},P.prototype.toString=function(t){return this.str},b.prototype.intValue=function(){return this.value},b.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},b.isNaN=function(t){return Number.isNaN(t)},O.isWhitespace=function(t){return 32>=t&&t>=0||127==t},O.toUpperCase=function(t){return t.toUpperCase()},e(_.prototype,{le:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<=t.lo},extractSignificantDigits:function(t,e){var n=this.abs(),i=_.magnitude(n.hi),r=_.TEN.pow(i);n=n.divide(r),n.gt(_.TEN)?(n=n.divide(_.TEN),i+=1):n.lt(_.ONE)&&(n=n.multiply(_.TEN),i-=1);for(var s=i+1,o=new P,a=_.MAX_PRINT_DIGITS-1,u=0;a>=u;u++){t&&u===s&&o.append(".");var l=Math.trunc(n.hi);if(0>l)break;var h=!1,c=0;l>9?(h=!0,c="9"):c="0"+l,o.append(c),n=n.subtract(_.valueOf(l)).multiply(_.TEN),h&&n.selfAdd(_.TEN);var f=!0,g=_.magnitude(n.hi);if(0>g&&Math.abs(g)>=a-u&&(f=!1),!f)break}return e[0]=i,o.toString()},sqr:function(){return this.multiply(this)},doubleValue:function(){return this.hi+this.lo},subtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var e=arguments[0];return this.add(-e)}},equals:function(){if(1===arguments.length){var t=arguments[0];return this.hi===t.hi&&this.lo===t.lo}},isZero:function(){return 0===this.hi&&0===this.lo},selfSubtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t.hi,-t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.isNaN()?this:this.selfAdd(-e,0)}},getSpecialNumberString:function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},min:function(t){return this.le(t)?this:t},selfDivide:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfDivide(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfDivide(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null,h=null,c=null;return u=this.hi/n,l=_.SPLIT*u,r=l-u,c=_.SPLIT*n,r=l-r,s=u-r,o=c-n,h=u*n,o=c-o,a=n-o,c=r*o-h+r*a+s*o+s*a,l=(this.hi-h-c+this.lo-u*i)/n,c=u+l,this.hi=c,this.lo=u-c+l,this}},dump:function(){return"DD<"+this.hi+", "+this.lo+">"},divide:function(){if(arguments[0]instanceof _){var t=arguments[0],e=null,n=null,i=null,s=null,o=null,a=null,u=null,l=null;o=this.hi/t.hi,a=_.SPLIT*o,e=a-o,l=_.SPLIT*t.hi,e=a-e,n=o-e,i=l-t.hi,u=o*t.hi,i=l-i,s=t.hi-i,l=e*i-u+e*s+n*i+n*s,a=(this.hi-u-l+this.lo-o*t.lo)/t.hi,l=o+a;var h=l,c=o-l+a;return new _(h,c)}if("number"==typeof arguments[0]){var f=arguments[0];return r.isNaN(f)?_.createNaN():_.copy(this).selfDivide(f,0)}},ge:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>=t.lo},pow:function(t){if(0===t)return _.valueOf(1);var e=new _(this),n=_.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2===1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return 0>t?n.reciprocal():n},ceil:function(){if(this.isNaN())return _.NaN;var t=Math.ceil(this.hi),e=0;return t===this.hi&&(e=Math.ceil(this.lo)),new _(t,e)},compareTo:function(t){var e=t;return this.hi<e.hi?-1:this.hi>e.hi?1:this.lo<e.lo?-1:this.lo>e.lo?1:0},rint:function(){if(this.isNaN())return this;var t=this.add(.5);return t.floor()},setValue:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var e=arguments[0];return this.init(e),this}},max:function(t){return this.ge(t)?this:t},sqrt:function(){if(this.isZero())return _.valueOf(0);if(this.isNegative())return _.NaN;var t=1/Math.sqrt(this.hi),e=this.hi*t,n=_.valueOf(e),i=this.subtract(n.sqr()),r=i.hi*(.5*t);return n.add(r)},selfAdd:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfAdd(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0],n=null,i=null,r=null,s=null,o=null,a=null;return r=this.hi+e,o=r-this.hi,s=r-o,s=e-o+(this.hi-s),a=s+this.lo,n=r+a,i=a+(r-n),this.hi=n+i,this.lo=i+(n-this.hi),this}}else if(2===arguments.length){var u=arguments[0],l=arguments[1],n=null,i=null,h=null,c=null,r=null,s=null,o=null,a=null;r=this.hi+u,h=this.lo+l,o=r-this.hi,a=h-this.lo,s=r-o,c=h-a,s=u-o+(this.hi-s),c=l-a+(this.lo-c),o=s+h,n=r+o,i=o+(r-n),o=c+i;var f=n+o,g=o+(n-f);return this.hi=f,this.lo=g,this}},selfMultiply:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfMultiply(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfMultiply(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null;u=_.SPLIT*this.hi,r=u-this.hi,l=_.SPLIT*n,r=u-r,s=this.hi-r,o=l-n,u=this.hi*n,o=l-o,a=n-o,l=r*o-u+r*a+s*o+s*a+(this.hi*i+this.lo*n);var h=u+l;r=u-h;var c=l+r;return this.hi=h,this.lo=c,this}},selfSqr:function(){return this.selfMultiply(this)},floor:function(){if(this.isNaN())return _.NaN;var t=Math.floor(this.hi),e=0;return t===this.hi&&(e=Math.floor(this.lo)),new _(t,e)},negate:function(){return this.isNaN()?this:new _(-this.hi,-this.lo)},clone:function(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}finally{}},multiply:function(){if(arguments[0]instanceof _){var t=arguments[0];return t.isNaN()?_.createNaN():_.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var e=arguments[0];return r.isNaN(e)?_.createNaN():_.copy(this).selfMultiply(e,0)}},isNaN:function(){return r.isNaN(this.hi)},intValue:function(){return Math.trunc(this.hi)},toString:function(){var t=_.magnitude(this.hi);return t>=-3&&20>=t?this.toStandardNotation():this.toSciNotation()},toStandardNotation:function(){var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1,r=n;if("."===n.charAt(0))r="0"+n;else if(0>i)r="0."+_.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){var s=i-n.length,o=_.stringOfChar("0",s);r=n+o+".0"}return this.isNegative()?"-"+r:r},reciprocal:function(){var t=null,e=null,n=null,i=null,r=null,s=null,o=null,a=null;r=1/this.hi,s=_.SPLIT*r,t=s-r,a=_.SPLIT*this.hi,t=s-t,e=r-t,n=a-this.hi,o=r*this.hi,n=a-n,i=this.hi-n,a=t*n-o+t*i+e*n+e*i,s=(1-o-a-r*this.lo)/this.hi;var u=r+s,l=r-u+s;return new _(u,l)},toSciNotation:function(){if(this.isZero())return _.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=_.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);var r="";n.length>1&&(r=n.substring(1));var s=n.charAt(0)+"."+r;return this.isNegative()?"-"+s+i:s+i},abs:function(){return this.isNaN()?_.NaN:this.isNegative()?this.negate():new _(this)},isPositive:function(){return this.hi>0||0===this.hi&&this.lo>0},lt:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<t.lo},add:function(){if(arguments[0]instanceof _){var t=arguments[0];return _.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var e=arguments[0];return _.copy(this).selfAdd(e)}},init:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.hi=t,this.lo=0}else if(arguments[0]instanceof _){var e=arguments[0];this.hi=e.hi,this.lo=e.lo}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.hi=n,this.lo=i}},gt:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>t.lo},isNegative:function(){return this.hi<0||0===this.hi&&this.lo<0},trunc:function(){return this.isNaN()?_.NaN:this.isPositive()?this.floor():this.ceil()},signum:function(){return this.hi>0?1:this.hi<0?-1:this.lo>0?1:this.lo<0?-1:0},interfaces_:function(){return[u,s,o]},getClass:function(){return _}}),_.sqr=function(t){return _.valueOf(t).selfMultiply(t)},_.valueOf=function(){if("string"==typeof arguments[0]){var t=arguments[0];return _.parse(t)}if("number"==typeof arguments[0]){var e=arguments[0];return new _(e)}},_.sqrt=function(t){return _.valueOf(t).sqrt()},_.parse=function(t){for(var e=0,n=t.length;O.isWhitespace(t.charAt(e));)e++;var i=!1;if(n>e){var r=t.charAt(e);"-"!==r&&"+"!==r||(e++,"-"===r&&(i=!0))}for(var s=new _,o=0,a=0,u=0;;){if(e>=n)break;var l=t.charAt(e);if(e++,O.isDigit(l)){var h=l-"0";s.selfMultiply(_.TEN),s.selfAdd(h),o++}else{if("."!==l){if("e"===l||"E"===l){var c=t.substring(e);try{u=b.parseInt(c)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+c+" in string "+t):e}finally{}break}throw new NumberFormatException("Unexpected character '"+l+"' at position "+e+" in string "+t)}a=o}}var f=s,g=o-a-u;if(0===g)f=s;else if(g>0){var d=_.TEN.pow(g);f=s.divide(d)}else if(0>g){var d=_.TEN.pow(-g);f=s.multiply(d)}return i?f.negate():f},_.createNaN=function(){return new _(r.NaN,r.NaN)},_.copy=function(t){return new _(t)},_.magnitude=function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),i=Math.trunc(Math.floor(n)),r=Math.pow(10,i);return e>=10*r&&(i+=1),i},_.stringOfChar=function(t,e){for(var n=new P,i=0;e>i;i++)n.append(t);return n.toString()},_.PI=new _(3.141592653589793,1.2246467991473532e-16),_.TWO_PI=new _(6.283185307179586,2.4492935982947064e-16),_.PI_2=new _(1.5707963267948966,6.123233995736766e-17),_.E=new _(2.718281828459045,1.4456468917292502e-16),_.NaN=new _(r.NaN,r.NaN),_.EPS=1.23259516440783e-32,_.SPLIT=134217729,_.MAX_PRINT_DIGITS=32,_.TEN=_.valueOf(10),_.ONE=_.valueOf(1),_.SCI_NOT_EXPONENT_CHAR="E",_.SCI_NOT_ZERO="0.0E0",e(M.prototype,{interfaces_:function(){return[]},getClass:function(){return M}}),M.orientationIndex=function(t,e,n){var i=M.orientationIndexFilter(t,e,n);if(1>=i)return i;var r=_.valueOf(e.x).selfAdd(-t.x),s=_.valueOf(e.y).selfAdd(-t.y),o=_.valueOf(n.x).selfAdd(-e.x),a=_.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum()},M.signOfDet2x2=function(t,e,n,i){var r=t.multiply(i).selfSubtract(e.multiply(n));return r.signum()},M.intersection=function(t,e,n,i){var r=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(e.x).selfSubtract(t.x)),s=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(e.y).selfSubtract(t.y)),o=r.subtract(s),a=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),u=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),l=a.subtract(u),h=l.selfDivide(o).doubleValue(),c=_.valueOf(t.x).selfAdd(_.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),f=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),d=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),p=f.subtract(d),v=p.selfDivide(o).doubleValue(),m=_.valueOf(n.y).selfAdd(_.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();return new g(c,m)},M.orientationIndexFilter=function(t,e,n){var i=null,r=(t.x-n.x)*(e.y-n.y),s=(t.y-n.y)*(e.x-n.x),o=r-s;if(r>0){if(0>=s)return M.signum(o);i=r+s}else{if(!(0>r))return M.signum(o);if(s>=0)return M.signum(o);i=-r-s}var a=M.DP_SAFE_EPSILON*i;return o>=a||-o>=a?M.signum(o):2},M.signum=function(t){return t>0?1:0>t?-1:0},M.DP_SAFE_EPSILON=1e-15,e(D.prototype,{setOrdinate:function(t,e,n){},size:function(){},getOrdinate:function(t,e){},getCoordinate:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},getCoordinateCopy:function(t){},getDimension:function(){},getX:function(t){},clone:function(){},expandEnvelope:function(t){},copy:function(){},getY:function(t){},toCoordinateArray:function(){},interfaces_:function(){return[o]},getClass:function(){return D}}),D.X=0,D.Y=1,D.Z=2,D.M=3,A.arraycopy=function(t,e,n,i,r){for(var s=0,o=e;e+r>o;o++)n[i+s]=t[o],s++},A.getProperty=function(t){return{"line.separator":"\n"}[t]},e(F.prototype,{getY:function(){var t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getX:function(){var t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getCoordinate:function(){var t=new g;return t.x=this.getX(),t.y=this.getY(),t},interfaces_:function(){return[]},getClass:function(){return F}}),F.intersection=function(t,e,n,i){var s=t.y-e.y,o=e.x-t.x,a=t.x*e.y-e.x*t.y,u=n.y-i.y,l=i.x-n.x,h=n.x*i.y-i.x*n.y,c=o*h-l*a,f=u*a-s*h,d=s*l-u*o,p=c/d,v=f/d;if(r.isNaN(p)||r.isInfinite(p)||r.isNaN(v)||r.isInfinite(v))throw new w;return new g(p,v)},e(G.prototype,{create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){arguments[0]}else if(R(arguments[0],D)){arguments[0]}}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return G}}),e(q.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return q}}),e(B.prototype,{isGeometryCollection:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION},getFactory:function(){return this.factory},getGeometryN:function(t){return this},getArea:function(){return 0},isRectangle:function(){return!1},equals:function(){if(1===arguments.length){if(arguments[0]instanceof B){var t=arguments[0];return null===t?!1:this.equalsTopo(t)}if(arguments[0]instanceof Object){var e=arguments[0];if(!(e instanceof B))return!1;var n=e;return this.equalsExact(n)}}},equalsExact:function(t){return this===t||this.equalsExact(t,0)},geometryChanged:function(){this.apply(B.geometryChangedFilter)},geometryChangedAction:function(){this.envelope=null},equalsNorm:function(t){return null===t?!1:this.norm().equalsExact(t.norm())},getLength:function(){return 0},getNumGeometries:function(){return 1},compareTo:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(n,i)}},getUserData:function(){return this.userData},getSRID:function(){return this.SRID},getEnvelope:function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},checkNotGeometryCollection:function(t){if(t.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION)throw new i("This method does not support GeometryCollection arguments")},equal:function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n},norm:function(){var t=this.copy();return t.normalize(),t},getPrecisionModel:function(){return this.factory.getPrecisionModel()},getEnvelopeInternal:function(){return null===this.envelope&&(this.envelope=this.computeEnvelopeInternal()),new C(this.envelope)},setSRID:function(t){this.SRID=t},setUserData:function(t){this.userData=t},compare:function(t,e){for(var n=t.iterator(),i=e.iterator();n.hasNext()&&i.hasNext();){var r=n.next(),s=i.next(),o=r.compareTo(s);if(0!==o)return o}return n.hasNext()?1:i.hasNext()?-1:0},hashCode:function(){return this.getEnvelopeInternal().hashCode()},isGeometryCollectionOrDerived:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===B.SORTINDEX_MULTIPOINT||this.getSortIndex()===B.SORTINDEX_MULTILINESTRING||this.getSortIndex()===B.SORTINDEX_MULTIPOLYGON},interfaces_:function(){return[o,s,u]},getClass:function(){return B}}),B.hasNonEmptyElements=function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1},B.hasNullElements=function(t){for(var e=0;e<t.length;e++)if(null===t[e])return!0;return!1},B.serialVersionUID=0x799ea46522854c00,B.SORTINDEX_POINT=0,B.SORTINDEX_MULTIPOINT=1,B.SORTINDEX_LINESTRING=2,B.SORTINDEX_LINEARRING=3,B.SORTINDEX_MULTILINESTRING=4,B.SORTINDEX_POLYGON=5,B.SORTINDEX_MULTIPOLYGON=6,B.SORTINDEX_GEOMETRYCOLLECTION=7,B.geometryChangedFilter={interfaces_:function(){return[q]},filter:function(t){t.geometryChangedAction()}},e(z.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return z}}),e(V.prototype,{isInBoundary:function(t){},interfaces_:function(){return[]},getClass:function(){return V}}),e(k.prototype,{isInBoundary:function(t){return t%2===1},interfaces_:function(){return[V]},getClass:function(){return k}}),e(Y.prototype,{isInBoundary:function(t){return t>0},interfaces_:function(){return[V]},getClass:function(){return Y}}),e(U.prototype,{isInBoundary:function(t){return t>1},interfaces_:function(){return[V]},getClass:function(){return U}}),e(X.prototype,{isInBoundary:function(t){return 1===t},interfaces_:function(){return[V]},getClass:function(){return X}}),V.Mod2BoundaryNodeRule=k,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=X,V.MOD2_BOUNDARY_RULE=new k,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new X,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE,e(H.prototype,{interfaces_:function(){return[]},getClass:function(){return H}}),H.isRing=function(t){return t.length<4?!1:!!t[0].equals2D(t[t.length-1])},H.ptNotInList=function(t,e){for(var n=0;n<t.length;n++){var i=t[n];if(H.indexOf(i,e)<0)return i}return null},H.scroll=function(t,e){var n=H.indexOf(e,t);if(0>n)return null;var i=new Array(t.length).fill(null);A.arraycopy(t,n,i,0,t.length-n),A.arraycopy(t,0,i,t.length-n,n),A.arraycopy(i,0,t,0,t.length)},H.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];if(i===r)return!0;if(null===i||null===r)return!1;if(i.length!==r.length)return!1;for(var n=0;n<i.length;n++)if(0!==s.compare(i[n],r[n]))return!1;return!0}},H.intersection=function(t,e){for(var n=new N,i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()},H.hasRepeatedPoints=function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1},H.removeRepeatedPoints=function(t){if(!H.hasRepeatedPoints(t))return t;var e=new N(t,!1);return e.toCoordinateArray()},H.reverse=function(t){for(var e=t.length-1,n=Math.trunc(e/2),i=0;n>=i;i++){var r=t[i];t[i]=t[e-i],t[e-i]=r}},H.removeNull=function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var i=new Array(e).fill(null);if(0===e)return i;for(var r=0,n=0;n<t.length;n++)null!==t[n]&&(i[r++]=t[n]);return i},H.copyDeep=function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length)for(var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=arguments[4],n=0;a>n;n++)s[o+n]=new g(i[r+n])},H.isEqualReversed=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[t.length-n-1];if(0!==i.compareTo(r))return!1}return!0},H.envelope=function(t){for(var e=new C,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e},H.toCoordinateArray=function(t){return t.toArray(H.coordArrayType)},H.atLeastNCoordinatesOrNothing=function(t,e){return e.length>=t?e:[]},H.indexOf=function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1},H.increasingDirection=function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1},H.compare=function(t,e){for(var n=0;n<t.length&&n<e.length;){var i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0},H.minCoordinate=function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e},H.extract=function(t,e,n){e=T.clamp(e,0,t.length),n=T.clamp(n,-1,t.length);var i=n-e+1;0>n&&(i=0),e>=t.length&&(i=0),e>n&&(i=0);var r=new Array(i).fill(null);if(0===i)return r;for(var s=0,o=e;n>=o;o++)r[s++]=t[o];return r},e(W.prototype,{compare:function(t,e){var n=t,i=e;return H.compare(n,i)},interfaces_:function(){return[a]},getClass:function(){return W}}),e(j.prototype,{compare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;var r=H.compare(n,i),s=H.isEqualReversed(n,i);return s?0:r},OLDcompare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;for(var r=H.increasingDirection(n),s=H.increasingDirection(i),o=r>0?0:n.length-1,a=s>0?0:n.length-1,u=0;u<n.length;u++){var l=n[o].compareTo(i[a]);if(0!==l)return l;o+=r,a+=s}return 0},interfaces_:function(){return[a]},getClass:function(){return j}}),H.ForwardComparator=W,H.BidirectionalComparator=j,H.coordArrayType=new Array(0).fill(null),K.prototype.get=function(){},K.prototype.put=function(){},K.prototype.size=function(){},K.prototype.values=function(){},K.prototype.entrySet=function(){},Z.prototype=new K,Q.prototype=new v,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(i===t)return!0}return!1},J.prototype.add=function(t){return this.contains(t)?!1:(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new javascript.util.OperationNotSupported},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new Js(this)};var Js=function(t){this.hashSet_=t,this.position_=0};Js.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new x;return this.hashSet_.array_[this.position_++]},Js.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},Js.prototype.remove=function(){throw new E};var $s=0,to=1;rt.prototype=new Z,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(0>n)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,i,r=this.root_;do if(n=r,i=t.compareTo(r.key),0>i)r=r.left;else{if(!(i>0)){var s=r.value;return r.value=e,s}r=r.right}while(null!==r);var o={key:t,left:null,right:null,value:e,parent:n,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}};return 0>i?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){for(t.color=to;null!=t&&t!=this.root_&&t.parent.color==to;)if(tt(t)==nt(tt(tt(t)))){var e=it(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==it(tt(t))&&(t=tt(t),this.rotateLeft(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateRight(tt(tt(t))))}else{var e=nt(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==nt(tt(t))&&(t=tt(t),this.rotateRight(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateLeft(tt(tt(t))))}this.root_.color=$s},rt.prototype.values=function(){var t=new I,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left==t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right==t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){if(null===t)return null;if(null!==t.right){for(var e=t.right;null!==e.left;)e=e.left;return e}for(var e=t.parent,n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},e(st.prototype,{interfaces_:function(){return[]},getClass:function(){return st}}),ot.prototype=new Q,at.prototype=new ot,at.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(0===i.compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(1===i.compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new E},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new eo(this)};var eo=function(t){this.treeSet_=t,this.position_=0};eo.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new x;return this.treeSet_.array_[this.position_++]},eo.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},eo.prototype.remove=function(){throw new E},ut.sort=function(){var t,e,n,i,r=arguments[0];if(1===arguments.length)return i=function(t,e){return t.compareTo(e)},void r.sort(i);if(2===arguments.length)n=arguments[1],i=function(t,e){return n.compare(t,e)},r.sort(i);else{if(3===arguments.length){e=r.slice(arguments[1],arguments[2]),e.sort();var s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length));for(r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}if(4===arguments.length){for(e=r.slice(arguments[1],arguments[2]),n=arguments[3],i=function(t,e){return n.compare(t,e)},e.sort(i),s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length)),r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}}},ut.asList=function(t){for(var e=new I,n=0,i=t.length;i>n;n++)e.add(t[n]);return e},e(lt.prototype,{interfaces_:function(){return[]},getClass:function(){return lt}}),lt.toDimensionSymbol=function(t){switch(t){case lt.FALSE:return lt.SYM_FALSE;case lt.TRUE:return lt.SYM_TRUE;case lt.DONTCARE:return lt.SYM_DONTCARE;case lt.P:return lt.SYM_P;case lt.L:return lt.SYM_L;case lt.A:return lt.SYM_A}throw new i("Unknown dimension value: "+t)},lt.toDimensionValue=function(t){switch(O.toUpperCase(t)){case lt.SYM_FALSE:return lt.FALSE;case lt.SYM_TRUE:return lt.TRUE;case lt.SYM_DONTCARE:return lt.DONTCARE;case lt.SYM_P:return lt.P;case lt.SYM_L:return lt.L;case lt.SYM_A:return lt.A}throw new i("Unknown dimension symbol: "+t)},lt.P=0,lt.L=1,lt.A=2,lt.FALSE=-1,lt.TRUE=-2,lt.DONTCARE=-3,lt.SYM_FALSE="F",lt.SYM_TRUE="T",lt.SYM_DONTCARE="*",lt.SYM_P="0",lt.SYM_L="1",lt.SYM_A="2",e(ht.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return ht}}),e(ct.prototype,{filter:function(t,e){},isDone:function(){},isGeometryChanged:function(){},interfaces_:function(){return[]},getClass:function(){return ct}}),h(ft,B),e(ft.prototype,{computeEnvelopeInternal:function(){for(var t=new C,e=0;e<this.geometries.length;e++)t.expandToInclude(this.geometries[e].getEnvelopeInternal());return t},getGeometryN:function(t){return this.geometries[t]},getSortIndex:function(){return B.SORTINDEX_GEOMETRYCOLLECTION},getCoordinates:function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this.geometries.length;n++)for(var i=this.geometries[n].getCoordinates(),r=0;r<i.length;r++)e++,t[e]=i[r];return t},getArea:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getArea();return t},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.geometries.length!==n.geometries.length)return!1;for(var i=0;i<this.geometries.length;i++)if(!this.geometries[i].equalsExact(n.geometries[i],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<this.geometries.length;t++)this.geometries[t].normalize();ut.sort(this.geometries)},getCoordinate:function(){return this.isEmpty()?null:this.geometries[0].getCoordinate()},getBoundaryDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getBoundaryDimension());return t},getDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getDimension());return t},getLength:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getLength();return t},getNumPoints:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getNumPoints();return t},getNumGeometries:function(){return this.geometries.length},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createGeometryCollection(e)},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=new at(ut.asList(this.geometries)),n=new at(ut.asList(t.geometries));return this.compare(e,n)}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s=i,o=this.getNumGeometries(),a=s.getNumGeometries(),u=0;o>u&&a>u;){var l=this.getGeometryN(u),h=s.getGeometryN(u),c=l.compareToSameClass(h,r);if(0!==c)return c;u++}return o>u?1:a>u?-1:0}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.geometries.length;e++)this.geometries[e].apply(t);else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.geometries.length)return null;for(var e=0;e<this.geometries.length&&(this.geometries[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(i)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(r)}},getBoundary:function(){return this.checkNotGeometryCollection(this),f.shouldNeverReachHere(),null},clone:function(){var t=B.prototype.clone.call(this);t.geometries=new Array(this.geometries.length).fill(null);for(var e=0;e<this.geometries.length;e++)t.geometries[e]=this.geometries[e].clone();return t},getGeometryType:function(){return"GeometryCollection"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new ft(t,this.factory)},isEmpty:function(){for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isEmpty())return!1;return!0},interfaces_:function(){return[]},getClass:function(){return ft}}),ft.serialVersionUID=-0x4f07bcb1f857d800,h(gt,ft),e(gt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTILINESTRING},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){if(this.isEmpty())return!1;for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isClosed())return!1;return!0},getDimension:function(){return 1},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[t-1-n]=this.geometries[n].reverse();return this.getFactory().createMultiLineString(e)},getBoundary:function(){return new dt(this).getBoundary()},getGeometryType:function(){return"MultiLineString"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new gt(t,this.factory)},interfaces_:function(){
return[st]},getClass:function(){return gt}}),gt.serialVersionUID=0x7155d2ab4afa8000,e(dt.prototype,{boundaryMultiLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();var e=this.computeBoundaryCoordinates(t);return 1===e.length?this.geomFact.createPoint(e[0]):this.geomFact.createMultiPointFromCoords(e)},getBoundary:function(){return this.geom instanceof St?this.boundaryLineString(this.geom):this.geom instanceof gt?this.boundaryMultiLineString(this.geom):this.geom.getBoundary()},boundaryLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){var e=this.bnRule.isInBoundary(2);return e?t.getStartPoint():this.geomFact.createMultiPoint()}return this.geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])},getEmptyMultiPoint:function(){return this.geomFact.createMultiPoint()},computeBoundaryCoordinates:function(t){var e=new I;this.endpointMap=new rt;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);0!==i.getNumPoints()&&(this.addEndpoint(i.getCoordinateN(0)),this.addEndpoint(i.getCoordinateN(i.getNumPoints()-1)))}for(var r=this.endpointMap.entrySet().iterator();r.hasNext();){var s=r.next(),o=s.getValue(),a=o.count;this.bnRule.isInBoundary(a)&&e.add(s.getKey())}return H.toCoordinateArray(e)},addEndpoint:function(t){var e=this.endpointMap.get(t);null===e&&(e=new pt,this.endpointMap.put(t,e)),e.count++},interfaces_:function(){return[]},getClass:function(){return dt}}),dt.getBoundary=function(){if(1===arguments.length){var t=arguments[0],e=new dt(t);return e.getBoundary()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new dt(n,i);return e.getBoundary()}},e(pt.prototype,{interfaces_:function(){return[]},getClass:function(){return pt}}),e(Nt.prototype,{interfaces_:function(){return[]},getClass:function(){return Nt}}),Nt.chars=function(t,e){for(var n=new Array(e).fill(null),i=0;e>i;i++)n[i]=t;return new String(n)},Nt.getStackTrace=function(){if(1===arguments.length){var t=arguments[0],e=new xt,n=new vt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s="",o=new mt(Nt.getStackTrace(i)),a=new It(o),u=0;r>u;u++)try{s+=a.readLine()+Nt.NEWLINE}catch(t){if(!(t instanceof Et))throw t;f.shouldNeverReachHere()}finally{}return s}},Nt.split=function(t,e){for(var n=e.length,i=new I,r=""+t,s=r.indexOf(e);s>=0;){var o=r.substring(0,s);i.add(o),r=r.substring(s+n),s=r.indexOf(e)}r.length>0&&i.add(r);for(var a=new Array(i.size()).fill(null),u=0;u<a.length;u++)a[u]=i.get(u);return a},Nt.toString=function(){if(1===arguments.length){var t=arguments[0];return Nt.SIMPLE_ORDINATE_FORMAT.format(t)}},Nt.spaces=function(t){return Nt.chars(" ",t)},Nt.NEWLINE=A.getProperty("line.separator"),Nt.SIMPLE_ORDINATE_FORMAT=new yt("0.#"),e(Ct.prototype,{interfaces_:function(){return[]},getClass:function(){return Ct}}),Ct.copyCoord=function(t,e,n,i){for(var r=Math.min(t.getDimension(),n.getDimension()),s=0;r>s;s++)n.setOrdinate(i,s,t.getOrdinate(e,s))},Ct.isRing=function(t){var e=t.size();return 0===e?!0:3>=e?!1:t.getOrdinate(0,D.X)===t.getOrdinate(e-1,D.X)&&t.getOrdinate(0,D.Y)===t.getOrdinate(e-1,D.Y)},Ct.isEqual=function(t,e){var n=t.size(),i=e.size();if(n!==i)return!1;for(var s=Math.min(t.getDimension(),e.getDimension()),o=0;n>o;o++)for(var a=0;s>a;a++){var u=t.getOrdinate(o,a),l=e.getOrdinate(o,a);if(!(t.getOrdinate(o,a)===e.getOrdinate(o,a)||r.isNaN(u)&&r.isNaN(l)))return!1}return!0},Ct.extend=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();if(Ct.copy(e,0,i,0,r),r>0)for(var s=r;n>s;s++)Ct.copy(e,r-1,i,s,1);return i},Ct.reverse=function(t){for(var e=t.size()-1,n=Math.trunc(e/2),i=0;n>=i;i++)Ct.swap(t,i,e-i)},Ct.swap=function(t,e,n){if(e===n)return null;for(var i=0;i<t.getDimension();i++){var r=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,r)}},Ct.copy=function(t,e,n,i,r){for(var s=0;r>s;s++)Ct.copyCoord(t,e+s,n,i+s)},Ct.toString=function(){if(1===arguments.length){var t=arguments[0],e=t.size();if(0===e)return"()";var n=t.getDimension(),i=new P;i.append("(");for(var r=0;e>r;r++){r>0&&i.append(" ");for(var s=0;n>s;s++)s>0&&i.append(","),i.append(Nt.toString(t.getOrdinate(r,s)))}return i.append(")"),i.toString()}},Ct.ensureValidRing=function(t,e){var n=e.size();if(0===n)return e;if(3>=n)return Ct.createClosedRing(t,e,4);var i=e.getOrdinate(0,D.X)===e.getOrdinate(n-1,D.X)&&e.getOrdinate(0,D.Y)===e.getOrdinate(n-1,D.Y);return i?e:Ct.createClosedRing(t,e,n+1)},Ct.createClosedRing=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();Ct.copy(e,0,i,0,r);for(var s=r;n>s;s++)Ct.copy(e,0,i,s,1);return i},h(St,B),e(St.prototype,{computeEnvelopeInternal:function(){return this.isEmpty()?new C:this.points.expandEnvelope(new C)},isRing:function(){return this.isClosed()&&this.isSimple()},getSortIndex:function(){return B.SORTINDEX_LINESTRING},getCoordinates:function(){return this.points.toCoordinateArray()},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.points.size()!==n.points.size())return!1;for(var i=0;i<this.points.size();i++)if(!this.equal(this.points.getCoordinate(i),n.points.getCoordinate(i),e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<Math.trunc(this.points.size()/2);t++){var e=this.points.size()-1-t;if(!this.points.getCoordinate(t).equals(this.points.getCoordinate(e)))return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e))>0&&Ct.reverse(this.points),null}},getCoordinate:function(){return this.isEmpty()?null:this.points.getCoordinate(0)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){return this.isEmpty()?!1:this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},getEndPoint:function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},getDimension:function(){return 1},getLength:function(){return he.computeLength(this.points)},getNumPoints:function(){return this.points.size()},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLineString(t);return e},compareToSameClass:function(){if(1===arguments.length){for(var t=arguments[0],e=t,n=0,i=0;n<this.points.size()&&i<e.points.size();){var r=this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));if(0!==r)return r;n++,i++}return n<this.points.size()?1:i<e.points.size()?-1:0}if(2===arguments.length){var s=arguments[0],o=arguments[1],e=s;return o.compare(this.points,e.points)}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.points.size();e++)t.filter(this.points.getCoordinate(e));else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.points.size())return null;for(var e=0;e<this.points.size()&&(n.filter(this.points,e),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this)}},getBoundary:function(){return new dt(this).getBoundary()},isEquivalentClass:function(t){return t instanceof St},clone:function(){var t=B.prototype.clone.call(this);return t.points=this.points.clone(),t},getCoordinateN:function(t){return this.points.getCoordinate(t)},getGeometryType:function(){return"LineString"},copy:function(){return new St(this.points.copy(),this.factory)},getCoordinateSequence:function(){return this.points},isEmpty:function(){return 0===this.points.size()},init:function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new i("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this.points=t},isCoordinate:function(t){for(var e=0;e<this.points.size();e++)if(this.points.getCoordinate(e).equals(t))return!0;return!1},getStartPoint:function(){return this.isEmpty()?null:this.getPointN(0)},getPointN:function(t){return this.getFactory().createPoint(this.points.getCoordinate(t))},interfaces_:function(){return[st]},getClass:function(){return St}}),St.serialVersionUID=0x2b2b51ba435c8e00,e(wt.prototype,{interfaces_:function(){return[]},getClass:function(){return wt}}),h(Lt,B),e(Lt.prototype,{computeEnvelopeInternal:function(){if(this.isEmpty())return new C;var t=new C;return t.expandToInclude(this.coordinates.getX(0),this.coordinates.getY(0)),t},getSortIndex:function(){return B.SORTINDEX_POINT},getCoordinates:function(){return this.isEmpty()?[]:[this.getCoordinate()]},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?this.isEmpty()&&t.isEmpty()?!0:this.isEmpty()!==t.isEmpty()?!1:this.equal(t.getCoordinate(),this.getCoordinate(),e):!1}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){},getCoordinate:function(){return 0!==this.coordinates.size()?this.coordinates.getCoordinate(0):null},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getNumPoints:function(){return this.isEmpty()?0:1},reverse:function(){return this.copy()},getX:function(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getCoordinate().compareTo(e.getCoordinate())}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return i.compare(this.coordinates,e.coordinates)}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(R(arguments[0],ct)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this.coordinates,0),e.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var n=arguments[0];n.filter(this)}else if(R(arguments[0],q)){var i=arguments[0];i.filter(this)}},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},clone:function(){var t=B.prototype.clone.call(this);return t.coordinates=this.coordinates.clone(),t},getGeometryType:function(){return"Point"},copy:function(){return new Lt(this.coordinates.copy(),this.factory)},getCoordinateSequence:function(){return this.coordinates},getY:function(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y},isEmpty:function(){return 0===this.coordinates.size()},init:function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),f.isTrue(t.size()<=1),this.coordinates=t},isSimple:function(){return!0},interfaces_:function(){return[wt]},getClass:function(){return Lt}}),Lt.serialVersionUID=0x44077bad161cbc00,e(Rt.prototype,{interfaces_:function(){return[]},getClass:function(){return Rt}}),h(Tt,B),e(Tt.prototype,{computeEnvelopeInternal:function(){return this.shell.getEnvelopeInternal()},getSortIndex:function(){return B.SORTINDEX_POLYGON},getCoordinates:function(){if(this.isEmpty())return[];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this.shell.getCoordinates(),i=0;i<n.length;i++)e++,t[e]=n[i];for(var r=0;r<this.holes.length;r++)for(var s=this.holes[r].getCoordinates(),o=0;o<s.length;o++)e++,t[e]=s[o];return t},getArea:function(){var t=0;t+=Math.abs(he.signedArea(this.shell.getCoordinateSequence()));for(var e=0;e<this.holes.length;e++)t-=Math.abs(he.signedArea(this.holes[e].getCoordinateSequence()));return t},isRectangle:function(){if(0!==this.getNumInteriorRing())return!1;if(null===this.shell)return!1;if(5!==this.shell.getNumPoints())return!1;for(var t=this.shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;5>n;n++){var i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;var r=t.getY(n);if(r!==e.getMinY()&&r!==e.getMaxY())return!1}for(var s=t.getX(0),o=t.getY(0),n=1;4>=n;n++){var i=t.getX(n),r=t.getY(n),a=i!==s,u=r!==o;if(a===u)return!1;s=i,o=r}return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t,i=this.shell,r=n.shell;if(!i.equalsExact(r,e))return!1;if(this.holes.length!==n.holes.length)return!1;for(var s=0;s<this.holes.length;s++)if(!this.holes[s].equalsExact(n.holes[s],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){if(0===arguments.length){this.normalize(this.shell,!0);for(var t=0;t<this.holes.length;t++)this.normalize(this.holes[t],!1);ut.sort(this.holes)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var i=new Array(e.getCoordinates().length-1).fill(null);A.arraycopy(e.getCoordinates(),0,i,0,i.length);var r=H.minCoordinate(e.getCoordinates());H.scroll(i,r),A.arraycopy(i,0,e.getCoordinates(),0,i.length),e.getCoordinates()[i.length]=i[0],he.isCCW(e.getCoordinates())===n&&H.reverse(e.getCoordinates())}},getCoordinate:function(){return this.shell.getCoordinate()},getNumInteriorRing:function(){return this.holes.length},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},getLength:function(){var t=0;t+=this.shell.getLength();for(var e=0;e<this.holes.length;e++)t+=this.holes[e].getLength();return t},getNumPoints:function(){for(var t=this.shell.getNumPoints(),e=0;e<this.holes.length;e++)t+=this.holes[e].getNumPoints();return t},reverse:function(){var t=this.copy();t.shell=this.shell.copy().reverse(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].copy().reverse();return t},convexHull:function(){return this.getExteriorRing().convexHull()},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=this.shell,n=t.shell;return e.compareToSameClass(n)}if(2===arguments.length){var i=arguments[0],r=arguments[1],s=i,e=this.shell,n=s.shell,o=e.compareToSameClass(n,r);if(0!==o)return o;for(var a=this.getNumInteriorRing(),u=s.getNumInteriorRing(),l=0;a>l&&u>l;){var h=this.getInteriorRingN(l),c=s.getInteriorRingN(l),f=h.compareToSameClass(c,r);if(0!==f)return f;l++}return a>l?1:u>l?-1:0}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];this.shell.apply(t);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(t)}else if(R(arguments[0],ct)){var n=arguments[0];if(this.shell.apply(n),!n.isDone())for(var e=0;e<this.holes.length&&(this.holes[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this),this.shell.apply(r);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(r)}},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this.holes.length+1).fill(null);t[0]=this.shell;for(var e=0;e<this.holes.length;e++)t[e+1]=this.holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)},clone:function(){var t=B.prototype.clone.call(this);t.shell=this.shell.clone(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].clone();return t},getGeometryType:function(){return"Polygon"},copy:function(){for(var t=this.shell.copy(),e=new Array(this.holes.length).fill(null),n=0;n<e.length;n++)e[n]=this.holes[n].copy();return new Tt(t,e,this.factory)},getExteriorRing:function(){return this.shell},isEmpty:function(){return this.shell.isEmpty()},getInteriorRingN:function(t){return this.holes[t]},interfaces_:function(){return[Rt]},getClass:function(){return Tt}}),Tt.serialVersionUID=-0x307ffefd8dc97200,h(Pt,ft),e(Pt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOINT},isValid:function(){return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.geometries[t].getCoordinate()}return ft.prototype.getCoordinate.apply(this,arguments)},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},getGeometryType:function(){return"MultiPoint"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Pt(t,this.factory)},interfaces_:function(){return[wt]},getClass:function(){return Pt}}),Pt.serialVersionUID=-0x6fb1ed4162e0fc00,h(bt,St),e(bt.prototype,{getSortIndex:function(){return B.SORTINDEX_LINEARRING},getBoundaryDimension:function(){return lt.FALSE},isClosed:function(){return this.isEmpty()?!0:St.prototype.isClosed.call(this)},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLinearRing(t);return e},validateConstruction:function(){if(!this.isEmpty()&&!St.prototype.isClosed.call(this))throw new i("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<bt.MINIMUM_VALID_SIZE)throw new i("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},getGeometryType:function(){return"LinearRing"},copy:function(){return new bt(this.points.copy(),this.factory)},interfaces_:function(){return[]},getClass:function(){return bt}}),bt.MINIMUM_VALID_SIZE=4,bt.serialVersionUID=-0x3b229e262367a600,h(Ot,ft),e(Ot.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOLYGON},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createMultiPolygon(e)},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new I,e=0;e<this.geometries.length;e++)for(var n=this.geometries[e],i=n.getBoundary(),r=0;r<i.getNumGeometries();r++)t.add(i.getGeometryN(r));var s=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s))},getGeometryType:function(){return"MultiPolygon"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Ot(t,this.factory)},interfaces_:function(){return[Rt]},getClass:function(){return Ot}}),Ot.serialVersionUID=-0x7a5aa1369171980,e(_t.prototype,{setCopyUserData:function(t){this.isUserDataCopied=t},edit:function(t,e){if(null===t)return null;var n=this.editInternal(t,e);return this.isUserDataCopied&&n.setUserData(t.getUserData()),n},editInternal:function(t,e){return null===this.factory&&(this.factory=t.getFactory()),t instanceof ft?this.editGeometryCollection(t,e):t instanceof Tt?this.editPolygon(t,e):t instanceof Lt?e.edit(t,this.factory):t instanceof St?e.edit(t,this.factory):(f.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)},editGeometryCollection:function(t,e){for(var n=e.edit(t,this.factory),i=new I,r=0;r<n.getNumGeometries();r++){var s=this.edit(n.getGeometryN(r),e);null===s||s.isEmpty()||i.add(s)}return n.getClass()===Pt?this.factory.createMultiPoint(i.toArray([])):n.getClass()===gt?this.factory.createMultiLineString(i.toArray([])):n.getClass()===Ot?this.factory.createMultiPolygon(i.toArray([])):this.factory.createGeometryCollection(i.toArray([]))},editPolygon:function(t,e){var n=e.edit(t,this.factory);if(null===n&&(n=this.factory.createPolygon(null)),n.isEmpty())return n;var i=this.edit(n.getExteriorRing(),e);if(null===i||i.isEmpty())return this.factory.createPolygon();for(var r=new I,s=0;s<n.getNumInteriorRing();s++){var o=this.edit(n.getInteriorRingN(s),e);null===o||o.isEmpty()||r.add(o)}return this.factory.createPolygon(i,r.toArray([]))},interfaces_:function(){return[]},getClass:function(){return _t}}),_t.GeometryEditorOperation=Mt,e(Dt.prototype,{edit:function(t,e){return t},interfaces_:function(){return[Mt]},getClass:function(){return Dt}}),e(At.prototype,{edit:function(t,e){if(t instanceof bt)return e.createLinearRing(this.editCoordinates(t.getCoordinates(),t));if(t instanceof St)return e.createLineString(this.editCoordinates(t.getCoordinates(),t));if(t instanceof Lt){var n=this.editCoordinates(t.getCoordinates(),t);return n.length>0?e.createPoint(n[0]):e.createPoint()}return t},interfaces_:function(){return[Mt]},getClass:function(){return At}}),e(Ft.prototype,{edit:function(t,e){return t instanceof bt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof St?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Lt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t},interfaces_:function(){return[Mt]},getClass:function(){return Ft}}),_t.NoOpGeometryOperation=Dt,_t.CoordinateOperation=At,_t.CoordinateSequenceOperation=Ft,e(Gt.prototype,{setOrdinate:function(t,e,n){switch(e){case D.X:this.coordinates[t].x=n;break;case D.Y:this.coordinates[t].y=n;break;case D.Z:this.coordinates[t].z=n;break;default:throw new i("invalid ordinateIndex")}},size:function(){return this.coordinates.length},getOrdinate:function(t,e){switch(e){case D.X:return this.coordinates[t].x;case D.Y:return this.coordinates[t].y;case D.Z:return this.coordinates[t].z}return r.NaN},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.coordinates[t]}if(2===arguments.length){var e=arguments[0],n=arguments[1];n.x=this.coordinates[e].x,n.y=this.coordinates[e].y,n.z=this.coordinates[e].z}},getCoordinateCopy:function(t){return new g(this.coordinates[t])},getDimension:function(){return this.dimension},getX:function(t){return this.coordinates[t].x},clone:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].clone();return new Gt(t,this.dimension)},expandEnvelope:function(t){for(var e=0;e<this.coordinates.length;e++)t.expandToInclude(this.coordinates[e]);return t},copy:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].copy();return new Gt(t,this.dimension)},toString:function(){if(this.coordinates.length>0){var t=new P(17*this.coordinates.length);t.append("("),t.append(this.coordinates[0]);for(var e=1;e<this.coordinates.length;e++)t.append(", "),t.append(this.coordinates[e]);return t.append(")"),t.toString()}return"()"},getY:function(t){return this.coordinates[t].y},toCoordinateArray:function(){return this.coordinates},interfaces_:function(){return[D,u]},getClass:function(){return Gt}}),Gt.serialVersionUID=-0xcb44a778db18e00,e(qt.prototype,{readResolve:function(){return qt.instance()},create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Gt(t)}if(R(arguments[0],D)){var e=arguments[0];return new Gt(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return i>3&&(i=3),2>i?new Gt(n):new Gt(n,i)}},interfaces_:function(){return[G,u]},getClass:function(){return qt}}),qt.instance=function(){return qt.instanceObject},qt.serialVersionUID=-0x38e49fa6cf6f2e00,qt.instanceObject=new qt;var no,io=Object.defineProperty,ro=zt({delete:kt,has:Xt,get:Yt,set:Ht,keys:jt,values:Kt,entries:Zt,forEach:$t,clear:Wt}),so="undefined"!=typeof Map&&Map.prototype.values?Map:ro;te.prototype=new K,te.prototype.get=function(t){return this.map_.get(t)||null},te.prototype.put=function(t,e){return this.map_.set(t,e),e},te.prototype.values=function(){for(var t=new I,e=this.map_.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t},te.prototype.entrySet=function(){var t=new J;return this.map_.entries().forEach(function(e){return t.add(e)}),t},te.prototype.size=function(){return this.map_.size()},e(ee.prototype,{equals:function(t){if(!(t instanceof ee))return!1;var e=t;return this.modelType===e.modelType&&this.scale===e.scale},compareTo:function(t){var e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return new b(n).compareTo(new b(i))},getScale:function(){return this.scale},isFloating:function(){return this.modelType===ee.FLOATING||this.modelType===ee.FLOATING_SINGLE},getType:function(){return this.modelType},toString:function(){var t="UNKNOWN";return this.modelType===ee.FLOATING?t="Floating":this.modelType===ee.FLOATING_SINGLE?t="Floating-Single":this.modelType===ee.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t},makePrecise:function(){if("number"==typeof arguments[0]){var t=arguments[0];if(r.isNaN(t))return t;if(this.modelType===ee.FLOATING_SINGLE){var e=t;return e}return this.modelType===ee.FIXED?Math.round(t*this.scale)/this.scale:t}if(arguments[0]instanceof g){var n=arguments[0];if(this.modelType===ee.FLOATING)return null;n.x=this.makePrecise(n.x),n.y=this.makePrecise(n.y)}},getMaximumSignificantDigits:function(){var t=16;return this.modelType===ee.FLOATING?t=16:this.modelType===ee.FLOATING_SINGLE?t=6:this.modelType===ee.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t},setScale:function(t){this.scale=Math.abs(t)},interfaces_:function(){return[u,s]},getClass:function(){return ee}}),ee.mostPrecise=function(t,e){return t.compareTo(e)>=0?t:e},e(ne.prototype,{readResolve:function(){return ne.nameToTypeMap.get(this.name)},toString:function(){return this.name},interfaces_:function(){return[u]},getClass:function(){return ne}}),ne.serialVersionUID=-552860263173159e4,ne.nameToTypeMap=new te,ee.Type=ne,ee.serialVersionUID=0x6bee6404e9a25c00,ee.FIXED=new ne("FIXED"),ee.FLOATING=new ne("FLOATING"),ee.FLOATING_SINGLE=new ne("FLOATING SINGLE"),ee.maximumPreciseValue=9007199254740992,e(ie.prototype,{toGeometry:function(t){return t.isNull()?this.createPoint(null):t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)},createLineString:function(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new St(e,this)}}},createMultiLineString:function(){if(0===arguments.length)return new gt(null,this);if(1===arguments.length){var t=arguments[0];return new gt(t,this)}},buildGeometry:function(t){for(var e=null,n=!1,i=!1,r=t.iterator();r.hasNext();){var s=r.next(),o=s.getClass();null===e&&(e=o),o!==e&&(n=!0),s.isGeometryCollectionOrDerived()&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(ie.toGeometryArray(t));var a=t.iterator().next(),u=t.size()>1;if(u){if(a instanceof Tt)return this.createMultiPolygon(ie.toPolygonArray(t));if(a instanceof St)return this.createMultiLineString(ie.toLineStringArray(t));if(a instanceof Lt)return this.createMultiPoint(ie.toPointArray(t));f.shouldNeverReachHere("Unhandled class: "+a.getClass().getName())}return a},createMultiPointFromCoords:function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)},createPoint:function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(R(arguments[0],D)){var e=arguments[0];return new Lt(e,this)}}},getCoordinateSequenceFactory:function(){return this.coordinateSequenceFactory},createPolygon:function(){if(0===arguments.length)return new Tt(null,null,this);if(1===arguments.length){if(R(arguments[0],D)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof bt){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];return new Tt(i,r,this)}},getSRID:function(){return this.SRID},createGeometryCollection:function(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){var t=arguments[0];return new ft(t,this)}},createGeometry:function(t){var e=new _t(this);return e.edit(t,{edit:function(){if(2===arguments.length){var t=arguments[0];arguments[1];return this.coordinateSequenceFactory.create(t)}}})},getPrecisionModel:function(){return this.precisionModel},createLinearRing:function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new bt(e,this)}}},createMultiPolygon:function(){if(0===arguments.length)return new Ot(null,this);if(1===arguments.length){var t=arguments[0];return new Ot(t,this)}},createMultiPoint:function(){if(0===arguments.length)return new Pt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Pt(t,this)}if(arguments[0]instanceof Array){var e=arguments[0];return this.createMultiPoint(null!==e?this.getCoordinateSequenceFactory().create(e):null)}if(R(arguments[0],D)){var n=arguments[0];if(null===n)return this.createMultiPoint(new Array(0).fill(null));for(var i=new Array(n.size()).fill(null),r=0;r<n.size();r++){var s=this.getCoordinateSequenceFactory().create(1,n.getDimension());Ct.copy(n,r,s,0,1),i[r]=this.createPoint(s)}return this.createMultiPoint(i)}}},interfaces_:function(){return[u]},getClass:function(){return ie}}),ie.toMultiPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toGeometryArray=function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.getDefaultCoordinateSequenceFactory=function(){return qt.instance()},ie.toMultiLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toMultiPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLinearRingArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},ie.serialVersionUID=-0x5ea75f2051eeb400;var oo={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};e(re.prototype,{read:function(t){var e,n,i;t=t.replace(/[\n\r]/g," ");var r=oo.typeStr.exec(t);if(-1!==t.search("EMPTY")&&(r=oo.emptyTypeStr.exec(t),r[2]=void 0),r&&(n=r[1].toLowerCase(),i=r[2],uo[n]&&(e=uo[n].apply(this,[i]))),void 0===e)throw new Error("Could not parse WKT "+t);return e},write:function(t){return this.extractGeometry(t)},extractGeometry:function(t){var e=t.getGeometryType().toLowerCase();if(!ao[e])return null;var n,i=e.toUpperCase();return n=t.isEmpty()?i+" EMPTY":i+"("+ao[e].apply(this,[t])+")"}});var ao={coordinate:function(t){return t.x+" "+t.y},point:function(t){
return ao.coordinate.call(this,t.coordinates.coordinates[0])},multipoint:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.point.apply(this,[t.geometries[n]])+")");return e.join(",")},linestring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},linearring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},multilinestring:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.geometries[n]])+")");return e.join(",")},polygon:function(t){var e=[];e.push("("+ao.linestring.apply(this,[t.shell])+")");for(var n=0,i=t.holes.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.holes[n]])+")");return e.join(",")},multipolygon:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.polygon.apply(this,[t.geometries[n]])+")");return e.join(",")},geometrycollection:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push(this.extractGeometry(t.geometries[n]));return e.join(",")}},uo={point:function(t){if(void 0===t)return this.geometryFactory.createPoint();var e=t.trim().split(oo.spaces);return this.geometryFactory.createPoint(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])))},multipoint:function(t){if(void 0===t)return this.geometryFactory.createMultiPoint();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.point.apply(this,[e]));return this.geometryFactory.createMultiPoint(i)},linestring:function(t){if(void 0===t)return this.geometryFactory.createLineString();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i)},linearring:function(t){if(void 0===t)return this.geometryFactory.createLinearRing();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i)},multilinestring:function(t){if(void 0===t)return this.geometryFactory.createMultiLineString();for(var e,n=t.trim().split(oo.parenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.linestring.apply(this,[e]));return this.geometryFactory.createMultiLineString(i)},polygon:function(t){if(void 0===t)return this.geometryFactory.createPolygon();for(var e,n,i,r,s=t.trim().split(oo.parenComma),o=[],a=0,u=s.length;u>a;++a)e=s[a].replace(oo.trimParens,"$1"),n=uo.linestring.apply(this,[e]),i=this.geometryFactory.createLinearRing(n.points),0===a?r=i:o.push(i);return this.geometryFactory.createPolygon(r,o)},multipolygon:function(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();for(var e,n=t.trim().split(oo.doubleParenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.polygon.apply(this,[e]));return this.geometryFactory.createMultiPolygon(i)},geometrycollection:function(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();t=t.replace(/,\s*([A-Za-z])/g,"|$1");for(var e=t.trim().split("|"),n=[],i=0,r=e.length;r>i;++i)n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n)}};e(se.prototype,{write:function(t){return this.parser.write(t)}}),e(se,{toLineString:function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}),e(oe.prototype,{getIndexAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intLineIndex[t][e]},getTopologySummary:function(){var t=new P;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()},computeIntersection:function(t,e,n,i){this.inputLines[0][0]=t,this.inputLines[0][1]=e,this.inputLines[1][0]=n,this.inputLines[1][1]=i,this.result=this.computeIntersect(t,e,n,i)},getIntersectionNum:function(){return this.result},computeIntLineIndex:function(){if(0===arguments.length)null===this.intLineIndex&&(this.intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0],e=this.getEdgeDistance(t,0),n=this.getEdgeDistance(t,1);e>n?(this.intLineIndex[t][0]=0,this.intLineIndex[t][1]=1):(this.intLineIndex[t][0]=1,this.intLineIndex[t][1]=0)}},isProper:function(){return this.hasIntersection()&&this._isProper},setPrecisionModel:function(t){this.precisionModel=t},isInteriorIntersection:function(){if(0===arguments.length)return this.isInteriorIntersection(0)?!0:!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this.result;e++)if(!this.intPt[e].equals2D(this.inputLines[t][0])&&!this.intPt[e].equals2D(this.inputLines[t][1]))return!0;return!1}},getIntersection:function(t){return this.intPt[t]},isEndPoint:function(){return this.hasIntersection()&&!this._isProper},hasIntersection:function(){return this.result!==oe.NO_INTERSECTION},getEdgeDistance:function(t,e){var n=oe.computeEdgeDistance(this.intPt[e],this.inputLines[t][0],this.inputLines[t][1]);return n},isCollinear:function(){return this.result===oe.COLLINEAR_INTERSECTION},toString:function(){return se.toLineString(this.inputLines[0][0],this.inputLines[0][1])+" - "+se.toLineString(this.inputLines[1][0],this.inputLines[1][1])+this.getTopologySummary()},getEndpoint:function(t,e){return this.inputLines[t][e]},isIntersection:function(t){for(var e=0;e<this.result;e++)if(this.intPt[e].equals2D(t))return!0;return!1},getIntersectionAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intPt[this.intLineIndex[t][e]]},interfaces_:function(){return[]},getClass:function(){return oe}}),oe.computeEdgeDistance=function(t,e,n){var i=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),s=-1;if(t.equals(e))s=0;else if(t.equals(n))s=i>r?i:r;else{var o=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);s=i>r?o:a,0!==s||t.equals(e)||(s=Math.max(o,a))}return f.isTrue(!(0===s&&!t.equals(e)),"Bad distance calculation"),s},oe.nonRobustComputeEdgeDistance=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=Math.sqrt(i*i+r*r);return f.isTrue(!(0===s&&!t.equals(e)),"Invalid distance calculation"),s},oe.DONT_INTERSECT=0,oe.DO_INTERSECT=1,oe.COLLINEAR=2,oe.NO_INTERSECTION=0,oe.POINT_INTERSECTION=1,oe.COLLINEAR_INTERSECTION=2,h(ae,oe),e(ae.prototype,{isInSegmentEnvelopes:function(t){var e=new C(this.inputLines[0][0],this.inputLines[0][1]),n=new C(this.inputLines[1][0],this.inputLines[1][1]);return e.contains(t)&&n.contains(t)},computeIntersection:function(){if(3!==arguments.length)return oe.prototype.computeIntersection.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2];return this._isProper=!1,C.intersects(e,n,t)&&0===he.orientationIndex(e,n,t)&&0===he.orientationIndex(n,e,t)?(this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this.result=oe.POINT_INTERSECTION,null):void(this.result=oe.NO_INTERSECTION)},normalizeToMinimum:function(t,e,n,i,r){r.x=this.smallestInAbsValue(t.x,e.x,n.x,i.x),r.y=this.smallestInAbsValue(t.y,e.y,n.y,i.y),t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},safeHCoordinateIntersection:function(t,e,n,i){var r=null;try{r=F.intersection(t,e,n,i)}catch(s){if(!(s instanceof w))throw s;r=ae.nearestEndpoint(t,e,n,i)}finally{}return r},intersection:function(t,e,n,i){var r=this.intersectionWithNormalization(t,e,n,i);return this.isInSegmentEnvelopes(r)||(r=new g(ae.nearestEndpoint(t,e,n,i))),null!==this.precisionModel&&this.precisionModel.makePrecise(r),r},smallestInAbsValue:function(t,e,n,i){var r=t,s=Math.abs(r);return Math.abs(e)<s&&(r=e,s=Math.abs(e)),Math.abs(n)<s&&(r=n,s=Math.abs(n)),Math.abs(i)<s&&(r=i),r},checkDD:function(t,e,n,i,r){var s=M.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(s);A.out.println("DD in env = "+o+"  --------------------- "+s),r.distance(s)>1e-4&&A.out.println("Distance = "+r.distance(s))},intersectionWithNormalization:function(t,e,n,i){var r=new g(t),s=new g(e),o=new g(n),a=new g(i),u=new g;this.normalizeToEnvCentre(r,s,o,a,u);var l=this.safeHCoordinateIntersection(r,s,o,a);return l.x+=u.x,l.y+=u.y,l},computeCollinearIntersection:function(t,e,n,i){var r=C.intersects(t,e,n),s=C.intersects(t,e,i),o=C.intersects(n,i,t),a=C.intersects(n,i,e);return r&&s?(this.intPt[0]=n,this.intPt[1]=i,oe.COLLINEAR_INTERSECTION):o&&a?(this.intPt[0]=t,this.intPt[1]=e,oe.COLLINEAR_INTERSECTION):r&&o?(this.intPt[0]=n,this.intPt[1]=t,!n.equals(t)||s||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):r&&a?(this.intPt[0]=n,this.intPt[1]=e,!n.equals(e)||s||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&o?(this.intPt[0]=i,this.intPt[1]=t,!i.equals(t)||r||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&a?(this.intPt[0]=i,this.intPt[1]=e,!i.equals(e)||r||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):oe.NO_INTERSECTION},normalizeToEnvCentre:function(t,e,n,i,r){var s=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,a=t.x>e.x?t.x:e.x,u=t.y>e.y?t.y:e.y,l=n.x<i.x?n.x:i.x,h=n.y<i.y?n.y:i.y,c=n.x>i.x?n.x:i.x,f=n.y>i.y?n.y:i.y,g=s>l?s:l,d=c>a?a:c,p=o>h?o:h,v=f>u?u:f,m=(g+d)/2,y=(p+v)/2;r.x=m,r.y=y,t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},computeIntersect:function(t,e,n,i){if(this._isProper=!1,!C.intersects(t,e,n,i))return oe.NO_INTERSECTION;var r=he.orientationIndex(t,e,n),s=he.orientationIndex(t,e,i);if(r>0&&s>0||0>r&&0>s)return oe.NO_INTERSECTION;var o=he.orientationIndex(n,i,t),a=he.orientationIndex(n,i,e);if(o>0&&a>0||0>o&&0>a)return oe.NO_INTERSECTION;var u=0===r&&0===s&&0===o&&0===a;return u?this.computeCollinearIntersection(t,e,n,i):(0===r||0===s||0===o||0===a?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this.intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this.intPt[0]=e:0===r?this.intPt[0]=new g(n):0===s?this.intPt[0]=new g(i):0===o?this.intPt[0]=new g(t):0===a&&(this.intPt[0]=new g(e))):(this._isProper=!0,this.intPt[0]=this.intersection(t,e,n,i)),oe.POINT_INTERSECTION)},interfaces_:function(){return[]},getClass:function(){return ae}}),ae.nearestEndpoint=function(t,e,n,i){var r=t,s=he.distancePointLine(t,n,i),o=he.distancePointLine(e,n,i);return s>o&&(s=o,r=e),o=he.distancePointLine(n,t,e),s>o&&(s=o,r=n),o=he.distancePointLine(i,t,e),s>o&&(s=o,r=i),r},e(ue.prototype,{interfaces_:function(){return[]},getClass:function(){return ue}}),ue.orientationIndex=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-e.x,o=n.y-e.y;return ue.signOfDet2x2(i,r,s,o)},ue.signOfDet2x2=function(t,e,n,i){var r=null,s=null,o=null,a=0;if(r=1,0===t||0===i)return 0===e||0===n?0:e>0?n>0?-r:r:n>0?r:-r;if(0===e||0===n)return i>0?t>0?r:-r:t>0?-r:r;if(e>0?i>0?i>=e||(r=-r,s=t,t=n,n=s,s=e,e=i,i=s):-i>=e?(r=-r,n=-n,i=-i):(s=t,t=-n,n=s,s=e,e=-i,i=s):i>0?i>=-e?(r=-r,t=-t,e=-e):(s=-t,t=n,n=s,s=-e,e=i,i=s):e>=i?(t=-t,e=-e,n=-n,i=-i):(r=-r,s=-t,t=-n,n=s,s=-e,e=-i,i=s),t>0){if(!(n>0))return r;if(!(n>=t))return r}else{if(n>0)return-r;if(!(t>=n))return-r;r=-r,t=-t,n=-n}for(;;){if(a+=1,o=Math.floor(n/t),n-=o*t,i-=o*e,0>i)return-r;if(i>e)return r;if(t>n+n){if(i+i>e)return r}else{if(e>i+i)return-r;n=t-n,i=e-i,r=-r}if(0===i)return 0===n?0:-r;if(0===n)return r;if(o=Math.floor(t/n),t-=o*n,e-=o*i,0>e)return r;if(e>i)return-r;if(n>t+t){if(e+e>i)return-r}else{if(i>e+e)return r;t=n-t,e=i-e,r=-r}if(0===e)return 0===t?0:r;if(0===t)return-r}},e(le.prototype,{countSegment:function(t,e){if(t.x<this.p.x&&e.x<this.p.x)return null;if(this.p.x===e.x&&this.p.y===e.y)return this.isPointOnSegment=!0,null;if(t.y===this.p.y&&e.y===this.p.y){var n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this.p.x>=n&&this.p.x<=i&&(this.isPointOnSegment=!0),null}if(t.y>this.p.y&&e.y<=this.p.y||e.y>this.p.y&&t.y<=this.p.y){var r=t.x-this.p.x,s=t.y-this.p.y,o=e.x-this.p.x,a=e.y-this.p.y,u=ue.signOfDet2x2(r,s,o,a);if(0===u)return this.isPointOnSegment=!0,null;s>a&&(u=-u),u>0&&this.crossingCount++}},isPointInPolygon:function(){return this.getLocation()!==L.EXTERIOR},getLocation:function(){return this.isPointOnSegment?L.BOUNDARY:this.crossingCount%2===1?L.INTERIOR:L.EXTERIOR},isOnSegment:function(){return this.isPointOnSegment},interfaces_:function(){return[]},getClass:function(){return le}}),le.locatePointInRing=function(){if(arguments[0]instanceof g&&R(arguments[1],D)){for(var t=arguments[0],e=arguments[1],n=new le(t),i=new g,r=new g,s=1;s<e.size();s++)if(e.getCoordinate(s,i),e.getCoordinate(s-1,r),n.countSegment(i,r),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){for(var o=arguments[0],a=arguments[1],n=new le(o),s=1;s<a.length;s++){var i=a[s],r=a[s-1];if(n.countSegment(i,r),n.isOnSegment())return n.getLocation()}return n.getLocation()}},e(he.prototype,{interfaces_:function(){return[]},getClass:function(){return he}}),he.orientationIndex=function(t,e,n){return M.orientationIndex(t,e,n)},he.signedArea=function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,i=1;i<t.length-1;i++){var r=t[i].x-n,s=t[i+1].y,o=t[i-1].y;e+=r*(o-s)}return e/2}if(R(arguments[0],D)){var a=arguments[0],u=a.size();if(3>u)return 0;var l=new g,h=new g,c=new g;a.getCoordinate(0,h),a.getCoordinate(1,c);var n=h.x;c.x-=n;for(var e=0,i=1;u-1>i;i++)l.y=h.y,h.x=c.x,h.y=c.y,a.getCoordinate(i+1,c),c.x-=n,e+=h.x*(l.y-c.y);return e/2}},he.distanceLineLine=function(t,e,n,i){if(t.equals(e))return he.distancePointLine(t,n,i);if(n.equals(i))return he.distancePointLine(i,t,e);var r=!1;if(C.intersects(t,e,n,i)){var s=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===s)r=!0;else{var o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),a=(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y),u=a/s,l=o/s;(0>l||l>1||0>u||u>1)&&(r=!0)}}else r=!0;return r?T.min(he.distancePointLine(t,n,i),he.distancePointLine(e,n,i),he.distancePointLine(n,t,e),he.distancePointLine(i,t,e)):0},he.isPointInRing=function(t,e){return he.locatePointInRing(t,e)!==L.EXTERIOR},he.computeLength=function(t){var e=t.size();if(1>=e)return 0;var n=0,i=new g;t.getCoordinate(0,i);for(var r=i.x,s=i.y,o=1;e>o;o++){t.getCoordinate(o,i);var a=i.x,u=i.y,l=a-r,h=u-s;n+=Math.sqrt(l*l+h*h),r=a,s=u}return n},he.isCCW=function(t){var e=t.length-1;if(3>e)throw new i("Ring has fewer than 4 points, so orientation cannot be determined");for(var n=t[0],r=0,s=1;e>=s;s++){var o=t[s];o.y>n.y&&(n=o,r=s)}var a=r;do a-=1,0>a&&(a=e);while(t[a].equals2D(n)&&a!==r);var u=r;do u=(u+1)%e;while(t[u].equals2D(n)&&u!==r);var l=t[a],h=t[u];if(l.equals2D(n)||h.equals2D(n)||l.equals2D(h))return!1;var c=he.computeOrientation(l,n,h),f=!1;return f=0===c?l.x>h.x:c>0},he.locatePointInRing=function(t,e){return le.locatePointInRing(t,e)},he.distancePointLinePerpendicular=function(t,e,n){var i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)},he.computeOrientation=function(t,e,n){return he.orientationIndex(t,e,n)},he.distancePointLine=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(0===e.length)throw new i("Line array must contain at least one vertex");for(var n=t.distance(e[0]),r=0;r<e.length-1;r++){var s=he.distancePointLine(t,e[r],e[r+1]);n>s&&(n=s)}return n}if(3===arguments.length){var o=arguments[0],a=arguments[1],u=arguments[2];if(a.x===u.x&&a.y===u.y)return o.distance(a);var l=(u.x-a.x)*(u.x-a.x)+(u.y-a.y)*(u.y-a.y),h=((o.x-a.x)*(u.x-a.x)+(o.y-a.y)*(u.y-a.y))/l;if(0>=h)return o.distance(a);if(h>=1)return o.distance(u);var c=((a.y-o.y)*(u.x-a.x)-(a.x-o.x)*(u.y-a.y))/l;return Math.abs(c)*Math.sqrt(l)}},he.isOnLine=function(t,e){for(var n=new ae,i=1;i<e.length;i++){var r=e[i-1],s=e[i];if(n.computeIntersection(t,r,s),n.hasIntersection())return!0}return!1},he.CLOCKWISE=-1,he.RIGHT=he.CLOCKWISE,he.COUNTERCLOCKWISE=1,he.LEFT=he.COUNTERCLOCKWISE,he.COLLINEAR=0,he.STRAIGHT=he.COLLINEAR,e(ce.prototype,{minX:function(){return Math.min(this.p0.x,this.p1.x)},orientationIndex:function(){if(arguments[0]instanceof ce){var t=arguments[0],e=he.orientationIndex(this.p0,this.p1,t.p0),n=he.orientationIndex(this.p0,this.p1,t.p1);return e>=0&&n>=0?Math.max(e,n):0>=e&&0>=n?Math.max(e,n):0}if(arguments[0]instanceof g){var i=arguments[0];return he.orientationIndex(this.p0,this.p1,i)}},toGeometry:function(t){return t.createLineString([this.p0,this.p1])},isVertical:function(){return this.p0.x===this.p1.x},equals:function(t){if(!(t instanceof ce))return!1;var e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)},intersection:function(t){var e=new ae;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null},project:function(){if(arguments[0]instanceof g){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);var e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ce){var i=arguments[0],r=this.projectionFactor(i.p0),s=this.projectionFactor(i.p1);if(r>=1&&s>=1)return null;if(0>=r&&0>=s)return null;var o=this.project(i.p0);0>r&&(o=this.p0),r>1&&(o=this.p1);var a=this.project(i.p1);return 0>s&&(a=this.p0),s>1&&(a=this.p1),new ce(o,a)}},normalize:function(){this.p1.compareTo(this.p0)<0&&this.reverse()},angle:function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},getCoordinate:function(t){return 0===t?this.p0:this.p1},distancePerpendicular:function(t){return he.distancePointLinePerpendicular(t,this.p0,this.p1)},minY:function(){return Math.min(this.p0.y,this.p1.y)},midPoint:function(){return ce.midPoint(this.p0,this.p1)},projectionFactor:function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(0>=i)return r.NaN;var s=((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i;return s},closestPoints:function(t){var e=this.intersection(t);if(null!==e)return[e,e];var n=new Array(2).fill(null),i=r.MAX_VALUE,s=null,o=this.closestPoint(t.p0);i=o.distance(t.p0),n[0]=o,n[1]=t.p0;var a=this.closestPoint(t.p1);s=a.distance(t.p1),i>s&&(i=s,n[0]=a,n[1]=t.p1);var u=t.closestPoint(this.p0);s=u.distance(this.p0),i>s&&(i=s,n[0]=this.p0,n[1]=u);var l=t.closestPoint(this.p1);return s=l.distance(this.p1),i>s&&(i=s,n[0]=this.p1,n[1]=l),n},closestPoint:function(t){var e=this.projectionFactor(t);if(e>0&&1>e)return this.project(t);var n=this.p0.distance(t),i=this.p1.distance(t);return i>n?this.p0:this.p1},maxX:function(){return Math.max(this.p0.x,this.p1.x)},getLength:function(){return this.p0.distance(this.p1)},compareTo:function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)},reverse:function(){var t=this.p0;this.p0=this.p1,this.p1=t},equalsTopo:function(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)},lineIntersection:function(t){try{var e=F.intersection(this.p0,this.p1,t.p0,t.p1);return e}catch(t){if(!(t instanceof w))throw t}finally{}return null},maxY:function(){return Math.max(this.p0.y,this.p1.y)},pointAlongOffset:function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y,o=Math.sqrt(r*r+s*s),a=0,u=0;if(0!==e){if(0>=o)throw new IllegalStateException("Cannot compute offset from zero-length line segment");a=e*r/o,u=e*s/o}var l=n-u,h=i+a,c=new g(l,h);return c},setCoordinates:function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y}},segmentFraction:function(t){var e=this.projectionFactor(t);return 0>e?e=0:(e>1||r.isNaN(e))&&(e=1),e},toString:function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},isHorizontal:function(){return this.p0.y===this.p1.y},distance:function(){if(arguments[0]instanceof ce){var t=arguments[0];return he.distanceLineLine(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){var e=arguments[0];return he.distancePointLine(e,this.p0,this.p1)}},pointAlong:function(t){var e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e},hashCode:function(){var t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=java.lang.Double.doubleToLongBits(this.p1.x);n^=31*java.lang.Double.doubleToLongBits(this.p1.y);var i=Math.trunc(n)^Math.trunc(n>>32);return e^i},interfaces_:function(){return[s,u]},getClass:function(){return ce}}),ce.midPoint=function(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)},ce.serialVersionUID=0x2d2172135f411c00,e(fe.prototype,{isIntersects:function(){return!this.isDisjoint()},isCovers:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},isCoveredBy:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},set:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.matrix[n][i]=lt.toDimensionValue(t.charAt(e))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]=o}},isContains:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},setAtLeast:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,lt.toDimensionValue(t.charAt(e)))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]<o&&(this.matrix[r][s]=o)}},setAtLeastIfValid:function(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)},isWithin:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},isTouches:function(t,e){return t>e?this.isTouches(e,t):t===lt.A&&e===lt.A||t===lt.L&&e===lt.L||t===lt.L&&e===lt.A||t===lt.P&&e===lt.A||t===lt.P&&e===lt.L?this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&(fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY])):!1},isOverlaps:function(t,e){return t===lt.P&&e===lt.P||t===lt.A&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?1===this.matrix[L.INTERIOR][L.INTERIOR]&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):!1},isEquals:function(t,e){return t!==e?!1:fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},toString:function(){for(var t=new P("123456789"),e=0;3>e;e++)for(var n=0;3>n;n++)t.setCharAt(3*e+n,lt.toDimensionSymbol(this.matrix[e][n]));return t.toString()},setAll:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.matrix[e][n]=t},get:function(t,e){return this.matrix[t][e]},transpose:function(){var t=this.matrix[1][0];return this.matrix[1][0]=this.matrix[0][1],this.matrix[0][1]=t,t=this.matrix[2][0],this.matrix[2][0]=this.matrix[0][2],this.matrix[0][2]=t,t=this.matrix[2][1],this.matrix[2][1]=this.matrix[1][2],this.matrix[1][2]=t,this},matches:function(t){if(9!==t.length)throw new i("Should be length 9: "+t);for(var e=0;3>e;e++)for(var n=0;3>n;n++)if(!fe.matches(this.matrix[e][n],t.charAt(3*e+n)))return!1;return!0},add:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.setAtLeast(e,n,t.get(e,n))},isDisjoint:function(){return this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.INTERIOR][L.BOUNDARY]===lt.FALSE&&this.matrix[L.BOUNDARY][L.INTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.BOUNDARY]===lt.FALSE},isCrosses:function(t,e){return t===lt.P&&e===lt.L||t===lt.P&&e===lt.A||t===lt.L&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]):t===lt.L&&e===lt.P||t===lt.A&&e===lt.P||t===lt.A&&e===lt.L?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?0===this.matrix[L.INTERIOR][L.INTERIOR]:!1},interfaces_:function(){return[o]},getClass:function(){return fe}}),fe.matches=function(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){var t=arguments[0],e=arguments[1];return e===lt.SYM_DONTCARE?!0:e===lt.SYM_TRUE&&(t>=0||t===lt.TRUE)?!0:e===lt.SYM_FALSE&&t===lt.FALSE?!0:e===lt.SYM_P&&t===lt.P?!0:e===lt.SYM_L&&t===lt.L?!0:e===lt.SYM_A&&t===lt.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){var n=arguments[0],i=arguments[1],r=new fe(n);return r.matches(i)}},fe.isTrue=function(t){return t>=0||t===lt.TRUE};var lo=Object.freeze({Coordinate:g,CoordinateList:N,Envelope:C,LineSegment:ce,GeometryFactory:ie,Geometry:B,Point:Lt,LineString:St,LinearRing:bt,Polygon:Tt,GeometryCollection:ft,MultiPoint:Pt,MultiLineString:gt,MultiPolygon:Ot,Dimension:lt,IntersectionMatrix:fe});e(ge.prototype,{addPoint:function(t){this.ptCount+=1,this.ptCentSum.x+=t.x,this.ptCentSum.y+=t.y},setBasePoint:function(t){null===this.areaBasePt&&(this.areaBasePt=t)},addLineSegments:function(t){for(var e=0,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);if(0!==i){e+=i;var r=(t[n].x+t[n+1].x)/2;this.lineCentSum.x+=i*r;var s=(t[n].y+t[n+1].y)/2;this.lineCentSum.y+=i*s}}this.totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])},addHole:function(t){for(var e=he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},getCentroid:function(){var t=new g;if(Math.abs(this.areasum2)>0)t.x=this.cg3.x/3/this.areasum2,t.y=this.cg3.y/3/this.areasum2;else if(this.totalLength>0)t.x=this.lineCentSum.x/this.totalLength,t.y=this.lineCentSum.y/this.totalLength;else{if(!(this.ptCount>0))return null;t.x=this.ptCentSum.x/this.ptCount,t.y=this.ptCentSum.y/this.ptCount}return t},addShell:function(t){t.length>0&&this.setBasePoint(t[0]);for(var e=!he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},addTriangle:function(t,e,n,i){var r=i?1:-1;ge.centroid3(t,e,n,this.triangleCent3);var s=ge.area2(t,e,n);this.cg3.x+=r*s*this.triangleCent3.x,this.cg3.y+=r*s*this.triangleCent3.y,this.areasum2+=r*s},add:function(){if(arguments[0]instanceof Tt){var t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(var e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof B){var n=arguments[0];if(n.isEmpty())return null;if(n instanceof Lt)this.addPoint(n.getCoordinate());else if(n instanceof St)this.addLineSegments(n.getCoordinates());else if(n instanceof Tt){var i=n;this.add(i)}else if(n instanceof ft)for(var r=n,e=0;e<r.getNumGeometries();e++)this.add(r.getGeometryN(e))}},interfaces_:function(){return[]},getClass:function(){return ge}}),ge.area2=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)},ge.centroid3=function(t,e,n,i){return i.x=t.x+e.x+n.x,i.y=t.y+e.y+n.y,null},ge.getCentroid=function(t){var e=new ge(t);return e.getCentroid()},de.prototype=new Error,de.prototype.name="EmptyStackException",pe.prototype=new y,pe.prototype.add=function(t){return this.array_.push(t),!0},pe.prototype.get=function(t){if(0>t||t>=this.size())throw new IndexOutOfBoundsException;return this.array_[t]},pe.prototype.push=function(t){return this.array_.push(t),t},pe.prototype.pop=function(t){if(0===this.array_.length)throw new de;return this.array_.pop()},pe.prototype.peek=function(){if(0===this.array_.length)throw new de;return this.array_[this.array_.length-1]},pe.prototype.empty=function(){return 0===this.array_.length},pe.prototype.isEmpty=function(){return this.empty()},pe.prototype.search=function(t){return this.array_.indexOf(t)},pe.prototype.size=function(){return this.array_.length},pe.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},e(ve.prototype,{filter:function(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))},getCoordinates:function(){var t=new Array(this.list.size()).fill(null);return this.list.toArray(t)},interfaces_:function(){return[z]},getClass:function(){return ve}}),ve.filterCoordinates=function(t){for(var e=new ve,n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()},e(me.prototype,{preSort:function(t){for(var e=null,n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ut.sort(t,1,t.length,new ye(t[0])),t},computeOctRing:function(t){var e=this.computeOctPts(t),n=new N;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())},lineOrPolygon:function(t){if(t=this.cleanRing(t),3===t.length)return this.geomFactory.createLineString([t[0],t[1]]);var e=this.geomFactory.createLinearRing(t);return this.geomFactory.createPolygon(e,null)},cleanRing:function(t){f.equals(t[0],t[t.length-1]);for(var e=new I,n=null,i=0;i<=t.length-2;i++){var r=t[i],s=t[i+1];r.equals(s)||null!==n&&this.isBetween(n,r,s)||(e.add(r),n=r)}e.add(t[t.length-1]);var o=new Array(e.size()).fill(null);return e.toArray(o)},isBetween:function(t,e,n){if(0!==he.computeOrientation(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1},reduce:function(t){var e=this.computeOctRing(t);if(null===e)return t;for(var n=new at,i=0;i<e.length;i++)n.add(e[i]);for(var i=0;i<t.length;i++)he.isPointInRing(t[i],e)||n.add(t[i]);var r=H.toCoordinateArray(n);return r.length<3?this.padArray3(r):r},getConvexHull:function(){if(0===this.inputPts.length)return this.geomFactory.createGeometryCollection(null);if(1===this.inputPts.length)return this.geomFactory.createPoint(this.inputPts[0]);if(2===this.inputPts.length)return this.geomFactory.createLineString(this.inputPts);var t=this.inputPts;this.inputPts.length>50&&(t=this.reduce(this.inputPts));var e=this.preSort(t),n=this.grahamScan(e),i=this.toCoordinateArray(n);return this.lineOrPolygon(i)},padArray3:function(t){for(var e=new Array(3).fill(null),n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e},computeOctPts:function(t){for(var e=new Array(8).fill(null),n=0;n<e.length;n++)e[n]=t[0];for(var i=1;i<t.length;i++)t[i].x<e[0].x&&(e[0]=t[i]),t[i].x-t[i].y<e[1].x-e[1].y&&(e[1]=t[i]),t[i].y>e[2].y&&(e[2]=t[i]),t[i].x+t[i].y>e[3].x+e[3].y&&(e[3]=t[i]),t[i].x>e[4].x&&(e[4]=t[i]),t[i].x-t[i].y>e[5].x-e[5].y&&(e[5]=t[i]),t[i].y<e[6].y&&(e[6]=t[i]),t[i].x+t[i].y<e[7].x+e[7].y&&(e[7]=t[i]);return e},toCoordinateArray:function(t){for(var e=new Array(t.size()).fill(null),n=0;n<t.size();n++){var i=t.get(n);e[n]=i}return e},grahamScan:function(t){var e=null,n=new pe;e=n.push(t[0]),e=n.push(t[1]),e=n.push(t[2]);for(var i=3;i<t.length;i++){for(e=n.pop();!n.empty()&&he.computeOrientation(n.peek(),e,t[i])>0;)e=n.pop();e=n.push(e),e=n.push(t[i])}return e=n.push(t[0]),n},interfaces_:function(){return[]},getClass:function(){return me}}),me.extractCoordinates=function(t){var e=new ve;return t.apply(e),e.getCoordinates()},e(ye.prototype,{compare:function(t,e){var n=t,i=e;return ye.polarCompare(this.origin,n,i)},interfaces_:function(){return[a]},getClass:function(){return ye}}),ye.polarCompare=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-t.x,o=n.y-t.y,a=he.computeOrientation(t,e,n);
if(a===he.COUNTERCLOCKWISE)return 1;if(a===he.CLOCKWISE)return-1;var u=i*i+r*r,l=s*s+o*o;return l>u?-1:u>l?1:0},me.RadialComparator=ye,e(xe.prototype,{transformPoint:function(t,e){return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))},transformPolygon:function(t,e){var n=!0,i=this.transformLinearRing(t.getExteriorRing(),t);null!==i&&i instanceof bt&&!i.isEmpty()||(n=!1);for(var r=new I,s=0;s<t.getNumInteriorRing();s++){var o=this.transformLinearRing(t.getInteriorRingN(s),t);null===o||o.isEmpty()||(o instanceof bt||(n=!1),r.add(o))}if(n)return this.factory.createPolygon(i,r.toArray([]));var a=new I;return null!==i&&a.add(i),a.addAll(r),this.factory.buildGeometry(a)},createCoordinateSequence:function(t){return this.factory.getCoordinateSequenceFactory().create(t)},getInputGeometry:function(){return this.inputGeom},transformMultiLineString:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformLineString(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformCoordinates:function(t,e){return this.copy(t)},transformLineString:function(t,e){return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))},transformMultiPoint:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPoint(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformMultiPolygon:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPolygon(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},copy:function(t){return t.copy()},transformGeometryCollection:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transform(t.getGeometryN(i));null!==r&&(this.pruneEmptyGeometry&&r.isEmpty()||n.add(r))}return this.preserveGeometryCollectionType?this.factory.createGeometryCollection(ie.toGeometryArray(n)):this.factory.buildGeometry(n)},transform:function(t){if(this.inputGeom=t,this.factory=t.getFactory(),t instanceof Lt)return this.transformPoint(t,null);if(t instanceof Pt)return this.transformMultiPoint(t,null);if(t instanceof bt)return this.transformLinearRing(t,null);if(t instanceof St)return this.transformLineString(t,null);if(t instanceof gt)return this.transformMultiLineString(t,null);if(t instanceof Tt)return this.transformPolygon(t,null);if(t instanceof Ot)return this.transformMultiPolygon(t,null);if(t instanceof ft)return this.transformGeometryCollection(t,null);throw new i("Unknown Geometry subtype: "+t.getClass().getName())},transformLinearRing:function(t,e){var n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this.factory.createLinearRing(null);var i=n.size();return i>0&&4>i&&!this.preserveType?this.factory.createLineString(n):this.factory.createLinearRing(n)},interfaces_:function(){return[]},getClass:function(){return xe}}),e(Ee.prototype,{snapVertices:function(t,e){for(var n=this._isClosed?t.size()-1:t.size(),i=0;n>i;i++){var r=t.get(i),s=this.findSnapForVertex(r,e);null!==s&&(t.set(i,new g(s)),0===i&&this._isClosed&&t.set(t.size()-1,new g(s)))}},findSnapForVertex:function(t,e){for(var n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this.snapTolerance)return e[n]}return null},snapTo:function(t){var e=new N(this.srcPts);this.snapVertices(e,t),this.snapSegments(e,t);var n=e.toCoordinateArray();return n},snapSegments:function(t,e){if(0===e.length)return null;var n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(var i=0;n>i;i++){var r=e[i],s=this.findSegmentIndexToSnap(r,t);s>=0&&t.add(s+1,new g(r),!1)}},findSegmentIndexToSnap:function(t,e){for(var n=r.MAX_VALUE,i=-1,s=0;s<e.size()-1;s++){if(this.seg.p0=e.get(s),this.seg.p1=e.get(s+1),this.seg.p0.equals2D(t)||this.seg.p1.equals2D(t)){if(this.allowSnappingToSourceVertices)continue;return-1}var o=this.seg.distance(t);o<this.snapTolerance&&n>o&&(n=o,i=s)}return i},setAllowSnappingToSourceVertices:function(t){this.allowSnappingToSourceVertices=t},interfaces_:function(){return[]},getClass:function(){return Ee}}),Ee.isClosed=function(t){return t.length<=1?!1:t[0].equals2D(t[t.length-1])},e(Ie.prototype,{snapTo:function(t,e){var n=this.extractTargetCoordinates(t),i=new Ne(e,n);return i.transform(this.srcGeom)},snapToSelf:function(t,e){var n=this.extractTargetCoordinates(this.srcGeom),i=new Ne(t,n,!0),r=i.transform(this.srcGeom),s=r;return e&&R(s,Rt)&&(s=r.buffer(0)),s},computeSnapTolerance:function(t){var e=this.computeMinimumSegmentLength(t),n=e/10;return n},extractTargetCoordinates:function(t){for(var e=new at,n=t.getCoordinates(),i=0;i<n.length;i++)e.add(n[i]);return e.toArray(new Array(0).fill(null))},computeMinimumSegmentLength:function(t){for(var e=r.MAX_VALUE,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);e>i&&(e=i)}return e},interfaces_:function(){return[]},getClass:function(){return Ie}}),Ie.snap=function(t,e,n){var i=new Array(2).fill(null),r=new Ie(t);i[0]=r.snapTo(e,n);var s=new Ie(e);return i[1]=s.snapTo(i[0],n),i},Ie.computeOverlaySnapTolerance=function(){if(1===arguments.length){var t=arguments[0],e=Ie.computeSizeBasedSnapTolerance(t),n=t.getPrecisionModel();if(n.getType()===ee.FIXED){var i=1/n.getScale()*2/1.415;i>e&&(e=i)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1];return Math.min(Ie.computeOverlaySnapTolerance(r),Ie.computeOverlaySnapTolerance(s))}},Ie.computeSizeBasedSnapTolerance=function(t){var e=t.getEnvelopeInternal(),n=Math.min(e.getHeight(),e.getWidth()),i=n*Ie.SNAP_PRECISION_FACTOR;return i},Ie.snapToSelf=function(t,e,n){var i=new Ie(t);return i.snapToSelf(e,n)},Ie.SNAP_PRECISION_FACTOR=1e-9,h(Ne,xe),e(Ne.prototype,{snapLine:function(t,e){var n=new Ee(t,this.snapTolerance);return n.setAllowSnappingToSourceVertices(this.isSelfSnap),n.snapTo(e)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=this.snapLine(n,this.snapPts);return this.factory.getCoordinateSequenceFactory().create(i)},interfaces_:function(){return[]},getClass:function(){return Ne}}),e(Ce.prototype,{getCommon:function(){return r.longBitsToDouble(this.commonBits)},add:function(t){var e=r.doubleToLongBits(t);if(this.isFirst)return this.commonBits=e,this.commonSignExp=Ce.signExpBits(this.commonBits),this.isFirst=!1,null;var n=Ce.signExpBits(e);return n!==this.commonSignExp?(this.commonBits=0,null):(this.commonMantissaBitsCount=Ce.numCommonMostSigMantissaBits(this.commonBits,e),void(this.commonBits=Ce.zeroLowerBits(this.commonBits,64-(12+this.commonMantissaBitsCount))))},toString:function(){if(1===arguments.length){var t=arguments[0],e=r.longBitsToDouble(t),n=Long.toBinaryString(t),i="0000000000000000000000000000000000000000000000000000000000000000"+n,s=i.substring(i.length-64),o=s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]";return o}},interfaces_:function(){return[]},getClass:function(){return Ce}}),Ce.getBit=function(t,e){var n=1<<e;return 0!==(t&n)?1:0},Ce.signExpBits=function(t){return t>>52},Ce.zeroLowerBits=function(t,e){var n=(1<<e)-1,i=~n,r=t&i;return r},Ce.numCommonMostSigMantissaBits=function(t,e){for(var n=0,i=52;i>=0;i--){if(Ce.getBit(t,i)!==Ce.getBit(e,i))return n;n++}return 52},e(Se.prototype,{addCommonBits:function(t){var e=new Le(this.commonCoord);t.apply(e),t.geometryChanged()},removeCommonBits:function(t){if(0===this.commonCoord.x&&0===this.commonCoord.y)return t;var e=new g(this.commonCoord);e.x=-e.x,e.y=-e.y;var n=new Le(e);return t.apply(n),t.geometryChanged(),t},getCommonCoordinate:function(){return this.commonCoord},add:function(t){t.apply(this.ccFilter),this.commonCoord=this.ccFilter.getCommonCoordinate()},interfaces_:function(){return[]},getClass:function(){return Se}}),e(we.prototype,{filter:function(t){this.commonBitsX.add(t.x),this.commonBitsY.add(t.y)},getCommonCoordinate:function(){return new g(this.commonBitsX.getCommon(),this.commonBitsY.getCommon())},interfaces_:function(){return[z]},getClass:function(){return we}}),e(Le.prototype,{filter:function(t,e){var n=t.getOrdinate(e,0)+this.trans.x,i=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,i)},isDone:function(){return!1},isGeometryChanged:function(){return!0},interfaces_:function(){return[ct]},getClass:function(){return Le}}),Se.CommonCoordinateFilter=we,Se.Translater=Le,e(Re.prototype,{next:function(){if(this.atStart)return this.atStart=!1,Re.isAtomic(this.parent)&&this.index++,this.parent;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return this.subcollectionIterator.next();this.subcollectionIterator=null}if(this.index>=this.max)throw new x;var t=this.parent.getGeometryN(this.index++);return t instanceof ft?(this.subcollectionIterator=new Re(t),this.subcollectionIterator.next()):t},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){if(this.atStart)return!0;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return!0;this.subcollectionIterator=null}return!(this.index>=this.max)},interfaces_:function(){return[p]},getClass:function(){return Re}}),Re.isAtomic=function(t){return!(t instanceof ft)},e(Te.prototype,{locateInternal:function(){if(arguments[0]instanceof g&&arguments[1]instanceof Tt){var t=arguments[0],e=arguments[1];if(e.isEmpty())return L.EXTERIOR;var n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===L.EXTERIOR)return L.EXTERIOR;if(i===L.BOUNDARY)return L.BOUNDARY;for(var r=0;r<e.getNumInteriorRing();r++){var s=e.getInteriorRingN(r),o=this.locateInPolygonRing(t,s);if(o===L.INTERIOR)return L.EXTERIOR;if(o===L.BOUNDARY)return L.BOUNDARY}return L.INTERIOR}if(arguments[0]instanceof g&&arguments[1]instanceof St){var a=arguments[0],u=arguments[1];if(!u.getEnvelopeInternal().intersects(a))return L.EXTERIOR;var l=u.getCoordinates();return u.isClosed()||!a.equals(l[0])&&!a.equals(l[l.length-1])?he.isOnLine(a,l)?L.INTERIOR:L.EXTERIOR:L.BOUNDARY}if(arguments[0]instanceof g&&arguments[1]instanceof Lt){var h=arguments[0],c=arguments[1],f=c.getCoordinate();return f.equals2D(h)?L.INTERIOR:L.EXTERIOR}},locateInPolygonRing:function(t,e){return e.getEnvelopeInternal().intersects(t)?he.locatePointInRing(t,e.getCoordinates()):L.EXTERIOR},intersects:function(t,e){return this.locate(t,e)!==L.EXTERIOR},updateLocationInfo:function(t){t===L.INTERIOR&&(this.isIn=!0),t===L.BOUNDARY&&this.numBoundaries++},computeLocation:function(t,e){if(e instanceof Lt&&this.updateLocationInfo(this.locateInternal(t,e)),e instanceof St)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof Tt)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof gt)for(var n=e,i=0;i<n.getNumGeometries();i++){var r=n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,r))}else if(e instanceof Ot)for(var s=e,i=0;i<s.getNumGeometries();i++){var o=s.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,o))}else if(e instanceof ft)for(var a=new Re(e);a.hasNext();){var u=a.next();u!==e&&this.computeLocation(t,u)}},locate:function(t,e){return e.isEmpty()?L.EXTERIOR:e instanceof St?this.locateInternal(t,e):e instanceof Tt?this.locateInternal(t,e):(this.isIn=!1,this.numBoundaries=0,this.computeLocation(t,e),this.boundaryRule.isInBoundary(this.numBoundaries)?L.BOUNDARY:this.numBoundaries>0||this.isIn?L.INTERIOR:L.EXTERIOR)},interfaces_:function(){return[]},getClass:function(){return Te}}),e(Pe.prototype,{interfaces_:function(){return[]},getClass:function(){return Pe}}),Pe.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the octant for point ( "+t+", "+e+" )");var n=Math.abs(t),r=Math.abs(e);return t>=0?e>=0?n>=r?0:1:n>=r?7:6:e>=0?n>=r?3:2:n>=r?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1],a=o.x-s.x,u=o.y-s.y;if(0===a&&0===u)throw new i("Cannot compute the octant for two identical points "+s);return Pe.octant(a,u)}},e(be.prototype,{getCoordinates:function(){},size:function(){},getCoordinate:function(t){},isClosed:function(){},setData:function(t){},getData:function(){},interfaces_:function(){return[]},getClass:function(){return be}}),e(Oe.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:Pe.octant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},getData:function(){return this.data},toString:function(){return se.toLineString(new Gt(this.pts))},interfaces_:function(){return[be]},getClass:function(){return Oe}}),e(_e.prototype,{getBounds:function(){},interfaces_:function(){return[]},getClass:function(){return _e}}),e(Me.prototype,{getItem:function(){return this.item},getBounds:function(){return this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Me}}),e(De.prototype,{poll:function(){if(this.isEmpty())return null;var t=this.items.get(1);return this.items.set(1,this.items.get(this._size)),this._size-=1,this.reorder(1),t},size:function(){return this._size},reorder:function(t){for(var e=null,n=this.items.get(t);2*t<=this._size&&(e=2*t,e!==this._size&&this.items.get(e+1).compareTo(this.items.get(e))<0&&e++,this.items.get(e).compareTo(n)<0);t=e)this.items.set(t,this.items.get(e));this.items.set(t,n)},clear:function(){this._size=0,this.items.clear()},isEmpty:function(){return 0===this._size},add:function(t){this.items.add(null),this._size+=1;var e=this._size;for(this.items.set(0,t);t.compareTo(this.items.get(Math.trunc(e/2)))<0;e/=2)this.items.set(e,this.items.get(Math.trunc(e/2)));this.items.set(e,t)},interfaces_:function(){return[]},getClass:function(){return De}}),e(Ae.prototype,{visitItem:function(t){},interfaces_:function(){return[]},getClass:function(){return Ae}}),e(Fe.prototype,{insert:function(t,e){},remove:function(t,e){},query:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return Fe}}),e(Ge.prototype,{getLevel:function(){return this.level},size:function(){return this.childBoundables.size()},getChildBoundables:function(){return this.childBoundables},addChildBoundable:function(t){f.isTrue(null===this.bounds),this.childBoundables.add(t)},isEmpty:function(){return this.childBoundables.isEmpty()},getBounds:function(){return null===this.bounds&&(this.bounds=this.computeBounds()),this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Ge}}),Ge.serialVersionUID=0x5a1e55ec41369800;var ho={reverseOrder:function(){return{compare:function(t,e){return e.compareTo(t)}}},min:function(t){return ho.sort(t),t.get(0)},sort:function(t,e){var n=t.toArray();e?ut.sort(n,e):ut.sort(n);for(var i=t.iterator(),r=0,s=n.length;s>r;r++)i.next(),i.set(n[r])},singletonList:function(t){var e=new I;return e.add(t),e}};e(qe.prototype,{expandToQueue:function(t,e){var n=qe.isComposite(this.boundable1),r=qe.isComposite(this.boundable2);if(n&&r)return qe.area(this.boundable1)>qe.area(this.boundable2)?(this.expand(this.boundable1,this.boundable2,t,e),null):(this.expand(this.boundable2,this.boundable1,t,e),null);if(n)return this.expand(this.boundable1,this.boundable2,t,e),null;if(r)return this.expand(this.boundable2,this.boundable1,t,e),null;throw new i("neither boundable is composite")},isLeaves:function(){return!(qe.isComposite(this.boundable1)||qe.isComposite(this.boundable2))},compareTo:function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0},expand:function(t,e,n,i){for(var r=t.getChildBoundables(),s=r.iterator();s.hasNext();){var o=s.next(),a=new qe(o,e,this.itemDistance);a.getDistance()<i&&n.add(a)}},getBoundable:function(t){return 0===t?this.boundable1:this.boundable2},getDistance:function(){return this._distance},distance:function(){return this.isLeaves()?this.itemDistance.distance(this.boundable1,this.boundable2):this.boundable1.getBounds().distance(this.boundable2.getBounds())},interfaces_:function(){return[s]},getClass:function(){return qe}}),qe.area=function(t){return t.getBounds().getArea()},qe.isComposite=function(t){return t instanceof Ge},e(Be.prototype,{getNodeCapacity:function(){return this.nodeCapacity},lastNode:function(t){return t.get(t.size()-1)},size:function t(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this.root));if(1===arguments.length){for(var e=arguments[0],t=0,n=e.getChildBoundables().iterator();n.hasNext();){var i=n.next();i instanceof Ge?t+=this.size(i):i instanceof Me&&(t+=1)}return t}},removeItem:function(t,e){for(var n=null,i=t.getChildBoundables().iterator();i.hasNext();){var r=i.next();r instanceof Me&&r.getItem()===e&&(n=r)}return null!==n?(t.getChildBoundables().remove(n),!0):!1},itemsTree:function(){if(0===arguments.length){this.build();var t=this.itemsTree(this.root);return null===t?new I:t}if(1===arguments.length){for(var e=arguments[0],n=new I,i=e.getChildBoundables().iterator();i.hasNext();){var r=i.next();if(r instanceof Ge){var s=this.itemsTree(r);null!==s&&n.add(s)}else r instanceof Me?n.add(r.getItem()):f.shouldNeverReachHere()}return n.size()<=0?null:n}},insert:function(t,e){f.isTrue(!this.built,"Cannot insert items into an STR packed R-tree after it has been built."),this.itemBoundables.add(new Me(t,e))},boundablesAtLevel:function(){if(1===arguments.length){var t=arguments[0],e=new I;return this.boundablesAtLevel(t,this.root,e),e}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(f.isTrue(n>-2),i.getLevel()===n)return r.add(i),null;for(var s=i.getChildBoundables().iterator();s.hasNext();){var o=s.next();o instanceof Ge?this.boundablesAtLevel(n,o,r):(f.isTrue(o instanceof Me),-1===n&&r.add(o))}return null}},query:function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new I;return this.isEmpty()?e:(this.getIntersectsOp().intersects(this.root.getBounds(),t)&&this.query(t,this.root,e),e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this.root.getBounds(),n)&&this.query(n,this.root,i)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var r=arguments[0],s=arguments[1],o=arguments[2],a=s.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),r)&&(l instanceof Ge?this.query(r,l,o):l instanceof Me?o.visitItem(l.getItem()):f.shouldNeverReachHere())}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var h=arguments[0],c=arguments[1],g=arguments[2],a=c.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),h)&&(l instanceof Ge?this.query(h,l,g):l instanceof Me?g.add(l.getItem()):f.shouldNeverReachHere())}},build:function(){return this.built?null:(this.root=this.itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this.itemBoundables,-1),this.itemBoundables=null,void(this.built=!0))},getRoot:function(){return this.build(),this.root},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),this.getIntersectsOp().intersects(this.root.getBounds(),t)?this.remove(t,this.root,e):!1}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=this.removeItem(i,r);if(s)return!0;for(var o=null,a=i.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&u instanceof Ge&&(s=this.remove(n,u,r))){o=u;break}}return null!==o&&o.getChildBoundables().isEmpty()&&i.getChildBoundables().remove(o),s}},createHigherLevels:function(t,e){f.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)},depth:function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this.root));if(1===arguments.length){for(var t=arguments[0],e=0,n=t.getChildBoundables().iterator();n.hasNext();){var i=n.next();if(i instanceof Ge){var r=this.depth(i);r>e&&(e=r)}}return e+1}},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=new I;n.add(this.createNode(e));var i=new I(t);ho.sort(i,this.getComparator());for(var r=i.iterator();r.hasNext();){var s=r.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n},isEmpty:function(){return this.built?this.root.isEmpty():this.itemBoundables.isEmpty()},interfaces_:function(){return[u]},getClass:function(){return Be}}),Be.compareDoubles=function(t,e){return t>e?1:e>t?-1:0},Be.IntersectsOp=ze,Be.serialVersionUID=-0x35ef64c82d4c5400,Be.DEFAULT_NODE_CAPACITY=10,e(Ve.prototype,{distance:function(t,e){},interfaces_:function(){return[]},getClass:function(){return Ve}}),h(ke,Be),e(ke.prototype,{createParentBoundablesFromVerticalSlices:function(t,e){f.isTrue(t.length>0);for(var n=new I,i=0;i<t.length;i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i],e));return n},createNode:function(t){return new Ye(t)},size:function(){return 0===arguments.length?Be.prototype.size.call(this):Be.prototype.size.apply(this,arguments)},insert:function(){if(2!==arguments.length)return Be.prototype.insert.apply(this,arguments);var t=arguments[0],e=arguments[1];return t.isNull()?null:void Be.prototype.insert.call(this,t,e)},getIntersectsOp:function(){return ke.intersectsOp},verticalSlices:function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),i=new Array(e).fill(null),r=t.iterator(),s=0;e>s;s++){i[s]=new I;for(var o=0;r.hasNext()&&n>o;){var a=r.next();i[s].add(a),o++}}return i},query:function(){if(1===arguments.length){var t=arguments[0];return Be.prototype.query.call(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];Be.prototype.query.call(this,e,n)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var i=arguments[0],r=arguments[1],s=arguments[2];Be.prototype.query.call(this,i,r,s)}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var o=arguments[0],a=arguments[1],u=arguments[2];Be.prototype.query.call(this,o,a,u)}},getComparator:function(){return ke.yComparator},createParentBoundablesFromVerticalSlice:function(t,e){return Be.prototype.createParentBoundables.call(this,t,e)},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Be.prototype.remove.call(this,t,e)}return Be.prototype.remove.apply(this,arguments)},depth:function(){return 0===arguments.length?Be.prototype.depth.call(this):Be.prototype.depth.apply(this,arguments)},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),i=new I(t);ho.sort(i,ke.xComparator);var r=this.verticalSlices(i,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(r,e)},nearestNeighbour:function(){if(1===arguments.length){if(R(arguments[0],Ve)){var t=arguments[0],e=new qe(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe){var n=arguments[0];return this.nearestNeighbour(n,r.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof ke&&R(arguments[1],Ve)){var i=arguments[0],s=arguments[1],e=new qe(this.getRoot(),i.getRoot(),s);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe&&"number"==typeof arguments[1]){var o=arguments[0],a=arguments[1],u=a,l=null,h=new De;for(h.add(o);!h.isEmpty()&&u>0;){var c=h.poll(),f=c.getDistance();if(f>=u)break;c.isLeaves()?(u=f,l=c):c.expandToQueue(h,u)}return[l.getBoundable(0).getItem(),l.getBoundable(1).getItem()]}}else if(3===arguments.length){var g=arguments[0],d=arguments[1],p=arguments[2],v=new Me(g,d),e=new qe(this.getRoot(),v,p);return this.nearestNeighbour(e)[0]}},interfaces_:function(){return[Fe,u]},getClass:function(){return ke}}),ke.centreX=function(t){return ke.avg(t.getMinX(),t.getMaxX())},ke.avg=function(t,e){return(t+e)/2},ke.centreY=function(t){return ke.avg(t.getMinY(),t.getMaxY())},h(Ye,Ge),e(Ye.prototype,{computeBounds:function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new C(n.getBounds()):t.expandToInclude(n.getBounds())}return t},interfaces_:function(){return[]},getClass:function(){return Ye}}),ke.STRtreeNode=Ye,ke.serialVersionUID=0x39920f7d5f261e0,ke.xComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreX(t.getBounds()),ke.centreX(e.getBounds()))}},ke.yComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreY(t.getBounds()),ke.centreY(e.getBounds()))}},ke.intersectsOp={interfaces_:function(){return[IntersectsOp]},intersects:function(t,e){return t.intersects(e)}},ke.DEFAULT_NODE_CAPACITY=10,e(Ue.prototype,{interfaces_:function(){return[]},getClass:function(){return Ue}}),Ue.relativeSign=function(t,e){return e>t?-1:t>e?1:0},Ue.compare=function(t,e,n){if(e.equals2D(n))return 0;var i=Ue.relativeSign(e.x,n.x),r=Ue.relativeSign(e.y,n.y);switch(t){case 0:return Ue.compareValue(i,r);case 1:return Ue.compareValue(r,i);case 2:return Ue.compareValue(r,-i);case 3:return Ue.compareValue(-i,r);case 4:return Ue.compareValue(-i,-r);case 5:return Ue.compareValue(-r,-i);case 6:return Ue.compareValue(-r,i);case 7:return Ue.compareValue(i,-r)}return f.shouldNeverReachHere("invalid octant value"),0},Ue.compareValue=function(t,e){return 0>t?-1:t>0?1:0>e?-1:e>0?1:0},e(Xe.prototype,{getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)},compareTo:function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:Ue.compare(this.segmentOctant,this.coord,e.coord)},isEndPoint:function(t){return 0!==this.segmentIndex||this._isInterior?this.segmentIndex===t:!0},isInterior:function(){return this._isInterior},interfaces_:function(){return[s]},getClass:function(){return Xe}}),e(He.prototype,{getSplitCoordinates:function(){var t=new N;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next();this.addEdgeCoordinates(n,i,t),n=i}return t.toCoordinateArray()},addCollapsedNodes:function(){var t=new I;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this.edge.getCoordinate(n),n)}},print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},findCollapsesFromExistingVertices:function(t){for(var e=0;e<this.edge.size()-2;e++){var n=this.edge.getCoordinate(e),i=(this.edge.getCoordinate(e+1),this.edge.getCoordinate(e+2));n.equals2D(i)&&t.add(new b(e+1))}},addEdgeCoordinates:function(t,e,n){var i=e.segmentIndex-t.segmentIndex+2,r=this.edge.getCoordinate(e.segmentIndex),s=e.isInterior()||!e.coord.equals2D(r);s||i--;n.add(new g(t.coord),!1);for(var o=t.segmentIndex+1;o<=e.segmentIndex;o++)n.add(this.edge.getCoordinate(o));s&&n.add(new g(e.coord))},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},findCollapseIndex:function(t,e,n){if(!t.coord.equals2D(e.coord))return!1;var i=e.segmentIndex-t.segmentIndex;return e.isInterior()||i--,1===i?(n[0]=t.segmentIndex+1,!0):!1},findCollapsesFromInsertedNodes:function(t){for(var e=new Array(1).fill(null),n=this.iterator(),i=n.next();n.hasNext();){var r=n.next(),s=this.findCollapseIndex(i,r,e);s&&t.add(new b(e[0])),i=r}},getEdge:function(){return this.edge},addEndpoints:function(){var t=this.edge.size()-1;this.add(this.edge.getCoordinate(0),0),this.add(this.edge.getCoordinate(t),t)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.getCoordinate(a);return r&&(s[o]=new g(e.coord)),new Ke(s,this.edge.getData())},add:function(t,e){var n=new Xe(this.edge,t,e,this.edge.getSegmentOctant(e)),i=this.nodeMap.get(n);return null!==i?(f.isTrue(i.coord.equals2D(t),"Found equal nodes with different coordinates"),i):(this.nodeMap.put(n,n),n)},checkSplitEdgesCorrectness:function(t){var e=this.edge.getCoordinates(),n=t.get(0),i=n.getCoordinate(0);if(!i.equals2D(e[0]))throw new l("bad split edge start point at "+i);var r=t.get(t.size()-1),s=r.getCoordinates(),o=s[s.length-1];if(!o.equals2D(e[e.length-1]))throw new l("bad split edge end point at "+o)},interfaces_:function(){return[]},getClass:function(){return He}}),e(We.prototype,{next:function(){return null===this.currNode?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):null===this.nextNode?null:this.nextNode.segmentIndex===this.currNode.segmentIndex?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):(this.nextNode.segmentIndex>this.currNode.segmentIndex,null)},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){return null!==this.nextNode},readNextNode:function(){this.nodeIt.hasNext()?this.nextNode=this.nodeIt.next():this.nextNode=null},interfaces_:function(){return[p]},getClass:function(){return We}}),e(je.prototype,{addIntersection:function(t,e){},interfaces_:function(){return[be]},getClass:function(){return je}}),e(Ke.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},safeOctant:function(t,e){return t.equals2D(e)?0:Pe.octant(t,e)},getData:function(){return this.data},addIntersection:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=(arguments[2],arguments[3]),s=new g(n.getIntersection(r));this.addIntersection(s,i)}},toString:function(){return se.toLineString(new Gt(this.pts))},getNodeList:function(){return this.nodeList},addIntersectionNode:function(t,e){var n=e,i=n+1;if(i<this.pts.length){var r=this.pts[i];t.equals2D(r)&&(n=i)}var s=this.nodeList.add(t,n);return s},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[je]},getClass:function(){return Ke}}),Ke.getNodedSubstrings=function(){if(1===arguments.length){var t=arguments[0],e=new I;return Ke.getNodedSubstrings(t,e),e}if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){var s=r.next();s.getNodeList().addSplitEdges(i)}},e(Ze.prototype,{overlap:function(){if(2===arguments.length){arguments[0],arguments[1]}else if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t.getLineSegment(e,this.overlapSeg1),n.getLineSegment(i,this.overlapSeg2),this.overlap(this.overlapSeg1,this.overlapSeg2)}},interfaces_:function(){return[]},getClass:function(){return Ze}}),e(Qe.prototype,{getLineSegment:function(t,e){e.p0=this.pts[t],e.p1=this.pts[t+1]},computeSelect:function(t,e,n,i){var r=this.pts[e],s=this.pts[n];if(i.tempEnv1.init(r,s),n-e===1)return i.select(this,e),null;if(!t.intersects(i.tempEnv1))return null;var o=Math.trunc((e+n)/2);
o>e&&this.computeSelect(t,e,o,i),n>o&&this.computeSelect(t,o,n,i)},getCoordinates:function(){for(var t=new Array(this.end-this.start+1).fill(null),e=0,n=this.start;n<=this.end;n++)t[e++]=this.pts[n];return t},computeOverlaps:function(t,e){this.computeOverlapsInternal(this.start,this.end,t,t.start,t.end,e)},setId:function(t){this.id=t},select:function(t,e){this.computeSelect(t,this.start,this.end,e)},getEnvelope:function(){if(null===this.env){var t=this.pts[this.start],e=this.pts[this.end];this.env=new C(t,e)}return this.env},getEndIndex:function(){return this.end},getStartIndex:function(){return this.start},getContext:function(){return this.context},getId:function(){return this.id},computeOverlapsInternal:function(t,e,n,i,r,s){var o=this.pts[t],a=this.pts[e],u=n.pts[i],l=n.pts[r];if(e-t===1&&r-i===1)return s.overlap(this,t,n,i),null;if(s.tempEnv1.init(o,a),s.tempEnv2.init(u,l),!s.tempEnv1.intersects(s.tempEnv2))return null;var h=Math.trunc((t+e)/2),c=Math.trunc((i+r)/2);h>t&&(c>i&&this.computeOverlapsInternal(t,h,n,i,c,s),r>c&&this.computeOverlapsInternal(t,h,n,c,r,s)),e>h&&(c>i&&this.computeOverlapsInternal(h,e,n,i,c,s),r>c&&this.computeOverlapsInternal(h,e,n,c,r,s))},interfaces_:function(){return[]},getClass:function(){return Qe}}),e(Je.prototype,{interfaces_:function(){return[]},getClass:function(){return Je}}),Je.isNorthern=function(t){return t===Je.NE||t===Je.NW},Je.isOpposite=function(t,e){if(t===e)return!1;var n=(t-e+4)%4;return 2===n},Je.commonHalfPlane=function(t,e){if(t===e)return t;var n=(t-e+4)%4;if(2===n)return-1;var i=e>t?t:e,r=t>e?t:e;return 0===i&&3===r?3:i},Je.isInHalfPlane=function(t,e){return e===Je.SE?t===Je.SE||t===Je.SW:t===e||t===e+1},Je.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Je.NE:Je.SE:e>=0?Je.NW:Je.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){var n=arguments[0],r=arguments[1];if(r.x===n.x&&r.y===n.y)throw new i("Cannot compute the quadrant for two identical points "+n);return r.x>=n.x?r.y>=n.y?Je.NE:Je.SE:r.y>=n.y?Je.NW:Je.SW}},Je.NE=0,Je.NW=1,Je.SW=2,Je.SE=3,e($e.prototype,{interfaces_:function(){return[]},getClass:function(){return $e}}),$e.getChainStartIndices=function(t){var e=0,n=new I;n.add(new b(e));do{var i=$e.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=$e.toIntArray(n);return r},$e.findChainEnd=function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var i=Je.quadrant(t[n],t[n+1]),r=e+1;r<t.length;){if(!t[r-1].equals2D(t[r])){var s=Je.quadrant(t[r-1],t[r]);if(s!==i)break}r++}return r-1},$e.getChains=function(){if(1===arguments.length){var t=arguments[0];return $e.getChains(t,null)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new I,r=$e.getChainStartIndices(e),s=0;s<r.length-1;s++){var o=new Qe(e,r[s],r[s+1],n);i.add(o)}return i}},$e.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(tn.prototype,{computeNodes:function(t){},getNodedSubstrings:function(){},interfaces_:function(){return[]},getClass:function(){return tn}}),e(en.prototype,{setSegmentIntersector:function(t){this.segInt=t},interfaces_:function(){return[tn]},getClass:function(){return en}}),h(nn,en),e(nn.prototype,{getMonotoneChains:function(){return this.monoChains},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},getIndex:function(){return this.index},add:function(t){for(var e=$e.getChains(t.getCoordinates(),t),n=e.iterator();n.hasNext();){var i=n.next();i.setId(this.idCounter++),this.index.insert(i.getEnvelope(),i),this.monoChains.add(i)}},computeNodes:function(t){this.nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()},intersectChains:function(){for(var t=new rn(this.segInt),e=this.monoChains.iterator();e.hasNext();)for(var n=e.next(),i=this.index.query(n.getEnvelope()),r=i.iterator();r.hasNext();){var s=r.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this.nOverlaps++),this.segInt.isDone())return null}},interfaces_:function(){return[]},getClass:function(){return nn}}),h(rn,Ze),e(rn.prototype,{overlap:function(){if(4!==arguments.length)return Ze.prototype.overlap.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],r=t.getContext(),s=n.getContext();this.si.processIntersections(r,e,s,i)},interfaces_:function(){return[]},getClass:function(){return rn}}),nn.SegmentOverlapAction=rn,h(sn,l),e(sn.prototype,{getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return sn}}),sn.msgWithCoord=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(on.prototype,{processIntersections:function(t,e,n,i){},isDone:function(){},interfaces_:function(){return[]},getClass:function(){return on}}),e(an.prototype,{getInteriorIntersection:function(){return this.interiorIntersection},setCheckEndSegmentsOnly:function(t){this.isCheckEndSegmentsOnly=t},getIntersectionSegments:function(){return this.intSegments},count:function(){return this.intersectionCount},getIntersections:function(){return this.intersections},setFindAllIntersections:function(t){this.findAllIntersections=t},setKeepIntersections:function(t){this.keepIntersections=t},processIntersections:function(t,e,n,i){if(!this.findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===i)return null;if(this.isCheckEndSegmentsOnly){var r=this.isEndSegment(t,e)||this.isEndSegment(n,i);if(!r)return null}var s=t.getCoordinates()[e],o=t.getCoordinates()[e+1],a=n.getCoordinates()[i],u=n.getCoordinates()[i+1];this.li.computeIntersection(s,o,a,u),this.li.hasIntersection()&&this.li.isInteriorIntersection()&&(this.intSegments=new Array(4).fill(null),this.intSegments[0]=s,this.intSegments[1]=o,this.intSegments[2]=a,this.intSegments[3]=u,this.interiorIntersection=this.li.getIntersection(0),this.keepIntersections&&this.intersections.add(this.interiorIntersection),this.intersectionCount++)},isEndSegment:function(t,e){return 0===e?!0:e>=t.size()-2},hasIntersection:function(){return null!==this.interiorIntersection},isDone:function(){return this.findAllIntersections?!1:null!==this.interiorIntersection},interfaces_:function(){return[on]},getClass:function(){return an}}),an.createAllIntersectionsFinder=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e},an.createAnyIntersectionFinder=function(t){return new an(t)},an.createIntersectionCounter=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e},e(un.prototype,{execute:function(){return null!==this.segInt?null:void this.checkInteriorIntersections()},getIntersections:function(){return this.segInt.getIntersections()},isValid:function(){return this.execute(),this._isValid},setFindAllIntersections:function(t){this.findAllIntersections=t},checkInteriorIntersections:function(){this._isValid=!0,this.segInt=new an(this.li),this.segInt.setFindAllIntersections(this.findAllIntersections);var t=new nn;return t.setSegmentIntersector(this.segInt),t.computeNodes(this.segStrings),this.segInt.hasIntersection()?(this._isValid=!1,null):void 0},checkValid:function(){if(this.execute(),!this._isValid)throw new sn(this.getErrorMessage(),this.segInt.getInteriorIntersection())},getErrorMessage:function(){if(this._isValid)return"no intersections found";var t=this.segInt.getIntersectionSegments();return"found non-noded intersection between "+se.toLineString(t[0],t[1])+" and "+se.toLineString(t[2],t[3])},interfaces_:function(){return[]},getClass:function(){return un}}),un.computeIntersections=function(t){var e=new un(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()},e(ln.prototype,{checkValid:function(){this.nv.checkValid()},interfaces_:function(){return[]},getClass:function(){return ln}}),ln.toSegmentStrings=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Oe(i.getCoordinates(),i))}return e},ln.checkValid=function(t){var e=new ln(t);e.checkValid()},e(hn.prototype,{map:function(t){for(var e=new I,n=0;n<t.getNumGeometries();n++){var i=this.mapOp.map(t.getGeometryN(n));i.isEmpty()||e.add(i)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(e))},interfaces_:function(){return[]},getClass:function(){return hn}}),hn.map=function(t,e){var n=new hn(e);return n.map(t)},e(cn.prototype,{interfaces_:function(){return[]},getClass:function(){return cn}}),cn.opposite=function(t){return t===cn.LEFT?cn.RIGHT:t===cn.RIGHT?cn.LEFT:t},cn.ON=0,cn.LEFT=1,cn.RIGHT=2,e(fn.prototype,{setAllLocations:function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t},isNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==L.NONE)return!1;return!0},setAllLocationsIfNull:function(t){for(var e=0;e<this.location.length;e++)this.location[e]===L.NONE&&(this.location[e]=t)},isLine:function(){return 1===this.location.length},merge:function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[cn.ON]=this.location[cn.ON],e[cn.LEFT]=L.NONE,e[cn.RIGHT]=L.NONE,this.location=e}for(var n=0;n<this.location.length;n++)this.location[n]===L.NONE&&n<t.location.length&&(this.location[n]=t.location[n])},getLocations:function(){return this.location},flip:function(){if(this.location.length<=1)return null;var t=this.location[cn.LEFT];this.location[cn.LEFT]=this.location[cn.RIGHT],this.location[cn.RIGHT]=t},toString:function(){var t=new P;return this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.LEFT])),t.append(L.toLocationSymbol(this.location[cn.ON])),this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.RIGHT])),t.toString()},setLocations:function(t,e,n){this.location[cn.ON]=t,this.location[cn.LEFT]=e,this.location[cn.RIGHT]=n},get:function(t){return t<this.location.length?this.location[t]:L.NONE},isArea:function(){return this.location.length>1},isAnyNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===L.NONE)return!0;return!1},setLocation:function(){if(1===arguments.length){var t=arguments[0];this.setLocation(cn.ON,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n}},init:function(t){this.location=new Array(t).fill(null),this.setAllLocations(L.NONE)},isEqualOnSide:function(t,e){return this.location[e]===t.location[e]},allPositionsEqual:function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0},interfaces_:function(){return[]},getClass:function(){return fn}}),e(gn.prototype,{getGeometryCount:function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t},setAllLocations:function(t,e){this.elt[t].setAllLocations(e)},isNull:function(t){return this.elt[t].isNull()},setAllLocationsIfNull:function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n)}},isLine:function(t){return this.elt[t].isLine()},merge:function(t){for(var e=0;2>e;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new fn(t.elt[e]):this.elt[e].merge(t.elt[e])},flip:function(){this.elt[0].flip(),this.elt[1].flip()},getLocation:function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(cn.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}},toString:function(){var t=new P;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()},isArea:function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}},isAnyNull:function(t){return this.elt[t].isAnyNull()},setLocation:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(cn.ON,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.elt[n].setLocation(i,r)}},isEqualOnSide:function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)},allPositionsEqual:function(t,e){return this.elt[t].allPositionsEqual(e)},toLine:function(t){this.elt[t].isArea()&&(this.elt[t]=new fn(this.elt[t].location[0]))},interfaces_:function(){return[]},getClass:function(){return gn}}),gn.toLineLabel=function(t){for(var e=new gn(L.NONE),n=0;2>n;n++)e.setLocation(n,t.getLocation(n));return e},e(dn.prototype,{computeRing:function(){if(null!==this.ring)return null;for(var t=new Array(this.pts.size()).fill(null),e=0;e<this.pts.size();e++)t[e]=this.pts.get(e);this.ring=this.geometryFactory.createLinearRing(t),this._isHole=he.isCCW(this.ring.getCoordinates())},isIsolated:function(){return 1===this.label.getGeometryCount()},computePoints:function(t){this.startDe=t;var e=t,n=!0;do{if(null===e)throw new sn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new sn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this.edges.add(e);var i=e.getLabel();f.isTrue(i.isArea()),this.mergeLabel(i),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this.startDe)},getLinearRing:function(){return this.ring},getCoordinate:function(t){return this.pts.get(t)},computeMaxNodeDegree:function(){this.maxNodeDegree=0;var t=this.startDe;do{var e=t.getNode(),n=e.getEdges().getOutgoingDegree(this);n>this.maxNodeDegree&&(this.maxNodeDegree=n),t=this.getNext(t)}while(t!==this.startDe);this.maxNodeDegree*=2},addPoints:function(t,e,n){var i=t.getCoordinates();if(e){var r=1;n&&(r=0);for(var s=r;s<i.length;s++)this.pts.add(i[s])}else{var r=i.length-2;n&&(r=i.length-1);for(var s=r;s>=0;s--)this.pts.add(i[s])}},isHole:function(){return this._isHole},setInResult:function(){var t=this.startDe;do t.getEdge().setInResult(!0),t=t.getNext();while(t!==this.startDe)},containsPoint:function(t){var e=this.getLinearRing(),n=e.getEnvelopeInternal();if(!n.contains(t))return!1;if(!he.isPointInRing(t,e.getCoordinates()))return!1;for(var i=this.holes.iterator();i.hasNext();){var r=i.next();if(r.containsPoint(t))return!1}return!0},addHole:function(t){this.holes.add(t)},isShell:function(){return null===this.shell},getLabel:function(){return this.label},getEdges:function(){return this.edges},getMaxNodeDegree:function(){return this.maxNodeDegree<0&&this.computeMaxNodeDegree(),this.maxNodeDegree},getShell:function(){return this.shell},mergeLabel:function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=e.getLocation(n,cn.RIGHT);if(i===L.NONE)return null;if(this.label.getLocation(n)===L.NONE)return this.label.setLocation(n,i),null}},setShell:function(t){this.shell=t,null!==t&&t.addHole(this)},toPolygon:function(t){for(var e=new Array(this.holes.size()).fill(null),n=0;n<this.holes.size();n++)e[n]=this.holes.get(n).getLinearRing();var i=t.createPolygon(this.getLinearRing(),e);return i},interfaces_:function(){return[]},getClass:function(){return dn}}),h(pn,dn),e(pn.prototype,{setEdgeRing:function(t,e){t.setMinEdgeRing(e)},getNext:function(t){return t.getNextMin()},interfaces_:function(){return[]},getClass:function(){return pn}}),h(vn,dn),e(vn.prototype,{buildMinimalRings:function(){var t=new I,e=this.startDe;do{if(null===e.getMinEdgeRing()){var n=new pn(e,this.geometryFactory);t.add(n)}e=e.getNext()}while(e!==this.startDe);return t},setEdgeRing:function(t,e){t.setEdgeRing(e)},linkDirectedEdgesForMinimalEdgeRings:function(){var t=this.startDe;do{var e=t.getNode();e.getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this.startDe)},getNext:function(t){return t.getNext()},interfaces_:function(){return[]},getClass:function(){return vn}}),e(mn.prototype,{setVisited:function(t){this._isVisited=t},setInResult:function(t){this._isInResult=t},isCovered:function(){return this._isCovered},isCoveredSet:function(){return this._isCoveredSet},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setCovered:function(t){this._isCovered=t,this._isCoveredSet=!0},updateIM:function(t){f.isTrue(this.label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)},isInResult:function(){return this._isInResult},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return mn}}),h(yn,mn),e(yn.prototype,{isIncidentEdgeInResult:function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();){var e=t.next();if(e.getEdge().isInResult())return!0}return!1},isIsolated:function(){return 1===this.label.getGeometryCount()},getCoordinate:function(){return this.coord},print:function(t){t.println("node "+this.coord+" lbl: "+this.label)},computeIM:function(t){},computeMergedLocation:function(t,e){var n=L.NONE;if(n=this.label.getLocation(e),!t.isNull(e)){var i=t.getLocation(e);n!==L.BOUNDARY&&(n=i)}return n},setLabel:function(){if(2!==arguments.length)return mn.prototype.setLabel.apply(this,arguments);var t=arguments[0],e=arguments[1];null===this.label?this.label=new gn(t,e):this.label.setLocation(t,e)},getEdges:function(){return this.edges},mergeLabel:function(){if(arguments[0]instanceof yn){var t=arguments[0];this.mergeLabel(t.label)}else if(arguments[0]instanceof gn)for(var e=arguments[0],n=0;2>n;n++){var i=this.computeMergedLocation(e,n),r=this.label.getLocation(n);r===L.NONE&&this.label.setLocation(n,i)}},add:function(t){this.edges.insert(t),t.setNode(this)},setLabelBoundary:function(t){if(null===this.label)return null;var e=L.NONE;null!==this.label&&(e=this.label.getLocation(t));var n=null;switch(e){case L.BOUNDARY:n=L.INTERIOR;break;case L.INTERIOR:n=L.BOUNDARY;break;default:n=L.BOUNDARY}this.label.setLocation(t,n)},interfaces_:function(){return[]},getClass:function(){return yn}}),e(xn.prototype,{find:function(t){return this.nodeMap.get(t)},addNode:function(){if(arguments[0]instanceof g){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof yn){var n=arguments[0],e=this.nodeMap.get(n.getCoordinate());return null===e?(this.nodeMap.put(n.getCoordinate(),n),n):(e.mergeLabel(n),e)}},print:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},values:function(){return this.nodeMap.values()},getBoundaryNodes:function(t){for(var e=new I,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().getLocation(t)===L.BOUNDARY&&e.add(i)}return e},add:function(t){var e=t.getCoordinate(),n=this.addNode(e);n.add(t)},interfaces_:function(){return[]},getClass:function(){return xn}}),e(En.prototype,{compareDirection:function(t){return this.dx===t.dx&&this.dy===t.dy?0:this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getDy:function(){return this.dy},getCoordinate:function(){return this.p0},setNode:function(t){this.node=t},print:function(t){var e=Math.atan2(this.dy,this.dx),n=this.getClass().getName(),i=n.lastIndexOf("."),r=n.substring(i+1);t.print("  "+r+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+e+"   "+this.label)},compareTo:function(t){var e=t;return this.compareDirection(e)},getDirectedCoordinate:function(){return this.p1},getDx:function(){return this.dx},getLabel:function(){return this.label},getEdge:function(){return this.edge},getQuadrant:function(){return this.quadrant},getNode:function(){return this.node},toString:function(){var t=Math.atan2(this.dy,this.dx),e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);return"  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+t+"   "+this.label},computeLabel:function(t){},init:function(t,e){this.p0=t,this.p1=e,this.dx=e.x-t.x,this.dy=e.y-t.y,this.quadrant=Je.quadrant(this.dx,this.dy),f.isTrue(!(0===this.dx&&0===this.dy),"EdgeEnd with identical endpoints found")},interfaces_:function(){return[s]},getClass:function(){return En}}),h(In,En),e(In.prototype,{getNextMin:function(){return this.nextMin},getDepth:function(t){return this.depth[t]},setVisited:function(t){this._isVisited=t},computeDirectedLabel:function(){this.label=new gn(this.edge.getLabel()),this._isForward||this.label.flip()},getNext:function(){return this.next},setDepth:function(t,e){if(-999!==this.depth[t]&&this.depth[t]!==e)throw new sn("assigned depths do not match",this.getCoordinate());this.depth[t]=e},isInteriorAreaEdge:function t(){for(var t=!0,e=0;2>e;e++)this.label.isArea(e)&&this.label.getLocation(e,cn.LEFT)===L.INTERIOR&&this.label.getLocation(e,cn.RIGHT)===L.INTERIOR||(t=!1);return t},setNextMin:function(t){this.nextMin=t},print:function(t){En.prototype.print.call(this,t),t.print(" "+this.depth[cn.LEFT]+"/"+this.depth[cn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")},setMinEdgeRing:function(t){this.minEdgeRing=t},isLineEdge:function(){var t=this.label.isLine(0)||this.label.isLine(1),e=!this.label.isArea(0)||this.label.allPositionsEqual(0,L.EXTERIOR),n=!this.label.isArea(1)||this.label.allPositionsEqual(1,L.EXTERIOR);return t&&e&&n},setEdgeRing:function(t){this.edgeRing=t},getMinEdgeRing:function(){return this.minEdgeRing},getDepthDelta:function(){var t=this.edge.getDepthDelta();return this._isForward||(t=-t),t},setInResult:function(t){this._isInResult=t},getSym:function(){return this.sym},isForward:function(){return this._isForward},getEdge:function(){return this.edge},printEdge:function(t){this.print(t),t.print(" "),this._isForward?this.edge.print(t):this.edge.printReverse(t)},setSym:function(t){this.sym=t},setVisitedEdge:function(t){this.setVisited(t),this.sym.setVisited(t)},setEdgeDepths:function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var i=1;t===cn.LEFT&&(i=-1);var r=cn.opposite(t),s=n*i,o=e+s;this.setDepth(t,e),this.setDepth(r,o)},getEdgeRing:function(){return this.edgeRing},isInResult:function(){return this._isInResult},setNext:function(t){this.next=t},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return In}}),In.depthFactor=function(t,e){return t===L.EXTERIOR&&e===L.INTERIOR?1:t===L.INTERIOR&&e===L.EXTERIOR?-1:0},e(Nn.prototype,{createNode:function(t){return new yn(t,null)},interfaces_:function(){return[]},getClass:function(){return Nn}}),e(Cn.prototype,{printEdges:function(t){t.println("Edges:");for(var e=0;e<this.edges.size();e++){t.println("edge "+e+":");var n=this.edges.get(e);n.print(t),n.eiList.print(t)}},find:function(t){return this.nodes.find(t)},addNode:function(){if(arguments[0]instanceof yn){var t=arguments[0];return this.nodes.addNode(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.nodes.addNode(e)}},getNodeIterator:function(){return this.nodes.iterator()},linkResultDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkResultDirectedEdges()}},debugPrintln:function(t){A.out.println(t)},isBoundaryNode:function(t,e){var n=this.nodes.find(e);if(null===n)return!1;var i=n.getLabel();return null!==i&&i.getLocation(t)===L.BOUNDARY},linkAllDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkAllDirectedEdges()}},matchInSameDirection:function(t,e,n,i){return t.equals(n)?he.computeOrientation(t,e,i)===he.COLLINEAR&&Je.quadrant(t,e)===Je.quadrant(n,i):!1},getEdgeEnds:function(){return this.edgeEndList},debugPrint:function(t){A.out.print(t)},getEdgeIterator:function(){return this.edges.iterator()},findEdgeInSameDirection:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(this.matchInSameDirection(t,e,r[0],r[1]))return i;if(this.matchInSameDirection(t,e,r[r.length-1],r[r.length-2]))return i}return null},insertEdge:function(t){this.edges.add(t)},findEdgeEnd:function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null},addEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.edges.add(n);var i=new In(n,!0),r=new In(n,!1);i.setSym(r),r.setSym(i),this.add(i),this.add(r)}},add:function(t){this.nodes.add(t),this.edgeEndList.add(t)},getNodes:function(){return this.nodes.values()},findEdge:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(t.equals(r[0])&&e.equals(r[1]))return i}return null},interfaces_:function(){return[]},getClass:function(){return Cn}}),Cn.linkResultDirectedEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.getEdges().linkResultDirectedEdges()}},e(Sn.prototype,{sortShellsAndHoles:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isHole()?n.add(r):e.add(r)}},computePolygons:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=i.toPolygon(this.geometryFactory);e.add(r)}return e},placeFreeHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(null===i.getShell()){var r=this.findEdgeRingContaining(i,t);if(null===r)throw new sn("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(r)}}},buildMinimalEdgeRings:function(t,e,n){for(var i=new I,r=t.iterator();r.hasNext();){var s=r.next();if(s.getMaxNodeDegree()>2){s.linkDirectedEdgesForMinimalEdgeRings();var o=s.buildMinimalRings(),a=this.findShell(o);null!==a?(this.placePolygonHoles(a,o),e.add(a)):n.addAll(o)}else i.add(s)}return i},containsPoint:function(t){for(var e=this.shellList.iterator();e.hasNext();){var n=e.next();if(n.containsPoint(t))return!0}return!1},buildMaximalEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&i.getLabel().isArea()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);e.add(r),r.setInResult()}}return e},placePolygonHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();i.isHole()&&i.setShell(t)}},getPolygons:function(){var t=this.computePolygons(this.shellList);return t},findEdgeRingContaining:function(t,e){for(var n=t.getLinearRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),h=l.getEnvelopeInternal();null!==s&&(o=s.getLinearRing().getEnvelopeInternal());var c=!1;h.contains(i)&&he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u)}return s},findShell:function(t){for(var e=0,n=null,i=t.iterator();i.hasNext();){var r=i.next();r.isHole()||(n=r,e++)}return f.isTrue(1>=e,"found two shells in MinimalEdgeRing list"),n},add:function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];Cn.linkResultDirectedEdges(n);var i=this.buildMaximalEdgeRings(e),r=new I,s=this.buildMinimalEdgeRings(i,this.shellList,r);this.sortShellsAndHoles(s,this.shellList,r),this.placeFreeHoles(this.shellList,r)}},interfaces_:function(){return[]},getClass:function(){return Sn}}),e(wn.prototype,{collectLines:function(t){for(var e=this.op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next();this.collectLineEdge(n,t,this.lineEdgesList),this.collectBoundaryTouchEdge(n,t,this.lineEdgesList)}},labelIsolatedLine:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.op.getArgGeometry(e));t.getLabel().setLocation(e,n)},build:function(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this.resultLineList},collectLineEdge:function(t,e,n){var i=t.getLabel(),r=t.getEdge();t.isLineEdge()&&(t.isVisited()||!ii.isResultOfOp(i,e)||r.isCovered()||(n.add(r),t.setVisitedEdge(!0)))},findCoveredLineEdges:function(){for(var t=this.op.getGraph().getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().findCoveredLineEdges()}for(var n=this.op.getGraph().getEdgeEnds().iterator();n.hasNext();){var i=n.next(),r=i.getEdge();if(i.isLineEdge()&&!r.isCoveredSet()){var s=this.op.isCoveredByA(i.getCoordinate());r.setCovered(s)}}},labelIsolatedLines:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(i.isNull(0)?this.labelIsolatedLine(n,0):this.labelIsolatedLine(n,1))}},buildLines:function(t){for(var e=this.lineEdgesList.iterator();e.hasNext();){var n=e.next(),i=(n.getLabel(),this.geometryFactory.createLineString(n.getCoordinates()));this.resultLineList.add(i),n.setInResult(!0)}},collectBoundaryTouchEdge:function(t,e,n){var i=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(f.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(ii.isResultOfOp(i,e)&&e===ii.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))},interfaces_:function(){return[]},getClass:function(){return wn}}),e(Ln.prototype,{filterCoveredNodeToPoint:function(t){var e=t.getCoordinate();if(!this.op.isCoveredByLA(e)){var n=this.geometryFactory.createPoint(e);this.resultPointList.add(n)}},extractNonCoveredResultNodes:function(t){for(var e=this.op.getGraph().getNodes().iterator();e.hasNext();){var n=e.next();if(!(n.isInResult()||n.isIncidentEdgeInResult()||0!==n.getEdges().getDegree()&&t!==ii.INTERSECTION)){var i=n.getLabel();ii.isResultOfOp(i,t)&&this.filterCoveredNodeToPoint(n)}}},build:function(t){return this.extractNonCoveredResultNodes(t),this.resultPointList},interfaces_:function(){return[]},getClass:function(){return Ln}}),e(Rn.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return Rn}}),e(Tn.prototype,{locate:function(t){return Tn.locate(t,this.geom)},interfaces_:function(){return[Rn]},getClass:function(){return Tn}}),Tn.isPointInRing=function(t,e){return e.getEnvelopeInternal().intersects(t)?he.isPointInRing(t,e.getCoordinates()):!1},Tn.containsPointInPolygon=function(t,e){if(e.isEmpty())return!1;var n=e.getExteriorRing();if(!Tn.isPointInRing(t,n))return!1;for(var i=0;i<e.getNumInteriorRing();i++){var r=e.getInteriorRingN(i);if(Tn.isPointInRing(t,r))return!1}return!0},Tn.containsPoint=function(t,e){if(e instanceof Tt)return Tn.containsPointInPolygon(t,e);if(e instanceof ft)for(var n=new Re(e);n.hasNext();){var i=n.next();if(i!==e&&Tn.containsPoint(t,i))return!0}return!1},Tn.locate=function(t,e){return e.isEmpty()?L.EXTERIOR:Tn.containsPoint(t,e)?L.INTERIOR:L.EXTERIOR},e(Pn.prototype,{getNextCW:function(t){this.getEdges();var e=this.edgeList.indexOf(t),n=e-1;return 0===e&&(n=this.edgeList.size()-1),this.edgeList.get(n)},propagateSideLabels:function(t){for(var e=L.NONE,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();r.isArea(t)&&r.getLocation(t,cn.LEFT)!==L.NONE&&(e=r.getLocation(t,cn.LEFT))}if(e===L.NONE)return null;for(var s=e,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();if(r.getLocation(t,cn.ON)===L.NONE&&r.setLocation(t,cn.ON,s),r.isArea(t)){var o=r.getLocation(t,cn.LEFT),a=r.getLocation(t,cn.RIGHT);if(a!==L.NONE){if(a!==s)throw new sn("side location conflict",i.getCoordinate());o===L.NONE&&f.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),s=o}else f.isTrue(r.getLocation(t,cn.LEFT)===L.NONE,"found single null side"),r.setLocation(t,cn.RIGHT,s),r.setLocation(t,cn.LEFT,s)}}},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},print:function(t){A.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},isAreaLabelsConsistent:function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},checkAreaLabelsConsistent:function(t){var e=this.getEdges();if(e.size()<=0)return!0;var n=e.size()-1,i=e.get(n).getLabel(),r=i.getLocation(t,cn.LEFT);f.isTrue(r!==L.NONE,"Found unlabelled area edge");for(var s=r,o=this.iterator();o.hasNext();){var a=o.next(),u=a.getLabel();
f.isTrue(u.isArea(t),"Found non-area edge");var l=u.getLocation(t,cn.LEFT),h=u.getLocation(t,cn.RIGHT);if(l===h)return!1;if(h!==s)return!1;s=l}return!0},findIndex:function(t){this.iterator();for(var e=0;e<this.edgeList.size();e++){var n=this.edgeList.get(e);if(n===t)return e}return-1},iterator:function(){return this.getEdges().iterator()},getEdges:function(){return null===this.edgeList&&(this.edgeList=new I(this.edgeMap.values())),this.edgeList},getLocation:function(t,e,n){return this.ptInAreaLocation[t]===L.NONE&&(this.ptInAreaLocation[t]=Tn.locate(e,n[t].getGeometry())),this.ptInAreaLocation[t]},toString:function(){var t=new P;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n")}return t.toString()},computeEdgeEndLabels:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.computeLabel(t)}},computeLabelling:function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)r.isLine(s)&&r.getLocation(s)===L.BOUNDARY&&(e[s]=!0);for(var n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)if(r.isAnyNull(s)){var o=L.NONE;if(e[s])o=L.EXTERIOR;else{var a=i.getCoordinate();o=this.getLocation(s,a,t)}r.setAllLocationsIfNull(s,o)}},getDegree:function(){return this.edgeMap.size()},insertEdgeEnd:function(t,e){this.edgeMap.put(t,e),this.edgeList=null},interfaces_:function(){return[]},getClass:function(){return Pn}}),h(bn,Pn),e(bn.prototype,{linkResultDirectedEdges:function(){this.getResultAreaEdges();for(var t=null,e=null,n=this.SCANNING_FOR_INCOMING,i=0;i<this.resultAreaEdgeList.size();i++){var r=this.resultAreaEdgeList.get(i),s=r.getSym();if(r.getLabel().isArea())switch(null===t&&r.isInResult()&&(t=r),n){case this.SCANNING_FOR_INCOMING:if(!s.isInResult())continue;e=s,n=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(!r.isInResult())continue;e.setNext(r),n=this.SCANNING_FOR_INCOMING}}if(n===this.LINKING_TO_OUTGOING){if(null===t)throw new sn("no outgoing dirEdge found",this.getCoordinate());f.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}},insert:function(t){var e=t;this.insertEdgeEnd(e,e)},getRightmostEdge:function(){var t=this.getEdges(),e=t.size();if(1>e)return null;var n=t.get(0);if(1===e)return n;var i=t.get(e-1),r=n.getQuadrant(),s=i.getQuadrant();if(Je.isNorthern(r)&&Je.isNorthern(s))return n;if(!Je.isNorthern(r)&&!Je.isNorthern(s))return i;return 0!==n.getDy()?n:0!==i.getDy()?i:(f.shouldNeverReachHere("found two horizontal edges incident on node"),null)},print:function(t){A.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}},getResultAreaEdges:function(){if(null!==this.resultAreaEdgeList)return this.resultAreaEdgeList;this.resultAreaEdgeList=new I;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this.resultAreaEdgeList.add(e)}return this.resultAreaEdgeList},updateLabelling:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.setAllLocationsIfNull(0,t.getLocation(0)),i.setAllLocationsIfNull(1,t.getLocation(1))}},linkAllDirectedEdges:function(){this.getEdges();for(var t=null,e=null,n=this.edgeList.size()-1;n>=0;n--){var i=this.edgeList.get(n),r=i.getSym();null===e&&(e=r),null!==t&&r.setNext(t),t=i}e.setNext(t)},computeDepths:function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=(t.getLabel(),t.getDepth(cn.LEFT)),i=t.getDepth(cn.RIGHT),r=this.computeDepths(e+1,this.edgeList.size(),n),s=this.computeDepths(0,e,r);if(s!==i)throw new sn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=u,h=o;a>h;h++){var c=this.edgeList.get(h);c.getLabel();c.setEdgeDepths(cn.RIGHT,l),l=c.getDepth(cn.LEFT)}return l}},mergeSymLabels:function(){for(var t=this.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();n.merge(e.getSym().getLabel())}},linkMinimalDirectedEdges:function(t){for(var e=null,n=null,i=this.SCANNING_FOR_INCOMING,r=this.resultAreaEdgeList.size()-1;r>=0;r--){var s=this.resultAreaEdgeList.get(r),o=s.getSym();switch(null===e&&s.getEdgeRing()===t&&(e=s),i){case this.SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,i=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(s.getEdgeRing()!==t)continue;n.setNextMin(s),i=this.SCANNING_FOR_INCOMING}}i===this.LINKING_TO_OUTGOING&&(f.isTrue(null!==e,"found null for first outgoing dirEdge"),f.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))},getOutgoingDegree:function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();){var n=e.next();n.isInResult()&&t++}return t}if(1===arguments.length){for(var i=arguments[0],t=0,e=this.iterator();e.hasNext();){var n=e.next();n.getEdgeRing()===i&&t++}return t}},getLabel:function(){return this.label},findCoveredLineEdges:function(){for(var t=L.NONE,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=L.INTERIOR;break}if(i.isInResult()){t=L.EXTERIOR;break}}}if(t===L.NONE)return null;for(var r=t,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();n.isLineEdge()?n.getEdge().setCovered(r===L.INTERIOR):(n.isInResult()&&(r=L.EXTERIOR),i.isInResult()&&(r=L.INTERIOR))}},computeLabelling:function(t){Pn.prototype.computeLabelling.call(this,t),this.label=new gn(L.NONE);for(var e=this.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge(),r=i.getLabel(),s=0;2>s;s++){var o=r.getLocation(s);o!==L.INTERIOR&&o!==L.BOUNDARY||this.label.setLocation(s,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return bn}}),h(On,Nn),e(On.prototype,{createNode:function(t){return new yn(t,new bn)},interfaces_:function(){return[]},getClass:function(){return On}}),e(_n.prototype,{computeIntersections:function(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)},interfaces_:function(){return[]},getClass:function(){return _n}}),e(Mn.prototype,{isDelete:function(){return this.eventType===Mn.DELETE},setDeleteEventIndex:function(t){this.deleteEventIndex=t},getObject:function(){return this.obj},compareTo:function(t){var e=t;return this.xValue<e.xValue?-1:this.xValue>e.xValue?1:this.eventType<e.eventType?-1:this.eventType>e.eventType?1:0},getInsertEvent:function(){return this.insertEvent},isInsert:function(){return this.eventType===Mn.INSERT},isSameLabel:function(t){return null===this.label?!1:this.label===t.label},getDeleteEventIndex:function(){return this.deleteEventIndex},interfaces_:function(){return[s]},getClass:function(){return Mn}}),Mn.INSERT=1,Mn.DELETE=2,e(Dn.prototype,{interfaces_:function(){return[]},getClass:function(){return Dn}}),e(An.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(An.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.getNumPoints()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},setIsDoneIfProperInt:function(t){this.isDoneWhenProperInt=t},hasProperInteriorIntersection:function(){return this.hasProperInterior},isBoundaryPointInternal:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinate();if(t.isIntersection(r))return!0}return!1},hasProperIntersection:function(){return this.hasProper},hasIntersection:function(){return this._hasIntersection},isDone:function(){return this._isDone},isBoundaryPoint:function(t,e){return null===e?!1:this.isBoundaryPointInternal(t,e[0])?!0:!!this.isBoundaryPointInternal(t,e[1])},setBoundaryNodes:function(t,e){this.bdyNodes=new Array(2).fill(null),this.bdyNodes[0]=t,this.bdyNodes[1]=e},addIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this.numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this.includeProper&&this.li.isProper()||(t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)),this.li.isProper()&&(this.properIntersectionPoint=this.li.getIntersection(0).copy(),this.hasProper=!0,this.isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this.li,this.bdyNodes)||(this.hasProperInterior=!0))))},interfaces_:function(){return[]},getClass:function(){return An}}),An.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},h(Fn,Dn),e(Fn.prototype,{prepareEvents:function(){ho.sort(this.events);for(var t=0;t<this.events.size();t++){var e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}},computeIntersections:function(){if(1===arguments.length){var t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var e=0;e<this.events.size();e++){var n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof An&&R(arguments[0],y)&&R(arguments[1],y)){var i=arguments[0],r=arguments[1],s=arguments[2];this.addEdges(i,i),this.addEdges(r,r),this.computeIntersections(s)}else if("boolean"==typeof arguments[2]&&R(arguments[0],y)&&arguments[1]instanceof An){var o=arguments[0],a=arguments[1],u=arguments[2];u?this.addEdges(o,null):this.addEdges(o),this.computeIntersections(a)}},addEdge:function(t,e){for(var n=t.getMonotoneChainEdge(),i=n.getStartIndexes(),r=0;r<i.length-1;r++){var s=new _n(n,r),o=new Mn(e,n.getMinX(r),s);this.events.add(o),this.events.add(new Mn(n.getMaxX(r),o))}},processOverlaps:function(t,e,n,i){for(var r=n.getObject(),s=t;e>s;s++){var o=this.events.get(s);if(o.isInsert()){var a=o.getObject();n.isSameLabel(o)||(r.computeIntersections(a,i),this.nOverlaps++)}}},addEdges:function(){if(1===arguments.length)for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.addEdge(n,n)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],e=i.iterator();e.hasNext();){var n=e.next();this.addEdge(n,r)}},interfaces_:function(){return[]},getClass:function(){return Fn}}),e(Gn.prototype,{getMin:function(){return this.min},intersects:function(t,e){return!(this.min>e||this.max<t)},getMax:function(){return this.max},toString:function(){return se.toLineString(new g(this.min,0),new g(this.max,0))},interfaces_:function(){return[]},getClass:function(){return Gn}}),e(qn.prototype,{compare:function(t,e){var n=t,i=e,r=(n.min+n.max)/2,s=(i.min+i.max)/2;return s>r?-1:r>s?1:0},interfaces_:function(){return[a]},getClass:function(){return qn}}),Gn.NodeComparator=qn,h(Bn,Gn),e(Bn.prototype,{query:function(t,e,n){return this.intersects(t,e)?void n.visitItem(this.item):null},interfaces_:function(){return[]},getClass:function(){return Bn}}),h(zn,Gn),e(zn.prototype,{buildExtent:function(t,e){this.min=Math.min(t.min,e.min),this.max=Math.max(t.max,e.max)},query:function(t,e,n){return this.intersects(t,e)?(null!==this.node1&&this.node1.query(t,e,n),void(null!==this.node2&&this.node2.query(t,e,n))):null},interfaces_:function(){return[]},getClass:function(){return zn}}),e(Vn.prototype,{buildTree:function(){ho.sort(this.leaves,new IntervalRTreeNode.NodeComparator);for(var t=this.leaves,e=null,n=new I;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}},insert:function(t,e,n){if(null!==this.root)throw new IllegalStateException("Index cannot be added to once it has been queried");this.leaves.add(new Bn(t,e,n))},query:function(t,e,n){this.init(),this.root.query(t,e,n)},buildRoot:function(){return null!==this.root?null:void(this.root=this.buildTree())},printNode:function(t){A.out.println(se.toLineString(new g(t.min,this.level),new g(t.max,this.level)))},init:function(){return null!==this.root?null:void this.buildRoot()},buildLevel:function(t,e){this.level++,e.clear();for(var n=0;n<t.size();n+=2){var i=t.get(n),r=n+1<t.size()?t.get(n):null;if(null===r)e.add(i);else{var s=new zn(t.get(n),t.get(n+1));e.add(s)}}},interfaces_:function(){return[]},getClass:function(){return Vn}}),e(kn.prototype,{filter:function(t){if(this.isForcedToLineString&&t instanceof bt){var e=t.getFactory().createLineString(t.getCoordinateSequence());return this.lines.add(e),null}t instanceof St&&this.lines.add(t)},setForceToLineString:function(t){this.isForcedToLineString=t},interfaces_:function(){return[q]},getClass:function(){return kn}}),kn.getGeometry=function(){if(1===arguments.length){var t=arguments[0];return t.getFactory().buildGeometry(kn.getLines(t))}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().buildGeometry(kn.getLines(e,n))}},kn.getLines=function(){if(1===arguments.length){var t=arguments[0];return kn.getLines(t,!1)}if(2===arguments.length){if(R(arguments[0],v)&&R(arguments[1],v)){for(var e=arguments[0],n=arguments[1],i=e.iterator();i.hasNext();){var r=i.next();kn.getLines(r,n)}return n}if(arguments[0]instanceof B&&"boolean"==typeof arguments[1]){var s=arguments[0],o=arguments[1],a=new I;return s.apply(new kn(a,o)),a}if(arguments[0]instanceof B&&R(arguments[1],v)){var u=arguments[0],l=arguments[1];return u instanceof St?l.add(u):u.apply(new kn(l)),l}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&R(arguments[0],v)&&R(arguments[1],v)){for(var h=arguments[0],c=arguments[1],f=arguments[2],i=h.iterator();i.hasNext();){var r=i.next();kn.getLines(r,c,f)}return c}if("boolean"==typeof arguments[2]&&arguments[0]instanceof B&&R(arguments[1],v)){var g=arguments[0],d=arguments[1],p=arguments[2];return g.apply(new kn(d,p)),d}}},e(Yn.prototype,{visitItem:function(t){this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return Yn}}),e(Un.prototype,{locate:function(t){var e=new le(t),n=new Xn(e);return this.index.query(t.y,t.y,n),e.getLocation()},interfaces_:function(){return[Rn]},getClass:function(){return Un}}),e(Xn.prototype,{visitItem:function(t){var e=t;this.counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))},interfaces_:function(){return[Ae]},getClass:function(){return Xn}}),e(Hn.prototype,{init:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinates();this.addLine(r)}},addLine:function(t){for(var e=1;e<t.length;e++){var n=new ce(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),r=Math.max(n.p0.y,n.p1.y);this.index.insert(i,r,n)}},query:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yn;return this.index.query(t,e,n),n.getItems()}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.index.query(i,r,s)}},interfaces_:function(){return[]},getClass:function(){return Hn}}),Un.SegmentVisitor=Xn,Un.IntervalIndexedGeometry=Hn,e(Wn.prototype,{getSegmentIndex:function(){return this.segmentIndex},getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)},compareTo:function(t){var e=t;return this.compare(e.segmentIndex,e.dist)},isEndPoint:function(t){return 0===this.segmentIndex&&0===this.dist?!0:this.segmentIndex===t},toString:function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},getDistance:function(){return this.dist},compare:function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0},interfaces_:function(){return[s]},getClass:function(){return Wn}}),e(jn.prototype,{print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},addEndpoints:function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.pts[e.segmentIndex],r=e.dist>0||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.pts[a];return r&&(s[o]=e.coord),new Jn(s,new gn(this.edge.label))},add:function(t,e,n){var i=new Wn(t,e,n),r=this.nodeMap.get(i);return null!==r?r:(this.nodeMap.put(i,i),i)},isIntersection:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();if(n.coord.equals(t))return!0}return!1},interfaces_:function(){return[]},getClass:function(){return jn}}),e(Kn.prototype,{getChainStartIndices:function(t){var e=0,n=new I;n.add(new b(e));do{var i=this.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=Kn.toIntArray(n);return r},findChainEnd:function(t,e){for(var n=Je.quadrant(t[e],t[e+1]),i=e+1;i<t.length;){var r=Je.quadrant(t[i-1],t[i]);if(r!==n)break;i++}return i-1},interfaces_:function(){return[]},getClass:function(){return Kn}}),Kn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(Zn.prototype,{getCoordinates:function(){return this.pts},getMaxX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n},getMinX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return n>e?e:n},computeIntersectsForChain:function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5],h=this.pts[r],c=this.pts[s],f=o.pts[a],g=o.pts[u];if(s-r===1&&u-a===1)return l.addIntersections(this.e,r,o.e,a),null;if(this.env1.init(h,c),this.env2.init(f,g),!this.env1.intersects(this.env2))return null;var d=Math.trunc((r+s)/2),p=Math.trunc((a+u)/2);d>r&&(p>a&&this.computeIntersectsForChain(r,d,o,a,p,l),u>p&&this.computeIntersectsForChain(r,d,o,p,u,l)),s>d&&(p>a&&this.computeIntersectsForChain(d,s,o,a,p,l),u>p&&this.computeIntersectsForChain(d,s,o,p,u,l))}},getStartIndexes:function(){return this.startIndex},computeIntersects:function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)},interfaces_:function(){return[]},getClass:function(){return Zn}}),e(Qn.prototype,{getDepth:function(t,e){return this.depth[t][e]},setDepth:function(t,e,n){this.depth[t][e]=n},isNull:function(){if(0===arguments.length){for(var t=0;2>t;t++)for(var e=0;3>e;e++)if(this.depth[t][e]!==Qn.NULL_VALUE)return!1;return!0}if(1===arguments.length){var n=arguments[0];return this.depth[n][1]===Qn.NULL_VALUE}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this.depth[i][r]===Qn.NULL_VALUE}},normalize:function(){for(var t=0;2>t;t++)if(!this.isNull(t)){var e=this.depth[t][1];this.depth[t][2]<e&&(e=this.depth[t][2]),0>e&&(e=0);for(var n=1;3>n;n++){var i=0;this.depth[t][n]>e&&(i=1),this.depth[t][n]=i}}},getDelta:function(t){return this.depth[t][cn.RIGHT]-this.depth[t][cn.LEFT]},getLocation:function(t,e){return this.depth[t][e]<=0?L.EXTERIOR:L.INTERIOR},toString:function(){return"A: "+this.depth[0][1]+","+this.depth[0][2]+" B: "+this.depth[1][1]+","+this.depth[1][2]},add:function(){if(1===arguments.length)for(var t=arguments[0],e=0;2>e;e++)for(var n=1;3>n;n++){var i=t.getLocation(e,n);i!==L.EXTERIOR&&i!==L.INTERIOR||(this.isNull(e,n)?this.depth[e][n]=Qn.depthAtLocation(i):this.depth[e][n]+=Qn.depthAtLocation(i))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];o===L.INTERIOR&&this.depth[r][s]++}},interfaces_:function(){return[]},getClass:function(){return Qn}}),Qn.depthAtLocation=function(t){return t===L.EXTERIOR?0:t===L.INTERIOR?1:Qn.NULL_VALUE},Qn.NULL_VALUE=-1,h(Jn,mn),e(Jn.prototype,{getDepth:function(){return this.depth},getCollapsedEdge:function(){var t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];var e=new Jn(t,gn.toLineLabel(this.label));return e},isIsolated:function(){return this._isIsolated},getCoordinates:function(){return this.pts},setIsolated:function(t){this._isIsolated=t},setName:function(t){this.name=t},equals:function(t){if(!(t instanceof Jn))return!1;var e=t;if(this.pts.length!==e.pts.length)return!1;for(var n=!0,i=!0,r=this.pts.length,s=0;s<this.pts.length;s++)if(this.pts[s].equals2D(e.pts[s])||(n=!1),this.pts[s].equals2D(e.pts[--r])||(i=!1),!n&&!i)return!1;return!0},getCoordinate:function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}},print:function(t){t.print("edge "+this.name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this.label+" "+this.depthDelta)},computeIM:function(t){Jn.updateIM(this.label,t)},isCollapsed:function(){return this.label.isArea()?3!==this.pts.length?!1:!!this.pts[0].equals(this.pts[2]):!1},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getMaximumSegmentIndex:function(){return this.pts.length-1},getDepthDelta:function(){return this.depthDelta},getNumPoints:function(){return this.pts.length},printReverse:function(t){t.print("edge "+this.name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")},getMonotoneChainEdge:function(){return null===this.mce&&(this.mce=new Zn(this)),this.mce},getEnvelope:function(){if(null===this.env){this.env=new C;for(var t=0;t<this.pts.length;t++)this.env.expandToInclude(this.pts[t])}return this.env},addIntersection:function(t,e,n,i){var r=new g(t.getIntersection(i)),s=e,o=t.getEdgeDistance(n,i),a=s+1;if(a<this.pts.length){var u=this.pts[a];r.equals2D(u)&&(s=a,o=0)}this.eiList.add(r,s,o)},toString:function(){var t=new P;t.append("edge "+this.name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this.label+" "+this.depthDelta),t.toString()},isPointwiseEqual:function(t){if(this.pts.length!==t.pts.length)return!1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0},setDepthDelta:function(t){this.depthDelta=t},getEdgeIntersectionList:function(){return this.eiList},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[]},getClass:function(){return Jn}}),Jn.updateIM=function(){if(2!==arguments.length)return mn.prototype.updateIM.apply(this,arguments);var t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,cn.ON),t.getLocation(1,cn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,cn.LEFT),t.getLocation(1,cn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,cn.RIGHT),t.getLocation(1,cn.RIGHT),2))},h($n,Cn),e($n.prototype,{insertBoundaryPoint:function(t,e){var n=this.nodes.addNode(e),i=n.getLabel(),r=1,s=L.NONE;s=i.getLocation(t,cn.ON),s===L.BOUNDARY&&r++;var o=$n.determineBoundary(this.boundaryNodeRule,r);i.setLocation(t,o)},computeSelfNodes:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=new An(n,!0,!1);s.setIsDoneIfProperInt(r);var o=this.createEdgeSetIntersector(),a=this.parentGeom instanceof bt||this.parentGeom instanceof Tt||this.parentGeom instanceof Ot,u=i||!a;return o.computeIntersections(this.edges,s,u),this.addSelfIntersectionNodes(this.argIndex),s}},computeSplitEdges:function(t){for(var e=this.edges.iterator();e.hasNext();){var n=e.next();n.eiList.addSplitEdges(t)}},computeEdgeIntersections:function(t,e,n){var i=new An(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());var r=this.createEdgeSetIntersector();return r.computeIntersections(this.edges,t.edges,i),i},getGeometry:function(){return this.parentGeom},getBoundaryNodeRule:function(){return this.boundaryNodeRule},hasTooFewPoints:function(){return this._hasTooFewPoints},addPoint:function(){if(arguments[0]instanceof Lt){var t=arguments[0],e=t.getCoordinate();this.insertPoint(this.argIndex,e,L.INTERIOR)}else if(arguments[0]instanceof g){var n=arguments[0];this.insertPoint(this.argIndex,n,L.INTERIOR)}},addPolygon:function(t){this.addPolygonRing(t.getExteriorRing(),L.EXTERIOR,L.INTERIOR);for(var e=0;e<t.getNumInteriorRing();e++){var n=t.getInteriorRingN(e);this.addPolygonRing(n,L.INTERIOR,L.EXTERIOR)}},addEdge:function(t){this.insertEdge(t);var e=t.getCoordinates();this.insertPoint(this.argIndex,e[0],L.BOUNDARY),this.insertPoint(this.argIndex,e[e.length-1],L.BOUNDARY)},addLineString:function(t){var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this.invalidPoint=e[0],null;var n=new Jn(e,new gn(this.argIndex,L.INTERIOR));this.lineEdgeMap.put(t,n),this.insertEdge(n),f.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this.argIndex,e[0]),this.insertBoundaryPoint(this.argIndex,e[e.length-1])},getInvalidPoint:function(){return this.invalidPoint},getBoundaryPoints:function(){for(var t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null),n=0,i=t.iterator();i.hasNext();){var r=i.next();e[n++]=r.getCoordinate().copy()}return e},getBoundaryNodes:function(){return null===this.boundaryNodes&&(this.boundaryNodes=this.nodes.getBoundaryNodes(this.argIndex)),this.boundaryNodes},addSelfIntersectionNode:function(t,e,n){return this.isBoundaryNode(t,e)?null:void(n===L.BOUNDARY&&this.useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n))},addPolygonRing:function(t,e,n){if(t.isEmpty())return null;var i=H.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this.invalidPoint=i[0],null;var r=e,s=n;he.isCCW(i)&&(r=n,s=e);var o=new Jn(i,new gn(this.argIndex,L.BOUNDARY,r,s));this.lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this.argIndex,i[0],L.BOUNDARY)},insertPoint:function(t,e,n){var i=this.nodes.addNode(e),r=i.getLabel();null===r?i.label=new gn(t,n):r.setLocation(t,n)},createEdgeSetIntersector:function(){return new Fn},addSelfIntersectionNodes:function(t){for(var e=this.edges.iterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.eiList.iterator();r.hasNext();){var s=r.next();this.addSelfIntersectionNode(t,s.coord,i)}},add:function(){if(1!==arguments.length)return Cn.prototype.add.apply(this,arguments);var t=arguments[0];if(t.isEmpty())return null;if(t instanceof Ot&&(this.useBoundaryDeterminationRule=!1),t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},locate:function(t){return R(this.parentGeom,Rt)&&this.parentGeom.getNumGeometries()>50?(null===this.areaPtLocator&&(this.areaPtLocator=new Un(this.parentGeom)),this.areaPtLocator.locate(t)):this.ptLocator.locate(t,this.parentGeom)},findEdge:function(){if(1===arguments.length){var t=arguments[0];return this.lineEdgeMap.get(t)}return Cn.prototype.findEdge.apply(this,arguments)},interfaces_:function(){return[]},getClass:function(){return $n}}),$n.determineBoundary=function(t,e){return t.isInBoundary(e)?L.BOUNDARY:L.INTERIOR},e(ti.prototype,{getArgGeometry:function(t){return this.arg[t].getGeometry()},setComputationPrecision:function(t){this.resultPrecisionModel=t,this.li.setPrecisionModel(this.resultPrecisionModel)},interfaces_:function(){return[]},getClass:function(){return ti}}),e(ei.prototype,{compareTo:function(t){var e=t,n=ei.compareOriented(this.pts,this._orientation,e.pts,e._orientation);return n},interfaces_:function(){return[s]},getClass:function(){return ei}}),ei.orientation=function(t){return 1===H.increasingDirection(t)},ei.compareOriented=function(t,e,n,i){for(var r=e?1:-1,s=i?1:-1,o=e?t.length:-1,a=i?n.length:-1,u=e?0:t.length-1,l=i?0:n.length-1;;){var h=t[u].compareTo(n[l]);if(0!==h)return h;u+=r,l+=s;var c=u===o,f=l===a;if(c&&!f)return-1;if(!c&&f)return 1;if(c&&f)return 0}},e(ni.prototype,{print:function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this.edges.size();e++){var n=this.edges.get(e);e>0&&t.print(","),t.print("(");for(var i=n.getCoordinates(),r=0;r<i.length;r++)r>0&&t.print(","),t.print(i[r].x+" "+i[r].y);t.println(")")}t.print(")  ")},addAll:function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next())},findEdgeIndex:function(t){for(var e=0;e<this.edges.size();e++)if(this.edges.get(e).equals(t))return e;return-1},iterator:function(){return this.edges.iterator()},getEdges:function(){return this.edges},get:function(t){return this.edges.get(t)},findEqualEdge:function(t){var e=new ei(t.getCoordinates()),n=this.ocaMap.get(e);return n},add:function(t){this.edges.add(t);var e=new ei(t.getCoordinates());this.ocaMap.put(e,t)},interfaces_:function(){return[]},getClass:function(){return ni}}),h(ii,ti),e(ii.prototype,{insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip());var r=e.getDepth();r.isNull()&&r.add(n),r.add(i),n.merge(i)}else this.edgeList.add(t)},getGraph:function(){return this.graph},cancelDuplicateResultEdges:function(){for(var t=this.graph.getEdgeEnds().iterator();t.hasNext();){var e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}},isCoveredByLA:function(t){return this.isCovered(t,this.resultLineList)?!0:!!this.isCovered(t,this.resultPolyList)},computeGeometry:function(t,e,n,i){var r=new I;return r.addAll(t),r.addAll(e),r.addAll(n),r.isEmpty()?ii.createEmptyResult(i,this.arg[0].getGeometry(),this.arg[1].getGeometry(),this.geomFact):this.geomFact.buildGeometry(r)},mergeSymLabels:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().mergeSymLabels()}},isCovered:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=this.ptLocator.locate(t,i);if(r!==L.EXTERIOR)return!0}return!1},replaceCollapsedEdges:function(){for(var t=new I,e=this.edgeList.iterator();e.hasNext();){var n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this.edgeList.addAll(t)},updateNodeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}},getResultGeometry:function(t){return this.computeOverlay(t),this.resultGeom},insertUniqueEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertUniqueEdge(n)}},computeOverlay:function(t){this.copyPoints(0),this.copyPoints(1),this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1),this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!0);var e=new I;this.arg[0].computeSplitEdges(e),this.arg[1].computeSplitEdges(e);this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),ln.checkValid(this.edgeList.getEdges()),this.graph.addEdges(this.edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();var n=new Sn(this.geomFact);n.add(this.graph),this.resultPolyList=n.getPolygons();var i=new wn(this,this.geomFact,this.ptLocator);this.resultLineList=i.build(t);var r=new Ln(this,this.geomFact,this.ptLocator);this.resultPointList=r.build(t),
this.resultGeom=this.computeGeometry(this.resultPointList,this.resultLineList,this.resultPolyList,t)},labelIncompleteNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setLocation(e,n)},copyPoints:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.graph.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},findResultAreaEdges:function(t){for(var e=this.graph.getEdgeEnds().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.isArea()&&!n.isInteriorAreaEdge()&&ii.isResultOfOp(i.getLocation(0,cn.RIGHT),i.getLocation(1,cn.RIGHT),t)&&n.setInResult(!0)}},computeLabelsFromDepths:function(){for(var t=this.edgeList.iterator();t.hasNext();){var e=t.next(),n=e.getLabel(),i=e.getDepth();if(!i.isNull()){i.normalize();for(var r=0;2>r;r++)n.isNull(r)||!n.isArea()||i.isNull(r)||(0===i.getDelta(r)?n.toLine(r):(f.isTrue(!i.isNull(r,cn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(r,cn.LEFT,i.getLocation(r,cn.LEFT)),f.isTrue(!i.isNull(r,cn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(r,cn.RIGHT,i.getLocation(r,cn.RIGHT))))}}},computeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}this.mergeSymLabels(),this.updateNodeLabelling()},labelIncompleteNodes:function(){for(var t=0,e=this.graph.getNodes().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(t++,i.isNull(0)?this.labelIncompleteNode(n,0):this.labelIncompleteNode(n,1)),n.getEdges().updateLabelling(i)}},isCoveredByA:function(t){return!!this.isCovered(t,this.resultPolyList)},interfaces_:function(){return[]},getClass:function(){return ii}}),ii.overlayOp=function(t,e,n){var i=new ii(t,e),r=i.getResultGeometry(n);return r},ii.intersection=function(t,e){if(t.isEmpty()||e.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){var n=e;return hn.map(t,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(n)}})}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.INTERSECTION)},ii.symDifference=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.SYMDIFFERENCE)},ii.resultDimension=function(t,e,n){var i=e.getDimension(),r=n.getDimension(),s=-1;switch(t){case ii.INTERSECTION:s=Math.min(i,r);break;case ii.UNION:s=Math.max(i,r);break;case ii.DIFFERENCE:s=i;break;case ii.SYMDIFFERENCE:s=Math.max(i,r)}return s},ii.createEmptyResult=function(t,e,n,i){var r=null;switch(ii.resultDimension(t,e,n)){case-1:r=i.createGeometryCollection(new Array(0).fill(null));break;case 0:r=i.createPoint();break;case 1:r=i.createLineString();break;case 2:r=i.createPolygon()}return r},ii.difference=function(t,e){return t.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,t,e,t.getFactory()):e.isEmpty()?t.copy():(t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.DIFFERENCE))},ii.isResultOfOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=t.getLocation(0),i=t.getLocation(1);return ii.isResultOfOp(n,i,e)}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];switch(r===L.BOUNDARY&&(r=L.INTERIOR),s===L.BOUNDARY&&(s=L.INTERIOR),o){case ii.INTERSECTION:return r===L.INTERIOR&&s===L.INTERIOR;case ii.UNION:return r===L.INTERIOR||s===L.INTERIOR;case ii.DIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR;case ii.SYMDIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR||r!==L.INTERIOR&&s===L.INTERIOR}return!1}},ii.INTERSECTION=1,ii.UNION=2,ii.DIFFERENCE=3,ii.SYMDIFFERENCE=4,e(ri.prototype,{selfSnap:function(t){var e=new Ie(t),n=e.snapTo(t,this.snapTolerance);return n},removeCommonBits:function(t){this.cbr=new Se,this.cbr.add(t[0]),this.cbr.add(t[1]);var e=new Array(2).fill(null);return e[0]=this.cbr.removeCommonBits(t[0].copy()),e[1]=this.cbr.removeCommonBits(t[1].copy()),e},prepareResult:function(t){return this.cbr.addCommonBits(t),t},getResultGeometry:function(t){var e=this.snap(this.geom),n=ii.overlayOp(e[0],e[1],t);return this.prepareResult(n)},checkValid:function(t){t.isValid()||A.out.println("Snapped geometry is invalid")},computeSnapTolerance:function(){this.snapTolerance=Ie.computeOverlaySnapTolerance(this.geom[0],this.geom[1])},snap:function(t){var e=this.removeCommonBits(t),n=Ie.snap(e[0],e[1],this.snapTolerance);return n},interfaces_:function(){return[]},getClass:function(){return ri}}),ri.overlayOp=function(t,e,n){var i=new ri(t,e);return i.getResultGeometry(n)},ri.union=function(t,e){return ri.overlayOp(t,e,ii.UNION)},ri.intersection=function(t,e){return ri.overlayOp(t,e,ii.INTERSECTION)},ri.symDifference=function(t,e){return ri.overlayOp(t,e,ii.SYMDIFFERENCE)},ri.difference=function(t,e){return ri.overlayOp(t,e,ii.DIFFERENCE)},e(si.prototype,{getResultGeometry:function(t){var e=null,n=!1,i=null;try{e=ii.overlayOp(this.geom[0],this.geom[1],t);var r=!0;r&&(n=!0)}catch(t){if(!(t instanceof l))throw t;i=t}finally{}if(!n)try{e=ri.overlayOp(this.geom[0],this.geom[1],t)}catch(t){throw t instanceof l?i:t}finally{}return e},interfaces_:function(){return[]},getClass:function(){return si}}),si.overlayOp=function(t,e,n){var i=new si(t,e);return i.getResultGeometry(n)},si.union=function(t,e){return si.overlayOp(t,e,ii.UNION)},si.intersection=function(t,e){return si.overlayOp(t,e,ii.INTERSECTION)},si.symDifference=function(t,e){return si.overlayOp(t,e,ii.SYMDIFFERENCE)},si.difference=function(t,e){return si.overlayOp(t,e,ii.DIFFERENCE)},e(oi.prototype,{addPolygon:function(t){if(t.isEmpty())return null;var e=null,n=0,i=this.horizontalBisector(t);if(0===i.getLength())n=0,e=i.getCoordinate();else{var r=si.overlayOp(i,t,ii.INTERSECTION),s=this.widestGeometry(r);n=s.getEnvelopeInternal().getWidth(),e=oi.centre(s.getEnvelopeInternal())}(null===this.interiorPoint||n>this.maxWidth)&&(this.interiorPoint=e,this.maxWidth=n)},getInteriorPoint:function(){return this.interiorPoint},widestGeometry:function t(){if(arguments[0]instanceof ft){var e=arguments[0];if(e.isEmpty())return e;for(var t=e.getGeometryN(0),n=1;n<e.getNumGeometries();n++)e.getGeometryN(n).getEnvelopeInternal().getWidth()>t.getEnvelopeInternal().getWidth()&&(t=e.getGeometryN(n));return t}if(arguments[0]instanceof B){var i=arguments[0];return i instanceof ft?this.widestGeometry(i):i}},horizontalBisector:function(t){var e=t.getEnvelopeInternal(),n=ai.getBisectorY(t);return this.factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])},add:function(t){if(t instanceof Tt)this.addPolygon(t);else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))},interfaces_:function(){return[]},getClass:function(){return oi}}),oi.centre=function(t){return new g(oi.avg(t.getMinX(),t.getMaxX()),oi.avg(t.getMinY(),t.getMaxY()))},oi.avg=function(t,e){return(t+e)/2},e(ai.prototype,{updateInterval:function(t){t<=this.centreY?t>this.loY&&(this.loY=t):t>this.centreY&&t<this.hiY&&(this.hiY=t)},getBisectorY:function(){this.process(this.poly.getExteriorRing());for(var t=0;t<this.poly.getNumInteriorRing();t++)this.process(this.poly.getInteriorRingN(t));var e=oi.avg(this.hiY,this.loY);return e},process:function(t){for(var e=t.getCoordinateSequence(),n=0;n<e.size();n++){var i=e.getY(n);this.updateInterval(i)}},interfaces_:function(){return[]},getClass:function(){return ai}}),ai.getBisectorY=function(t){var e=new ai(t);return e.getBisectorY()},oi.SafeBisectorFinder=ai,e(ui.prototype,{addEndpoints:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addEndpoints(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addEndpoints(e.getGeometryN(n))}else if(arguments[0]instanceof Array){var i=arguments[0];this.add(i[0]),this.add(i[i.length-1])}},getInteriorPoint:function(){return this.interiorPoint},addInterior:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addInterior(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addInterior(e.getGeometryN(n))}else if(arguments[0]instanceof Array)for(var i=arguments[0],n=1;n<i.length-1;n++)this.add(i[n])},add:function(t){var e=t.distance(this.centroid);e<this.minDistance&&(this.interiorPoint=new g(t),this.minDistance=e)},interfaces_:function(){return[]},getClass:function(){return ui}}),e(li.prototype,{getInteriorPoint:function(){return this.interiorPoint},add:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof Lt)this.add(t.getCoordinate());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))}else if(arguments[0]instanceof g){var i=arguments[0],r=i.distance(this.centroid);r<this.minDistance&&(this.interiorPoint=new g(i),this.minDistance=r)}},interfaces_:function(){return[]},getClass:function(){return li}}),e(hi.prototype,{interfaces_:function(){return[]},getClass:function(){return hi}}),hi.toDegrees=function(t){return 180*t/Math.PI},hi.normalize=function(t){for(;t>Math.PI;)t-=hi.PI_TIMES_2;for(;t<=-Math.PI;)t+=hi.PI_TIMES_2;return t},hi.angle=function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],i=n.x-e.x,r=n.y-e.y;return Math.atan2(r,i)}},hi.isAcute=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return a>0},hi.isObtuse=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return 0>a},hi.interiorAngle=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n);return Math.abs(r-i)},hi.normalizePositive=function(t){if(0>t){for(;0>t;)t+=hi.PI_TIMES_2;t>=hi.PI_TIMES_2&&(t=0)}else{for(;t>=hi.PI_TIMES_2;)t-=hi.PI_TIMES_2;0>t&&(t=0)}return t},hi.angleBetween=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n);return hi.diff(i,r)},hi.diff=function(t,e){var n=null;return n=e>t?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n},hi.toRadians=function(t){return t*Math.PI/180},hi.getTurn=function(t,e){var n=Math.sin(e-t);return n>0?hi.COUNTERCLOCKWISE:0>n?hi.CLOCKWISE:hi.NONE},hi.angleBetweenOriented=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n),s=r-i;return s<=-Math.PI?s+hi.PI_TIMES_2:s>Math.PI?s-hi.PI_TIMES_2:s},hi.PI_TIMES_2=2*Math.PI,hi.PI_OVER_2=Math.PI/2,hi.PI_OVER_4=Math.PI/4,hi.COUNTERCLOCKWISE=he.COUNTERCLOCKWISE,hi.CLOCKWISE=he.CLOCKWISE,hi.NONE=he.COLLINEAR,e(ci.prototype,{area:function(){return ci.area(this.p0,this.p1,this.p2)},signedArea:function(){return ci.signedArea(this.p0,this.p1,this.p2)},interpolateZ:function(t){if(null===t)throw new i("Supplied point is null.");return ci.interpolateZ(t,this.p0,this.p1,this.p2)},longestSideLength:function(){return ci.longestSideLength(this.p0,this.p1,this.p2)},isAcute:function(){return ci.isAcute(this.p0,this.p1,this.p2)},circumcentre:function(){return ci.circumcentre(this.p0,this.p1,this.p2)},area3D:function(){return ci.area3D(this.p0,this.p1,this.p2)},centroid:function(){return ci.centroid(this.p0,this.p1,this.p2)},inCentre:function(){return ci.inCentre(this.p0,this.p1,this.p2)},interfaces_:function(){return[]},getClass:function(){return ci}}),ci.area=function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)},ci.signedArea=function(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2},ci.det=function(t,e,n,i){return t*i-e*n},ci.interpolateZ=function(t,e,n,i){var r=e.x,s=e.y,o=n.x-r,a=i.x-r,u=n.y-s,l=i.y-s,h=o*l-a*u,c=t.x-r,f=t.y-s,g=(l*c-a*f)/h,d=(-u*c+o*f)/h,p=e.z+g*(n.z-e.z)+d*(i.z-e.z);return p},ci.longestSideLength=function(t,e,n){var i=t.distance(e),r=e.distance(n),s=n.distance(t),o=i;return r>o&&(o=r),s>o&&(o=s),o},ci.isAcute=function(t,e,n){return hi.isAcute(t,e,n)&&hi.isAcute(e,n,t)?!!hi.isAcute(n,t,e):!1},ci.circumcentre=function(t,e,n){var i=n.x,r=n.y,s=t.x-i,o=t.y-r,a=e.x-i,u=e.y-r,l=2*ci.det(s,o,a,u),h=ci.det(o,s*s+o*o,u,a*a+u*u),c=ci.det(s,s*s+o*o,a,a*a+u*u),f=i-h/l,d=r+c/l;return new g(f,d)},ci.perpendicularBisector=function(t,e){var n=e.x-t.x,i=e.y-t.y,r=new F(t.x+n/2,t.y+i/2,1),s=new F(t.x-i+n/2,t.y+n+i/2,1);return new F(r,s)},ci.angleBisector=function(t,e,n){var i=e.distance(t),r=e.distance(n),s=i/(i+r),o=n.x-t.x,a=n.y-t.y,u=new g(t.x+s*o,t.y+s*a);return u},ci.area3D=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=e.z-t.z,o=n.x-t.x,a=n.y-t.y,u=n.z-t.z,l=r*u-s*a,h=s*o-i*u,c=i*a-r*o,f=l*l+h*h+c*c,g=Math.sqrt(f)/2;return g},ci.centroid=function(t,e,n){var i=(t.x+e.x+n.x)/3,r=(t.y+e.y+n.y)/3;return new g(i,r)},ci.inCentre=function(t,e,n){var i=e.distance(n),r=t.distance(n),s=t.distance(e),o=i+r+s,a=(i*t.x+r*e.x+s*n.x)/o,u=(i*t.y+r*e.y+s*n.y)/o;return new g(a,u)},e(fi.prototype,{getRadius:function(){return this.compute(),this.radius},getDiameter:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[1];return this.input.getFactory().createLineString([t,e])},getExtremalPoints:function(){return this.compute(),this.extremalPts},computeCirclePoints:function(){if(this.input.isEmpty())return this.extremalPts=new Array(0).fill(null),null;if(1===this.input.getNumPoints()){var t=this.input.getCoordinates();return this.extremalPts=[new g(t[0])],null}var e=this.input.convexHull(),n=e.getCoordinates(),t=n;if(n[0].equals2D(n[n.length-1])&&(t=new Array(n.length-1).fill(null),H.copyDeep(n,0,t,0,n.length-1)),t.length<=2)return this.extremalPts=H.copyDeep(t),null;for(var i=fi.lowestPoint(t),r=fi.pointWitMinAngleWithX(t,i),s=0;s<t.length;s++){var o=fi.pointWithMinAngleWithSegment(t,i,r);if(hi.isObtuse(i,o,r))return this.extremalPts=[new g(i),new g(r)],null;if(hi.isObtuse(o,i,r))i=o;else{if(!hi.isObtuse(o,r,i))return this.extremalPts=[new g(i),new g(r),new g(o)],null;r=o}}f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")},compute:function(){return null!==this.extremalPts?null:(this.computeCirclePoints(),this.computeCentre(),void(null!==this.centre&&(this.radius=this.centre.distance(this.extremalPts[0]))))},getFarthestPoints:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[this.extremalPts.length-1];return this.input.getFactory().createLineString([t,e])},getCircle:function(){if(this.compute(),null===this.centre)return this.input.getFactory().createPolygon();var t=this.input.getFactory().createPoint(this.centre);return 0===this.radius?t:t.buffer(this.radius)},getCentre:function(){return this.compute(),this.centre},computeCentre:function(){switch(this.extremalPts.length){case 0:this.centre=null;break;case 1:this.centre=this.extremalPts[0];break;case 2:this.centre=new g((this.extremalPts[0].x+this.extremalPts[1].x)/2,(this.extremalPts[0].y+this.extremalPts[1].y)/2);break;case 3:this.centre=ci.circumcentre(this.extremalPts[0],this.extremalPts[1],this.extremalPts[2])}},interfaces_:function(){return[]},getClass:function(){return fi}}),fi.pointWitMinAngleWithX=function(t,e){for(var n=r.MAX_VALUE,i=null,s=0;s<t.length;s++){var o=t[s];if(o!==e){var a=o.x-e.x,u=o.y-e.y;0>u&&(u=-u);var l=Math.sqrt(a*a+u*u),h=u/l;n>h&&(n=h,i=o)}}return i},fi.lowestPoint=function(t){for(var e=t[0],n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e},fi.pointWithMinAngleWithSegment=function(t,e,n){for(var i=r.MAX_VALUE,s=null,o=0;o<t.length;o++){var a=t[o];if(a!==e&&a!==n){var u=hi.angleBetween(e,a,n);i>u&&(i=u,s=a)}}return s},e(gi.prototype,{getWidthCoordinate:function(){return this.computeMinimumDiameter(),this.minWidthPt},getSupportingSegment:function(){return this.computeMinimumDiameter(),this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0,this.minBaseSeg.p1])},getDiameter:function(){if(this.computeMinimumDiameter(),null===this.minWidthPt)return this.inputGeom.getFactory().createLineString(null);var t=this.minBaseSeg.project(this.minWidthPt);return this.inputGeom.getFactory().createLineString([t,this.minWidthPt])},computeWidthConvex:function(t){t instanceof Tt?this.convexHullPts=t.getExteriorRing().getCoordinates():this.convexHullPts=t.getCoordinates(),0===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=null,this.minBaseSeg=null):1===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[0]):2===this.convexHullPts.length||3===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[1]):this.computeConvexRingMinDiameter(this.convexHullPts)},computeConvexRingMinDiameter:function(t){this.minWidth=r.MAX_VALUE;for(var e=1,n=new ce,i=0;i<t.length-1;i++)n.p0=t[i],n.p1=t[i+1],e=this.findMaxPerpDistance(t,n,e)},computeMinimumDiameter:function(){if(null!==this.minWidthPt)return null;if(this.isConvex)this.computeWidthConvex(this.inputGeom);else{var t=new me(this.inputGeom).getConvexHull();this.computeWidthConvex(t)}},getLength:function(){return this.computeMinimumDiameter(),this.minWidth},findMaxPerpDistance:function(t,e,n){for(var i=e.distancePerpendicular(t[n]),r=i,s=n,o=s;r>=i;)i=r,s=o,o=gi.nextIndex(t,s),r=e.distancePerpendicular(t[o]);return i<this.minWidth&&(this.minPtIndex=s,this.minWidth=i,this.minWidthPt=t[this.minPtIndex],this.minBaseSeg=new ce(e)),s},getMinimumRectangle:function(){if(this.computeMinimumDiameter(),0===this.minWidth)return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)?this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0):this.minBaseSeg.toGeometry(this.inputGeom.getFactory());for(var t=this.minBaseSeg.p1.x-this.minBaseSeg.p0.x,e=this.minBaseSeg.p1.y-this.minBaseSeg.p0.y,n=r.MAX_VALUE,i=-r.MAX_VALUE,s=r.MAX_VALUE,o=-r.MAX_VALUE,a=0;a<this.convexHullPts.length;a++){var u=gi.computeC(t,e,this.convexHullPts[a]);u>i&&(i=u),n>u&&(n=u);var l=gi.computeC(-e,t,this.convexHullPts[a]);l>o&&(o=l),s>l&&(s=l)}var h=gi.computeSegmentForLine(-t,-e,o),c=gi.computeSegmentForLine(-t,-e,s),f=gi.computeSegmentForLine(-e,t,i),g=gi.computeSegmentForLine(-e,t,n),d=f.lineIntersection(h),p=g.lineIntersection(h),v=g.lineIntersection(c),m=f.lineIntersection(c),y=this.inputGeom.getFactory().createLinearRing([d,p,v,m,d]);return this.inputGeom.getFactory().createPolygon(y,null)},interfaces_:function(){return[]},getClass:function(){return gi}}),gi.nextIndex=function(t,e){return e++,e>=t.length&&(e=0),e},gi.computeC=function(t,e,n){return t*n.y-e*n.x},gi.getMinimumDiameter=function(t){return new gi(t).getDiameter()},gi.getMinimumRectangle=function(t){return new gi(t).getMinimumRectangle()},gi.computeSegmentForLine=function(t,e,n){var i=null,r=null;return Math.abs(e)>Math.abs(t)?(i=new g(0,n/e),r=new g(1,n/e-t/e)):(i=new g(n/t,0),r=new g(n/t-e/t,1)),new ce(i,r)};var co=Object.freeze({Centroid:ge,CGAlgorithms:he,ConvexHull:me,InteriorPointArea:oi,InteriorPointLine:ui,InteriorPointPoint:li,RobustLineIntersector:ae,MinimumBoundingCircle:fi,MinimumDiameter:gi});e(di.prototype,{getResultGeometry:function(){return new pi(this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>=t)throw new i("Tolerance must be positive");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return di}}),di.densifyPoints=function(t,e,n){for(var i=new ce,r=new N,s=0;s<t.length-1;s++){i.p0=t[s],i.p1=t[s+1],r.add(i.p0,!1);var o=i.getLength(),a=Math.trunc(o/e)+1;if(a>1)for(var u=o/a,l=1;a>l;l++){var h=l*u/o,c=i.pointAlong(h);n.makePrecise(c),r.add(c,!1)}}return r.add(t[t.length-1],!1),r.toCoordinateArray()},di.densify=function(t,e){var n=new di(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(pi,xe),e(pi.prototype,{transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformPolygon:function(t,e){var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=di.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof St&&1===i.length&&(i=new Array(0).fill(null)),this.factory.getCoordinateSequenceFactory().create(i)},createValidArea:function(t){return t.buffer(0)},interfaces_:function(){return[]},getClass:function(){return pi}}),di.DensifyTransformer=pi;var fo=Object.freeze({Densifier:di});e(vi.prototype,{find:function(t){var e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null},dest:function(){return this._sym._orig},oNext:function(){return this._sym._next},insert:function(t){if(this.oNext()===this)return this.insertAfter(t),null;var e=this.compareTo(t),n=this;do{var i=n.oNext(),r=i.compareTo(t);if(r!==e||i===this)return n.insertAfter(t),null;n=i}while(n!==this);f.shouldNeverReachHere()},insertAfter:function(t){f.equals(this._orig,t.orig());var e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)},degree:function t(){var t=0,e=this;do t++,e=e.oNext();while(e!==this);return t},equals:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}},deltaY:function(){return this._sym._orig.y-this._orig.y},sym:function(){return this._sym},prev:function(){return this._sym.next()._sym},compareAngularDirection:function(t){var e=this.deltaX(),n=this.deltaY(),i=t.deltaX(),r=t.deltaY();if(e===i&&n===r)return 0;var s=Je.quadrant(e,n),o=Je.quadrant(i,r);return s>o?1:o>s?-1:he.computeOrientation(t._orig,t.dest(),this.dest())},prevNode:function(){for(var t=this;2===t.degree();)if(t=t.prev(),t===this)return null;return t},compareTo:function(t){var e=t,n=this.compareAngularDirection(e);return n},next:function(){return this._next},setSym:function(t){this._sym=t},orig:function(){return this._orig},toString:function(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"},setNext:function(t){this._next=t},init:function(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)},deltaX:function(){return this._sym._orig.x-this._orig.x},interfaces_:function(){return[]},getClass:function(){return vi}}),vi.init=function(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t},vi.create=function(t,e){var n=new vi(t),i=new vi(e);return n.init(i),n},h(mi,vi),e(mi.prototype,{mark:function(){this._isMarked=!0},setMark:function(t){this._isMarked=t},isMarked:function(){return this._isMarked},interfaces_:function(){return[]},getClass:function(){return mi}}),mi.setMarkBoth=function(t,e){t.setMark(e),t.sym().setMark(e)},mi.isMarked=function(t){return t.isMarked()},mi.setMark=function(t,e){t.setMark(e)},mi.markBoth=function(t){t.mark(),t.sym().mark()},mi.mark=function(t){t.mark()},e(yi.prototype,{insert:function(t,e,n){var i=this.create(t,e);null!==n?n.insert(i):this.vertexMap.put(t,i);var r=this.vertexMap.get(e);return null!==r?r.insert(i.sym()):this.vertexMap.put(e,i.sym()),i},create:function(t,e){var n=this.createEdge(t),i=this.createEdge(e);return vi.init(n,i),n},createEdge:function(t){return new vi(t)},addEdge:function(t,e){if(!yi.isValidEdge(t,e))return null;var n=this.vertexMap.get(t),i=null;if(null!==n&&(i=n.find(e)),null!==i)return i;var r=this.insert(t,e,n);return r},getVertexEdges:function(){return this.vertexMap.values()},findEdge:function(t,e){var n=this.vertexMap.get(t);return null===n?null:n.find(e)},interfaces_:function(){return[]},getClass:function(){return yi}}),yi.isValidEdge=function(t,e){var n=e.compareTo(t);return 0!==n},h(xi,mi),e(xi.prototype,{setStart:function(){this._isStart=!0},isStart:function(){return this._isStart},interfaces_:function(){return[]},getClass:function(){return xi}}),h(Ei,yi),e(Ei.prototype,{createEdge:function(t){return new xi(t)},interfaces_:function(){return[]},getClass:function(){return Ei}}),e(Ii.prototype,{addLine:function(t){this.lines.add(this.factory.createLineString(t.toCoordinateArray()))},updateRingStartEdge:function(t){return t.isStart()||(t=t.sym(),t.isStart())?null===this.ringStartEdge?(this.ringStartEdge=t,null):void(t.orig().compareTo(this.ringStartEdge.orig())<0&&(this.ringStartEdge=t)):null},getResult:function(){return null===this.result&&this.computeResult(),this.result},process:function(t){var e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()},buildRing:function(t){var e=new N,n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){var i=n.next();if(i===t)break;e.add(i.orig().copy(),!1),n=i}e.add(n.dest().copy(),!1),this.addLine(e)},buildLine:function(t){var e=new N,n=t;for(this.ringStartEdge=null,mi.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);var i=n.next();if(i===t)return this.buildRing(this.ringStartEdge),null;e.add(i.orig().copy(),!1),n=i,mi.markBoth(n)}e.add(n.dest().copy(),!1),this.stackEdges(n.sym()),this.addLine(e)},stackEdges:function(t){var e=t;do mi.isMarked(e)||this.nodeEdgeStack.add(e),e=e.oNext();while(e!==t)},computeResult:function(){for(var t=this.graph.getVertexEdges(),e=t.iterator();e.hasNext();){var n=e.next();mi.isMarked(n)||this.process(n)}this.result=this.factory.buildGeometry(this.lines)},buildLines:function(){for(;!this.nodeEdgeStack.empty();){var t=this.nodeEdgeStack.pop();mi.isMarked(t)||this.buildLine(t)}},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v))for(var e=arguments[0],n=e.iterator();n.hasNext();){var i=n.next();this.add(i)}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory());for(var s=r.getCoordinateSequence(),o=!1,n=1;n<s.size();n++){var a=this.graph.addEdge(s.getCoordinate(n-1),s.getCoordinate(n));null!==a&&(o||(a.setStart(),o=!0))}}},interfaces_:function(){return[]},getClass:function(){return Ii}}),Ii.dissolve=function(t){var e=new Ii;return e.add(t),e.getResult()};var go=Object.freeze({LineDissolver:Ii});e(Ni.prototype,{hasChildren:function(){for(var t=0;4>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;4>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},getNodeCount:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+1},size:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this.items);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].addAllItemsFromOverlapping(t,e)},visitItems:function(t,e){for(var n=this.items.iterator();n.hasNext();)e.visitItem(n.next())},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;4>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},visit:function(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].visit(t,e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;4>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},isEmpty:function t(){var t=!0;this.items.isEmpty()||(t=!1);for(var e=0;4>e;e++)null!==this.subnode[e]&&(this.subnode[e].isEmpty()||(t=!1));return t},add:function(t){this.items.add(t)},interfaces_:function(){return[u]},getClass:function(){return Ni}}),Ni.getSubnodeIndex=function(t,e,n){var i=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(i=3),t.getMaxY()<=n&&(i=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(i=2),t.getMaxY()<=n&&(i=0)),i},Ci.exponent=function(t){return Si(64,t)-1023},Ci.powerOf2=function(t){return Math.pow(2,t)},e(wi.prototype,{getLevel:function(){return this.level},computeKey:function(){if(1===arguments.length){var t=arguments[0];for(this.level=wi.computeQuadLevel(t),this.env=new C,this.computeKey(this.level,t);!this.env.contains(t);)this.level+=1,this.computeKey(this.level,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=Ci.powerOf2(e);this.pt.x=Math.floor(n.getMinX()/i)*i,this.pt.y=Math.floor(n.getMinY()/i)*i,this.env.init(this.pt.x,this.pt.x+i,this.pt.y,this.pt.y+i)}},getEnvelope:function(){return this.env},getCentre:function(){return new g((this.env.getMinX()+this.env.getMaxX())/2,(this.env.getMinY()+this.env.getMaxY())/2)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return wi}}),wi.computeQuadLevel=function(t){var e=t.getWidth(),n=t.getHeight(),i=e>n?e:n,r=Ci.exponent(i)+1;return r},h(Li,Ni),e(Li.prototype,{find:function(t){var e=Ni.getSubnodeIndex(t,this.centrex,this.centrey);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},isSearchMatch:function(t){return this.env.intersects(t)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getEnvelope:function(){return this.env},getNode:function(t){var e=Ni.getSubnodeIndex(t,this.centrex,this.centrey);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0,i=0,r=0;switch(t){case 0:e=this.env.getMinX(),n=this.centrex,i=this.env.getMinY(),r=this.centrey;break;case 1:e=this.centrex,n=this.env.getMaxX(),i=this.env.getMinY(),r=this.centrey;break;case 2:e=this.env.getMinX(),n=this.centrex,i=this.centrey,r=this.env.getMaxY();break;case 3:e=this.centrex,n=this.env.getMaxX(),i=this.centrey,r=this.env.getMaxY()}var s=new C(e,n,i,r),o=new Li(s,this.level-1);return o},insertNode:function(t){f.isTrue(null===this.env||this.env.contains(t.env));var e=Ni.getSubnodeIndex(t.env,this.centrex,this.centrey);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insertNode(t),this.subnode[e]=n}},interfaces_:function(){return[]},getClass:function(){return Li}}),Li.createNode=function(t){var e=new wi(t),n=new Li(e.getEnvelope(),e.getLevel());return n},Li.createExpanded=function(t,e){var n=new C(e);null!==t&&n.expandToInclude(t.env);var i=Li.createNode(n);return null!==t&&i.insertNode(t),i},e(Ri.prototype,{interfaces_:function(){return[]},getClass:function(){return Ri}}),Ri.isZeroWidth=function(t,e){var n=e-t;if(0===n)return!0;var i=Math.max(Math.abs(t),Math.abs(e)),r=n/i,s=Ci.exponent(r);return s<=Ri.MIN_BINARY_EXPONENT},Ri.MIN_BINARY_EXPONENT=-50,h(Ti,Ni),e(Ti.prototype,{insert:function(t,e){var n=Ni.getSubnodeIndex(t,Ti.origin.x,Ti.origin.y);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getEnvelope().contains(t)){var r=Li.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getEnvelope().contains(e));var i=Ri.isZeroWidth(e.getMinX(),e.getMaxX()),r=Ri.isZeroWidth(e.getMinY(),e.getMaxY()),s=null;s=i||r?t.find(e):t.getNode(e),s.add(n)},interfaces_:function(){return[]},getClass:function(){return Ti}}),Ti.origin=new g(0,0),e(Pi.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=Pi.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){var t=arguments[0],e=new Yn;return this.query(t,e),e.getItems()}if(2===arguments.length){var n=arguments[0],i=arguments[1];this.root.visit(n,i)}},queryAll:function(){var t=new I;return this.root.addAllItems(t),
t},remove:function(t,e){var n=Pi.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e);var n=t.getHeight();n<this.minExtent&&n>0&&(this.minExtent=n)},depth:function(){return null!==this.root?this.root.depth():0},isEmpty:function(){return null===this.root},interfaces_:function(){return[Fe,u]},getClass:function(){return Pi}}),Pi.ensureExtent=function(t,e){var n=t.getMinX(),i=t.getMaxX(),r=t.getMinY(),s=t.getMaxY();return n!==i&&r!==s?t:(n===i&&(n-=e/2,i=n+e/2),r===s&&(r-=e/2,s=r+e/2),new C(n,i,r,s))},Pi.serialVersionUID=-0x678b60c967a25400;var po=Object.freeze({Quadtree:Pi}),vo=Object.freeze({STRtree:ke}),mo=Object.freeze({quadtree:po,strtree:vo}),yo=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];e(bi.prototype,{read:function(t){var e=void 0;e="string"==typeof t?JSON.parse(t):t;var n=e.type;if(!xo[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==yo.indexOf(n)?xo[n].apply(this,[e.coordinates]):"GeometryCollection"===n?xo[n].apply(this,[e.geometries]):xo[n].apply(this,[e])},write:function(t){var e=t.getGeometryType();if(!Eo[e])throw new Error("Geometry is not supported");return Eo[e].apply(this,[t])}});var xo={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var i=t.geometry.type;if(!xo[i])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=xo.bbox.apply(this,[t.bbox])),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.apply(this,[t.bbox])),e},coordinates:function t(e){for(var t=[],n=0;n<e.length;++n){var i=e[n];t.push(new g(i[0],i[1]))}return t},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){var e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(xo.Point.apply(this,[t[n]]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=xo.coordinates.apply(this,[t]);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(xo.LineString.apply(this,[t[n]]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=xo.coordinates.apply(this,[t[0]]),n=this.geometryFactory.createLinearRing(e),i=[],r=1;r<t.length;++r){var s=t[r],o=xo.coordinates.apply(this,[s]),a=this.geometryFactory.createLinearRing(o);i.push(a)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(xo.Polygon.apply(this,[i]))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},Eo={coordinate:function(t){return[t.x,t.y]},Point:function(t){var e=Eo.coordinate.apply(this,[t.getCoordinate()]);return{type:"Point",coordinates:e}},MultiPoint:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.Point.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),i=0;i<n.length;++i){var r=n[i];e.push(Eo.coordinate.apply(this,[r]))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.LineString.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=Eo.LineString.apply(this,[t.shell]);e.push(n.coordinates);for(var i=0;i<t.holes.length;++i){var r=t.holes[i],s=Eo.LineString.apply(this,[r]);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.Polygon.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=i.getGeometryType();e.push(Eo[r].apply(this,[i]))}return{type:"GeometryCollection",geometries:e}}};e(Oi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){var e,n;if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(e=0,n=t.points.length;n>e;e++)this.precisionModel.makePrecise(t.points[e]);else if(t.geometries)for(e=0,n=t.geometries.length;n>e;e++)this.reducePrecision(t.geometries[e])}}),e(_i.prototype,{write:function(t){return this.parser.write(t)}}),e(Mi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(var e=0,n=t.points.coordinates.length;n>e;e++)this.precisionModel.makePrecise(t.points.coordinates[e]);else if(t.geometries)for(var i=0,r=t.geometries.length;r>i;i++)this.reducePrecision(t.geometries[i])}}),e(Ai.prototype,{read:function(t){return t instanceof ol.geom.Point?this.convertFromPoint(t):t instanceof ol.geom.LineString?this.convertFromLineString(t):t instanceof ol.geom.LinearRing?this.convertFromLinearRing(t):t instanceof ol.geom.Polygon?this.convertFromPolygon(t):t instanceof ol.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof ol.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof ol.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof ol.geom.GeometryCollection?this.convertFromCollection(t):void 0},convertFromPoint:function(t){var e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))},convertFromLineString:function(t){return this.geometryFactory.createLineString(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromLinearRing:function(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromPolygon:function(t){for(var e=t.getLinearRings(),n=null,i=[],r=0;r<e.length;r++){var s=this.convertFromLinearRing(e[r]);0===r?n=s:i.push(s)}return this.geometryFactory.createPolygon(n,i)},convertFromMultiPoint:function(t){var e=t.getPoints().map(function(t){return this.convertFromPoint(t)},this);return this.geometryFactory.createMultiPoint(e)},convertFromMultiLineString:function(t){var e=t.getLineStrings().map(function(t){return this.convertFromLineString(t)},this);return this.geometryFactory.createMultiLineString(e)},convertFromMultiPolygon:function(t){var e=t.getPolygons().map(function(t){return this.convertFromPolygon(t)},this);return this.geometryFactory.createMultiPolygon(e)},convertFromCollection:function(t){var e=t.getGeometries().map(function(t){return this.read(t)},this);return this.geometryFactory.createGeometryCollection(e)},write:function(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0},convertToPoint:function(t){return new ol.geom.Point([t.x,t.y])},convertToLineString:function(t){var e=t.points.coordinates.map(Di);return new ol.geom.LineString(e)},convertToLinearRing:function(t){var e=t.points.coordinates.map(Di);return new ol.geom.LinearRing(e)},convertToPolygon:function(t){for(var e=[t.shell.points.coordinates.map(Di)],n=0;n<t.holes.length;n++)e.push(t.holes[n].points.coordinates.map(Di));return new ol.geom.Polygon(e)},convertToMultiPoint:function(t){return new ol.geom.MultiPoint(t.getCoordinates().map(Di))},convertToMultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToLineString(t.geometries[n]).getCoordinates());return new ol.geom.MultiLineString(e)},convertToMultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());return new ol.geom.MultiPolygon(e)},convertToCollection:function(t){for(var e=[],n=0;n<t.geometries.length;n++){var i=t.geometries[n];e.push(this.write(i))}return new ol.geom.GeometryCollection(e)}});var Io=Object.freeze({GeoJSONReader:Oi,GeoJSONWriter:_i,OL3Parser:Ai,WKTReader:Mi,WKTWriter:se});e(Fi.prototype,{rescale:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.rescale(n.getCoordinates())}else if(arguments[0]instanceof Array){var i=arguments[0],r=null,s=null;2===i.length&&(r=new g(i[0]),s=new g(i[1]));for(var e=0;e<i.length;e++)i[e].x=i[e].x/this.scaleFactor+this.offsetX,i[e].y=i[e].y/this.scaleFactor+this.offsetY;2===i.length&&i[0].equals2D(i[1])&&A.out.println(i)}},scale:function(){if(R(arguments[0],v)){for(var t=arguments[0],e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ke(this.scale(i.getCoordinates()),i.getData()))}return e}if(arguments[0]instanceof Array){for(var r=arguments[0],s=new Array(r.length).fill(null),n=0;n<r.length;n++)s[n]=new g(Math.round((r[n].x-this.offsetX)*this.scaleFactor),Math.round((r[n].y-this.offsetY)*this.scaleFactor),r[n].z);var o=H.removeRepeatedPoints(s);return o}},isIntegerPrecision:function(){return 1===this.scaleFactor},getNodedSubstrings:function(){var t=this.noder.getNodedSubstrings();return this.isScaled&&this.rescale(t),t},computeNodes:function(t){var e=t;this.isScaled&&(e=this.scale(t)),this.noder.computeNodes(e)},interfaces_:function(){return[tn]},getClass:function(){return Fi}});var No=Object.freeze({MCIndexNoder:nn,ScaledNoder:Fi,SegmentString:be});e(Gi.prototype,{isSimpleMultiPoint:function(t){if(t.isEmpty())return!0;for(var e=new at,n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n),r=i.getCoordinate();if(e.contains(r))return this.nonSimpleLocation=r,!1;e.add(r)}return!0},isSimplePolygonal:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next();if(!this.isSimpleLinearGeometry(i))return!1}return!0},hasClosedEndpointIntersection:function(t){for(var e=new rt,n=t.getEdgeIterator();n.hasNext();){var i=n.next(),r=(i.getMaximumSegmentIndex(),i.isClosed()),s=i.getCoordinate(0);this.addEndpoint(e,s,r);var o=i.getCoordinate(i.getNumPoints()-1);this.addEndpoint(e,o,r)}for(var n=e.values().iterator();n.hasNext();){var a=n.next();if(a.isClosed&&2!==a.degree)return this.nonSimpleLocation=a.getCoordinate(),!0}return!1},getNonSimpleLocation:function(){return this.nonSimpleLocation},isSimpleLinearGeometry:function(t){if(t.isEmpty())return!0;var e=new $n(0,t),n=new ae,i=e.computeSelfNodes(n,!0);return i.hasIntersection()?i.hasProperIntersection()?(this.nonSimpleLocation=i.getProperIntersectionPoint(),!1):this.hasNonEndpointIntersection(e)?!1:!this.isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e):!0},hasNonEndpointIntersection:function(t){for(var e=t.getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getMaximumSegmentIndex(),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next();if(!s.isEndPoint(i))return this.nonSimpleLocation=s.getCoordinate(),!0}return!1},addEndpoint:function(t,e,n){var i=t.get(e);null===i&&(i=new qi(e),t.put(e,i)),i.addEndpoint(n)},computeSimple:function(t){return this.nonSimpleLocation=null,t.isEmpty()?!0:t instanceof St?this.isSimpleLinearGeometry(t):t instanceof gt?this.isSimpleLinearGeometry(t):t instanceof Pt?this.isSimpleMultiPoint(t):R(t,Rt)?this.isSimplePolygonal(t):t instanceof ft?this.isSimpleGeometryCollection(t):!0},isSimple:function(){return this.nonSimpleLocation=null,this.computeSimple(this.inputGeom)},isSimpleGeometryCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0},interfaces_:function(){return[]},getClass:function(){return Gi}}),e(qi.prototype,{addEndpoint:function(t){this.degree++,this.isClosed|=t},getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return qi}}),Gi.EndpointInfo=qi,e(Bi.prototype,{getEndCapStyle:function(){return this.endCapStyle},isSingleSided:function(){return this._isSingleSided},setQuadrantSegments:function(t){this.quadrantSegments=t,0===this.quadrantSegments&&(this.joinStyle=Bi.JOIN_BEVEL),this.quadrantSegments<0&&(this.joinStyle=Bi.JOIN_MITRE,this.mitreLimit=Math.abs(this.quadrantSegments)),0>=t&&(this.quadrantSegments=1),this.joinStyle!==Bi.JOIN_ROUND&&(this.quadrantSegments=Bi.DEFAULT_QUADRANT_SEGMENTS)},getJoinStyle:function(){return this.joinStyle},setJoinStyle:function(t){this.joinStyle=t},setSimplifyFactor:function(t){this.simplifyFactor=0>t?0:t},getSimplifyFactor:function(){return this.simplifyFactor},getQuadrantSegments:function(){return this.quadrantSegments},setEndCapStyle:function(t){this.endCapStyle=t},getMitreLimit:function(){return this.mitreLimit},setMitreLimit:function(t){this.mitreLimit=t},setSingleSided:function(t){this._isSingleSided=t},interfaces_:function(){return[]},getClass:function(){return Bi}}),Bi.bufferDistanceError=function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)},Bi.CAP_ROUND=1,Bi.CAP_FLAT=2,Bi.CAP_SQUARE=3,Bi.JOIN_ROUND=1,Bi.JOIN_MITRE=2,Bi.JOIN_BEVEL=3,Bi.DEFAULT_QUADRANT_SEGMENTS=8,Bi.DEFAULT_MITRE_LIMIT=5,Bi.DEFAULT_SIMPLIFY_FACTOR=.01,e(zi.prototype,{getCoordinate:function(){return this.minCoord},getRightmostSide:function(t,e){var n=this.getRightmostSideOfSegment(t,e);return 0>n&&(n=this.getRightmostSideOfSegment(t,e-1)),0>n&&(this.minCoord=null,this.checkForRightmostCoordinate(t)),n},findRightmostEdgeAtVertex:function(){var t=this.minDe.getEdge().getCoordinates();f.isTrue(this.minIndex>0&&this.minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this.minIndex-1],n=t[this.minIndex+1],i=he.computeOrientation(this.minCoord,n,e),r=!1;e.y<this.minCoord.y&&n.y<this.minCoord.y&&i===he.COUNTERCLOCKWISE?r=!0:e.y>this.minCoord.y&&n.y>this.minCoord.y&&i===he.CLOCKWISE&&(r=!0),r&&(this.minIndex=this.minIndex-1)},getRightmostSideOfSegment:function(t,e){var n=t.getEdge(),i=n.getCoordinates();if(0>e||e+1>=i.length)return-1;if(i[e].y===i[e+1].y)return-1;var r=cn.LEFT;return i[e].y<i[e+1].y&&(r=cn.RIGHT),r},getEdge:function(){return this.orientedDe},checkForRightmostCoordinate:function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this.minCoord||e[n].x>this.minCoord.x)&&(this.minDe=t,this.minIndex=n,this.minCoord=e[n])},findRightmostEdgeAtNode:function(){var t=this.minDe.getNode(),e=t.getEdges();this.minDe=e.getRightmostEdge(),this.minDe.isForward()||(this.minDe=this.minDe.getSym(),this.minIndex=this.minDe.getEdge().getCoordinates().length-1)},findEdge:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n)}f.isTrue(0!==this.minIndex||this.minCoord.equals(this.minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this.minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this.orientedDe=this.minDe;var i=this.getRightmostSide(this.minDe,this.minIndex);i===cn.LEFT&&(this.orientedDe=this.minDe.getSym())},interfaces_:function(){return[]},getClass:function(){return zi}}),Vi.prototype.addLast=function(t){this.array_.push(t)},Vi.prototype.removeFirst=function(){return this.array_.shift()},Vi.prototype.isEmpty=function(){return 0===this.array_.length},e(ki.prototype,{clearVisitedEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.setVisited(!1)}},getRightmostCoordinate:function(){return this.rightMostCoord},computeNodeDepth:function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var i=n.next();if(i.isVisited()||i.getSym().isVisited()){e=i;break}}if(null===e)throw new sn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();i.setVisited(!0),this.copySymDepths(i)}},computeDepth:function(t){this.clearVisitedEdges();var e=this.finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(cn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)},create:function(t){this.addReachable(t),this.finder.findEdge(this.dirEdgeList),this.rightMostCoord=this.finder.getCoordinate()},findResultEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(cn.RIGHT)>=1&&e.getDepth(cn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}},computeDepths:function(t){var e=new J,n=new Vi,i=t.getNode();for(n.addLast(i),e.add(i),t.setVisited(!0);!n.isEmpty();){var r=n.removeFirst();e.add(r),this.computeNodeDepth(r);for(var s=r.getEdges().iterator();s.hasNext();){var o=s.next(),a=o.getSym();if(!a.isVisited()){var u=a.getNode();e.contains(u)||(n.addLast(u),e.add(u))}}}},compareTo:function(t){var e=t;return this.rightMostCoord.x<e.rightMostCoord.x?-1:this.rightMostCoord.x>e.rightMostCoord.x?1:0},getEnvelope:function(){if(null===this.env){for(var t=new C,e=this.dirEdgeList.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge().getCoordinates(),r=0;r<i.length-1;r++)t.expandToInclude(i[r]);this.env=t}return this.env},addReachable:function(t){var e=new pe;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e)}},copySymDepths:function(t){var e=t.getSym();e.setDepth(cn.LEFT,t.getDepth(cn.RIGHT)),e.setDepth(cn.RIGHT,t.getDepth(cn.LEFT))},add:function(t,e){t.setVisited(!0),this.nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();this.dirEdgeList.add(i);var r=i.getSym(),s=r.getNode();s.isVisited()||e.push(s)}},getNodes:function(){return this.nodes},getDirectedEdges:function(){return this.dirEdgeList},interfaces_:function(){return[s]},getClass:function(){return ki}}),e(Yi.prototype,{isDeletable:function(t,e,n,i){var r=this.inputLine[t],s=this.inputLine[e],o=this.inputLine[n];return this.isConcave(r,s,o)&&this.isShallow(r,s,o,i)?this.isShallowSampled(r,s,t,n,i):!1},deleteShallowConcavities:function(){for(var t=1,e=(this.inputLine.length-1,this.findNextNonDeletedIndex(t)),n=this.findNextNonDeletedIndex(e),i=!1;n<this.inputLine.length;){var r=!1;this.isDeletable(t,e,n,this.distanceTol)&&(this.isDeleted[e]=Yi.DELETE,r=!0,i=!0),t=r?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return i},isShallowConcavity:function(t,e,n,i){var r=he.computeOrientation(t,e,n),s=r===this.angleOrientation;if(!s)return!1;var o=he.distancePointLine(e,t,n);return i>o},isShallowSampled:function(t,e,n,i,r){var s=Math.trunc((i-n)/Yi.NUM_PTS_TO_CHECK);0>=s&&(s=1);for(var o=n;i>o;o+=s)if(!this.isShallow(t,e,this.inputLine[o],r))return!1;return!0},isConcave:function t(e,n,i){var r=he.computeOrientation(e,n,i),t=r===this.angleOrientation;return t},simplify:function(t){this.distanceTol=Math.abs(t),0>t&&(this.angleOrientation=he.CLOCKWISE),this.isDeleted=new Array(this.inputLine.length).fill(null);var e=!1;do e=this.deleteShallowConcavities();while(e);return this.collapseLine()},findNextNonDeletedIndex:function(t){for(var e=t+1;e<this.inputLine.length&&this.isDeleted[e]===Yi.DELETE;)e++;return e},isShallow:function(t,e,n,i){var r=he.distancePointLine(e,t,n);return i>r},collapseLine:function(){for(var t=new N,e=0;e<this.inputLine.length;e++)this.isDeleted[e]!==Yi.DELETE&&t.add(this.inputLine[e]);return t.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return Yi}}),Yi.simplify=function(t,e){var n=new Yi(t);return n.simplify(e)},Yi.INIT=0,Yi.DELETE=1,Yi.KEEP=1,Yi.NUM_PTS_TO_CHECK=10,e(Ui.prototype,{getCoordinates:function(){var t=this.ptList.toArray(Ui.COORDINATE_ARRAY_TYPE);return t},setPrecisionModel:function(t){this.precisionModel=t},addPt:function(t){var e=new g(t);return this.precisionModel.makePrecise(e),this.isRedundant(e)?null:void this.ptList.add(e)},reverse:function(){},addPts:function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var n=t.length-1;n>=0;n--)this.addPt(t[n])},isRedundant:function(t){if(this.ptList.size()<1)return!1;var e=this.ptList.get(this.ptList.size()-1),n=t.distance(e);return n<this.minimimVertexDistance},toString:function(){var t=new ie,e=t.createLineString(this.getCoordinates());return e.toString()},closeRing:function(){if(this.ptList.size()<1)return null;var t=new g(this.ptList.get(0)),e=this.ptList.get(this.ptList.size()-1),n=null;return this.ptList.size()>=2&&(n=this.ptList.get(this.ptList.size()-2)),t.equals(e)?null:void this.ptList.add(t)},setMinimumVertexDistance:function(t){this.minimimVertexDistance=t},interfaces_:function(){return[]},getClass:function(){return Ui}}),Ui.COORDINATE_ARRAY_TYPE=new Array(0).fill(null),e(Xi.prototype,{addNextSegment:function(t,e){if(this.s0=this.s1,this.s1=this.s2,this.s2=t,this.seg0.setCoordinates(this.s0,this.s1),this.computeOffsetSegment(this.seg0,this.side,this.distance,this.offset0),this.seg1.setCoordinates(this.s1,this.s2),this.computeOffsetSegment(this.seg1,this.side,this.distance,this.offset1),this.s1.equals(this.s2))return null;var n=he.computeOrientation(this.s0,this.s1,this.s2),i=n===he.CLOCKWISE&&this.side===cn.LEFT||n===he.COUNTERCLOCKWISE&&this.side===cn.RIGHT;0===n?this.addCollinear(e):i?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)},addLineEndCap:function(t,e){var n=new ce(t,e),i=new ce;this.computeOffsetSegment(n,cn.LEFT,this.distance,i);var r=new ce;this.computeOffsetSegment(n,cn.RIGHT,this.distance,r);var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s);switch(this.bufParams.getEndCapStyle()){case Bi.CAP_ROUND:this.segList.addPt(i.p1),this.addFilletArc(e,a+Math.PI/2,a-Math.PI/2,he.CLOCKWISE,this.distance),this.segList.addPt(r.p1);break;case Bi.CAP_FLAT:this.segList.addPt(i.p1),this.segList.addPt(r.p1);break;case Bi.CAP_SQUARE:var u=new g;u.x=Math.abs(this.distance)*Math.cos(a),u.y=Math.abs(this.distance)*Math.sin(a);var l=new g(i.p1.x+u.x,i.p1.y+u.y),h=new g(r.p1.x+u.x,r.p1.y+u.y);this.segList.addPt(l),this.segList.addPt(h)}},getCoordinates:function(){var t=this.segList.getCoordinates();return t},addMitreJoin:function(t,e,n,i){var r=!0,s=null;try{s=F.intersection(e.p0,e.p1,n.p0,n.p1);var o=0>=i?1:s.distance(t)/Math.abs(i);o>this.bufParams.getMitreLimit()&&(r=!1)}catch(t){if(!(t instanceof w))throw t;s=new g(0,0),r=!1}finally{}r?this.segList.addPt(s):this.addLimitedMitreJoin(e,n,i,this.bufParams.getMitreLimit())},addFilletCorner:function(t,e,n,i,r){var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s),u=n.x-t.x,l=n.y-t.y,h=Math.atan2(l,u);i===he.CLOCKWISE?h>=a&&(a+=2*Math.PI):a>=h&&(a-=2*Math.PI),this.segList.addPt(e),this.addFilletArc(t,a,h,i,r),this.segList.addPt(n)},addOutsideTurn:function(t,e){return this.offset0.p1.distance(this.offset1.p0)<this.distance*Xi.OFFSET_SEGMENT_SEPARATION_FACTOR?(this.segList.addPt(this.offset0.p1),null):void(this.bufParams.getJoinStyle()===Bi.JOIN_MITRE?this.addMitreJoin(this.s1,this.offset0,this.offset1,this.distance):this.bufParams.getJoinStyle()===Bi.JOIN_BEVEL?this.addBevelJoin(this.offset0,this.offset1):(e&&this.segList.addPt(this.offset0.p1),this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,t,this.distance),this.segList.addPt(this.offset1.p0)))},createSquare:function(t){this.segList.addPt(new g(t.x+this.distance,t.y+this.distance)),this.segList.addPt(new g(t.x+this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y+this.distance)),this.segList.closeRing()},addSegments:function(t,e){this.segList.addPts(t,e)},addFirstSegment:function(){this.segList.addPt(this.offset1.p0)},addLastSegment:function(){this.segList.addPt(this.offset1.p1)},initSideSegments:function(t,e,n){this.s1=t,this.s2=e,this.side=n,this.seg1.setCoordinates(t,e),this.computeOffsetSegment(this.seg1,n,this.distance,this.offset1)},addLimitedMitreJoin:function(t,e,n,i){var r=this.seg0.p1,s=hi.angle(r,this.seg0.p0),o=(hi.angle(r,this.seg1.p1),hi.angleBetweenOriented(this.seg0.p0,r,this.seg1.p1)),a=o/2,u=hi.normalize(s+a),l=hi.normalize(u+Math.PI),h=i*n,c=h*Math.abs(Math.sin(a)),f=n-c,d=r.x+h*Math.cos(l),p=r.y+h*Math.sin(l),v=new g(d,p),m=new ce(r,v),y=m.pointAlongOffset(1,f),x=m.pointAlongOffset(1,-f);this.side===cn.LEFT?(this.segList.addPt(y),this.segList.addPt(x)):(this.segList.addPt(x),this.segList.addPt(y))},computeOffsetSegment:function(t,e,n,i){var r=e===cn.LEFT?1:-1,s=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,a=Math.sqrt(s*s+o*o),u=r*n*s/a,l=r*n*o/a;i.p0.x=t.p0.x-l,i.p0.y=t.p0.y+u,i.p1.x=t.p1.x-l,i.p1.y=t.p1.y+u},addFilletArc:function(t,e,n,i,r){var s=i===he.CLOCKWISE?-1:1,o=Math.abs(e-n),a=Math.trunc(o/this.filletAngleQuantum+.5);if(1>a)return null;var u=null,l=null;u=0,l=o/a;for(var h=u,c=new g;o>h;){var f=e+s*h;c.x=t.x+r*Math.cos(f),c.y=t.y+r*Math.sin(f),this.segList.addPt(c),h+=l}},addInsideTurn:function(t,e){if(this.li.computeIntersection(this.offset0.p0,this.offset0.p1,this.offset1.p0,this.offset1.p1),this.li.hasIntersection())this.segList.addPt(this.li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this.offset0.p1.distance(this.offset1.p0)<this.distance*Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this.segList.addPt(this.offset0.p1);else{if(this.segList.addPt(this.offset0.p1),this.closingSegLengthFactor>0){var n=new g((this.closingSegLengthFactor*this.offset0.p1.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset0.p1.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(n);var i=new g((this.closingSegLengthFactor*this.offset1.p0.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset1.p0.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(i)}else this.segList.addPt(this.s1);this.segList.addPt(this.offset1.p0)}},createCircle:function(t){var e=new g(t.x+this.distance,t.y);this.segList.addPt(e),this.addFilletArc(t,0,2*Math.PI,-1,this.distance),this.segList.closeRing()},addBevelJoin:function(t,e){this.segList.addPt(t.p1),this.segList.addPt(e.p0)},init:function(t){this.distance=t,this.maxCurveSegmentError=t*(1-Math.cos(this.filletAngleQuantum/2)),this.segList=new Ui,this.segList.setPrecisionModel(this.precisionModel),this.segList.setMinimumVertexDistance(t*Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},addCollinear:function(t){this.li.computeIntersection(this.s0,this.s1,this.s1,this.s2);var e=this.li.getIntersectionNum();e>=2&&(this.bufParams.getJoinStyle()===Bi.JOIN_BEVEL||this.bufParams.getJoinStyle()===Bi.JOIN_MITRE?(t&&this.segList.addPt(this.offset0.p1),this.segList.addPt(this.offset1.p0)):this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,he.CLOCKWISE,this.distance))},closeRing:function(){this.segList.closeRing()},hasNarrowConcaveAngle:function(){return this._hasNarrowConcaveAngle},interfaces_:function(){return[]},getClass:function(){return Xi}}),Xi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,Xi.MAX_CLOSING_SEG_LEN_FACTOR=80,e(Hi.prototype,{getOffsetCurve:function(t,e){if(this.distance=e,0===e)return null;var n=0>e,i=Math.abs(e),r=this.getSegGen(i);t.length<=1?this.computePointCurve(t[0],r):this.computeOffsetCurve(t,n,r);var s=r.getCoordinates();return n&&H.reverse(s),s},computeSingleSidedBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){n.addSegments(t,!0);var r=Yi.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{n.addSegments(t,!1);var a=Yi.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment(),n.closeRing()},computeRingBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);e===cn.RIGHT&&(i=-i);var r=Yi.simplify(t,i),s=r.length-1;n.initSideSegments(r[s-1],r[0],e);for(var o=1;s>=o;o++){var a=1!==o;n.addNextSegment(r[o],a)}n.closeRing()},computeLineBufferCurve:function(t,e){var n=this.simplifyTolerance(this.distance),i=Yi.simplify(t,n),r=i.length-1;e.initSideSegments(i[0],i[1],cn.LEFT);for(var s=2;r>=s;s++)e.addNextSegment(i[s],!0);e.addLastSegment(),e.addLineEndCap(i[r-1],i[r]);var o=Yi.simplify(t,-n),a=o.length-1;e.initSideSegments(o[a],o[a-1],cn.LEFT);for(var s=a-2;s>=0;s--)e.addNextSegment(o[s],!0);e.addLastSegment(),e.addLineEndCap(o[1],o[0]),e.closeRing()},computePointCurve:function(t,e){switch(this.bufParams.getEndCapStyle()){case Bi.CAP_ROUND:e.createCircle(t);break;case Bi.CAP_SQUARE:e.createSquare(t)}},getLineCurve:function(t,e){if(this.distance=e,0>e&&!this.bufParams.isSingleSided())return null;if(0===e)return null;var n=Math.abs(e),i=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],i);else if(this.bufParams.isSingleSided()){var r=0>e;this.computeSingleSidedBufferCurve(t,r,i)}else this.computeLineBufferCurve(t,i);var s=i.getCoordinates();return s},getBufferParameters:function(){return this.bufParams},simplifyTolerance:function(t){return t*this.bufParams.getSimplifyFactor()},getRingCurve:function(t,e,n){if(this.distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return Hi.copyCoordinates(t);var i=this.getSegGen(n);return this.computeRingBufferCurve(t,e,i),i.getCoordinates()},computeOffsetCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){var r=Yi.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{var a=Yi.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment()},getSegGen:function(t){return new Xi(this.precisionModel,this.bufParams,t)},interfaces_:function(){return[]},getClass:function(){return Hi}}),Hi.copyCoordinates=function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new g(t[n]);return e},e(Wi.prototype,{findStabbedSegments:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=this.subgraphs.iterator();n.hasNext();){var i=n.next(),r=i.getEnvelope();t.y<r.getMinY()||t.y>r.getMaxY()||this.findStabbedSegments(t,i.getDirectedEdges(),e)}return e}if(3===arguments.length)if(R(arguments[2],y)&&arguments[0]instanceof g&&arguments[1]instanceof In)for(var s=arguments[0],o=arguments[1],a=arguments[2],u=o.getEdge().getCoordinates(),n=0;n<u.length-1;n++){this.seg.p0=u[n],this.seg.p1=u[n+1],this.seg.p0.y>this.seg.p1.y&&this.seg.reverse();var l=Math.max(this.seg.p0.x,this.seg.p1.x);if(!(l<s.x||this.seg.isHorizontal()||s.y<this.seg.p0.y||s.y>this.seg.p1.y||he.computeOrientation(this.seg.p0,this.seg.p1,s)===he.RIGHT)){var h=o.getDepth(cn.LEFT);this.seg.p0.equals(u[n])||(h=o.getDepth(cn.RIGHT));var c=new ji(this.seg,h);a.add(c)}}else if(R(arguments[2],y)&&arguments[0]instanceof g&&R(arguments[1],y))for(var f=arguments[0],d=arguments[1],p=arguments[2],n=d.iterator();n.hasNext();){var v=n.next();v.isForward()&&this.findStabbedSegments(f,v,p)}},getDepth:function(t){var e=this.findStabbedSegments(t);if(0===e.size())return 0;var n=ho.min(e);return n.leftDepth},interfaces_:function(){return[]},getClass:function(){return Wi}}),e(ji.prototype,{compareTo:function(t){var e=t;if(this.upwardSeg.minX()>=e.upwardSeg.maxX())return 1;if(this.upwardSeg.maxX()<=e.upwardSeg.minX())return-1;var n=this.upwardSeg.orientationIndex(e.upwardSeg);return 0!==n?n:(n=-1*e.upwardSeg.orientationIndex(this.upwardSeg),0!==n?n:this.upwardSeg.compareTo(e.upwardSeg))},compareX:function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)},toString:function(){return this.upwardSeg.toString()},interfaces_:function(){return[s]},getClass:function(){return ji}}),Wi.DepthSegment=ji,e(Ki.prototype,{addPoint:function(t){if(this.distance<=0)return null;
var e=t.getCoordinates(),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addPolygon:function(t){var e=this.distance,n=cn.LEFT;this.distance<0&&(e=-this.distance,n=cn.RIGHT);var i=t.getExteriorRing(),r=H.removeRepeatedPoints(i.getCoordinates());if(this.distance<0&&this.isErodedCompletely(i,this.distance))return null;if(this.distance<=0&&r.length<3)return null;this.addPolygonRing(r,e,n,L.EXTERIOR,L.INTERIOR);for(var s=0;s<t.getNumInteriorRing();s++){var o=t.getInteriorRingN(s),a=H.removeRepeatedPoints(o.getCoordinates());this.distance>0&&this.isErodedCompletely(o,-this.distance)||this.addPolygonRing(a,e,cn.opposite(n),L.INTERIOR,L.EXTERIOR)}},isTriangleErodedCompletely:function(t,e){var n=new ci(t[0],t[1],t[2]),i=n.inCentre(),r=he.distancePointLine(i,n.p0,n.p1);return r<Math.abs(e)},addLineString:function(t){if(this.distance<=0&&!this.curveBuilder.getBufferParameters().isSingleSided())return null;var e=H.removeRepeatedPoints(t.getCoordinates()),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addCurve:function(t,e,n){if(null===t||t.length<2)return null;var i=new Ke(t,new gn(0,L.BOUNDARY,e,n));this.curveList.add(i)},getCurves:function(){return this.add(this.inputGeom),this.curveList},addPolygonRing:function(t,e,n,i,r){if(0===e&&t.length<bt.MINIMUM_VALID_SIZE)return null;var s=i,o=r;t.length>=bt.MINIMUM_VALID_SIZE&&he.isCCW(t)&&(s=r,o=i,n=cn.opposite(n));var a=this.curveBuilder.getRingCurve(t,n,e);this.addCurve(a,s,o)},add:function(t){if(t.isEmpty())return null;if(t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},isErodedCompletely:function(t,e){var n=t.getCoordinates();if(n.length<4)return 0>e;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var i=t.getEnvelopeInternal(),r=Math.min(i.getHeight(),i.getWidth());return 0>e&&2*Math.abs(e)>r},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},interfaces_:function(){return[]},getClass:function(){return Ki}}),e(Zi.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(Zi.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.size()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},hasProperInteriorIntersection:function(){return this.hasProperInterior},getLineIntersector:function(){return this.li},hasProperIntersection:function(){return this.hasProper},processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.numIntersections++,this.li.isInteriorIntersection()&&(this.numInteriorIntersections++,this.hasInterior=!0),this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1),this.li.isProper()&&(this.numProperIntersections++,this.hasProper=!0,this.hasProperInterior=!0)))},hasIntersection:function(){return this._hasIntersection},isDone:function(){return!1},hasInteriorIntersection:function(){return this.hasInterior},interfaces_:function(){return[on]},getClass:function(){return Zi}}),Zi.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},e(Qi.prototype,{setWorkingPrecisionModel:function(t){this.workingPrecisionModel=t},insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip()),n.merge(i);var r=Qi.depthDelta(i),s=e.getDepthDelta(),o=s+r;e.setDepthDelta(o)}else this.edgeList.add(t),t.setDepthDelta(Qi.depthDelta(t.getLabel()))},buildSubgraphs:function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next(),s=r.getRightmostCoordinate(),o=new Wi(n),a=o.getDepth(s);r.computeDepth(a),r.findResultEdges(),n.add(r),e.add(r.getDirectedEdges(),r.getNodes())}},createSubgraphs:function(t){for(var e=new I,n=t.getNodes().iterator();n.hasNext();){var i=n.next();if(!i.isVisited()){var r=new ki;r.create(i),e.add(r)}}return ho.sort(e,ho.reverseOrder()),e},createEmptyResultGeometry:function(){var t=this.geomFact.createPolygon();return t},getNoder:function(t){if(null!==this.workingNoder)return this.workingNoder;var e=new nn,n=new ae;return n.setPrecisionModel(t),e.setSegmentIntersector(new Zi(n)),e},buffer:function(t,e){var n=this.workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this.geomFact=t.getFactory();var i=new Hi(n,this.bufParams),r=new Ki(t,e,i),s=r.getCurves();if(s.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(s,n),this.graph=new Cn(new On),this.graph.addEdges(this.edgeList.getEdges());var o=this.createSubgraphs(this.graph),a=new Sn(this.geomFact);this.buildSubgraphs(o,a);var u=a.getPolygons();if(u.size()<=0)return this.createEmptyResultGeometry();var l=this.geomFact.buildGeometry(u);return l},computeNodedEdges:function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var i=n.getNodedSubstrings(),r=i.iterator();r.hasNext();){var s=r.next(),o=s.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var a=s.getData(),u=new Jn(s.getCoordinates(),new gn(a));this.insertUniqueEdge(u)}}},setNoder:function(t){this.workingNoder=t},interfaces_:function(){return[]},getClass:function(){return Qi}}),Qi.depthDelta=function(t){var e=t.getLocation(0,cn.LEFT),n=t.getLocation(0,cn.RIGHT);return e===L.INTERIOR&&n===L.EXTERIOR?1:e===L.EXTERIOR&&n===L.INTERIOR?-1:0},Qi.convertSegStrings=function(t){for(var e=new ie,n=new I;t.hasNext();){var i=t.next(),r=e.createLineString(i.getCoordinates());n.add(r)}return e.buildGeometry(n)},e(Ji.prototype,{checkEndPtVertexIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next(),n=e.getCoordinates();this.checkEndPtVertexIntersections(n[0],this.segStrings),this.checkEndPtVertexIntersections(n[n.length-1],this.segStrings)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],t=r.iterator();t.hasNext();)for(var e=t.next(),n=e.getCoordinates(),s=1;s<n.length-1;s++)if(n[s].equals(i))throw new l("found endpt/interior pt intersection at index "+s+" :pt "+i)},checkInteriorIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this.segStrings.iterator();n.hasNext();){var i=n.next();this.checkInteriorIntersections(e,i)}else if(2===arguments.length)for(var r=arguments[0],s=arguments[1],o=r.getCoordinates(),a=s.getCoordinates(),u=0;u<o.length-1;u++)for(var h=0;h<a.length-1;h++)this.checkInteriorIntersections(r,u,s,h);else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3];if(c===g&&f===d)return null;var p=c.getCoordinates()[f],v=c.getCoordinates()[f+1],m=g.getCoordinates()[d],y=g.getCoordinates()[d+1];if(this.li.computeIntersection(p,v,m,y),this.li.hasIntersection()&&(this.li.isProper()||this.hasInteriorIntersection(this.li,p,v)||this.hasInteriorIntersection(this.li,m,y)))throw new l("found non-noded intersection at "+p+"-"+v+" and "+m+"-"+y)}},checkValid:function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},checkCollapses:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e)}else if(1===arguments.length)for(var n=arguments[0],i=n.getCoordinates(),t=0;t<i.length-2;t++)this.checkCollapse(i[t],i[t+1],i[t+2])},hasInteriorIntersection:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++){var r=t.getIntersection(i);if(!r.equals(e)&&!r.equals(n))return!0}return!1},checkCollapse:function(t,e,n){if(t.equals(n))throw new l("found non-noded collapse at "+Ji.fact.createLineString([t,e,n]))},interfaces_:function(){return[]},getClass:function(){return Ji}}),Ji.fact=new ie,e($i.prototype,{intersectsScaled:function(t,e){var n=Math.min(t.x,e.x),i=Math.max(t.x,e.x),r=Math.min(t.y,e.y),s=Math.max(t.y,e.y),o=this.maxx<n||this.minx>i||this.maxy<r||this.miny>s;if(o)return!1;var a=this.intersectsToleranceSquare(t,e);return f.isTrue(!(o&&a),"Found bad envelope test"),a},initCorners:function(t){var e=.5;this.minx=t.x-e,this.maxx=t.x+e,this.miny=t.y-e,this.maxy=t.y+e,this.corner[0]=new g(this.maxx,this.maxy),this.corner[1]=new g(this.minx,this.maxy),this.corner[2]=new g(this.minx,this.miny),this.corner[3]=new g(this.maxx,this.miny)},intersects:function(t,e){return 1===this.scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this.p0Scaled),this.copyScaled(e,this.p1Scaled),this.intersectsScaled(this.p0Scaled,this.p1Scaled))},scale:function(t){return Math.round(t*this.scaleFactor)},getCoordinate:function(){return this.originalPt},copyScaled:function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)},getSafeEnvelope:function(){if(null===this.safeEnv){var t=$i.SAFE_ENV_EXPANSION_FACTOR/this.scaleFactor;this.safeEnv=new C(this.originalPt.x-t,this.originalPt.x+t,this.originalPt.y-t,this.originalPt.y+t)}return this.safeEnv},intersectsPixelClosure:function(t,e){return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),!!this.li.hasIntersection())))},intersectsToleranceSquare:function(t,e){var n=!1,i=!1;return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.isProper()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.isProper()?!0:(this.li.hasIntersection()&&(n=!0),this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.isProper()?!0:(this.li.hasIntersection()&&(i=!0),this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),this.li.isProper()?!0:n&&i?!0:t.equals(this.pt)?!0:!!e.equals(this.pt))))},addSnappedNode:function(t,e){var n=t.getCoordinate(e),i=t.getCoordinate(e+1);return this.intersects(n,i)?(t.addIntersection(this.getCoordinate(),e),!0):!1},interfaces_:function(){return[]},getClass:function(){return $i}}),$i.SAFE_ENV_EXPANSION_FACTOR=.75,e(tr.prototype,{select:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){var t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}},interfaces_:function(){return[]},getClass:function(){return tr}}),e(er.prototype,{snap:function(){if(1===arguments.length){var t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=e.getSafeEnvelope(),s=new nr(e,n,i);return this.index.query(r,{interfaces_:function(){return[Ae]},visitItem:function(t){var e=t;e.select(r,s)}}),s.isNodeAdded()}},interfaces_:function(){return[]},getClass:function(){return er}}),h(nr,tr),e(nr.prototype,{isNodeAdded:function(){return this._isNodeAdded},select:function(){if(2!==arguments.length)return tr.prototype.select.apply(this,arguments);var t=arguments[0],e=arguments[1],n=t.getContext();return null!==this.parentEdge&&n===this.parentEdge&&e===this.hotPixelVertexIndex?null:void(this._isNodeAdded=this.hotPixel.addSnappedNode(n,e))},interfaces_:function(){return[]},getClass:function(){return nr}}),er.HotPixelSnapAction=nr,e(ir.prototype,{processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];if(this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&this.li.isInteriorIntersection()){for(var u=0;u<this.li.getIntersectionNum();u++)this.interiorIntersections.add(this.li.getIntersection(u));t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)}},isDone:function(){return!1},getInteriorIntersections:function(){return this.interiorIntersections},interfaces_:function(){return[on]},getClass:function(){return ir}}),e(rr.prototype,{checkCorrectness:function(t){var e=Ke.getNodedSubstrings(t),n=new Ji(e);try{n.checkValid()}catch(t){if(!(t instanceof S))throw t;t.printStackTrace()}finally{}},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},snapRound:function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)},findInteriorIntersections:function(t,e){var n=new ir(e);return this.noder.setSegmentIntersector(n),this.noder.computeNodes(t),n.getInteriorIntersections()},computeVertexSnaps:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.computeVertexSnaps(n)}else if(arguments[0]instanceof Ke)for(var i=arguments[0],r=i.getCoordinates(),s=0;s<r.length;s++){var o=new $i(r[s],this.scaleFactor,this.li),a=this.pointSnapper.snap(o,i,s);a&&i.addIntersection(r[s],s)}},computeNodes:function(t){this.nodedSegStrings=t,this.noder=new nn,this.pointSnapper=new er(this.noder.getIndex()),this.snapRound(t,this.li)},computeIntersectionSnaps:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=new $i(n,this.scaleFactor,this.li);this.pointSnapper.snap(i)}},interfaces_:function(){return[tn]},getClass:function(){return rr}}),e(sr.prototype,{bufferFixedPrecision:function(t){var e=new Fi(new rr(new ee(1)),t.getScale()),n=new Qi(this.bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this.resultGeometry=n.buffer(this.argGeom,this.distance)},bufferReducedPrecision:function(){if(0===arguments.length){for(var t=sr.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof sn))throw t;this.saveException=t}finally{}if(null!==this.resultGeometry)return null}throw this.saveException}if(1===arguments.length){var e=arguments[0],n=sr.precisionScaleFactor(this.argGeom,this.distance,e),i=new ee(n);this.bufferFixedPrecision(i)}},computeGeometry:function(){if(this.bufferOriginalPrecision(),null!==this.resultGeometry)return null;var t=this.argGeom.getFactory().getPrecisionModel();t.getType()===ee.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()},setQuadrantSegments:function(t){this.bufParams.setQuadrantSegments(t)},bufferOriginalPrecision:function(){try{var t=new Qi(this.bufParams);this.resultGeometry=t.buffer(this.argGeom,this.distance)}catch(t){if(!(t instanceof l))throw t;this.saveException=t}finally{}},getResultGeometry:function(t){return this.distance=t,this.computeGeometry(),this.resultGeometry},setEndCapStyle:function(t){this.bufParams.setEndCapStyle(t)},interfaces_:function(){return[]},getClass:function(){return sr}}),sr.bufferOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new sr(t),i=n.getResultGeometry(e);return i}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var r=arguments[0],s=arguments[1],o=arguments[2],a=new sr(r);a.setQuadrantSegments(o);var i=a.getResultGeometry(s);return i}if(arguments[2]instanceof Bi&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2],a=new sr(u,h),i=a.getResultGeometry(l);return i}}else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3],a=new sr(c);a.setQuadrantSegments(g),a.setEndCapStyle(d);var i=a.getResultGeometry(f);return i}},sr.precisionScaleFactor=function(t,e,n){var i=t.getEnvelopeInternal(),r=T.max(Math.abs(i.getMaxX()),Math.abs(i.getMaxY()),Math.abs(i.getMinX()),Math.abs(i.getMinY())),s=e>0?e:0,o=r+2*s,a=Math.trunc(Math.log(o)/Math.log(10)+1),u=n-a,l=Math.pow(10,u);return l},sr.CAP_ROUND=Bi.CAP_ROUND,sr.CAP_BUTT=Bi.CAP_FLAT,sr.CAP_FLAT=Bi.CAP_FLAT,sr.CAP_SQUARE=Bi.CAP_SQUARE,sr.MAX_PRECISION_DIGITS=12;var Co=Object.freeze({BufferOp:sr,BufferParameters:Bi});e(or.prototype,{filter:function(t){t instanceof Tt&&this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return or}}),or.getPolygons=function(){if(1===arguments.length){var t=arguments[0];return or.getPolygons(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Tt?n.add(e):e instanceof ft&&e.apply(new or(n)),n}},e(ar.prototype,{isInsideArea:function(){return this.segIndex===ar.INSIDE_AREA},getCoordinate:function(){return this.pt},getGeometryComponent:function(){return this.component},getSegmentIndex:function(){return this.segIndex},interfaces_:function(){return[]},getClass:function(){return ar}}),ar.INSIDE_AREA=-1,e(ur.prototype,{filter:function(t){t instanceof Lt&&this.pts.add(t)},interfaces_:function(){return[ht]},getClass:function(){return ur}}),ur.getPoints=function(){if(1===arguments.length){var t=arguments[0];return t instanceof Lt?ho.singletonList(t):ur.getPoints(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Lt?n.add(e):e instanceof ft&&e.apply(new ur(n)),n}},e(lr.prototype,{filter:function(t){(t instanceof Lt||t instanceof St||t instanceof Tt)&&this.locations.add(new ar(t,0,t.getCoordinate()))},interfaces_:function(){return[ht]},getClass:function(){return lr}}),lr.getLocations=function(t){var e=new I;return t.apply(new lr(e)),e},e(hr.prototype,{computeContainmentDistance:function(){if(0===arguments.length){var t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this.minDistance<=this.terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=1-e,r=or.getPolygons(this.geom[e]);if(r.size()>0){var s=lr.getLocations(this.geom[i]);if(this.computeContainmentDistance(s,r,n),this.minDistance<=this.terminateDistance)return this.minDistanceLocation[i]=n[0],this.minDistanceLocation[e]=n[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&R(arguments[0],y)&&R(arguments[1],y)){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=0;l<o.size();l++)for(var h=o.get(l),c=0;c<a.size();c++)if(this.computeContainmentDistance(h,a.get(c),u),this.minDistance<=this.terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof ar&&arguments[1]instanceof Tt){var f=arguments[0],g=arguments[1],d=arguments[2],p=f.getCoordinate();if(L.EXTERIOR!==this.ptLocator.locate(p,g))return this.minDistance=0,d[0]=f,d[1]=new ar(g,p),null}},computeMinDistanceLinesPoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},computeFacetDistance:function(){var t=new Array(2).fill(null),e=kn.getLines(this.geom[0]),n=kn.getLines(this.geom[1]),i=ur.getPoints(this.geom[0]),r=ur.getPoints(this.geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,r,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,i,t),this.updateMinDistance(t,!0),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(i,r,t),void this.updateMinDistance(t,!1))))},nearestLocations:function(){return this.computeMinDistance(),this.minDistanceLocation},updateMinDistance:function(t,e){return null===t[0]?null:void(e?(this.minDistanceLocation[0]=t[1],this.minDistanceLocation[1]=t[0]):(this.minDistanceLocation[0]=t[0],this.minDistanceLocation[1]=t[1]))},nearestPoints:function(){this.computeMinDistance();var t=[this.minDistanceLocation[0].getCoordinate(),this.minDistanceLocation[1].getCoordinate()];return t},computeMinDistance:function(){if(0===arguments.length){if(null!==this.minDistanceLocation)return null;if(this.minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this.minDistance<=this.terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof Lt){var t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this.minDistance)return null;for(var i=t.getCoordinates(),r=e.getCoordinate(),s=0;s<i.length-1;s++){var o=he.distancePointLine(r,i[s],i[s+1]);if(o<this.minDistance){this.minDistance=o;var a=new ce(i[s],i[s+1]),u=a.closestPoint(r);n[0]=new ar(t,s,u),n[1]=new ar(e,0,r)}if(this.minDistance<=this.terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof St){var l=arguments[0],h=arguments[1],c=arguments[2];if(l.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this.minDistance)return null;for(var i=l.getCoordinates(),f=h.getCoordinates(),s=0;s<i.length-1;s++)for(var g=0;g<f.length-1;g++){var o=he.distanceLineLine(i[s],i[s+1],f[g],f[g+1]);if(o<this.minDistance){this.minDistance=o;var d=new ce(i[s],i[s+1]),p=new ce(f[g],f[g+1]),v=d.closestPoints(p);c[0]=new ar(l,s,v[0]),c[1]=new ar(h,g,v[1])}if(this.minDistance<=this.terminateDistance)return null}}},computeMinDistancePoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s),a=r.getCoordinate().distance(o.getCoordinate());if(a<this.minDistance&&(this.minDistance=a,n[0]=new ar(r,0,r.getCoordinate()),n[1]=new ar(o,0,o.getCoordinate())),this.minDistance<=this.terminateDistance)return null}},distance:function(){if(null===this.geom[0]||null===this.geom[1])throw new i("null geometries are not supported");return this.geom[0].isEmpty()||this.geom[1].isEmpty()?0:(this.computeMinDistance(),this.minDistance)},computeMinDistanceLines:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},interfaces_:function(){return[]},getClass:function(){return hr}}),hr.distance=function(t,e){var n=new hr(t,e);return n.distance()},hr.isWithinDistance=function(t,e,n){var i=new hr(t,e,n);return i.distance()<=n},hr.nearestPoints=function(t,e){var n=new hr(t,e);return n.nearestPoints()};var So=Object.freeze({DistanceOp:hr});e(cr.prototype,{getCoordinates:function(){if(null===this.coordinates){for(var t=0,e=0,n=new N,i=this.directedEdges.iterator();i.hasNext();){var r=i.next();r.getEdgeDirection()?t++:e++,n.add(r.getEdge().getLine().getCoordinates(),!1,r.getEdgeDirection())}this.coordinates=n.toCoordinateArray(),e>t&&H.reverse(this.coordinates)}return this.coordinates},toLineString:function(){return this.factory.createLineString(this.getCoordinates())},add:function(t){this.directedEdges.add(t)},interfaces_:function(){return[]},getClass:function(){return cr}}),e(fr.prototype,{setVisited:function(t){this._isVisited=t},isMarked:function(){return this._isMarked},setData:function(t){this.data=t},getData:function(){return this.data},setMarked:function(t){this._isMarked=t},getContext:function(){return this.data},isVisited:function(){return this._isVisited},setContext:function(t){this.data=t},interfaces_:function(){return[]},getClass:function(){return fr}}),fr.getComponentWithVisitedState=function(t,e){for(;t.hasNext();){var n=t.next();if(n.isVisited()===e)return n}return null},fr.setVisited=function(t,e){for(;t.hasNext();){var n=t.next();n.setVisited(e)}},fr.setMarked=function(t,e){for(;t.hasNext();){var n=t.next();n.setMarked(e)}},h(gr,fr),e(gr.prototype,{isRemoved:function(){return null===this.parentEdge},compareDirection:function(t){return this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getCoordinate:function(){return this.from.getCoordinate()},print:function(t){var e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);t.print("  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+this.angle)},getDirectionPt:function(){return this.p1},getAngle:function(){return this.angle},compareTo:function(t){var e=t;return this.compareDirection(e)},getFromNode:function(){return this.from},getSym:function(){return this.sym},setEdge:function(t){this.parentEdge=t},remove:function(){this.sym=null,this.parentEdge=null},getEdge:function(){return this.parentEdge},getQuadrant:function(){return this.quadrant},setSym:function(t){this.sym=t},getToNode:function(){return this.to},getEdgeDirection:function(){return this.edgeDirection},interfaces_:function(){return[s]},getClass:function(){return gr}}),gr.toEdges=function(t){for(var e=new I,n=t.iterator();n.hasNext();)e.add(n.next().parentEdge);return e},h(dr,gr),e(dr.prototype,{getNext:function(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(f.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))},interfaces_:function(){return[]},getClass:function(){return dr}}),h(pr,fr),e(pr.prototype,{isRemoved:function(){return null===this.dirEdge},setDirectedEdges:function(t,e){this.dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)},getDirEdge:function(){if(Number.isInteger(arguments[0])){var t=arguments[0];return this.dirEdge[t]}if(arguments[0]instanceof mr){var e=arguments[0];return this.dirEdge[0].getFromNode()===e?this.dirEdge[0]:this.dirEdge[1].getFromNode()===e?this.dirEdge[1]:null}},remove:function(){this.dirEdge=null},getOppositeNode:function(t){return this.dirEdge[0].getFromNode()===t?this.dirEdge[0].getToNode():this.dirEdge[1].getFromNode()===t?this.dirEdge[1].getToNode():null},interfaces_:function(){return[]},getClass:function(){return pr}}),e(vr.prototype,{getNextEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e+1))},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},iterator:function(){return this.sortEdges(),this.outEdges.iterator()},sortEdges:function(){this.sorted||(ho.sort(this.outEdges),this.sorted=!0)},remove:function(t){this.outEdges.remove(t)},getEdges:function(){return this.sortEdges(),this.outEdges},getNextCWEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e-1))},getIndex:function(){if(arguments[0]instanceof pr){var t=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n.getEdge()===t)return e}return-1}if(arguments[0]instanceof gr){var i=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n===i)return e}return-1}if(Number.isInteger(arguments[0])){var r=arguments[0],s=r%this.outEdges.size();return 0>s&&(s+=this.outEdges.size()),s}},add:function(t){this.outEdges.add(t),this.sorted=!1},getDegree:function(){return this.outEdges.size()},interfaces_:function(){return[]},getClass:function(){return vr}}),h(mr,fr),e(mr.prototype,{isRemoved:function(){return null===this.pt},addOutEdge:function(t){this.deStar.add(t)},getCoordinate:function(){return this.pt},getOutEdges:function(){return this.deStar},remove:function(){if(0===arguments.length)this.pt=null;else if(1===arguments.length){var t=arguments[0];this.deStar.remove(t)}},getIndex:function(t){return this.deStar.getIndex(t)},getDegree:function(){return this.deStar.getDegree()},interfaces_:function(){return[]},getClass:function(){return mr}}),mr.getEdgesBetween=function(t,e){var n=gr.toEdges(t.getOutEdges().getEdges()),i=new J(n),r=gr.toEdges(e.getOutEdges().getEdges());return i.retainAll(r),i},h(yr,pr),e(yr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return yr}}),e(xr.prototype,{find:function(t){return this.nodeMap.get(t)},iterator:function(){return this.nodeMap.values().iterator()},remove:function(t){return this.nodeMap.remove(t)},values:function(){return this.nodeMap.values()},add:function(t){return this.nodeMap.put(t.getCoordinate(),t),t},interfaces_:function(){return[]},getClass:function(){return xr}}),e(Er.prototype,{findNodesOfDegree:function(t){for(var e=new I,n=this.nodeIterator();n.hasNext();){var i=n.next();i.getDegree()===t&&e.add(i)}return e},dirEdgeIterator:function(){return this.dirEdges.iterator()},edgeIterator:function(){return this.edges.iterator()},remove:function(){if(arguments[0]instanceof pr){var t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this.edges.remove(t),t.remove()}else if(arguments[0]instanceof gr){var e=arguments[0],n=e.getSym();null!==n&&n.setSym(null),e.getFromNode().remove(e),e.remove(),this.dirEdges.remove(e)}else if(arguments[0]instanceof mr){for(var i=arguments[0],r=i.getOutEdges().getEdges(),s=r.iterator();s.hasNext();){var o=s.next(),n=o.getSym();null!==n&&this.remove(n),this.dirEdges.remove(o);var a=o.getEdge();null!==a&&this.edges.remove(a)}this.nodeMap.remove(i.getCoordinate()),i.remove()}},findNode:function(t){return this.nodeMap.find(t)},getEdges:function(){return this.edges},nodeIterator:function(){return this.nodeMap.iterator()},contains:function(){if(arguments[0]instanceof pr){var t=arguments[0];return this.edges.contains(t)}if(arguments[0]instanceof gr){var e=arguments[0];return this.dirEdges.contains(e)}},add:function(){if(arguments[0]instanceof mr){var t=arguments[0];this.nodeMap.add(t)}else if(arguments[0]instanceof pr){var e=arguments[0];this.edges.add(e),this.add(e.getDirEdge(0)),this.add(e.getDirEdge(1))}else if(arguments[0]instanceof gr){var n=arguments[0];this.dirEdges.add(n)}},getNodes:function(){return this.nodeMap.values()},interfaces_:function(){return[]},getClass:function(){return Er}}),h(Ir,Er),e(Ir.prototype,{addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new dr(r,s,e[1],!0),a=new dr(s,r,e[e.length-2],!1),u=new yr(t);u.setDirectedEdges(o,a),this.add(u)},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new mr(t),this.add(e)),e},interfaces_:function(){return[]},getClass:function(){return Ir}}),e(Nr.prototype,{buildEdgeStringsForUnprocessedNodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.isMarked()||(f.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForNonDegree2Nodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForObviousStartNodes:function(){this.buildEdgeStringsForNonDegree2Nodes()},getMergedLineStrings:function(){return this.merge(),this.mergedLineStrings},buildEdgeStringsStartingAt:function(t){for(var e=t.getOutEdges().iterator();e.hasNext();){var n=e.next();n.getEdge().isMarked()||this.edgeStrings.add(this.buildEdgeStringStartingWith(n))}},merge:function(){if(null!==this.mergedLineStrings)return null;fr.setMarked(this.graph.nodeIterator(),!1),fr.setMarked(this.graph.edgeIterator(),!1),this.edgeStrings=new I,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this.mergedLineStrings=new I;for(var t=this.edgeStrings.iterator();t.hasNext();){var e=t.next();this.mergedLineStrings.add(e.toLineString())}},buildEdgeStringStartingWith:function(t){var e=new cr(this.factory),n=t;do e.add(n),n.getEdge().setMarked(!0),n=n.getNext();while(null!==n&&n!==t);return e},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v)){var e=arguments[0];this.mergedLineStrings=null;for(var n=e.iterator();n.hasNext();){
var i=n.next();this.add(i)}}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory()),this.graph.addEdge(r)}},buildEdgeStringsForIsolatedLoops:function(){this.buildEdgeStringsForUnprocessedNodes()},interfaces_:function(){return[]},getClass:function(){return Nr}});var wo=Object.freeze({LineMerger:Nr}),Lo=Object.freeze({OverlayOp:ii});h(Cr,gr),e(Cr.prototype,{getNext:function(){return this.next},isInRing:function(){return null!==this.edgeRing},setRing:function(t){this.edgeRing=t},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setNext:function(t){this.next=t},getRing:function(){return this.edgeRing},interfaces_:function(){return[]},getClass:function(){return Cr}}),h(Sr,pr),e(Sr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return Sr}}),e(wr.prototype,{isIncluded:function(){return this._isIncluded},getCoordinates:function(){if(null===this.ringPts){for(var t=new N,e=this.deList.iterator();e.hasNext();){var n=e.next(),i=n.getEdge();wr.addEdge(i.getLine().getCoordinates(),n.getEdgeDirection(),t)}this.ringPts=t.toCoordinateArray()}return this.ringPts},isIncludedSet:function(){return this._isIncludedSet},isValid:function(){return this.getCoordinates(),this.ringPts.length<=3?!1:(this.getRing(),this.ring.isValid())},build:function(t){var e=t;do this.add(e),e.setRing(this),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t)},isOuterHole:function(){return this._isHole?!this.hasShell():!1},getPolygon:function(){var t=null;if(null!==this.holes){t=new Array(this.holes.size()).fill(null);for(var e=0;e<this.holes.size();e++)t[e]=this.holes.get(e)}var n=this.factory.createPolygon(this.ring,t);return n},isHole:function(){return this._isHole},isProcessed:function(){return this._isProcessed},addHole:function(){if(arguments[0]instanceof bt){var t=arguments[0];null===this.holes&&(this.holes=new I),this.holes.add(t)}else if(arguments[0]instanceof wr){var e=arguments[0];e.setShell(this);var n=e.getRing();null===this.holes&&(this.holes=new I),this.holes.add(n)}},setIncluded:function(t){this._isIncluded=t,this._isIncludedSet=!0},getOuterHole:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing();if(n.isOuterHole())return n}return null},computeHole:function(){var t=this.getRing();this._isHole=he.isCCW(t.getCoordinates())},hasShell:function(){return null!==this.shell},isOuterShell:function(){return null!==this.getOuterHole()},getLineString:function(){return this.getCoordinates(),this.factory.createLineString(this.ringPts)},toString:function(){return se.toLineString(new Gt(this.getCoordinates()))},getShell:function(){return this.isHole()?this.shell:this},add:function(t){this.deList.add(t)},getRing:function(){if(null!==this.ring)return this.ring;this.getCoordinates(),this.ringPts.length<3&&A.out.println(this.ringPts);try{this.ring=this.factory.createLinearRing(this.ringPts)}catch(t){if(!(t instanceof S))throw t;A.out.println(this.ringPts)}finally{}return this.ring},updateIncluded:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing().getShell();if(null!==n&&n.isIncludedSet())return this.setIncluded(!n.isIncluded()),null}},setShell:function(t){this.shell=t},setProcessed:function(t){this._isProcessed=t},interfaces_:function(){return[]},getClass:function(){return wr}}),wr.findDirEdgesInRing=function(t){var e=t,n=new I;do n.add(e),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t);return n},wr.addEdge=function(t,e,n){if(e)for(var i=0;i<t.length;i++)n.add(t[i],!1);else for(var i=t.length-1;i>=0;i--)n.add(t[i],!1)},wr.findEdgeRingContaining=function(t,e){for(var n=t.getRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getRing(),h=l.getEnvelopeInternal();if(!h.equals(i)&&h.contains(i)){r=H.ptNotInList(n.getCoordinates(),l.getCoordinates());var c=!1;he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u,o=s.getRing().getEnvelopeInternal())}}return s},e(Lr.prototype,{compare:function(t,e){var n=t,i=e;return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope())},interfaces_:function(){return[a]},getClass:function(){return Lr}}),wr.EnvelopeComparator=Lr,h(Rr,Er),e(Rr.prototype,{findEdgeRing:function(t){var e=new wr(this.factory);return e.build(t),e},computeDepthParity:function(){if(0===arguments.length)for(;;){var t=null;if(null===t)return null;this.computeDepthParity(t)}else if(1===arguments.length){arguments[0]}},computeNextCWEdges:function(){for(var t=this.nodeIterator();t.hasNext();){var e=t.next();Rr.computeNextCWEdges(e)}},addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new Cr(r,s,e[1],!0),a=new Cr(s,r,e[e.length-2],!1),u=new Sr(t);u.setDirectedEdges(o,a),this.add(u)},deleteCutEdges:function(){this.computeNextCWEdges(),Rr.findLabeledEdgeRings(this.dirEdges);for(var t=new I,e=this.dirEdges.iterator();e.hasNext();){var n=e.next();if(!n.isMarked()){var i=n.getSym();if(n.getLabel()===i.getLabel()){n.setMarked(!0),i.setMarked(!0);var r=n.getEdge();t.add(r.getLine())}}}return t},getEdgeRings:function(){this.computeNextCWEdges(),Rr.label(this.dirEdges,-1);var t=Rr.findLabeledEdgeRings(this.dirEdges);this.convertMaximalToMinimalEdgeRings(t);for(var e=new I,n=this.dirEdges.iterator();n.hasNext();){var i=n.next();if(!i.isMarked()&&!i.isInRing()){var r=this.findEdgeRing(i);e.add(r)}}return e},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new mr(t),this.add(e)),e},convertMaximalToMinimalEdgeRings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel(),r=Rr.findIntersectionNodes(n,i);if(null!==r)for(var s=r.iterator();s.hasNext();){var o=s.next();Rr.computeNextCCWEdges(o,i)}}},deleteDangles:function(){for(var t=this.findNodesOfDegree(1),e=new J,n=new pe,i=t.iterator();i.hasNext();)n.push(i.next());for(;!n.isEmpty();){var r=n.pop();Rr.deleteAllEdges(r);for(var s=r.getOutEdges().getEdges(),i=s.iterator();i.hasNext();){var o=i.next();o.setMarked(!0);var a=o.getSym();null!==a&&a.setMarked(!0);var u=o.getEdge();e.add(u.getLine());var l=o.getToNode();1===Rr.getDegreeNonDeleted(l)&&n.push(l)}}return e},interfaces_:function(){return[]},getClass:function(){return Rr}}),Rr.findLabeledEdgeRings=function(t){for(var e=new I,n=1,i=t.iterator();i.hasNext();){var r=i.next();if(!(r.isMarked()||r.getLabel()>=0)){e.add(r);var s=wr.findDirEdgesInRing(r);Rr.label(s,n),n++}}return e},Rr.getDegreeNonDeleted=function(t){for(var e=t.getOutEdges().getEdges(),n=0,i=e.iterator();i.hasNext();){var r=i.next();r.isMarked()||n++}return n},Rr.deleteAllEdges=function(t){for(var e=t.getOutEdges().getEdges(),n=e.iterator();n.hasNext();){var i=n.next();i.setMarked(!0);var r=i.getSym();null!==r&&r.setMarked(!0)}},Rr.label=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();i.setLabel(e)}},Rr.computeNextCWEdges=function(t){for(var e=t.getOutEdges(),n=null,i=null,r=e.getEdges().iterator();r.hasNext();){var s=r.next();if(!s.isMarked()){if(null===n&&(n=s),null!==i){var o=i.getSym();o.setNext(s)}i=s}}if(null!==i){var o=i.getSym();o.setNext(n)}},Rr.computeNextCCWEdges=function(t,e){for(var n=t.getOutEdges(),i=null,r=null,s=n.getEdges(),o=s.size()-1;o>=0;o--){var a=s.get(o),u=a.getSym(),l=null;a.getLabel()===e&&(l=a);var h=null;u.getLabel()===e&&(h=u),null===l&&null===h||(null!==h&&(r=h),null!==l&&(null!==r&&(r.setNext(l),r=null),null===i&&(i=l)))}null!==r&&(f.isTrue(null!==i),r.setNext(i))},Rr.getDegree=function(t,e){for(var n=t.getOutEdges().getEdges(),i=0,r=n.iterator();r.hasNext();){var s=r.next();s.getLabel()===e&&i++}return i},Rr.findIntersectionNodes=function(t,e){var n=t,i=null;do{var r=n.getFromNode();Rr.getDegree(r,e)>1&&(null===i&&(i=new I),i.add(r)),n=n.getNext(),f.isTrue(null!==n,"found null DE in ring"),f.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return i},e(Tr.prototype,{getGeometry:function(){return null===this.geomFactory&&(this.geomFactory=new ie),this.polygonize(),this.extractOnlyPolygonal?this.geomFactory.buildGeometry(this.polyList):this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList))},getInvalidRingLines:function(){return this.polygonize(),this.invalidRingLines},findValidRings:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isValid()?e.add(r):n.add(r.getLineString())}},polygonize:function(){if(null!==this.polyList)return null;if(this.polyList=new I,null===this.graph)return null;this.dangles=this.graph.deleteDangles(),this.cutEdges=this.graph.deleteCutEdges();var t=this.graph.getEdgeRings(),e=new I;this.invalidRingLines=new I,this.isCheckingRingsValid?this.findValidRings(t,e,this.invalidRingLines):e=t,this.findShellsAndHoles(e),Tr.assignHolesToShells(this.holeList,this.shellList),ho.sort(this.shellList,new wr.EnvelopeComparator);var n=!0;this.extractOnlyPolygonal&&(Tr.findDisjointShells(this.shellList),n=!1),this.polyList=Tr.extractPolygons(this.shellList,n)},getDangles:function(){return this.polygonize(),this.dangles},getCutEdges:function(){return this.polygonize(),this.cutEdges},getPolygons:function(){return this.polygonize(),this.polyList},add:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.add(n)}else if(arguments[0]instanceof St){var i=arguments[0];this.geomFactory=i.getFactory(),null===this.graph&&(this.graph=new Rr(this.geomFactory)),this.graph.addEdge(i)}else if(arguments[0]instanceof B){var r=arguments[0];r.apply(this.lineStringAdder)}},setCheckRingsValid:function(t){this.isCheckingRingsValid=t},findShellsAndHoles:function(t){this.holeList=new I,this.shellList=new I;for(var e=t.iterator();e.hasNext();){var n=e.next();n.computeHole(),n.isHole()?this.holeList.add(n):this.shellList.add(n)}},interfaces_:function(){return[]},getClass:function(){return Tr}}),Tr.findOuterShells=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getOuterHole();null===i||i.isProcessed()||(n.setIncluded(!0),i.setProcessed(!0))}},Tr.extractPolygons=function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next();(e||r.isIncluded())&&n.add(r.getPolygon())}return n},Tr.assignHolesToShells=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();Tr.assignHoleToShell(i,e)}},Tr.assignHoleToShell=function(t,e){var n=wr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)},Tr.findDisjointShells=function(t){Tr.findOuterShells(t);var e=null;do{e=!1;for(var n=t.iterator();n.hasNext();){var i=n.next();i.isIncludedSet()||(i.updateIncluded(),i.isIncludedSet()||(e=!0))}}while(e)},e(Pr.prototype,{filter:function(t){t instanceof St&&this.p.add(t)},interfaces_:function(){return[q]},getClass:function(){return Pr}}),Tr.LineStringAdder=Pr;var Ro=Object.freeze({Polygonizer:Tr});e(br.prototype,{createEdgeEndForNext:function(t,e,n,i){var r=n.segmentIndex+1;if(r>=t.getNumPoints()&&null===i)return null;var s=t.getCoordinate(r);null!==i&&i.segmentIndex===n.segmentIndex&&(s=i.coord);var o=new En(t,n.coord,s,new gn(t.getLabel()));e.add(o)},createEdgeEndForPrev:function(t,e,n,i){var r=n.segmentIndex;if(0===n.dist){if(0===r)return null;r--}var s=t.getCoordinate(r);null!==i&&i.segmentIndex>=r&&(s=i.coord);var o=new gn(t.getLabel());o.flip();var a=new En(t,n.coord,s,o);e.add(a)},computeEdgeEnds:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=t;n.hasNext();){var i=n.next();this.computeEdgeEnds(i,e)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1],o=r.getEdgeIntersectionList();o.addEndpoints();var a=o.iterator(),u=null,l=null;if(!a.hasNext())return null;var h=a.next();do u=l,l=h,h=null,a.hasNext()&&(h=a.next()),null!==l&&(this.createEdgeEndForPrev(r,s,l,u),this.createEdgeEndForNext(r,s,l,h));while(null!==l)}},interfaces_:function(){return[]},getClass:function(){return br}}),h(Or,En),e(Or.prototype,{insert:function(t){this.edgeEnds.add(t)},print:function(t){t.println("EdgeEndBundle--> Label: "+this.label);for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t),t.println()}},iterator:function(){return this.edgeEnds.iterator()},getEdgeEnds:function(){return this.edgeEnds},computeLabelOn:function(t,e){for(var n=0,i=!1,r=this.iterator();r.hasNext();){var s=r.next(),o=s.getLabel().getLocation(t);o===L.BOUNDARY&&n++,o===L.INTERIOR&&(i=!0)}var o=L.NONE;i&&(o=L.INTERIOR),n>0&&(o=$n.determineBoundary(e,n)),this.label.setLocation(t,o)},computeLabelSide:function(t,e){for(var n=this.iterator();n.hasNext();){var i=n.next();if(i.getLabel().isArea()){var r=i.getLabel().getLocation(t,e);if(r===L.INTERIOR)return this.label.setLocation(t,e,L.INTERIOR),null;r===L.EXTERIOR&&this.label.setLocation(t,e,L.EXTERIOR)}}},getLabel:function(){return this.label},computeLabelSides:function(t){this.computeLabelSide(t,cn.LEFT),this.computeLabelSide(t,cn.RIGHT)},updateIM:function(t){Jn.updateIM(this.label,t)},computeLabel:function(t){for(var e=!1,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().isArea()&&(e=!0)}e?this.label=new gn(L.NONE,L.NONE,L.NONE):this.label=new gn(L.NONE);for(var r=0;2>r;r++)this.computeLabelOn(r,t),e&&this.computeLabelSides(r)},interfaces_:function(){return[]},getClass:function(){return Or}}),h(_r,Pn),e(_r.prototype,{updateIM:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}},insert:function(t){var e=this.edgeMap.get(t);null===e?(e=new Or(t),this.insertEdgeEnd(t,e)):e.insert(t)},interfaces_:function(){return[]},getClass:function(){return _r}}),h(Mr,yn),e(Mr.prototype,{updateIMFromEdges:function(t){this.edges.updateIM(t)},computeIM:function(t){t.setAtLeastIfValid(this.label.getLocation(0),this.label.getLocation(1),0)},interfaces_:function(){return[]},getClass:function(){return Mr}}),h(Dr,Nn),e(Dr.prototype,{createNode:function(t){return new Mr(t,new _r)},interfaces_:function(){return[]},getClass:function(){return Dr}}),e(Ar.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},computeProperIntersectionIM:function(t,e){var n=this.arg[0].getGeometry().getDimension(),i=this.arg[1].getGeometry().getDimension(),r=t.hasProperIntersection(),s=t.hasProperInteriorIntersection();2===n&&2===i?r&&e.setAtLeast("212101212"):2===n&&1===i?(r&&e.setAtLeast("FFF0FFFF2"),s&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(r&&e.setAtLeast("F0FFFFFF2"),s&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&s&&e.setAtLeast("0FFFFFFFF")},labelIsolatedEdges:function(t,e){for(var n=this.arg[t].getEdgeIterator();n.hasNext();){var i=n.next();i.isIsolated()&&(this.labelIsolatedEdge(i,e,this.arg[e].getGeometry()),this.isolatedEdges.add(i))}},labelIsolatedEdge:function(t,e,n){if(n.getDimension()>0){var i=this.ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,L.EXTERIOR)},computeIM:function(){var t=new fe;if(t.set(L.EXTERIOR,L.EXTERIOR,2),!this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1);var e=this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);var n=new br,i=n.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(i);var r=n.computeEdgeEnds(this.arg[1].getEdgeIterator());return this.insertEdgeEnds(r),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t},labelNodeEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}},copyNodesAndLabels:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.nodes.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},labelIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.find(s.coord);o.getLabel().isNull(t)&&(i===L.BOUNDARY?o.setLabelBoundary(t):o.setLabel(t,L.INTERIOR))}},labelIsolatedNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setAllLocations(e,n)},computeIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.addNode(s.coord);i===L.BOUNDARY?o.setLabelBoundary(t):o.getLabel().isNull(t)&&o.setLabel(t,L.INTERIOR)}},labelIsolatedNodes:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();f.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}},updateIM:function(t){for(var e=this.isolatedEdges.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}for(var i=this.nodes.iterator();i.hasNext();){var r=i.next();r.updateIM(t),r.updateIMFromEdges(t)}},computeDisjointIM:function(t){var e=this.arg[0].getGeometry();e.isEmpty()||(t.set(L.INTERIOR,L.EXTERIOR,e.getDimension()),t.set(L.BOUNDARY,L.EXTERIOR,e.getBoundaryDimension()));var n=this.arg[1].getGeometry();n.isEmpty()||(t.set(L.EXTERIOR,L.INTERIOR,n.getDimension()),t.set(L.EXTERIOR,L.BOUNDARY,n.getBoundaryDimension()))},interfaces_:function(){return[]},getClass:function(){return Ar}}),e(Fr.prototype,{isContainedInBoundary:function(t){if(t instanceof Tt)return!1;if(t instanceof Lt)return this.isPointContainedInBoundary(t);if(t instanceof St)return this.isLineStringContainedInBoundary(t);for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0},isLineSegmentContainedInBoundary:function(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this.rectEnv.getMinX()||t.x===this.rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this.rectEnv.getMinY()||t.y===this.rectEnv.getMaxY()))return!0;return!1},isLineStringContainedInBoundary:function(t){for(var e=t.getCoordinateSequence(),n=new g,i=new g,r=0;r<e.size()-1;r++)if(e.getCoordinate(r,n),e.getCoordinate(r+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0},isPointContainedInBoundary:function(){if(arguments[0]instanceof Lt){var t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){var e=arguments[0];return e.x===this.rectEnv.getMinX()||e.x===this.rectEnv.getMaxX()||e.y===this.rectEnv.getMinY()||e.y===this.rectEnv.getMaxY()}},contains:function(t){return this.rectEnv.contains(t.getEnvelopeInternal())?!this.isContainedInBoundary(t):!1},interfaces_:function(){return[]},getClass:function(){return Fr}}),Fr.contains=function(t,e){var n=new Fr(t);return n.contains(e)},e(Gr.prototype,{intersects:function(t,e){var n=new C(t,e);if(!this.rectEnv.intersects(n))return!1;if(this.rectEnv.intersects(t))return!0;if(this.rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){var i=t;t=e,e=i}var r=!1;return e.y>t.y&&(r=!0),r?this.li.computeIntersection(t,e,this.diagDown0,this.diagDown1):this.li.computeIntersection(t,e,this.diagUp0,this.diagUp1),!!this.li.hasIntersection()},interfaces_:function(){return[]},getClass:function(){return Gr}}),e(qr.prototype,{applyTo:function(t){for(var e=0;e<t.getNumGeometries()&&!this._isDone;e++){var n=t.getGeometryN(e);if(n instanceof ft)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}},interfaces_:function(){return[]},getClass:function(){return qr}}),e(Br.prototype,{intersects:function(t){if(!this.rectEnv.intersects(t.getEnvelopeInternal()))return!1;var e=new zr(this.rectEnv);if(e.applyTo(t),e.intersects())return!0;var n=new Vr(this.rectangle);if(n.applyTo(t),n.containsPoint())return!0;var i=new kr(this.rectangle);return i.applyTo(t),!!i.intersects()},interfaces_:function(){return[]},getClass:function(){return Br}}),Br.intersects=function(t,e){var n=new Br(t);return n.intersects(e)},h(zr,qr),e(zr.prototype,{isDone:function(){return this._intersects===!0},visit:function(t){var e=t.getEnvelopeInternal();return this.rectEnv.intersects(e)?this.rectEnv.contains(e)?(this._intersects=!0,null):e.getMinX()>=this.rectEnv.getMinX()&&e.getMaxX()<=this.rectEnv.getMaxX()?(this._intersects=!0,null):e.getMinY()>=this.rectEnv.getMinY()&&e.getMaxY()<=this.rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null},intersects:function(){return this._intersects},interfaces_:function(){return[]},getClass:function(){return zr}}),h(Vr,qr),e(Vr.prototype,{isDone:function(){return this._containsPoint===!0},visit:function(t){if(!(t instanceof Tt))return null;var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;for(var n=new g,i=0;4>i;i++)if(this.rectSeq.getCoordinate(i,n),e.contains(n)&&Tn.containsPointInPolygon(n,t))return this._containsPoint=!0,null},containsPoint:function(){return this._containsPoint},interfaces_:function(){return[]},getClass:function(){return Vr}}),h(kr,qr),e(kr.prototype,{intersects:function(){return this.hasIntersection},isDone:function(){return this.hasIntersection===!0},visit:function(t){var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;var n=kn.getLines(t);this.checkIntersectionWithLineStrings(n)},checkIntersectionWithLineStrings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();if(this.checkIntersectionWithSegments(n),this.hasIntersection)return null}},checkIntersectionWithSegments:function(t){for(var e=t.getCoordinateSequence(),n=1;n<e.size();n++)if(e.getCoordinate(n-1,this.p0),e.getCoordinate(n,this.p1),this.rectIntersector.intersects(this.p0,this.p1))return this.hasIntersection=!0,null},interfaces_:function(){return[]},getClass:function(){return kr}}),h(Yr,ti),e(Yr.prototype,{getIntersectionMatrix:function(){return this._relate.computeIM()},interfaces_:function(){return[]},getClass:function(){return Yr}}),Yr.covers=function(t,e){return t.getEnvelopeInternal().covers(e.getEnvelopeInternal())?t.isRectangle()?!0:Yr.relate(t,e).isCovers():!1},Yr.intersects=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?t.isRectangle()?Br.intersects(t,e):e.isRectangle()?Br.intersects(e,t):Yr.relate(t,e).isIntersects():!1},Yr.touches=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isTouches(t.getDimension(),e.getDimension()):!1},Yr.within=function(t,e){return e.contains(t)},Yr.coveredBy=function(t,e){return Yr.covers(e,t)},Yr.relate=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yr(t,e),i=n.getIntersectionMatrix();return i}if(3===arguments.length){if("string"==typeof arguments[2]&&arguments[0]instanceof B&&arguments[1]instanceof B){var r=arguments[0],s=arguments[1],o=arguments[2];return Yr.relateWithCheck(r,s).matches(o)}if(R(arguments[2],V)&&arguments[0]instanceof B&&arguments[1]instanceof B){var a=arguments[0],u=arguments[1],l=arguments[2],n=new Yr(a,u,l),i=n.getIntersectionMatrix();return i}}},Yr.overlaps=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isOverlaps(t.getDimension(),e.getDimension()):!1},Yr.disjoint=function(t,e){return!t.intersects(e)},Yr.relateWithCheck=function(t,e){return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),Yr.relate(t,e)},Yr.crosses=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isCrosses(t.getDimension(),e.getDimension()):!1},Yr.contains=function(t,e){return t.getEnvelopeInternal().contains(e.getEnvelopeInternal())?t.isRectangle()?Fr.contains(t,e):Yr.relate(t,e).isContains():!1};var To=Object.freeze({RelateOp:Yr});e(Ur.prototype,{extractElements:function(t,e){if(null===t)return null;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);this.skipEmpty&&i.isEmpty()||e.add(i)}},combine:function(){for(var t=new I,e=this.inputGeoms.iterator();e.hasNext();){var n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this.geomFactory?this.geomFactory.createGeometryCollection(null):null:this.geomFactory.buildGeometry(t)},interfaces_:function(){return[]},getClass:function(){return Ur}}),Ur.combine=function(){if(1===arguments.length){var t=arguments[0],e=new Ur(t);return e.combine()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new Ur(Ur.createList(n,i));return e.combine()}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],e=new Ur(Ur.createList(r,s,o));return e.combine()}},Ur.extractFactory=function(t){return t.isEmpty()?null:t.iterator().next().getFactory()},Ur.createList=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new I;return n.add(t),n.add(e),n}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],n=new I;return n.add(i),n.add(r),n.add(s),n}},e(Xr.prototype,{union:function(){for(var t=new Te,e=new at,n=0;n<this.pointGeom.getNumGeometries();n++){var i=this.pointGeom.getGeometryN(n),r=i.getCoordinate(),s=t.locate(r,this.otherGeom);s===L.EXTERIOR&&e.add(r)}if(0===e.size())return this.otherGeom;var o=null,a=H.toCoordinateArray(e);return o=1===a.length?this.geomFact.createPoint(a[0]):this.geomFact.createMultiPointFromCoords(a),Ur.combine(o,this.otherGeom)},interfaces_:function(){return[]},getClass:function(){return Xr}}),Xr.union=function(t,e){var n=new Xr(t,e);return n.union()},e(Hr.prototype,{filter:function(t){-1!==this.sortIndex&&t.getSortIndex()!==this.sortIndex||this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return Hr}}),Hr.extract=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Hr.extract(t,e,new I)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];return n.getSortIndex()===i?r.add(n):n instanceof ft&&n.apply(new Hr(i,r)),r}},e(Wr.prototype,{reduceToGeometries:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=null;R(i,y)?r=this.unionTree(i):i instanceof B&&(r=i),e.add(r)}return e},extractByEnvelope:function(t,e,n){for(var i=new I,r=0;r<e.getNumGeometries();r++){var s=e.getGeometryN(r);s.getEnvelopeInternal().intersects(t)?i.add(s):n.add(s)}return this.geomFactory.buildGeometry(i)},unionOptimized:function(t,e){var n=t.getEnvelopeInternal(),i=e.getEnvelopeInternal();if(!n.intersects(i)){var r=Ur.combine(t,e);return r}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);var s=n.intersection(i);return this.unionUsingEnvelopeIntersection(t,e,s)},union:function(){if(null===this.inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this.inputPolys.isEmpty())return null;this.geomFactory=this.inputPolys.iterator().next().getFactory();for(var t=new ke(Wr.STRTREE_NODE_CAPACITY),e=this.inputPolys.iterator();e.hasNext();){var n=e.next();t.insert(n.getEnvelopeInternal(),n)}this.inputPolys=null;var i=t.itemsTree(),r=this.unionTree(i);return r},binaryUnion:function(){if(1===arguments.length){var t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];if(1>=i-n){var r=Wr.getGeometry(e,n);return this.unionSafe(r,null)}if(i-n===2)return this.unionSafe(Wr.getGeometry(e,n),Wr.getGeometry(e,n+1));var s=Math.trunc((i+n)/2),r=this.binaryUnion(e,n,s),o=this.binaryUnion(e,s,i);return this.unionSafe(r,o)}},repeatedUnion:function(t){for(var e=null,n=t.iterator();n.hasNext();){var i=n.next();e=null===e?i.copy():e.union(i)}return e},unionSafe:function(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)},unionActual:function(t,e){return Wr.restrictToPolygons(t.union(e))},unionTree:function(t){var e=this.reduceToGeometries(t),n=this.binaryUnion(e);return n},unionUsingEnvelopeIntersection:function(t,e,n){var i=new I,r=this.extractByEnvelope(n,t,i),s=this.extractByEnvelope(n,e,i),o=this.unionActual(r,s);i.add(o);var a=Ur.combine(i);return a},bufferUnion:function(){if(1===arguments.length){var t=arguments[0],e=t.get(0).getFactory(),n=e.buildGeometry(t),i=n.buffer(0);return i}if(2===arguments.length){var r=arguments[0],s=arguments[1],e=r.getFactory(),n=e.createGeometryCollection([r,s]),i=n.buffer(0);return i}},interfaces_:function(){return[]},getClass:function(){return Wr}}),Wr.restrictToPolygons=function(t){if(R(t,Rt))return t;var e=or.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(ie.toPolygonArray(e))},Wr.getGeometry=function(t,e){return e>=t.size()?null:t.get(e)},Wr.union=function(t){var e=new Wr(t);return e.union()},Wr.STRTREE_NODE_CAPACITY=4,e(jr.prototype,{unionNoOpt:function(t){var e=this.geomFact.createPoint();return si.overlayOp(t,e,ii.UNION)},unionWithNull:function(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)},extract:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.extract(n)}else if(arguments[0]instanceof B){var i=arguments[0];null===this.geomFact&&(this.geomFact=i.getFactory()),Hr.extract(i,B.SORTINDEX_POLYGON,this.polygons),Hr.extract(i,B.SORTINDEX_LINESTRING,this.lines),Hr.extract(i,B.SORTINDEX_POINT,this.points)}},union:function t(){if(null===this.geomFact)return null;var e=null;if(this.points.size()>0){var n=this.geomFact.buildGeometry(this.points);e=this.unionNoOpt(n)}var i=null;if(this.lines.size()>0){var r=this.geomFact.buildGeometry(this.lines);i=this.unionNoOpt(r)}var s=null;this.polygons.size()>0&&(s=Wr.union(this.polygons));var o=this.unionWithNull(i,s),t=null;return t=null===e?o:null===o?e:Xr.union(e,o),null===t?this.geomFact.createGeometryCollection():t},interfaces_:function(){return[]},getClass:function(){return jr}}),jr.union=function(){if(1===arguments.length){if(R(arguments[0],v)){var t=arguments[0],e=new jr(t);return e.union()}if(arguments[0]instanceof B){var n=arguments[0],e=new jr(n);return e.union()}}else if(2===arguments.length){var i=arguments[0],r=arguments[1],e=new jr(i,r);return e.union()}};var Po=Object.freeze({UnaryUnionOp:jr});e(Kr.prototype,{visitInteriorRing:function(t,e){var n=t.getCoordinates(),i=n[0],r=Kr.findDifferentPoint(n,i),s=e.findEdgeInSameDirection(i,r),o=e.findEdgeEnd(s),a=null;o.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR?a=o:o.getSym().getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&(a=o.getSym()),f.isTrue(null!==a,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(a)},visitShellInteriors:function(t,e){if(t instanceof Tt){var n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof Ot)for(var i=t,r=0;r<i.getNumGeometries();r++){var n=i.getGeometryN(r);this.visitInteriorRing(n.getExteriorRing(),e)}},getCoordinate:function(){return this.disconnectedRingcoord},setInteriorEdgesInResult:function(t){for(var e=t.getEdgeEnds().iterator();e.hasNext();){var n=e.next();n.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&n.setInResult(!0)}},visitLinkedDirectedEdges:function(t){var e=t,n=t;do f.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext();while(n!==e)},buildEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);r.linkDirectedEdgesForMinimalEdgeRings();var s=r.buildMinimalRings();e.addAll(s)}}return e},hasUnvisitedShellEdge:function(t){for(var e=0;e<t.size();e++){var n=t.get(e);if(!n.isHole()){var i=n.getEdges(),r=i.get(0);if(r.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR)for(var s=0;s<i.size();s++)if(r=i.get(s),
!r.isVisited())return this.disconnectedRingcoord=r.getCoordinate(),!0}}return!1},isInteriorsConnected:function(){var t=new I;this.geomGraph.computeSplitEdges(t);var e=new Cn(new On);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();var n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this.geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)},interfaces_:function(){return[]},getClass:function(){return Kr}}),Kr.findDifferentPoint=function(t,e){for(var n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null},e(Zr.prototype,{hasChildren:function(){for(var t=0;2>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;2>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},size:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){return null===t||this.isSearchMatch(t)?(e.addAll(this.items),null!==this.subnode[0]&&this.subnode[0].addAllItemsFromOverlapping(t,e),void(null!==this.subnode[1]&&this.subnode[1].addAllItemsFromOverlapping(t,e))):null},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;2>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;2>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},nodeSize:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].nodeSize());return t+1},add:function(t){this.items.add(t)},interfaces_:function(){return[]},getClass:function(){return Zr}}),Zr.getSubnodeIndex=function(t,e){var n=-1;return t.min>=e&&(n=1),t.max<=e&&(n=0),n},e(Qr.prototype,{expandToInclude:function(t){t.max>this.max&&(this.max=t.max),t.min<this.min&&(this.min=t.min)},getWidth:function(){return this.max-this.min},overlaps:function(){if(1===arguments.length){var t=arguments[0];return this.overlaps(t.min,t.max)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return!(this.min>n||this.max<e)}},getMin:function(){return this.min},toString:function(){return"["+this.min+", "+this.max+"]"},contains:function(){if(1===arguments.length){if(arguments[0]instanceof Qr){var t=arguments[0];return this.contains(t.min,t.max)}if("number"==typeof arguments[0]){var e=arguments[0];return e>=this.min&&e<=this.max}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return n>=this.min&&i<=this.max}},init:function(t,e){this.min=t,this.max=e,t>e&&(this.min=e,this.max=t)},getMax:function(){return this.max},interfaces_:function(){return[]},getClass:function(){return Qr}}),e(Jr.prototype,{getInterval:function(){return this.interval},getLevel:function(){return this.level},computeKey:function(t){for(this.level=Jr.computeLevel(t),this.interval=new Qr,this.computeInterval(this.level,t);!this.interval.contains(t);)this.level+=1,this.computeInterval(this.level,t)},computeInterval:function(t,e){var n=Ci.powerOf2(t);this.pt=Math.floor(e.getMin()/n)*n,this.interval.init(this.pt,this.pt+n)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return Jr}}),Jr.computeLevel=function(t){var e=t.getWidth(),n=Ci.exponent(e)+1;return n},h($r,Zr),e($r.prototype,{getInterval:function(){return this.interval},find:function(t){var e=Zr.getSubnodeIndex(t,this.centre);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},insert:function(t){f.isTrue(null===this.interval||this.interval.contains(t.interval));var e=Zr.getSubnodeIndex(t.interval,this.centre);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insert(t),this.subnode[e]=n}},isSearchMatch:function(t){return t.overlaps(this.interval)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getNode:function(t){var e=Zr.getSubnodeIndex(t,this.centre);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0;switch(t){case 0:e=this.interval.getMin(),n=this.centre;break;case 1:e=this.centre,n=this.interval.getMax()}var i=new Qr(e,n),r=new $r(i,this.level-1);return r},interfaces_:function(){return[]},getClass:function(){return $r}}),$r.createNode=function(t){var e=new Jr(t),n=new $r(e.getInterval(),e.getLevel());return n},$r.createExpanded=function(t,e){var n=new Qr(e);null!==t&&n.expandToInclude(t.interval);var i=$r.createNode(n);return null!==t&&i.insert(t),i},h(ts,Zr),e(ts.prototype,{insert:function(t,e){var n=Zr.getSubnodeIndex(t,ts.origin);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getInterval().contains(t)){var r=$r.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getInterval().contains(e));var i=Ri.isZeroWidth(e.getMin(),e.getMax()),r=null;r=i?t.find(e):t.getNode(e),r.add(n)},interfaces_:function(){return[]},getClass:function(){return ts}}),ts.origin=0,e(es.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=es.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];return this.query(new Qr(t,t))}if(arguments[0]instanceof Qr){var e=arguments[0],n=new I;return this.query(e,n),n}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.root.addAllItemsFromOverlapping(i,r)}},iterator:function(){var t=new I;return this.root.addAllItems(t),t.iterator()},remove:function(t,e){var n=es.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e)},depth:function(){return null!==this.root?this.root.depth():0},nodeSize:function(){return null!==this.root?this.root.nodeSize():0},interfaces_:function(){return[]},getClass:function(){return es}}),es.ensureExtent=function(t,e){var n=t.getMin(),i=t.getMax();return n!==i?t:(n===i&&(n-=e/2,i=n+e/2),new Qr(n,i))},e(ns.prototype,{isInside:function(t){},interfaces_:function(){return[]},getClass:function(){return ns}}),e(is.prototype,{testLineSegment:function(t,e){var n=null,i=null,r=null,s=null,o=null,a=e.p0,u=e.p1;i=a.x-t.x,r=a.y-t.y,s=u.x-t.x,o=u.y-t.y,(r>0&&0>=o||o>0&&0>=r)&&(n=ue.signOfDet2x2(i,r,s,o)/(o-r),n>0&&this.crossings++)},buildIndex:function(){this.tree=new es;for(var t=H.removeRepeatedPoints(this.ring.getCoordinates()),e=$e.getChains(t),n=0;n<e.size();n++){var i=e.get(n),r=i.getEnvelope();this.interval.min=r.getMinY(),this.interval.max=r.getMaxY(),this.tree.insert(this.interval,i)}},testMonotoneChain:function(t,e,n){n.select(t,e)},isInside:function(t){this.crossings=0;var e=new C(r.NEGATIVE_INFINITY,r.POSITIVE_INFINITY,t.y,t.y);this.interval.min=t.y,this.interval.max=t.y;for(var n=this.tree.query(this.interval),i=new rs(this,t),s=n.iterator();s.hasNext();){var o=s.next();this.testMonotoneChain(e,i,o)}return this.crossings%2===1},interfaces_:function(){return[ns]},getClass:function(){return is}}),h(rs,tr),e(rs.prototype,{select:function(){if(1!==arguments.length)return tr.prototype.select.apply(this,arguments);var t=arguments[0];this.mcp.testLineSegment(this.p,t)},interfaces_:function(){return[]},getClass:function(){return rs}}),is.MCSelecter=rs,e(ss.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},getNodeIterator:function(){return this.nodes.iterator()},copyNodesAndLabels:function(t,e){for(var n=t.getNodeIterator();n.hasNext();){var i=n.next(),r=this.nodes.addNode(i.getCoordinate());r.setLabel(e,i.getLabel().getLocation(e))}},build:function(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);var e=new br,n=e.computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(n)},computeIntersectionNodes:function(t,e){for(var n=t.getEdgeIterator();n.hasNext();)for(var i=n.next(),r=i.getLabel().getLocation(e),s=i.getEdgeIntersectionList().iterator();s.hasNext();){var o=s.next(),a=this.nodes.addNode(o.coord);r===L.BOUNDARY?a.setLabelBoundary(e):a.getLabel().isNull(e)&&a.setLabel(e,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return ss}}),e(os.prototype,{isNodeEdgeAreaLabelsConsistent:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();){var e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this.geomGraph))return this.invalidPoint=e.getCoordinate().copy(),!1}return!0},getInvalidPoint:function(){return this.invalidPoint},hasDuplicateRings:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();)for(var e=t.next(),n=e.getEdges().iterator();n.hasNext();){var i=n.next();if(i.getEdgeEnds().size()>1)return this.invalidPoint=i.getEdge().getCoordinate(0),!0}return!1},isNodeConsistentArea:function(){var t=this.geomGraph.computeSelfNodes(this.li,!0,!0);return t.hasProperIntersection()?(this.invalidPoint=t.getProperIntersectionPoint(),!1):(this.nodeGraph.build(this.geomGraph),this.isNodeEdgeAreaLabelsConsistent())},interfaces_:function(){return[]},getClass:function(){return os}}),e(as.prototype,{buildIndex:function(){this.index=new ke;for(var t=0;t<this.rings.size();t++){var e=this.rings.get(t),n=e.getEnvelopeInternal();this.index.insert(n,e)}},getNestedPoint:function(){return this.nestedPt},isNonNested:function(){this.buildIndex();for(var t=0;t<this.rings.size();t++)for(var e=this.rings.get(t),n=e.getCoordinates(),i=this.index.query(e.getEnvelopeInternal()),r=0;r<i.size();r++){var s=i.get(r),o=s.getCoordinates();if(e!==s&&e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())){var a=ls.findPtNotNode(n,s,this.graph);if(null!==a){var u=he.isPointInRing(a,o);if(u)return this.nestedPt=a,!1}}}return!0},add:function(t){this.rings.add(t),this.totalEnv.expandToInclude(t.getEnvelopeInternal())},interfaces_:function(){return[]},getClass:function(){return as}}),e(us.prototype,{getErrorType:function(){return this.errorType},getMessage:function(){return us.errMsg[this.errorType]},getCoordinate:function(){return this.pt},toString:function(){var t="";return null!==this.pt&&(t=" at or near point "+this.pt),this.getMessage()+t},interfaces_:function(){return[]},getClass:function(){return us}}),us.ERROR=0,us.REPEATED_POINT=1,us.HOLE_OUTSIDE_SHELL=2,us.NESTED_HOLES=3,us.DISCONNECTED_INTERIOR=4,us.SELF_INTERSECTION=5,us.RING_SELF_INTERSECTION=6,us.NESTED_SHELLS=7,us.DUPLICATE_RINGS=8,us.TOO_FEW_POINTS=9,us.INVALID_COORDINATE=10,us.RING_NOT_CLOSED=11,us.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"],e(ls.prototype,{checkInvalidCoordinates:function(){if(arguments[0]instanceof Array){for(var t=arguments[0],e=0;e<t.length;e++)if(!ls.isValid(t[e]))return this.validErr=new us(us.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof Tt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()),null!==this.validErr)return null;for(var e=0;e<n.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()),null!==this.validErr)return null}},checkHolesNotNested:function(t,e){for(var n=new as(e),i=0;i<t.getNumInteriorRing();i++){var r=t.getInteriorRingN(i);n.add(r)}var s=n.isNonNested();s||(this.validErr=new us(us.NESTED_HOLES,n.getNestedPoint()))},checkConsistentArea:function(t){var e=new os(t),n=e.isNodeConsistentArea();return n?void(e.hasDuplicateRings()&&(this.validErr=new us(us.DUPLICATE_RINGS,e.getInvalidPoint()))):(this.validErr=new us(us.SELF_INTERSECTION,e.getInvalidPoint()),null)},isValid:function(){return this.checkValid(this.parentGeometry),null===this.validErr},checkShellInsideHole:function(t,e,n){var i=t.getCoordinates(),r=e.getCoordinates(),s=ls.findPtNotNode(i,e,n);if(null!==s){var o=he.isPointInRing(s,r);if(!o)return s}var a=ls.findPtNotNode(r,t,n);if(null!==a){var u=he.isPointInRing(a,i);return u?a:null}return f.shouldNeverReachHere("points in shell and hole appear to be equal"),null},checkNoSelfIntersectingRings:function(t){for(var e=t.getEdgeIterator();e.hasNext();){var n=e.next();if(this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()),null!==this.validErr)return null}},checkConnectedInteriors:function(t){var e=new Kr(t);e.isInteriorsConnected()||(this.validErr=new us(us.DISCONNECTED_INTERIOR,e.getCoordinate()))},checkNoSelfIntersectingRing:function(t){for(var e=new at,n=!0,i=t.iterator();i.hasNext();){var r=i.next();if(n)n=!1;else{if(e.contains(r.coord))return this.validErr=new us(us.RING_SELF_INTERSECTION,r.coord),null;e.add(r.coord)}}},checkHolesInShell:function(t,e){for(var n=t.getExteriorRing(),i=new is(n),r=0;r<t.getNumInteriorRing();r++){var s=t.getInteriorRingN(r),o=ls.findPtNotNode(s.getCoordinates(),n,e);if(null===o)return null;var a=!i.isInside(o);if(a)return this.validErr=new us(us.HOLE_OUTSIDE_SHELL,o),null}},checkTooFewPoints:function(t){return t.hasTooFewPoints()?(this.validErr=new us(us.TOO_FEW_POINTS,t.getInvalidPoint()),null):void 0},getValidationError:function(){return this.checkValid(this.parentGeometry),this.validErr},checkValid:function(){if(arguments[0]instanceof Lt){var t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Pt){var e=arguments[0];this.checkInvalidCoordinates(e.getCoordinates())}else if(arguments[0]instanceof bt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getCoordinates()),null!==this.validErr)return null;if(this.checkClosedRing(n),null!==this.validErr)return null;var i=new $n(0,n);if(this.checkTooFewPoints(i),null!==this.validErr)return null;var r=new ae;i.computeSelfNodes(r,!0,!0),this.checkNoSelfIntersectingRings(i)}else if(arguments[0]instanceof St){var s=arguments[0];if(this.checkInvalidCoordinates(s.getCoordinates()),null!==this.validErr)return null;var i=new $n(0,s);this.checkTooFewPoints(i)}else if(arguments[0]instanceof Tt){var o=arguments[0];if(this.checkInvalidCoordinates(o),null!==this.validErr)return null;if(this.checkClosedRings(o),null!==this.validErr)return null;var i=new $n(0,o);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;if(this.checkHolesInShell(o,i),null!==this.validErr)return null;if(this.checkHolesNotNested(o,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof Ot){for(var a=arguments[0],u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkInvalidCoordinates(l),null!==this.validErr)return null;if(this.checkClosedRings(l),null!==this.validErr)return null}var i=new $n(0,a);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesInShell(l,i),null!==this.validErr)return null}for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesNotNested(l,i),null!==this.validErr)return null}if(this.checkShellsNotNested(a,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof ft)for(var h=arguments[0],u=0;u<h.getNumGeometries();u++){var c=h.getGeometryN(u);if(this.checkValid(c),null!==this.validErr)return null}else if(arguments[0]instanceof B){var f=arguments[0];if(this.validErr=null,f.isEmpty())return null;if(f instanceof Lt)this.checkValid(f);else if(f instanceof Pt)this.checkValid(f);else if(f instanceof bt)this.checkValid(f);else if(f instanceof St)this.checkValid(f);else if(f instanceof Tt)this.checkValid(f);else if(f instanceof Ot)this.checkValid(f);else{if(!(f instanceof ft))throw new UnsupportedOperationException(f.getClass().getName());this.checkValid(f)}}},setSelfTouchingRingFormingHoleValid:function(t){this.isSelfTouchingRingFormingHoleValid=t},checkShellNotNested:function(t,e,n){var i=t.getCoordinates(),r=e.getExteriorRing(),s=r.getCoordinates(),o=ls.findPtNotNode(i,r,n);if(null===o)return null;var a=he.isPointInRing(o,s);if(!a)return null;if(e.getNumInteriorRing()<=0)return this.validErr=new us(us.NESTED_SHELLS,o),null;for(var u=null,l=0;l<e.getNumInteriorRing();l++){var h=e.getInteriorRingN(l);if(u=this.checkShellInsideHole(t,h,n),null===u)return null}this.validErr=new us(us.NESTED_SHELLS,u)},checkClosedRings:function(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this.validErr)return null;for(var e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this.validErr)return null},checkClosedRing:function(t){if(!t.isClosed()){var e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this.validErr=new us(us.RING_NOT_CLOSED,e)}},checkShellsNotNested:function(t,e){for(var n=0;n<t.getNumGeometries();n++)for(var i=t.getGeometryN(n),r=i.getExteriorRing(),s=0;s<t.getNumGeometries();s++)if(n!==s){var o=t.getGeometryN(s);if(this.checkShellNotNested(r,o,e),null!==this.validErr)return null}},interfaces_:function(){return[]},getClass:function(){return ls}}),ls.findPtNotNode=function(t,e,n){for(var i=n.findEdge(e),r=i.getEdgeIntersectionList(),s=0;s<t.length;s++){var o=t[s];if(!r.isIntersection(o))return o}return null},ls.isValid=function(){if(arguments[0]instanceof B){var t=arguments[0],e=new ls(t);return e.isValid()}if(arguments[0]instanceof g){var n=arguments[0];return r.isNaN(n.x)?!1:r.isInfinite(n.x)?!1:r.isNaN(n.y)?!1:!r.isInfinite(n.y)}};var bo=Object.freeze({IsValidOp:ls}),Oo=Object.freeze({BoundaryOp:dt,IsSimpleOp:Gi,buffer:Co,distance:So,linemerge:wo,overlay:Lo,polygonize:Ro,relate:To,union:Po,valid:bo});h(hs,_t.CoordinateOperation),e(hs.prototype,{editCoordinates:function(t,e){if(0===t.length)return null;for(var n=new Array(t.length).fill(null),i=0;i<t.length;i++){var r=new g(t[i]);this.targetPM.makePrecise(r),n[i]=r}var s=new N(n,!1),o=s.toCoordinateArray(),a=0;e instanceof St&&(a=2),e instanceof bt&&(a=4);var u=n;return this.removeCollapsed&&(u=null),o.length<a?u:o},interfaces_:function(){return[]},getClass:function(){return hs}}),e(cs.prototype,{fixPolygonalTopology:function(t){var e=t;this.changePrecisionModel||(e=this.changePM(t,this.targetPM));var n=e.buffer(0),i=n;return this.changePrecisionModel||(i=t.getFactory().createGeometry(n)),i},reducePointwise:function(t){var e=null;if(this.changePrecisionModel){var n=this.createFactory(t.getFactory(),this.targetPM);e=new _t(n)}else e=new _t;var i=this.removeCollapsed;t.getDimension()>=2&&(i=!0);var r=e.edit(t,new hs(this.targetPM,i));return r},changePM:function(t,e){var n=this.createEditor(t.getFactory(),e);return n.edit(t,new _t.NoOpGeometryOperation)},setRemoveCollapsedComponents:function(t){this.removeCollapsed=t},createFactory:function(t,e){var n=new ie(e,t.getSRID(),t.getCoordinateSequenceFactory());return n},setChangePrecisionModel:function(t){this.changePrecisionModel=t},reduce:function(t){var e=this.reducePointwise(t);return this.isPointwise?e:R(e,Rt)?e.isValid()?e:this.fixPolygonalTopology(e):e},setPointwise:function(t){this.isPointwise=t},createEditor:function(t,e){if(t.getPrecisionModel()===e)return new _t;var n=this.createFactory(t,e),i=new _t(n);return i},interfaces_:function(){return[]},getClass:function(){return cs}}),cs.reduce=function(t,e){var n=new cs(e);return n.reduce(t)},cs.reducePointwise=function(t,e){var n=new cs(e);return n.setPointwise(!0),n.reduce(t)};var _o=Object.freeze({GeometryPrecisionReducer:cs});e(fs.prototype,{simplifySection:function(t,e){if(t+1===e)return null;this.seg.p0=this.pts[t],this.seg.p1=this.pts[e];for(var n=-1,i=t,r=t+1;e>r;r++){var s=this.seg.distance(this.pts[r]);s>n&&(n=s,i=r)}if(n<=this.distanceTolerance)for(var r=t+1;e>r;r++)this.usePt[r]=!1;else this.simplifySection(t,i),this.simplifySection(i,e)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(){this.usePt=new Array(this.pts.length).fill(null);for(var t=0;t<this.pts.length;t++)this.usePt[t]=!0;this.simplifySection(0,this.pts.length-1);for(var e=new N,t=0;t<this.pts.length;t++)this.usePt[t]&&e.add(new g(this.pts[t]));return e.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return fs}}),fs.simplify=function(t,e){var n=new fs(t);return n.setDistanceTolerance(e),n.simplify()},e(gs.prototype,{setEnsureValid:function(t){this.isEnsureValidTopology=t},getResultGeometry:function(){return this.inputGeom.isEmpty()?this.inputGeom.copy():new ds(this.isEnsureValidTopology,this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return gs}}),gs.simplify=function(t,e){var n=new gs(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(ds,xe),e(ds.prototype,{transformPolygon:function(t,e){if(t.isEmpty())return null;var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},createValidArea:function(t){return this.isEnsureValidTopology?t.buffer(0):t},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=null;return i=0===n.length?new Array(0).fill(null):fs.simplify(n,this.distanceTolerance),this.factory.getCoordinateSequenceFactory().create(i)},transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformLinearRing:function(t,e){var n=e instanceof Tt,i=xe.prototype.transformLinearRing.call(this,t,e);return!n||i instanceof bt?i:null},interfaces_:function(){return[]},getClass:function(){return ds}}),gs.DPTransformer=ds,h(ps,ce),e(ps.prototype,{getIndex:function(){return this.index},getParent:function(){return this.parent},interfaces_:function(){return[]},getClass:function(){return ps}}),e(vs.prototype,{addToResult:function(t){this.resultSegs.add(t)},asLineString:function(){return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs))},getResultSize:function(){var t=this.resultSegs.size();return 0===t?0:t+1},getParent:function(){return this.parentLine},getSegment:function(t){return this.segs[t]},getParentCoordinates:function(){return this.parentLine.getCoordinates()},getMinimumSize:function(){return this.minimumSize},asLinearRing:function(){return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs))},getSegments:function(){return this.segs},init:function(){var t=this.parentLine.getCoordinates();this.segs=new Array(t.length-1).fill(null);for(var e=0;e<t.length-1;e++){var n=new ps(t[e],t[e+1],this.parentLine,e);this.segs[e]=n}},getResultCoordinates:function(){return vs.extractCoordinates(this.resultSegs)},interfaces_:function(){return[]},getClass:function(){return vs}}),vs.extractCoordinates=function(t){for(var e=new Array(t.size()+1).fill(null),n=null,i=0;i<t.size();i++)n=t.get(i),e[i]=n.p0;return e[e.length-1]=n.p1,e},e(ms.prototype,{remove:function(t){this.index.remove(new C(t.p0,t.p1),t)},add:function(){if(arguments[0]instanceof vs)for(var t=arguments[0],e=t.getSegments(),n=0;n<e.length;n++){var i=e[n];this.add(i)}else if(arguments[0]instanceof ce){var r=arguments[0];this.index.insert(new C(r.p0,r.p1),r)}},query:function(t){var e=new C(t.p0,t.p1),n=new ys(t);this.index.query(e,n);var i=n.getItems();return i},interfaces_:function(){return[]},getClass:function(){return ms}}),e(ys.prototype,{visitItem:function(t){var e=t;C.intersects(e.p0,e.p1,this.querySeg.p0,this.querySeg.p1)&&this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return ys}}),e(xs.prototype,{flatten:function(t,e){var n=this.linePts[t],i=this.linePts[e],r=new ce(n,i);return this.remove(this.line,t,e),this.outputIndex.add(r),r},hasBadIntersection:function(t,e,n){return this.hasBadOutputIntersection(n)?!0:!!this.hasBadInputIntersection(t,e,n)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplifySection:function(t,e,n){n+=1;var i=new Array(2).fill(null);if(t+1===e){var r=this.line.getSegment(t);return this.line.addToResult(r),null}var s=!0;if(this.line.getResultSize()<this.line.getMinimumSize()){var o=n+1;o<this.line.getMinimumSize()&&(s=!1)}var a=new Array(1).fill(null),u=this.findFurthestPoint(this.linePts,t,e,a);a[0]>this.distanceTolerance&&(s=!1);var l=new ce;if(l.p0=this.linePts[t],l.p1=this.linePts[e],i[0]=t,i[1]=e,this.hasBadIntersection(this.line,i,l)&&(s=!1),s){var r=this.flatten(t,e);return this.line.addToResult(r),null}this.simplifySection(t,u,n),this.simplifySection(u,e,n)},hasBadOutputIntersection:function(t){for(var e=this.outputIndex.query(t),n=e.iterator();n.hasNext();){var i=n.next();if(this.hasInteriorIntersection(i,t))return!0}return!1},findFurthestPoint:function(t,e,n,i){var r=new ce;r.p0=t[e],r.p1=t[n];for(var s=-1,o=e,a=e+1;n>a;a++){var u=t[a],l=r.distance(u);l>s&&(s=l,o=a)}return i[0]=s,o},simplify:function(t){this.line=t,this.linePts=t.getParentCoordinates(),this.simplifySection(0,this.linePts.length-1,0)},remove:function(t,e,n){for(var i=e;n>i;i++){var r=t.getSegment(i);this.inputIndex.remove(r)}},hasInteriorIntersection:function(t,e){return this.li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this.li.isInteriorIntersection()},hasBadInputIntersection:function(t,e,n){for(var i=this.inputIndex.query(n),r=i.iterator();r.hasNext();){var s=r.next();if(this.hasInteriorIntersection(s,n)){if(xs.isInLineSection(t,e,s))continue;return!0}}return!1},interfaces_:function(){return[]},getClass:function(){return xs}}),xs.isInLineSection=function(t,e,n){if(n.getParent()!==t.getParent())return!1;var i=n.getIndex();return i>=e[0]&&i<e[1]},e(Es.prototype,{setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(t){for(var e=t.iterator();e.hasNext();)this.inputIndex.add(e.next());for(var e=t.iterator();e.hasNext();){var n=new xs(this.inputIndex,this.outputIndex);n.setDistanceTolerance(this.distanceTolerance),n.simplify(e.next())}},interfaces_:function(){return[]},getClass:function(){return Es}}),e(Is.prototype,{getResultGeometry:function(){if(this.inputGeom.isEmpty())return this.inputGeom.copy();this.linestringMap=new te,this.inputGeom.apply(new Cs(this)),this.lineSimplifier.simplify(this.linestringMap.values());var t=new Ns(this.linestringMap).transform(this.inputGeom);return t},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.lineSimplifier.setDistanceTolerance(t)},interfaces_:function(){return[]},getClass:function(){return Is}}),Is.simplify=function(t,e){var n=new Is(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(Ns,xe),e(Ns.prototype,{transformCoordinates:function(t,e){if(0===t.size())return null;if(e instanceof St){var n=this.linestringMap.get(e);return this.createCoordinateSequence(n.getResultCoordinates())}return xe.prototype.transformCoordinates.call(this,t,e)},interfaces_:function(){return[]},getClass:function(){return Ns}}),e(Cs.prototype,{filter:function(t){if(t instanceof St){var e=t;if(e.isEmpty())return null;var n=e.isClosed()?4:2,i=new vs(e,n);this.tps.linestringMap.put(e,i)}},interfaces_:function(){return[q]},getClass:function(){return Cs}}),Is.LineStringTransformer=Ns,Is.LineStringMapBuilderFilter=Cs;var Mo=Object.freeze({DouglasPeuckerSimplifier:gs,TopologyPreservingSimplifier:Is});e(Ss.prototype,{splitAt:function(){if(1===arguments.length){var t=arguments[0],e=this.minimumLen/this.segLen;if(t.distance(this.seg.p0)<this.minimumLen)return this.splitPt=this.seg.pointAlong(e),null;if(t.distance(this.seg.p1)<this.minimumLen)return this.splitPt=Ss.pointAlongReverse(this.seg,e),null;this.splitPt=t}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.getConstrainedLength(n),s=r/this.segLen;i.equals2D(this.seg.p0)?this.splitPt=this.seg.pointAlong(s):this.splitPt=Ss.pointAlongReverse(this.seg,s)}},setMinimumLength:function(t){this.minimumLen=t},getConstrainedLength:function(t){return t<this.minimumLen?this.minimumLen:t},getSplitPoint:function(){return this.splitPt},interfaces_:function(){return[]},getClass:function(){return Ss}}),Ss.pointAlongReverse=function(t,e){var n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n},e(ws.prototype,{findSplitPoint:function(t,e){},interfaces_:function(){return[]},getClass:function(){return ws}}),e(Ls.prototype,{findSplitPoint:function(t,e){var n=t.getLineSegment(),i=n.getLength(),r=i/2,s=new Ss(n),o=Ls.projectedSplitPoint(t,e),a=2*o.distance(e)*.8,u=a;return u>r&&(u=r),s.setMinimumLength(u),s.splitAt(o),s.getSplitPoint()},interfaces_:function(){return[ws]},getClass:function(){return Ls}}),Ls.projectedSplitPoint=function(t,e){var n=t.getLineSegment(),i=n.project(e);return i},e(Rs.prototype,{interfaces_:function(){return[]},getClass:function(){return Rs}}),Rs.triArea=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)},Rs.isInCircleDDNormalized=function(t,e,n,i){var r=_.valueOf(t.x).selfSubtract(i.x),s=_.valueOf(t.y).selfSubtract(i.y),o=_.valueOf(e.x).selfSubtract(i.x),a=_.valueOf(e.y).selfSubtract(i.y),u=_.valueOf(n.x).selfSubtract(i.x),l=_.valueOf(n.y).selfSubtract(i.y),h=r.multiply(a).selfSubtract(o.multiply(s)),c=o.multiply(l).selfSubtract(u.multiply(a)),f=u.multiply(s).selfSubtract(r.multiply(l)),g=r.multiply(r).selfAdd(s.multiply(s)),d=o.multiply(o).selfAdd(a.multiply(a)),p=u.multiply(u).selfAdd(l.multiply(l)),v=g.selfMultiply(c).selfAdd(d.selfMultiply(f)).selfAdd(p.selfMultiply(h)),m=v.doubleValue()>0;return m},Rs.checkRobustInCircle=function(t,e,n,i){var r=Rs.isInCircleNonRobust(t,e,n,i),s=Rs.isInCircleDDSlow(t,e,n,i),o=Rs.isInCircleCC(t,e,n,i),a=ci.circumcentre(t,e,n);A.out.println("p radius diff a = "+Math.abs(i.distance(a)-t.distance(a))/t.distance(a)),r===s&&r===o||(A.out.println("inCircle robustness failure (double result = "+r+", DD result = "+s+", CC result = "+o+")"),A.out.println(se.toLineString(new Gt([t,e,n,i]))),A.out.println("Circumcentre = "+se.toPoint(a)+" radius = "+t.distance(a)),A.out.println("p radius diff a = "+Math.abs(i.distance(a)/t.distance(a)-1)),A.out.println("p radius diff b = "+Math.abs(i.distance(a)/e.distance(a)-1)),A.out.println("p radius diff c = "+Math.abs(i.distance(a)/n.distance(a)-1)),A.out.println())},Rs.isInCircleDDFast=function(t,e,n,i){var r=_.sqr(t.x).selfAdd(_.sqr(t.y)).selfMultiply(Rs.triAreaDDFast(e,n,i)),s=_.sqr(e.x).selfAdd(_.sqr(e.y)).selfMultiply(Rs.triAreaDDFast(t,n,i)),o=_.sqr(n.x).selfAdd(_.sqr(n.y)).selfMultiply(Rs.triAreaDDFast(t,e,i)),a=_.sqr(i.x).selfAdd(_.sqr(i.y)).selfMultiply(Rs.triAreaDDFast(t,e,n)),u=r.selfSubtract(s).selfAdd(o).selfSubtract(a),l=u.doubleValue()>0;return l},Rs.isInCircleCC=function(t,e,n,i){var r=ci.circumcentre(t,e,n),s=t.distance(r),o=i.distance(r)-s;return 0>=o},Rs.isInCircleNormalized=function(t,e,n,i){var r=t.x-i.x,s=t.y-i.y,o=e.x-i.x,a=e.y-i.y,u=n.x-i.x,l=n.y-i.y,h=r*a-o*s,c=o*l-u*a,f=u*s-r*l,g=r*r+s*s,d=o*o+a*a,p=u*u+l*l,v=g*c+d*f+p*h;return v>0},Rs.isInCircleDDSlow=function(t,e,n,i){var r=_.valueOf(i.x),s=_.valueOf(i.y),o=_.valueOf(t.x),a=_.valueOf(t.y),u=_.valueOf(e.x),l=_.valueOf(e.y),h=_.valueOf(n.x),c=_.valueOf(n.y),f=o.multiply(o).add(a.multiply(a)).multiply(Rs.triAreaDDSlow(u,l,h,c,r,s)),g=u.multiply(u).add(l.multiply(l)).multiply(Rs.triAreaDDSlow(o,a,h,c,r,s)),d=h.multiply(h).add(c.multiply(c)).multiply(Rs.triAreaDDSlow(o,a,u,l,r,s)),p=r.multiply(r).add(s.multiply(s)).multiply(Rs.triAreaDDSlow(o,a,u,l,h,c)),v=f.subtract(g).add(d).subtract(p),m=v.doubleValue()>0;
return m},Rs.isInCircleNonRobust=function(t,e,n,i){var r=(t.x*t.x+t.y*t.y)*Rs.triArea(e,n,i)-(e.x*e.x+e.y*e.y)*Rs.triArea(t,n,i)+(n.x*n.x+n.y*n.y)*Rs.triArea(t,e,i)-(i.x*i.x+i.y*i.y)*Rs.triArea(t,e,n)>0;return r},Rs.isInCircleRobust=function(t,e,n,i){return Rs.isInCircleNormalized(t,e,n,i)},Rs.triAreaDDSlow=function(t,e,n,i,r,s){return n.subtract(t).multiply(s.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)))},Rs.triAreaDDFast=function(t,e,n){var i=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(n.y).selfSubtract(t.y)),r=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(n.x).selfSubtract(t.x));return i.selfSubtract(r)},e(Ts.prototype,{circleCenter:function(t,e){var n=new Ts(this.getX(),this.getY()),i=this.bisector(n,t),r=this.bisector(t,e),s=new F(i,r),o=null;try{o=new Ts(s.getX(),s.getY())}catch(i){if(!(i instanceof w))throw i;A.err.println("a: "+n+"  b: "+t+"  c: "+e),A.err.println(i)}finally{}return o},dot:function(t){return this.p.x*t.getX()+this.p.y*t.getY()},magn:function(){return Math.sqrt(this.p.x*this.p.x+this.p.y*this.p.y)},getZ:function(){return this.p.z},bisector:function(t,e){var n=e.getX()-t.getX(),i=e.getY()-t.getY(),r=new F(t.getX()+n/2,t.getY()+i/2,1),s=new F(t.getX()-i+n/2,t.getY()+n+i/2,1);return new F(r,s)},equals:function(){if(1===arguments.length){var t=arguments[0];return this.p.x===t.getX()&&this.p.y===t.getY()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.p.distance(e.getCoordinate())<n}},getCoordinate:function(){return this.p},isInCircle:function(t,e,n){return Rs.isInCircleRobust(t.p,e.p,n.p,this.p)},interpolateZValue:function(t,e,n){var i=t.getX(),r=t.getY(),s=e.getX()-i,o=n.getX()-i,a=e.getY()-r,u=n.getY()-r,l=s*u-o*a,h=this.getX()-i,c=this.getY()-r,f=(u*h-o*c)/l,g=(-a*h+s*c)/l,d=t.getZ()+f*(e.getZ()-t.getZ())+g*(n.getZ()-t.getZ());return d},midPoint:function(t){var e=(this.p.x+t.getX())/2,n=(this.p.y+t.getY())/2,i=(this.p.z+t.getZ())/2;return new Ts(e,n,i)},rightOf:function(t){return this.isCCW(t.dest(),t.orig())},isCCW:function(t,e){return(t.p.x-this.p.x)*(e.p.y-this.p.y)-(t.p.y-this.p.y)*(e.p.x-this.p.x)>0},getX:function(){return this.p.x},crossProduct:function(t){return this.p.x*t.getY()-this.p.y*t.getX()},setZ:function(t){this.p.z=t},times:function(t){return new Ts(t*this.p.x,t*this.p.y)},cross:function(){return new Ts(this.p.y,-this.p.x)},leftOf:function(t){return this.isCCW(t.orig(),t.dest())},toString:function(){return"POINT ("+this.p.x+" "+this.p.y+")"},sub:function(t){return new Ts(this.p.x-t.getX(),this.p.y-t.getY())},getY:function(){return this.p.y},classify:function(t,e){var n=this,i=e.sub(t),r=n.sub(t),s=i.crossProduct(r);return s>0?Ts.LEFT:0>s?Ts.RIGHT:i.getX()*r.getX()<0||i.getY()*r.getY()<0?Ts.BEHIND:i.magn()<r.magn()?Ts.BEYOND:t.equals(n)?Ts.ORIGIN:e.equals(n)?Ts.DESTINATION:Ts.BETWEEN},sum:function(t){return new Ts(this.p.x+t.getX(),this.p.y+t.getY())},distance:function(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))},circumRadiusRatio:function(t,e){var n=this.circleCenter(t,e),i=this.distance(n,t),r=this.distance(this,t),s=this.distance(t,e);return r>s&&(r=s),s=this.distance(e,this),r>s&&(r=s),i/r},interfaces_:function(){return[]},getClass:function(){return Ts}}),Ts.interpolateZ=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=e.distance(n),r=t.distance(e),s=n.z-e.z,o=e.z+s*(r/i);return o}if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3],c=u.x,f=u.y,g=l.x-c,d=h.x-c,p=l.y-f,v=h.y-f,m=g*v-d*p,y=a.x-c,x=a.y-f,E=(v*y-d*x)/m,I=(-p*y+g*x)/m,N=u.z+E*(l.z-u.z)+I*(h.z-u.z);return N}},Ts.LEFT=0,Ts.RIGHT=1,Ts.BEYOND=2,Ts.BEHIND=3,Ts.BETWEEN=4,Ts.ORIGIN=5,Ts.DESTINATION=6,h(Ps,Ts),e(Ps.prototype,{getConstraint:function(){return this.constraint},setOnConstraint:function(t){this._isOnConstraint=t},merge:function(t){t._isOnConstraint&&(this._isOnConstraint=!0,this.constraint=t.constraint)},isOnConstraint:function(){return this._isOnConstraint},setConstraint:function(t){this._isOnConstraint=!0,this.constraint=t},interfaces_:function(){return[]},getClass:function(){return Ps}}),e(bs.prototype,{equalsNonOriented:function(t){return this.equalsOriented(t)?!0:!!this.equalsOriented(t.sym())},toLineSegment:function(){return new ce(this.vertex.getCoordinate(),this.dest().getCoordinate())},dest:function(){return this.sym().orig()},oNext:function(){return this.next},equalsOriented:function(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))},dNext:function(){return this.sym().oNext().sym()},lPrev:function(){return this.next.sym()},rPrev:function(){return this.sym().oNext()},rot:function(){return this._rot},oPrev:function(){return this._rot.next._rot},sym:function(){return this._rot._rot},setOrig:function(t){this.vertex=t},lNext:function(){return this.invRot().oNext().rot()},getLength:function(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())},invRot:function(){return this._rot.sym()},setDest:function(t){this.sym().setOrig(t)},setData:function(t){this.data=t},getData:function(){return this.data},delete:function(){this._rot=null},orig:function(){return this.vertex},rNext:function(){return this._rot.next.invRot()},toString:function(){var t=this.vertex.getCoordinate(),e=this.dest().getCoordinate();return se.toLineString(t,e)},isLive:function(){return null!==this._rot},getPrimary:function(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()},dPrev:function(){return this.invRot().oNext().invRot()},setNext:function(t){this.next=t},interfaces_:function(){return[]},getClass:function(){return bs}}),bs.makeEdge=function(t,e){var n=new bs,i=new bs,r=new bs,s=new bs;n._rot=i,i._rot=r,r._rot=s,s._rot=n,n.setNext(n),i.setNext(s),r.setNext(r),s.setNext(i);var o=n;return o.setOrig(t),o.setDest(e),o},bs.swap=function(t){var e=t.oPrev(),n=t.sym().oPrev();bs.splice(t,e),bs.splice(t.sym(),n),bs.splice(t,e.lNext()),bs.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())},bs.splice=function(t,e){var n=t.oNext().rot(),i=e.oNext().rot(),r=e.oNext(),s=t.oNext(),o=i.oNext(),a=n.oNext();t.setNext(r),e.setNext(s),n.setNext(o),i.setNext(a)},bs.connect=function(t,e){var n=bs.makeEdge(t.dest(),e.orig());return bs.splice(n,t.lNext()),bs.splice(n.sym(),e),n},e(Os.prototype,{insertSite:function(t){var e=this.subdiv.locate(t);if(this.subdiv.isVertexOfEdge(e,t))return e;this.subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this.subdiv.delete(e.oNext()));var n=this.subdiv.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.subdiv.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);for(;;){var r=e.oPrev();if(r.dest().rightOf(e)&&t.isInCircle(e.orig(),r.dest(),e.dest()))bs.swap(e),e=e.oPrev();else{if(e.oNext()===i)return n;e=e.oNext().lPrev()}}},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},interfaces_:function(){return[]},getClass:function(){return Os}}),e(_s.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return _s}}),e(Ms.prototype,{init:function(){this.lastEdge=this.findEdge()},locate:function(t){this.lastEdge.isLive()||this.init();var e=this.subdiv.locateFromEdge(t,this.lastEdge);return this.lastEdge=e,e},findEdge:function(){var t=this.subdiv.getEdges();return t.iterator().next()},interfaces_:function(){return[_s]},getClass:function(){return Ms}}),h(Ds,l),e(Ds.prototype,{getSegment:function(){return this.seg},interfaces_:function(){return[]},getClass:function(){return Ds}}),Ds.msgWithSpatial=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(As.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return As}}),e(Fs.prototype,{getTriangleVertices:function(t){var e=new Bs;return this.visitTriangles(e,t),e.getTriangleVertices()},isFrameVertex:function(t){return t.equals(this.frameVertex[0])?!0:t.equals(this.frameVertex[1])?!0:!!t.equals(this.frameVertex[2])},isVertexOfEdge:function(t,e){return!(!e.equals(t.orig(),this.tolerance)&&!e.equals(t.dest(),this.tolerance))},connect:function(t,e){var n=bs.connect(t,e);return this.quadEdges.add(n),n},getVoronoiCellPolygon:function(t,e){var n=new I,i=t;do{var r=t.rot().orig().getCoordinate();n.add(r),t=t.oPrev()}while(t!==i);var s=new N;s.addAll(n,!1),s.closeRing(),s.size()<4&&(A.out.println(s),s.add(s.get(s.size()-1),!0));var o=s.toCoordinateArray(),a=e.createPolygon(e.createLinearRing(o),null),u=i.orig();return a.setUserData(u.getCoordinate()),a},setLocator:function(t){this.locator=t},initSubdiv:function(){var t=this.makeEdge(this.frameVertex[0],this.frameVertex[1]),e=this.makeEdge(this.frameVertex[1],this.frameVertex[2]);bs.splice(t.sym(),e);var n=this.makeEdge(this.frameVertex[2],this.frameVertex[0]);return bs.splice(e.sym(),n),bs.splice(n.sym(),t),t},isFrameBorderEdge:function(t){var e=new Array(3).fill(null);Fs.getTriangleEdges(t,e);var n=new Array(3).fill(null);Fs.getTriangleEdges(t.sym(),n);var i=t.lNext().dest();if(this.isFrameVertex(i))return!0;var r=t.sym().lNext().dest();return!!this.isFrameVertex(r)},makeEdge:function(t,e){var n=bs.makeEdge(t,e);return this.quadEdges.add(n),n},visitTriangles:function(t,e){this.visitedKey++;var n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=this.fetchTriangleToVisit(r,n,e,i);null!==s&&t.visit(s)}}},isFrameEdge:function(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))},isOnEdge:function(t,e){this.seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());var n=this.seg.distance(e);return n<this.edgeCoincidenceTolerance},getEnvelope:function(){return new C(this.frameEnv)},createFrame:function(t){var e=t.getWidth(),n=t.getHeight(),i=0;i=e>n?10*e:10*n,this.frameVertex[0]=new Ts((t.getMaxX()+t.getMinX())/2,t.getMaxY()+i),this.frameVertex[1]=new Ts(t.getMinX()-i,t.getMinY()-i),this.frameVertex[2]=new Ts(t.getMaxX()+i,t.getMinY()-i),this.frameEnv=new C(this.frameVertex[0].getCoordinate(),this.frameVertex[1].getCoordinate()),this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())},getTriangleCoordinates:function(t){var e=new zs;return this.visitTriangles(e,t),e.getTriangles()},getVertices:function(t){for(var e=new J,n=this.quadEdges.iterator();n.hasNext();){var i=n.next(),r=i.orig();!t&&this.isFrameVertex(r)||e.add(r);var s=i.dest();!t&&this.isFrameVertex(s)||e.add(s)}return e},fetchTriangleToVisit:function(t,e,n,i){var r=t,s=0,o=!1;do{this.triEdges[s]=r,this.isFrameEdge(r)&&(o=!0);var a=r.sym();i.contains(a)||e.push(a),i.add(r),s++,r=r.lNext()}while(r!==t);return o&&!n?null:this.triEdges},getEdges:function(){if(0===arguments.length)return this.quadEdges;if(1===arguments.length){for(var t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createLineString([s.orig().getCoordinate(),s.dest().getCoordinate()])}return t.createMultiLineString(n)}},getVertexUniqueEdges:function(t){for(var e=new I,n=new J,i=this.quadEdges.iterator();i.hasNext();){var r=i.next(),s=r.orig();n.contains(s)||(n.add(s),!t&&this.isFrameVertex(s)||e.add(r));var o=r.sym(),a=o.orig();n.contains(a)||(n.add(a),!t&&this.isFrameVertex(a)||e.add(o))}return e},getTriangleEdges:function(t){var e=new qs;return this.visitTriangles(e,t),e.getTriangleEdges()},getPrimaryEdges:function(t){this.visitedKey++;var e=new I,n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=r.getPrimary();!t&&this.isFrameEdge(s)||e.add(s),n.push(r.oNext()),n.push(r.sym().oNext()),i.add(r),i.add(r.sym())}}return e},delete:function(t){bs.splice(t,t.oPrev()),bs.splice(t.sym(),t.sym().oPrev());var e=t.sym(),n=t.rot(),i=t.rot().sym();this.quadEdges.remove(t),this.quadEdges.remove(e),this.quadEdges.remove(n),this.quadEdges.remove(i),t.delete(),e.delete(),n.delete(),i.delete()},locateFromEdge:function(t,e){for(var n=0,i=this.quadEdges.size(),r=e;;){if(n++,n>i)throw new Ds(r.toLineSegment());if(t.equals(r.orig())||t.equals(r.dest()))break;if(t.rightOf(r))r=r.sym();else if(t.rightOf(r.oNext())){if(t.rightOf(r.dPrev()))break;r=r.dPrev()}else r=r.oNext()}return r},getTolerance:function(){return this.tolerance},getVoronoiCellPolygons:function(t){this.visitTriangles(new Gs,!0);for(var e=new I,n=this.getVertexUniqueEdges(!1),i=n.iterator();i.hasNext();){var r=i.next();e.add(this.getVoronoiCellPolygon(r,t))}return e},getVoronoiDiagram:function(t){var e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(ie.toGeometryArray(e))},getTriangles:function(t){for(var e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createPolygon(t.createLinearRing(s),null)}return t.createGeometryCollection(n)},insertSite:function(t){var e=this.locate(t);if(t.equals(e.orig(),this.tolerance)||t.equals(e.dest(),this.tolerance))return e;var n=this.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);return i},locate:function(){if(1===arguments.length){if(arguments[0]instanceof Ts){var t=arguments[0];return this.locator.locate(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.locator.locate(new Ts(e))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.locator.locate(new Ts(n));if(null===r)return null;var s=r;r.dest().getCoordinate().equals2D(n)&&(s=r.sym());var o=s;do{if(o.dest().getCoordinate().equals2D(i))return o;o=o.oNext()}while(o!==s);return null}},interfaces_:function(){return[]},getClass:function(){return Fs}}),Fs.getTriangleEdges=function(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new i("Edges do not form a triangle")},e(Gs.prototype,{visit:function(t){for(var e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),i=t[2].orig().getCoordinate(),r=ci.circumcentre(e,n,i),s=new Ts(r),o=0;3>o;o++)t[o].rot().setOrig(s)},interfaces_:function(){return[As]},getClass:function(){return Gs}}),e(qs.prototype,{getTriangleEdges:function(){return this.triList},visit:function(t){this.triList.add(t.clone())},interfaces_:function(){return[As]},getClass:function(){return qs}}),e(Bs.prototype,{visit:function(t){this.triList.add([t[0].orig(),t[1].orig(),t[2].orig()])},getTriangleVertices:function(){return this.triList},interfaces_:function(){return[As]},getClass:function(){return Bs}}),e(zs.prototype,{checkTriangleSize:function(t){var e="";t.length>=2?e=se.toLineString(t[0],t[1]):t.length>=1&&(e=se.toPoint(t[0]))},visit:function(t){this.coordList.clear();for(var e=0;3>e;e++){var n=t[e].orig();this.coordList.add(n.getCoordinate())}if(this.coordList.size()>0){this.coordList.closeRing();var i=this.coordList.toCoordinateArray();if(4!==i.length)return null;this.triCoords.add(i)}},getTriangles:function(){return this.triCoords},interfaces_:function(){return[As]},getClass:function(){return zs}}),Fs.TriangleCircumcentreVisitor=Gs,Fs.TriangleEdgesListVisitor=qs,Fs.TriangleVertexListVisitor=Bs,Fs.TriangleCoordinatesVisitor=zs,Fs.EDGE_COINCIDENCE_TOL_FACTOR=1e3,e(Vs.prototype,{getLineSegment:function(){return this.ls},getEndZ:function(){var t=this.ls.getCoordinate(1);return t.z},getStartZ:function(){var t=this.ls.getCoordinate(0);return t.z},intersection:function(t){return this.ls.intersection(t.getLineSegment())},getStart:function(){return this.ls.getCoordinate(0)},getEnd:function(){return this.ls.getCoordinate(1)},getEndY:function(){var t=this.ls.getCoordinate(1);return t.y},getStartX:function(){var t=this.ls.getCoordinate(0);return t.x},equalsTopo:function(t){return this.ls.equalsTopo(t.getLineSegment())},getStartY:function(){var t=this.ls.getCoordinate(0);return t.y},setData:function(t){this.data=t},getData:function(){return this.data},getEndX:function(){var t=this.ls.getCoordinate(1);return t.x},toString:function(){return this.ls.toString()},interfaces_:function(){return[]},getClass:function(){return Vs}}),e(ks.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return ks}}),e(Ys.prototype,{isRepeated:function(){return this.count>1},getRight:function(){return this.right},getCoordinate:function(){return this.p},setLeft:function(t){this.left=t},getX:function(){return this.p.x},getData:function(){return this.data},getCount:function(){return this.count},getLeft:function(){return this.left},getY:function(){return this.p.y},increment:function(){this.count=this.count+1},setRight:function(t){this.right=t},interfaces_:function(){return[]},getClass:function(){return Ys}}),e(Us.prototype,{insert:function(){if(1===arguments.length){var t=arguments[0];return this.insert(t,null)}if(2===arguments.length){var e=arguments[0],n=arguments[1];if(null===this.root)return this.root=new Ys(e,n),this.root;if(this.tolerance>0){var i=this.findBestMatchNode(e);if(null!==i)return i.increment(),i}return this.insertExact(e,n)}},query:function(){var t=arguments,e=this;if(1===arguments.length){var n=arguments[0],i=new I;return this.query(n,i),i}if(2===arguments.length)if(arguments[0]instanceof C&&R(arguments[1],y))!function(){var n=t[0],i=t[1];e.queryNode(e.root,n,!0,{interfaces_:function(){return[ks]},visit:function(t){i.add(t)}})}();else if(arguments[0]instanceof C&&R(arguments[1],ks)){var r=arguments[0],s=arguments[1];this.queryNode(this.root,r,!0,s)}},queryNode:function(t,e,n,i){if(null===t)return null;var r=null,s=null,o=null;n?(r=e.getMinX(),s=e.getMaxX(),o=t.getX()):(r=e.getMinY(),s=e.getMaxY(),o=t.getY());var a=o>r,u=s>=o;a&&this.queryNode(t.getLeft(),e,!n,i),e.contains(t.getCoordinate())&&i.visit(t),u&&this.queryNode(t.getRight(),e,!n,i)},findBestMatchNode:function(t){var e=new Xs(t,this.tolerance);return this.query(e.queryEnvelope(),e),e.getNode()},isEmpty:function(){return null===this.root},insertExact:function(t,e){for(var n=this.root,i=this.root,r=!0,s=!0;null!==n;){if(null!==n){var o=t.distance(n.getCoordinate())<=this.tolerance;if(o)return n.increment(),n}s=r?t.x<n.getX():t.y<n.getY(),i=n,n=s?n.getLeft():n.getRight(),r=!r}this.numberOfNodes=this.numberOfNodes+1;var a=new Ys(t,e);return s?i.setLeft(a):i.setRight(a),a},interfaces_:function(){return[]},getClass:function(){return Us}}),Us.toCoordinates=function(){if(1===arguments.length){var t=arguments[0];return Us.toCoordinates(t,!1)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new N,r=e.iterator();r.hasNext();)for(var s=r.next(),o=n?s.getCount():1,a=0;o>a;a++)i.add(s.getCoordinate(),!0);return i.toCoordinateArray()}},e(Xs.prototype,{visit:function(t){var e=this.p.distance(t.getCoordinate()),n=e<=this.tolerance;if(!n)return null;var i=!1;(null===this.matchNode||e<this.matchDist||null!==this.matchNode&&e===this.matchDist&&t.getCoordinate().compareTo(this.matchNode.getCoordinate())<1)&&(i=!0),i&&(this.matchNode=t,this.matchDist=e)},queryEnvelope:function(){var t=new C(this.p);return t.expandBy(this.tolerance),t},getNode:function(){return this.matchNode},interfaces_:function(){return[ks]},getClass:function(){return Xs}}),Us.BestMatchVisitor=Xs,e(Hs.prototype,{getInitialVertices:function(){return this.initialVertices},getKDT:function(){return this.kdt},enforceConstraints:function(){this.addConstraintVertices();var t=0,e=0;do e=this.enforceGabriel(this.segments),t++;while(e>0&&t<Hs.MAX_SPLIT_ITER)},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},getVertexFactory:function(){return this.vertexFactory},getPointArray:function(){for(var t=new Array(this.initialVertices.size()+this.segVertices.size()).fill(null),e=0,n=this.initialVertices.iterator();n.hasNext();){var i=n.next();t[e++]=i.getCoordinate()}for(var r=this.segVertices.iterator();r.hasNext();){var i=r.next();t[e++]=i.getCoordinate()}return t},setConstraints:function(t,e){this.segments=t,this.segVertices=e},computeConvexHull:function(){var t=new ie,e=this.getPointArray(),n=new me(e,t);this.convexHull=n.getConvexHull()},addConstraintVertices:function(){this.computeConvexHull(),this.insertSites(this.segVertices)},findNonGabrielPoint:function(t){var e=t.getStart(),n=t.getEnd(),i=new g((e.x+n.x)/2,(e.y+n.y)/2),s=e.distance(i),o=new C(i);o.expandBy(s);for(var a=this.kdt.query(o),u=null,l=r.MAX_VALUE,h=a.iterator();h.hasNext();){var c=h.next(),f=c.getCoordinate();if(!f.equals2D(e)&&!f.equals2D(n)){var d=i.distance(f);if(s>d){var p=d;(null===u||l>p)&&(u=f,l=p)}}}return u},getConstraintSegments:function(){return this.segments},setSplitPointFinder:function(t){this.splitFinder=t},getConvexHull:function(){return this.convexHull},getTolerance:function(){return this.tolerance},enforceGabriel:function(t){for(var e=new I,n=0,i=new I,r=t.iterator();r.hasNext();){var s=r.next(),o=this.findNonGabrielPoint(s);if(null!==o){this.splitPt=this.splitFinder.findSplitPoint(s,o);var a=this.createVertex(this.splitPt,s),u=(this.insertSite(a),new Vs(s.getStartX(),s.getStartY(),s.getStartZ(),a.getX(),a.getY(),a.getZ(),s.getData())),l=new Vs(a.getX(),a.getY(),a.getZ(),s.getEndX(),s.getEndY(),s.getEndZ(),s.getData());e.add(u),e.add(l),i.add(s),n+=1}}return t.removeAll(i),t.addAll(e),n},createVertex:function(){if(1===arguments.length){var t=arguments[0],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(t,null):new Ps(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(n,i):new Ps(n),e.setOnConstraint(!0),e}},getSubdivision:function(){return this.subdiv},computeBoundingBox:function(){var t=Hs.computeVertexEnvelope(this.initialVertices),e=Hs.computeVertexEnvelope(this.segVertices),n=new C(t);n.expandToInclude(e);var i=.2*n.getWidth(),r=.2*n.getHeight(),s=Math.max(i,r);this.computeAreaEnv=new C(n),this.computeAreaEnv.expandBy(s)},setVertexFactory:function(t){this.vertexFactory=t},formInitialDelaunay:function(){this.computeBoundingBox(),this.subdiv=new Fs(this.computeAreaEnv,this.tolerance),this.subdiv.setLocator(new Ms(this.subdiv)),this.incDel=new Os(this.subdiv),this.insertSites(this.initialVertices)},insertSite:function(){if(arguments[0]instanceof Ps){var t=arguments[0],e=this.kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){var n=e.getData();return n.merge(t),n}return this.incDel.insertSite(t),t}if(arguments[0]instanceof g){var i=arguments[0];this.insertSite(this.createVertex(i))}},interfaces_:function(){return[]},getClass:function(){return Hs}}),Hs.computeVertexEnvelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i.getCoordinate())}return e},Hs.MAX_SPLIT_ITER=99,e(Ws.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var n=new Os(this.subdiv);n.insertSites(e)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},interfaces_:function(){return[]},getClass:function(){return Ws}}),Ws.extractUniqueCoordinates=function(t){if(null===t)return new N;var e=t.getCoordinates();return Ws.unique(e)},Ws.envelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i)}return e},Ws.unique=function(t){var e=H.copyDeep(t);ut.sort(e);var n=new N(e,!1);return n},Ws.toVertices=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ts(i))}return e},e(js.prototype,{createSiteVertices:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();this.constraintVertexMap.containsKey(i)||e.add(new Ps(i))}return e},create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=new I;null!==this.constraintLines&&(t.expandToInclude(this.constraintLines.getEnvelopeInternal()),this.createVertices(this.constraintLines),e=js.createConstraintSegments(this.constraintLines));var n=this.createSiteVertices(this.siteCoords),i=new Hs(n,this.tolerance);i.setConstraints(e,new I(this.constraintVertexMap.values())),i.formInitialDelaunay(),i.enforceConstraints(),this.subdiv=i.getSubdivision()},setTolerance:function(t){this.tolerance=t},setConstraints:function(t){this.constraintLines=t},setSites:function(t){this.siteCoords=Ws.extractUniqueCoordinates(t)},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},createVertices:function(t){for(var e=t.getCoordinates(),n=0;n<e.length;n++){var i=new Ps(e[n]);this.constraintVertexMap.put(e[n],i)}},interfaces_:function(){return[]},getClass:function(){return js}}),js.createConstraintSegments=function(){if(1===arguments.length){for(var t=arguments[0],e=kn.getLines(t),n=new I,i=e.iterator();i.hasNext();){var r=i.next();js.createConstraintSegments(r,n)}return n}if(2===arguments.length)for(var s=arguments[0],o=arguments[1],a=s.getCoordinates(),i=1;i<a.length;i++)o.add(new Vs(a[i-1],a[i]))},e(Ks.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords);this.diagramEnv=t;var e=Math.max(this.diagramEnv.getWidth(),this.diagramEnv.getHeight());this.diagramEnv.expandBy(e),null!==this.clipEnv&&this.diagramEnv.expandToInclude(this.clipEnv);var n=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var i=new Os(this.subdiv);i.insertSites(n)},getDiagram:function(t){this.create();var e=this.subdiv.getVoronoiDiagram(t);return Ks.clipGeometryCollection(e,this.diagramEnv)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},setClipEnvelope:function(t){this.clipEnv=t},getSubdivision:function(){return this.create(),this.subdiv},interfaces_:function(){return[]},getClass:function(){return Ks}}),Ks.clipGeometryCollection=function(t,e){for(var n=t.getFactory().toGeometry(e),i=new I,r=0;r<t.getNumGeometries();r++){var s=t.getGeometryN(r),o=null;e.contains(s.getEnvelopeInternal())?o=s:e.intersects(s.getEnvelopeInternal())&&(o=n.intersection(s),o.setUserData(s.getUserData())),null===o||o.isEmpty()||i.add(o)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(i))};var Do=Object.freeze({ConformingDelaunayTriangulationBuilder:js,DelaunayTriangulationBuilder:Ws,VoronoiDiagramBuilder:Ks});e(Zs.prototype,{interfaces_:function(){return[]},getClass:function(){return Zs}}),Zs.union=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.UNION)},e(B.prototype,{equalsTopo:function(t){return this.getEnvelopeInternal().equals(t.getEnvelopeInternal())?Yr.relate(this,t).isEquals(this.getDimension(),t.getDimension()):!1},union:function(){if(0===arguments.length)return jr.union(this);if(1===arguments.length){var t=arguments[0];return Zs.union(this,t)}},isValid:function(){return ls.isValid(this)},intersection:function(t){if(this.isEmpty()||t.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,this,t,this.factory);if(this.isGeometryCollection()){var e=t;return hn.map(this,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(e)}})}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.INTERSECTION)},covers:function(t){return Yr.covers(this,t)},coveredBy:function(t){return Yr.coveredBy(this,t)},touches:function(t){return Yr.touches(this,t)},intersects:function(t){return Yr.intersects(this,t)},within:function(t){return Yr.within(this,t)},overlaps:function(t){return Yr.overlaps(this,t)},disjoint:function(t){return Yr.disjoint(this,t)},crosses:function(t){return Yr.crosses(this,t)},buffer:function(){if(1===arguments.length){var t=arguments[0];return sr.bufferOp(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return sr.bufferOp(this,e,n)}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];return sr.bufferOp(this,i,r,s)}},convexHull:function(){return new me(this).getConvexHull()},relate:function(){for(var t=arguments.length,e=Array(t),n=0;t>n;n++)e[n]=arguments[n];return Yr.relate.apply(Yr,[this].concat(e))},getCentroid:function(){if(this.isEmpty())return this.factory.createPoint();var t=ge.getCentroid(this);return this.createPointFromInternalCoord(t,this)},getInteriorPoint:function(){if(this.isEmpty())return this.factory.createPoint();var t=null,e=this.getDimension();if(0===e){var n=new li(this);t=n.getInteriorPoint()}else if(1===e){var n=new ui(this);t=n.getInteriorPoint()}else{var n=new oi(this);t=n.getInteriorPoint()}return this.createPointFromInternalCoord(t,this)},symDifference:function(t){if(this.isEmpty()||t.isEmpty()){if(this.isEmpty()&&t.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,this,t,this.factory);if(this.isEmpty())return t.copy();if(t.isEmpty())return this.copy()}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.SYMDIFFERENCE)},createPointFromInternalCoord:function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},toText:function(){var t=new se;return t.write(this)},toString:function(){this.toText()},contains:function(t){return Yr.contains(this,t)},difference:function(t){return this.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,this,t,this.factory):t.isEmpty()?this.copy():(this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.DIFFERENCE))},isSimple:function(){var t=new Gi(this);return t.isSimple()},isWithinDistance:function(t,e){var n=this.getEnvelopeInternal().distance(t.getEnvelopeInternal());return n>e?!1:hr.isWithinDistance(this,t,e)},distance:function(t){return hr.distance(this,t)},isEquivalentClass:function(t){return this.getClass()===t.getClass()}});var Ao="1.1.2 (248dab8)";t.version=Ao,t.algorithm=co,t.densify=fo,t.dissolve=go,t.geom=lo,t.index=mo,t.io=Io,t.noding=No,t.operation=Oo,t.precision=_o,t.simplify=Mo,t.triangulate=Do});

},{}],12:[function(require,module,exports){
'use strict';
(function (factory, window) {
    /*globals define, module, require*/

    // define an AMD module that relies on 'leaflet'
    if (typeof define === 'function' && define.amd) {
        define(['leaflet'], factory);


    // define a Common JS module that relies on 'leaflet'
    } else if (typeof exports === 'object') {
        module.exports = factory(require('leaflet'));
    }

    // attach your plugin to the global 'L' variable
    if(typeof window !== 'undefined' && window.L){
        factory(window.L);
    }

}(function (L) {
    L.Editable = L.Evented.extend({

        statics: {
            FORWARD: 1,
            BACKWARD: -1
        },

        options: {
            zIndex: 1000,
            polygonClass: L.Polygon,
            polylineClass: L.Polyline,
            markerClass: L.Marker,
            rectangleClass: L.Rectangle,
            circleClass: L.Circle,
            drawingCSSClass: 'leaflet-editable-drawing',
            drawingCursor: 'crosshair'
        },

        initialize: function (map, options) {
            L.setOptions(this, options);
            this._lastZIndex = this.options.zIndex;
            this.map = map;
            this.editLayer = this.createEditLayer();
            this.featuresLayer = this.createFeaturesLayer();
            this.forwardLineGuide = this.createLineGuide();
            this.backwardLineGuide = this.createLineGuide();
        },

        fireAndForward: function (type, e) {
            e = e || {};
            e.editTools = this;
            this.fire(type, e);
            this.map.fire(type, e);
        },

        createLineGuide: function () {
            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);
            return L.polyline([], options);
        },

        createVertexIcon: function (options) {
            return L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);
        },

        createEditLayer: function () {
            return this.options.editLayer || new L.LayerGroup().addTo(this.map);
        },

        createFeaturesLayer: function () {
            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);
        },

        moveForwardLineGuide: function (latlng) {
            if (this.forwardLineGuide._latlngs.length) {
                this.forwardLineGuide._latlngs[1] = latlng;
                this.forwardLineGuide._bounds.extend(latlng);
                this.forwardLineGuide.redraw();
            }
        },

        moveBackwardLineGuide: function (latlng) {
            if (this.backwardLineGuide._latlngs.length) {
                this.backwardLineGuide._latlngs[1] = latlng;
                this.backwardLineGuide._bounds.extend(latlng);
                this.backwardLineGuide.redraw();
            }
        },

        anchorForwardLineGuide: function (latlng) {
            this.forwardLineGuide._latlngs[0] = latlng;
            this.forwardLineGuide._bounds.extend(latlng);
            this.forwardLineGuide.redraw();
        },

        anchorBackwardLineGuide: function (latlng) {
            this.backwardLineGuide._latlngs[0] = latlng;
            this.backwardLineGuide._bounds.extend(latlng);
            this.backwardLineGuide.redraw();
        },

        attachForwardLineGuide: function () {
            this.editLayer.addLayer(this.forwardLineGuide);
        },

        attachBackwardLineGuide: function () {
            this.editLayer.addLayer(this.backwardLineGuide);
        },

        detachForwardLineGuide: function () {
            this.forwardLineGuide.setLatLngs([]);
            this.editLayer.removeLayer(this.forwardLineGuide);
        },

        detachBackwardLineGuide: function () {
            this.backwardLineGuide.setLatLngs([]);
            this.editLayer.removeLayer(this.backwardLineGuide);
        },

        blockEvents: function () {
            // Hack: force map not to listen to other layers events while drawing.
            if (!this._oldTargets) {
                this._oldTargets = this.map._targets;
                this.map._targets = {};
            }
        },

        unblockEvents: function () {
            if (this._oldTargets) {
                // Reset, but keep targets created while drawing.
                this.map._targets = L.extend(this.map._targets, this._oldTargets);
                delete this._oldTargets;
            }
        },

        registerForDrawing: function (editor) {
            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);
            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);
            this.blockEvents();
            this._drawingEditor = editor;
            this.map.on('mousedown', this.onMousedown, this);
            this.map.on('mouseup', this.onMouseup, this);
            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);
            this.defaultMapCursor = this.map._container.style.cursor;
            this.map._container.style.cursor = this.options.drawingCursor;
        },

        unregisterForDrawing: function (editor) {
            this.unblockEvents();
            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);
            this.map._container.style.cursor = this.defaultMapCursor;
            editor = editor || this._drawingEditor;
            if (!editor) return;
            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);
            this.map.off('mousedown', this.onMousedown, this);
            this.map.off('mouseup', this.onMouseup, this);
            if (editor !== this._drawingEditor) return;
            delete this._drawingEditor;
            if (editor._drawing) editor.cancelDrawing();
        },

        onMousedown: function (e) {
            this._mouseDown = e;
            this._drawingEditor.onDrawingMouseDown(e);
        },

        onMouseup: function (e) {
            if (this._mouseDown) {
                var origin = L.point(this._mouseDown.originalEvent.clientX, this._mouseDown.originalEvent.clientY);
                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);
                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);
                else this._drawingEditor.onDrawingMouseUp(e);
            }
            this._mouseDown = null;
        },

        drawing: function () {
            return this._drawingEditor && this._drawingEditor.drawing();
        },

        stopDrawing: function () {
            this.unregisterForDrawing();
        },

        commitDrawing: function (e) {
            if (!this._drawingEditor) return;
            this._drawingEditor.commitDrawing(e);
        },

        connectCreatedToMap: function (layer) {
            return this.featuresLayer.addLayer(layer);
        },

        startPolyline: function (latlng, options) {
            var line = this.createPolyline([], options);
            line.enableEdit(this.map).newShape(latlng);
            return line;
        },

        startPolygon: function (latlng, options) {
            var polygon = this.createPolygon([], options);
            polygon.enableEdit(this.map).newShape(latlng);
            return polygon;
        },

        startMarker: function (latlng, options) {
            latlng = latlng || this.map.getCenter().clone();
            var marker = this.createMarker(latlng, options);
            marker.enableEdit(this.map).startDrawing();
            return marker;
        },

        startRectangle: function(latlng, options) {
            var corner = latlng || L.latLng([0, 0]);
            var bounds = new L.LatLngBounds(corner, corner);
            var rectangle = this.createRectangle(bounds, options);
            rectangle.enableEdit(this.map).startDrawing();
            return rectangle;
        },

        startCircle: function (latlng, options) {
            latlng = latlng || this.map.getCenter().clone();
            var circle = this.createCircle(latlng, options);
            circle.enableEdit(this.map).startDrawing();
            return circle;
        },

        startHole: function (editor, latlng) {
            editor.newHole(latlng);
        },

        createLayer: function (klass, latlngs, options) {
            options = L.Util.extend({editOptions: {editTools: this}}, options);
            var layer = new klass(latlngs, options);
            this.fireAndForward('editable:created', {layer: layer});
            return layer;
        },

        createPolyline: function (latlngs, options) {
            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);
        },

        createPolygon: function (latlngs, options) {
            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);
        },

        createMarker: function (latlng, options) {
            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);
        },

        createRectangle: function (bounds, options) {
            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);
        },

        createCircle: function (latlng, options) {
            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);
        }

    });

    L.extend(L.Editable, {

        makeCancellable: function (e) {
            e.cancel = function () {
                e._cancelled = true;
            };
        }

    });

    L.Map.mergeOptions({
        editToolsClass: L.Editable
    });

    L.Map.addInitHook(function () {

        this.whenReady(function () {
            if (this.options.editable) {
                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);
            }
        });

    });

    L.Editable.VertexIcon = L.DivIcon.extend({

        options: {
            iconSize: new L.Point(8, 8)
        }

    });

    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({

        options: {
            iconSize: new L.Point(20, 20)
        }

    });


    L.Editable.VertexMarker = L.Marker.extend({

        options: {
            draggable: true,
            className: 'leaflet-div-icon leaflet-vertex-icon'
        },

        initialize: function (latlng, latlngs, editor, options) {
            // We don't use this._latlng, because on drag Leaflet replace it while
            // we want to keep reference.
            this.latlng = latlng;
            this.latlngs = latlngs;
            this.editor = editor;
            L.Marker.prototype.initialize.call(this, latlng, options);
            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});
            this.latlng.__vertex = this;
            this.editor.editLayer.addLayer(this);
            this.setZIndexOffset(editor.tools._lastZIndex + 1);
        },

        onAdd: function (map) {
            L.Marker.prototype.onAdd.call(this, map);
            this.on('drag', this.onDrag);
            this.on('dragstart', this.onDragStart);
            this.on('dragend', this.onDragEnd);
            this.on('mouseup', this.onMouseup);
            this.on('click', this.onClick);
            this.on('contextmenu', this.onContextMenu);
            this.on('mousedown touchstart', this.onMouseDown);
            this.addMiddleMarkers();
        },

        onRemove: function (map) {
            if (this.middleMarker) this.middleMarker.delete();
            delete this.latlng.__vertex;
            this.off('drag', this.onDrag);
            this.off('dragstart', this.onDragStart);
            this.off('dragend', this.onDragEnd);
            this.off('mouseup', this.onMouseup);
            this.off('click', this.onClick);
            this.off('contextmenu', this.onContextMenu);
            this.off('mousedown touchstart', this.onMouseDown);
            L.Marker.prototype.onRemove.call(this, map);
        },

        onDrag: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerDrag(e);
            var iconPos = L.DomUtil.getPosition(this._icon),
                latlng = this._map.layerPointToLatLng(iconPos);
            this.latlng.update(latlng);
            this._latlng = this.latlng;  // Push back to Leaflet our reference.
            this.editor.refresh();
            if (this.middleMarker) {
                this.middleMarker.updateLatLng();
            }
            var next = this.getNext();
            if (next && next.middleMarker) {
                next.middleMarker.updateLatLng();
            }
        },

        onDragStart: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerDragStart(e);
        },

        onDragEnd: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerDragEnd(e);
        },

        onClick: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerClick(e);
        },

        onMouseup: function (e) {
            L.DomEvent.stop(e);
            e.vertex = this;
            this.editor.map.fire('mouseup', e);
        },

        onContextMenu: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerContextMenu(e);
        },

        onMouseDown: function (e) {
            e.vertex = this;
            this.editor.onVertexMarkerMouseDown(e);
        },

        delete: function () {
            var next = this.getNext();  // Compute before changing latlng
            this.latlngs.splice(this.getIndex(), 1);
            this.editor.editLayer.removeLayer(this);
            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});
            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);
            if (next) next.resetMiddleMarker();
            this.editor.refresh();
        },

        getIndex: function () {
            return this.latlngs.indexOf(this.latlng);
        },

        getLastIndex: function () {
            return this.latlngs.length - 1;
        },

        getPrevious: function () {
            if (this.latlngs.length < 2) return;
            var index = this.getIndex(),
                previousIndex = index - 1;
            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();
            var previous = this.latlngs[previousIndex];
            if (previous) return previous.__vertex;
        },

        getNext: function () {
            if (this.latlngs.length < 2) return;
            var index = this.getIndex(),
                nextIndex = index + 1;
            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;
            var next = this.latlngs[nextIndex];
            if (next) return next.__vertex;
        },

        addMiddleMarker: function (previous) {
            if (!this.editor.hasMiddleMarkers()) return;
            previous = previous || this.getPrevious();
            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);
        },

        addMiddleMarkers: function () {
            if (!this.editor.hasMiddleMarkers()) return;
            var previous = this.getPrevious();
            if (previous) {
                this.addMiddleMarker(previous);
            }
            var next = this.getNext();
            if (next) {
                next.resetMiddleMarker();
            }
        },

        resetMiddleMarker: function () {
            if (this.middleMarker) this.middleMarker.delete();
            this.addMiddleMarker();
        },

        split: function () {
            if (!this.editor.splitShape) return;  // Only for PolylineEditor
            this.editor.splitShape(this.latlngs, this.getIndex());
        },

        continue: function () {
            if (!this.editor.continueBackward) return;  // Only for PolylineEditor
            var index = this.getIndex();
            if (index === 0) this.editor.continueBackward(this.latlngs);
            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);
        }

    });

    L.Editable.mergeOptions({
        vertexMarkerClass: L.Editable.VertexMarker
    });

    L.Editable.MiddleMarker = L.Marker.extend({

        options: {
            opacity: 0.5,
            className: 'leaflet-div-icon leaflet-middle-icon',
            draggable: true
        },

        initialize: function (left, right, latlngs, editor, options) {
            this.left = left;
            this.right = right;
            this.editor = editor;
            this.latlngs = latlngs;
            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);
            this._opacity = this.options.opacity;
            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});
            this.editor.editLayer.addLayer(this);
            this.setVisibility();
        },

        setVisibility: function () {
            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),
                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),
                size = L.point(this.options.icon.options.iconSize);
            if (leftPoint.distanceTo(rightPoint) < size.x * 3) {
                this.hide();
            } else {
                this.show();
            }
        },

        show: function () {
            this.setOpacity(this._opacity);
        },

        hide: function () {
            this.setOpacity(0);
        },

        updateLatLng: function () {
            this.setLatLng(this.computeLatLng());
            this.setVisibility();
        },

        computeLatLng: function () {
            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),
                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),
                y = (leftPoint.y + rightPoint.y) / 2,
                x = (leftPoint.x + rightPoint.x) / 2;
            return this.editor.map.containerPointToLatLng([x, y]);
        },

        onAdd: function (map) {
            L.Marker.prototype.onAdd.call(this, map);
            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);
            map.on('zoomend', this.setVisibility, this);
        },

        onRemove: function (map) {
            delete this.right.middleMarker;
            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);
            map.off('zoomend', this.setVisibility, this);
            L.Marker.prototype.onRemove.call(this, map);
        },

        onMouseDown: function (e) {
            var iconPos = L.DomUtil.getPosition(this._icon),
                latlng = this.editor.map.layerPointToLatLng(iconPos);
            e = {
                originalEvent: e,
                latlng: latlng
            };
            if (this.options.opacity === 0) return;
            L.Editable.makeCancellable(e);
            this.editor.onMiddleMarkerMouseDown(e);
            if (e._cancelled) return;
            this.latlngs.splice(this.index(), 0, e.latlng);
            this.editor.refresh();
            var icon = this._icon;
            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);
            /* Hack to workaround browser not firing touchend when element is no more on DOM */
            var parent = marker._icon.parentNode;
            parent.removeChild(marker._icon);
            marker._icon = icon;
            parent.appendChild(marker._icon);
            marker._initIcon();
            marker._initInteraction();
            marker.setOpacity(1);
            /* End hack */
            // Transfer ongoing dragging to real marker
            L.Draggable._dragging = false;
            marker.dragging._draggable._onDown(e.originalEvent);
            this.delete();
        },

        delete: function () {
            this.editor.editLayer.removeLayer(this);
        },

        index: function () {
            return this.latlngs.indexOf(this.right.latlng);
        }

    });

    L.Editable.mergeOptions({
        middleMarkerClass: L.Editable.MiddleMarker
    });

    L.Editable.BaseEditor = L.Class.extend({

        initialize: function (map, feature, options) {
            L.setOptions(this, options);
            this.map = map;
            this.feature = feature;
            this.feature.editor = this;
            this.editLayer = new L.LayerGroup();
            this.tools = this.options.editTools || map.editTools;
        },

        enable: function () {
            if (this._enabled) return this;
            if (this.isConnected()) this.tools.editLayer.addLayer(this.editLayer);
            this.onEnable();
            this._enabled = true;
            this.feature.on('remove', this.disable, this);
            return this;
        },

        disable: function () {
            this.feature.off('remove', this.disable, this);
            this.editLayer.clearLayers();
            this.tools.editLayer.removeLayer(this.editLayer);
            this.onDisable();
            delete this._enabled;
            if (this._drawing) this.cancelDrawing();
            return this;
        },

        drawing: function () {
            return !!this._drawing;
        },

        hasMiddleMarkers: function () {
            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;
        },

        fireAndForward: function (type, e) {
            e = e || {};
            e.layer = this.feature;
            this.feature.fire(type, e);
            this.tools.fireAndForward(type, e);
        },

        onEnable: function () {
            this.fireAndForward('editable:enable');
        },

        onDisable: function () {
            this.fireAndForward('editable:disable');
        },

        onEditing: function () {
            this.fireAndForward('editable:editing');
        },

        onStartDrawing: function () {
            this.fireAndForward('editable:drawing:start');
        },

        onEndDrawing: function () {
            this.fireAndForward('editable:drawing:end');
        },

        onCancelDrawing: function () {
            this.fireAndForward('editable:drawing:cancel');
        },

        onCommitDrawing: function (e) {
            this.fireAndForward('editable:drawing:commit', e);
        },

        onDrawingMouseDown: function (e) {
            this.fireAndForward('editable:drawing:mousedown', e);
        },

        onDrawingMouseUp: function (e) {
            this.fireAndForward('editable:drawing:mouseup', e);
        },

        startDrawing: function () {
            if (!this._drawing) this._drawing = L.Editable.FORWARD;
            this.tools.registerForDrawing(this);
            this.onStartDrawing();
        },

        commitDrawing: function (e) {
            this.onCommitDrawing(e);
            this.endDrawing();
        },

        cancelDrawing: function () {
            this.onCancelDrawing();
            this.endDrawing();
        },

        endDrawing: function () {
            this._drawing = false;
            this.tools.unregisterForDrawing(this);
            this.onEndDrawing();
        },

        onDrawingClick: function (e) {
            if (!this.drawing) return;
            L.Editable.makeCancellable(e);
            this.fireAndForward('editable:drawing:click', e);
            if (e._cancelled) return;
            if (!this.isConnected()) this.connect(e);
            this.processDrawingClick(e);
        },

        isConnected: function () {
            return this.map.hasLayer(this.feature);
        },

        connect: function (e) {
            this.tools.connectCreatedToMap(this.feature);
            this.tools.editLayer.addLayer(this.editLayer);
        },

        onMove: function (e) {
            this.fireAndForward('editable:drawing:move', e);
        },

        onDrawingMouseMove: function (e) {
            this.onMove(e);
        }

    });

    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({

        enable: function () {
            if (this._enabled) return this;
            L.Editable.BaseEditor.prototype.enable.call(this);
            if (this.isConnected()) this.enableDragging();
            else this.feature.on('add', this.enableDragging, this);
            this.feature.on('dragstart', this.onEditing, this);
            this.feature.on('drag', this.onMove, this);
            return this;
        },

        disable: function () {
            L.Editable.BaseEditor.prototype.disable.call(this);
            if (this.feature.dragging) this.feature.dragging.disable();
            this.feature.off('dragstart', this.onEditing, this);
            this.feature.off('drag', this.onMove, this);
            return this;
        },

        enableDragging: function () {
            this.feature.dragging.enable();
        },

        onDrawingMouseMove: function (e) {
            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
            if (this._drawing) this.feature.setLatLng(e.latlng);
        },

        processDrawingClick: function (e) {
            this.fireAndForward('editable:drawing:clicked', e);
            this.commitDrawing(e);
        },

        connect: function (e) {
            // On touch, the latlng has not been updated because there is
            // no mousemove.
            if (e) this.feature._latlng = e.latlng;
            L.Editable.BaseEditor.prototype.connect.call(this, e);
        }

    });

    L.Editable.PathEditor = L.Editable.BaseEditor.extend({

        CLOSED: false,
        MIN_VERTEX: 2,

        enable: function () {
            if (this._enabled) return this;
            L.Editable.BaseEditor.prototype.enable.call(this);
            if (this.feature) {
                this.initVertexMarkers();
            }
            return this;
        },

        disable: function () {
            return L.Editable.BaseEditor.prototype.disable.call(this);
        },

        initVertexMarkers: function (latlngs) {
            latlngs = latlngs || this.getLatLngs();
            if (L.Polyline._flat(latlngs)) this.addVertexMarkers(latlngs);
            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);
        },

        getLatLngs: function () {
            return this.feature.getLatLngs();
        },

        reset: function () {
            this.editLayer.clearLayers();
            this.initVertexMarkers();
        },

        addVertexMarker: function (latlng, latlngs) {
            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);
        },

        addVertexMarkers: function (latlngs) {
            for (var i = 0; i < latlngs.length; i++) {
                this.addVertexMarker(latlngs[i], latlngs);
            }
        },

        refreshVertexMarkers: function (latlngs) {
            latlngs = latlngs || this.getDefaultLatLngs();
            for (var i = 0; i < latlngs.length; i++) {
                latlngs[i].__vertex.update();
            }
        },

        addMiddleMarker: function (left, right, latlngs) {
            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);
        },

        onVertexMarkerClick: function (e) {
            L.Editable.makeCancellable(e);
            this.fireAndForward('editable:vertex:click', e);
            if (e._cancelled) return;
            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;
            var index = e.vertex.getIndex(), commit;
            if (e.originalEvent.ctrlKey) {
                this.onVertexMarkerCtrlClick(e);
            } else if (e.originalEvent.altKey) {
                this.onVertexMarkerAltClick(e);
            } else if (e.originalEvent.shiftKey) {
                this.onVertexMarkerShiftClick(e);
            } else if (e.originalEvent.metaKey) {
                this.onVertexMarkerMetaKeyClick(e);
            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {
                if (index >= this.MIN_VERTEX - 1) commit = true;
            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {
                commit = true;
            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {
                commit = true;  // Allow to close on first point also for polygons
            } else {
                this.onVertexRawMarkerClick(e);
            }
            this.fireAndForward('editable:vertex:clicked', e);
            if (commit) this.commitDrawing(e);
        },

        onVertexRawMarkerClick: function (e) {
            this.fireAndForward('editable:vertex:rawclick', e);
            if (e._cancelled) return;
            if (!this.vertexCanBeDeleted(e.vertex)) return;
            e.vertex.delete();
        },

        vertexCanBeDeleted: function (vertex) {
            return vertex.latlngs.length > this.MIN_VERTEX;
        },

        onVertexDeleted: function (e) {
            this.fireAndForward('editable:vertex:deleted', e);
        },

        onVertexMarkerCtrlClick: function (e) {
            this.fireAndForward('editable:vertex:ctrlclick', e);
        },

        onVertexMarkerShiftClick: function (e) {
            this.fireAndForward('editable:vertex:shiftclick', e);
        },

        onVertexMarkerMetaKeyClick: function (e) {
            this.fireAndForward('editable:vertex:metakeyclick', e);
        },

        onVertexMarkerAltClick: function (e) {
            this.fireAndForward('editable:vertex:altclick', e);
        },

        onVertexMarkerContextMenu: function (e) {
            this.fireAndForward('editable:vertex:contextmenu', e);
        },

        onVertexMarkerMouseDown: function (e) {
            this.fireAndForward('editable:vertex:mousedown', e);
        },

        onMiddleMarkerMouseDown: function (e) {
            this.fireAndForward('editable:middlemarker:mousedown', e);
        },

        onVertexMarkerDrag: function (e) {
            this.onMove(e);
            if (this.feature._bounds) this.extendBounds(e);
            this.fireAndForward('editable:vertex:drag', e);
        },

        onVertexMarkerDragStart: function (e) {
            this.fireAndForward('editable:vertex:dragstart', e);
        },

        onVertexMarkerDragEnd: function (e) {
            this.fireAndForward('editable:vertex:dragend', e);
        },

        setDrawnLatLngs: function (latlngs) {
            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();
        },

        startDrawing: function () {
            if (!this._drawnLatLngs) this.setDrawnLatLngs();
            L.Editable.BaseEditor.prototype.startDrawing.call(this);
        },

        startDrawingForward: function () {
            this.startDrawing();
            this.tools.attachForwardLineGuide();
        },

        endDrawing: function () {
            this.tools.detachForwardLineGuide();
            this.tools.detachBackwardLineGuide();
            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);
            L.Editable.BaseEditor.prototype.endDrawing.call(this);
            delete this._drawnLatLngs;
        },

        addLatLng: function (latlng) {
            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);
            else this._drawnLatLngs.unshift(latlng);
            this.feature._bounds.extend(latlng);
            this.addVertexMarker(latlng, this._drawnLatLngs);
            this.refresh();
        },

        newPointForward: function (latlng) {
            this.addLatLng(latlng);
            this.tools.anchorForwardLineGuide(latlng);
            if (!this.tools.backwardLineGuide._latlngs[0]) {
                this.tools.anchorBackwardLineGuide(latlng);
            }
        },

        newPointBackward: function (latlng) {
            this.addLatLng(latlng);
            this.tools.anchorBackwardLineGuide(latlng);
        },

        push: function (latlng) {
            if (!latlng) return console.error('L.Editable.PathEditor.push expect a vaild latlng as parameter');
            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);
            else this.newPointBackward(latlng);
        },

        removeLatLng: function (latlng) {
            latlng.__vertex.delete();
            this.refresh();
        },

        pop: function () {
            if (this._drawnLatLngs.length <= 1) return;
            var latlng;
            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];
            else latlng = this._drawnLatLngs[0];
            this.removeLatLng(latlng);
            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);
            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);
            return latlng;
        },

        processDrawingClick: function (e) {
            if (e.vertex && e.vertex.editor === this) return;
            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);
            else this.newPointBackward(e.latlng);
            this.fireAndForward('editable:drawing:clicked', e);
        },

        onDrawingMouseMove: function (e) {
            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
            if (this._drawing) {
                this.tools.moveForwardLineGuide(e.latlng);
                this.tools.moveBackwardLineGuide(e.latlng);
            }
        },

        refresh: function () {
            this.feature.redraw();
            this.onEditing();
        },

        newShape: function (latlng) {
            var shape = this.addNewEmptyShape();
            if (!shape) return;
            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline
            this.startDrawingForward();
            this.fireAndForward('editable:shape:new', {shape: shape});
            if (latlng) this.newPointForward(latlng);
        },

        deleteShape: function (shape, latlngs) {
            var e = {shape: shape};
            L.Editable.makeCancellable(e);
            this.fireAndForward('editable:shape:delete', e);
            if (e._cancelled) return;
            shape = this._deleteShape(shape, latlngs);
            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.
            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.
            this.refresh();
            this.reset();
            this.fireAndForward('editable:shape:deleted', {shape: shape});
            return shape;
        },

        _deleteShape: function (shape, latlngs) {
            latlngs = latlngs || this.getLatLngs();
            if (!latlngs.length) return;
            var self = this,
                inplaceDelete = function (latlngs, shape) {
                    // Called when deleting a flat latlngs
                    shape = latlngs.splice(0, Number.MAX_VALUE);
                    return shape;
                },
                spliceDelete = function (latlngs, shape) {
                    // Called when removing a latlngs inside an array
                    latlngs.splice(latlngs.indexOf(shape), 1);
                    if (!latlngs.length) self._deleteShape(latlngs);
                    return shape;
                };
            if (latlngs === shape) return inplaceDelete(latlngs, shape);
            for (var i = 0; i < latlngs.length; i++) {
                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);
                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);
            }
        },

        deleteShapeAt: function (latlng) {
            var shape = this.feature.shapeAt(latlng);
            if (shape) return this.deleteShape(shape);
        },

        appendShape: function (shape) {
            this.insertShape(shape);
        },

        prependShape: function (shape) {
            this.insertShape(shape, 0);
        },

        insertShape: function (shape, index) {
            this.ensureMulti();
            shape = this.formatShape(shape);
            if (typeof index === 'undefined') index = this.feature._latlngs.length;
            this.feature._latlngs.splice(index, 0, shape);
            this.feature.redraw();
            if (this._enabled) this.reset();
        },

        extendBounds: function (e) {
            this.feature._bounds.extend(e.vertex.latlng);
        }

    });

    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({

        startDrawingBackward: function (latlngs) {
            this._drawing = L.Editable.BACKWARD;
            this.startDrawing(latlngs);
            this.tools.attachBackwardLineGuide();
        },

        continueBackward: function (latlngs) {
            if (this.drawing()) return;
            latlngs = latlngs || this.getDefaultLatLngs();
            this.setDrawnLatLngs(latlngs);
            this.tools.anchorBackwardLineGuide(latlngs[0]);
            this.startDrawingBackward();
        },

        continueForward: function (latlngs) {
            if (this.drawing()) return;
            latlngs = latlngs || this.getDefaultLatLngs();
            this.setDrawnLatLngs(latlngs);
            this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);
            this.startDrawingForward();
        },

        getDefaultLatLngs: function (latlngs) {
            latlngs = latlngs || this.feature._latlngs;
            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;
            else return this.getDefaultLatLngs(latlngs[0]);
        },

        ensureMulti: function () {
            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs)) {
                this.feature._latlngs = [this.feature._latlngs];
            }
        },

        addNewEmptyShape: function () {
            if (this.feature._latlngs.length) {
                var shape = [];
                this.appendShape(shape);
                return shape;
            } else {
                return this.feature._latlngs;
            }
        },

        formatShape: function (shape) {
            if (L.Polyline._flat(shape)) return shape;
            else if (shape[0]) return this.formatShape(shape[0]);
        },

        splitShape: function (shape, index) {
            if (!index || index >= shape.length - 1) return;
            this.ensureMulti();
            var shapeIndex = this.feature._latlngs.indexOf(shape);
            if (shapeIndex === -1) return;
            var first = shape.slice(0, index + 1),
                second = shape.slice(index);
            // We deal with reference, we don't want twice the same latlng around.
            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);
            this.feature._latlngs.splice(shapeIndex, 1, first, second);
            this.refresh();
            this.reset();
        }

    });

    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({

        CLOSED: true,
        MIN_VERTEX: 3,

        startDrawingForward: function () {
            L.Editable.PathEditor.prototype.startDrawingForward.call(this);
            this.tools.attachBackwardLineGuide();
        },

        addNewEmptyHole: function (latlng) {
            this.ensureNotFlat();
            var latlngs = this.feature.shapeAt(latlng);
            if (!latlngs) return;
            var holes = [];
            latlngs.push(holes);
            return holes;
        },

        newHole: function (latlng) {
            var holes = this.addNewEmptyHole(latlng);
            if (!holes) return;
            this.setDrawnLatLngs(holes);
            this.startDrawingForward();
            if (latlng) this.newPointForward(latlng);
        },

        addNewEmptyShape: function () {
            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {
                var shape = [];
                this.appendShape(shape);
                return shape;
            } else {
                return this.feature._latlngs;
            }
        },

        ensureMulti: function () {
            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs[0])) {
                this.feature._latlngs = [this.feature._latlngs];
            }
        },

        ensureNotFlat: function () {
            if (!this.feature._latlngs.length || L.Polyline._flat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];
        },

        vertexCanBeDeleted: function (vertex) {
            var parent = this.feature.parentShape(vertex.latlngs),
                idx = L.Util.indexOf(parent, vertex.latlngs);
            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.
            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);
        },

        getDefaultLatLngs: function () {
            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);
            return this.feature._latlngs[0];
        },

        formatShape: function (shape) {
            // [[1, 2], [3, 4]] => must be nested
            // [] => must be nested
            // [[]] => is already nested
            if (L.Polyline._flat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];
            else return shape;
        }

    });

    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({

        CLOSED: true,
        MIN_VERTEX: 4,

        options: {
            skipMiddleMarkers: true
        },

        extendBounds: function (e) {
            var index = e.vertex.getIndex(),
                oppositeIndex = (index + 2) % 4,
                opposite = e.vertex.latlngs[oppositeIndex],
                bounds = new L.LatLngBounds(e.latlng, opposite);
            this.updateBounds(bounds);
            this.refreshVertexMarkers();
        },

        onDrawingMouseDown: function (e) {
            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);
            this.connect();
            var latlngs = this.getDefaultLatLngs();
            // L.Polygon._convertLatLngs removes last latlng if it equals first point,
            // which is the case here as all latlngs are [0, 0]
            if (latlngs.length === 3) latlngs.push(e.latlng);
            var bounds = new L.LatLngBounds(e.latlng, e.latlng);
            this.updateBounds(bounds);
            this.refresh();
            this.reset();
            this.commitDrawing(e);
            // Stop dragging map.
            this.map.dragging._draggable._onUp(e.originalEvent);
            // Now transfer ongoing drag action to the bottom right corner.
            // Should we refine which corne will handle the drag according to
            // drag direction?
            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);
        },

        getDefaultLatLngs: function (latlngs) {
            return latlngs || this.feature._latlngs[0];
        },

        updateBounds: function (bounds) {
            this.feature._bounds = bounds;
            var latlngs = this.getDefaultLatLngs(),
                newLatlngs = this.feature._boundsToLatLngs(bounds);
            // Keep references.
            for (var i = 0; i < latlngs.length; i++) {
                latlngs[i].update(newLatlngs[i]);
            };
        }

    });

    L.Editable.CircleEditor = L.Editable.PathEditor.extend({

        MIN_VERTEX: 2,

        options: {
            skipMiddleMarkers: true
        },

        initialize: function (map, feature, options) {
            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);
            this._resizeLatLng = this.computeResizeLatLng();
        },

        computeResizeLatLng: function () {
            // While circle is not added to the map, _radius is not set.
            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),
                point = this.map.project(this.feature._latlng);
            return this.map.unproject([point.x + delta, point.y - delta]);
        },

        updateResizeLatLng: function () {
            this._resizeLatLng.update(this.computeResizeLatLng());
            this._resizeLatLng.__vertex.update();
        },

        getLatLngs: function () {
            return [this.feature._latlng, this._resizeLatLng];
        },

        getDefaultLatLngs: function () {
            return this.getLatLngs();
        },

        onVertexMarkerDrag: function (e) {
            if (e.vertex.getIndex() === 1) this.resize(e);
            else this.updateResizeLatLng(e);
            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);
        },

        resize: function (e) {
            var radius = this.feature._latlng.distanceTo(e.latlng)
            this.feature.setRadius(radius);
        },

        onDrawingMouseDown: function (e) {
            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);
            this._resizeLatLng.update(e.latlng);
            this.feature._latlng.update(e.latlng);
            this.connect();
            this.commitDrawing(e);
            // Stop dragging map.
            this.map.dragging._draggable._onUp(e.originalEvent);
            // Now transfer ongoing drag action to the radius handler.
            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);
        },

        onDrawingMouseMove: function (e) {
            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
            this.feature._latlng.update(e.latlng);
            this.feature._latlng.__vertex.update();
        }

    });

    var EditableMixin = {

        createEditor: function (map) {
            map = map || this._map;
            var Klass = this.options.editorClass || this.getEditorClass(map);
            return new Klass(map, this, this.options.editOptions);
        },

        enableEdit: function (map) {
            if (!this.editor) this.createEditor(map);
            return this.editor.enable();
        },

        editEnabled: function () {
            return this.editor && this.editor._enabled;
        },

        disableEdit: function () {
            if (this.editor) {
                this.editor.disable();
                delete this.editor;
            }
        },

        toggleEdit: function () {
            if (this.editEnabled()) {
                this.disableEdit();
            } else {
                this.enableEdit();
            }
        },

        _onEditableAdd: function () {
            if (this.editor) this.enableEdit();
        }

    };

    L.Polyline.include(EditableMixin);
    L.Polygon.include(EditableMixin);
    L.Marker.include(EditableMixin);
    L.Rectangle.include(EditableMixin);
    L.Circle.include(EditableMixin);

    L.Polyline.include({

        getEditorClass: function (map) {
            return (map && map.options.polylineEditorClass) ? map.options.polylineEditorClass : L.Editable.PolylineEditor;
        },

        shapeAt: function (latlng, latlngs) {
            // We can have those cases:
            // - latlngs are just a flat array of latlngs, use this
            // - latlngs is an array of arrays of latlngs, loop over
            var shape = null;
            latlngs = latlngs || this._latlngs;
            if (!latlngs.length) return shape;
            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;
            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];
            return shape;
        },

        isInLatLngs: function (l, latlngs) {
            if (!latlngs) return false;
            var i, k, len, part = [], p,
                w = this._clickTolerance();
            this._projectLatlngs(latlngs, part, this._pxBounds);
            part = part[0];
            p = this._map.latLngToLayerPoint(l);

            if (!this._pxBounds.contains(p)) { return false; }
            for (i = 1, len = part.length, k = 0; i < len; k = i++) {

                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {
                    return true;
                }
            }
            return false;
        }

    });

    L.Polygon.include({

        getEditorClass: function (map) {
            return (map && map.options.polygonEditorClass) ? map.options.polygonEditorClass : L.Editable.PolygonEditor;
        },

        shapeAt: function (latlng, latlngs) {
            // We can have those cases:
            // - latlngs are just a flat array of latlngs, use this
            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first
            // - latlngs is an array of arrays of arrays, this is a multi, loop over
            var shape = null;
            latlngs = latlngs || this._latlngs;
            if (!latlngs.length) return shape;
            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;
            else if (L.Polyline._flat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;
            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];
            return shape;
        },

        isInLatLngs: function (l, latlngs) {
            var inside = false, l1, l2, j, k, len2;

            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {
                l1 = latlngs[j];
                l2 = latlngs[k];

                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&
                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {
                    inside = !inside;
                }
            }

            return inside;
        },

        parentShape: function (shape, latlngs) {
            latlngs = latlngs || this._latlngs;
            if (!latlngs) return;
            var idx = L.Util.indexOf(latlngs, shape);
            if (idx !== -1) return latlngs;
            for (var i = 0; i < latlngs.length; i++) {
                idx = L.Util.indexOf(latlngs[i], shape);
                if (idx !== -1) return latlngs[i];
            }
        }

    });

    L.Marker.include({

        getEditorClass: function (map) {
            return (map && map.options.markerEditorClass) ? map.options.markerEditorClass : L.Editable.MarkerEditor;
        }

    });

    L.Rectangle.include({

        getEditorClass: function (map) {
            return (map && map.options.rectangleEditorClass) ? map.options.rectangleEditorClass : L.Editable.RectangleEditor;
        }

    });

    L.Circle.include({

        getEditorClass: function (map) {
            return (map && map.options.circleEditorClass) ? map.options.circleEditorClass : L.Editable.CircleEditor;
        }

    });

    var keepEditable = function () {
        // Make sure you can remove/readd an editable layer.
        this.on('add', this._onEditableAdd);
    };
    L.Marker.addInitHook(keepEditable);
    L.Polyline.addInitHook(keepEditable);

    L.LatLng.prototype.update = function (latlng) {
        this.lat = latlng.lat;
        this.lng = latlng.lng;
    }

}, window));

},{"leaflet":13}],13:[function(require,module,exports){
/*
 Leaflet 1.0.0-rc.2, a JS library for interactive maps. http://leafletjs.com
 (c) 2010-2015 Vladimir Agafonkin, (c) 2010-2011 CloudMade
*/
(function (window, document, undefined) {
var L = {
	version: "1.0.0-rc.2"
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed
if (typeof window !== 'undefined') {
	expose();
}



/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

L.Util = {

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	extend: function (dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// @function bind(fn: Function, â€¦): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assiging it one if it doesn't have it.
	stamp: function (obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
		/*eslint-enable */
	},

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	lastId: 0,

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.bind` shortcut.
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	falseFn: function () { return false; },

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values â€” they will be evaluated passing `data` as an argument.
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_\-]+) *\}/g,

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	indexOf: function (array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	},

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	L.Util.requestAnimFrame = function (fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context));
		}
	};

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;




// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

L.Class = function () {};

L.Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
L.Class.include = function (props) {
	L.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};



/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */


L.Evented = L.Class.extend({

	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = {
				listeners: {},
				count: 0
			};
			this._events[type] = typeListeners;
		}

		var contextId = context && context !== this && L.stamp(context),
		    newListener = {fn: fn, ctx: context};

		if (!contextId) {
			contextId = 'no_context';
			newListener.ctx = undefined;
		}

		// fn array for context
		var listeners = typeListeners.listeners[contextId];
		if (!listeners) {
			listeners = [];
			typeListeners.listeners[contextId] = listeners;
		}

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn) {
				return;
			}
		}

		listeners.push(newListener);
		typeListeners.count++;
	},

	_off: function (type, fn, context) {
		var typeListeners,
		    contextId,
		    listeners,
		    i,
		    len;

		if (!this._events) { return; }

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			typeListeners = this._events[type];
			if (typeListeners) {
				for (contextId in typeListeners.listeners) {
					listeners = typeListeners.listeners[contextId];
					for (i = 0, len = listeners.length; i < len; i++) {
						listeners[i].fn = L.Util.falseFn;
					}
				}
				// clear all listeners for a type if function isn't specified
				delete this._events[type];
			}
			return;
		}

		typeListeners = this._events[type];
		if (!typeListeners) {
			return;
		}

		contextId = context && context !== this && L.stamp(context);
		if (!contextId) {
			contextId = 'no_context';
		}

		listeners = typeListeners.listeners[contextId];
		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = L.Util.falseFn;
					typeListeners.count--;

					if (len > 1) {
						if (!this._isFiring) {
							listeners.splice(i, 1);
						} else {
							/* copy array in case events are being fired */
							typeListeners.listeners[contextId] = listeners.slice();
							typeListeners.listeners[contextId].splice(i, 1);
						}
					} else {
						delete typeListeners.listeners[contextId];
					}

					return;
				}
				if (listeners.length === 0) {
					delete typeListeners.listeners[contextId];
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object â€” the first argument of the listener function will contain its
	// properties. The event might can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this});

		if (this._events) {
			var typeListeners = this._events[type];

			if (typeListeners) {
				this._isFiring = true;

				// each context
				for (var contextId in typeListeners.listeners) {
					var listeners = typeListeners.listeners[contextId];

					// each fn in context
					for (var i = 0, len = listeners.length; i < len; i++) {
						var l = listeners[i];
						l.fn.call(l.ctx || this, event);
					}
				}

				this._isFiring = false;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var typeListeners = this._events && this._events[type];
		if (typeListeners && typeListeners.count) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(â€¦): this
	// Behaves as [`on(â€¦)`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually

// @method addEventListener(â€¦): this
// Alias to [`on(â€¦)`](#evented-on)
proto.addEventListener = proto.on;

// @method removeEventListener(â€¦): this
// Alias to [`off(â€¦)`](#evented-off)

// @method clearAllEventListeners(â€¦): this
// Alias to [`off()`](#evented-off)
proto.removeEventListener = proto.clearAllEventListeners = proto.off;

// @method addOneTimeEventListener(â€¦): this
// Alias to [`once(â€¦)`](#evented-once)
proto.addOneTimeEventListener = proto.once;

// @method fireEvent(â€¦): this
// Alias to [`fire(â€¦)`](#evented-fire)
proto.fireEvent = proto.fire;

// @method hasEventListeners(â€¦): Boolean
// Alias to [`listens(â€¦)`](#evented-listens)
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};



/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,
	    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

	    win = navigator.platform.indexOf('Win') === 0,

	    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
	    pointer = window.PointerEvent || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera12 = 'OTransition' in doc.style;


	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {

		// @property ie: Boolean
		// `true` for all Internet Explorer versions (not Edge).
		ie: ie,

		// @property ielt9: Boolean
		// `true` for Internet Explorer versions less than 9.
		ielt9: ie && !document.addEventListener,

		// @property edge: Boolean
		// `true` for the Edge web browser.
		edge: 'msLaunchUri' in navigator && !('documentMode' in document),

		// @property webkit: Boolean
		// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
		webkit: webkit,

		// @property gecko: Boolean
		// `true` for gecko-based browsers like Firefox.
		gecko: gecko,

		// @property android: Boolean
		// `true` for any browser running on an Android platform.
		android: ua.indexOf('android') !== -1,

		// @property android23: Boolean
		// `true` for browsers running on Android 2 or Android 3.
		android23: android23,

		// @property chrome: Boolean
		// `true` for the Chrome browser.
		chrome: chrome,

		// @property safari: Boolean
		// `true` for the Safari browser.
		safari: !chrome && ua.indexOf('safari') !== -1,


		// @property win: Boolean
		// `true` when the browser is running in a Windows platform
		win: win,


		// @property ie3d: Boolean
		// `true` for all Internet Explorer versions supporting CSS transforms.
		ie3d: ie3d,

		// @property webkit3d: Boolean
		// `true` for webkit-based browsers supporting CSS transforms.
		webkit3d: webkit3d,

		// @property gecko3d: Boolean
		// `true` for gecko-based browsers supporting CSS transforms.
		gecko3d: gecko3d,

		// @property opera12: Boolean
		// `true` for the Opera browser supporting CSS transforms (version 12 or later).
		opera12: opera12,

		// @property any3d: Boolean
		// `true` for all browsers supporting CSS transforms.
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


		// @property mobile: Boolean
		// `true` for all browsers running in a mobile device.
		mobile: mobile,

		// @property mobileWebkit: Boolean
		// `true` for all webkit-based browsers in a mobile device.
		mobileWebkit: mobile && webkit,

		// @property mobileWebkit3d: Boolean
		// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
		mobileWebkit3d: mobile && webkit3d,

		// @property mobileOpera: Boolean
		// `true` for the Opera browser in a mobile device.
		mobileOpera: mobile && window.opera,

		// @property mobileGecko: Boolean
		// `true` for gecko-based browsers running in a mobile device.
		mobileGecko: mobile && gecko,


		// @property touch: Boolean
		// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
		touch: !!touch,

		// @property msPointer: Boolean
		// `true` for browsers implementing the Microsoft touch events model (notably IE10).
		msPointer: !!msPointer,

		// @property pointer: Boolean
		// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
		pointer: !!pointer,


		// @property retina: Boolean
		// `true` for browsers on a high-resolution "retina" screen.
		retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
	};

}());



/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

L.Point = function (x, y, round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(L.point(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new L.Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new L.Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new L.Point(x.x, x.y);
	}
	return new L.Point(x, y, round);
};



/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

L.Bounds = function (a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = L.point(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new L.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(topLeft: Point, bottomRight: Point)
// Creates a Bounds object from two coordinates (usually top-left and bottom-right corners).
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the points it contains
L.bounds = function (a, b) {
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};



/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = new L.Transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts real `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts real `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};



/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

L.DomUtil = {

	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	empty: function (el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	},

	// @function toFront(el: HTMLElement)
	// Makes `el` the last children of its parent, so it renders in front of the other children.
	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	// @function toBack(el: HTMLElement)
	// Makes `el` the first children of its parent, so it renders back from the other children.
	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {
			L.DomUtil._setOpacityIE(el, value);
		}
	},

	_setOpacityIE: function (el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	},

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0);

		el.style[L.DomUtil.TRANSFORM] =
			(L.Browser.ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	},

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

		/*eslint-disable */
		el._leaflet_pos = point;
		/*eslint-enable */

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new L.Point(0, 0);
	}
};


(function () {
	// prefix style property names

	// @property TRANSFORM: String
	// Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transform style name.
	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	L.DomUtil.preventOutline = function (element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element || !element.style) { return; }
		L.DomUtil.restoreOutline();
		this._outlineElement = element;
		this._outlineStyle = element.style.outline;
		element.style.outline = 'none';
		L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
	};

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	L.DomUtil.restoreOutline = function () {
		if (!this._outlineElement) { return; }
		this._outlineElement.style.outline = this._outlineStyle;
		delete this._outlineElement;
		delete this._outlineStyle;
		L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
})();



/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return L.latLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new L.LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

L.latLng = function (a, b, c) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new L.LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b, c);
};



/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var southWest = L.latLng(40.712, -74.227),
 * northEast = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(southWest, northEast);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
	equals: function (bounds) {
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(southWest: LatLng, northEast: LatLng)
// Creates a `LatLngBounds` object by defining south-west and north-east corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
L.latLngBounds = function (a, b) {
	if (a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};



/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection â€” the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:3395` and `Simple` CRS.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};



/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection â€” the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

L.Projection.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};



/*
 * @class CRS
 * @aka L.CRS
 * Abstract class that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

L.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level correspondingto a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng1: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude coordinate axis
	// wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean = false
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return L.latLng(lat, lng, alt);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});



/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) +
		        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});



/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API â€” it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

L.Map = L.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: L.CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = undefined
		// Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
		minZoom: undefined,

		// @option maxZoom: Number = undefined
		// Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back when he tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom) {
		// replaced by animation-powered implementation in Map.PanAnimation.js
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), zoom);
		return this;
	},

	// @method setZoom(zoom: Number, options: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && (this.getZoom() > this.options.maxZoom)) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so â€”
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so â€”
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},


	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		for (var i in this._layers) {
			this._layers[i].remove();
		}

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a children of `container`, or
	// as a children of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);
		padding = L.point(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;

		var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.zoom(scale * crs.scale(fromZoom));
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return L.DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeteadly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeteadly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		L.Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove) {
		if (!L.DomEvent) { return; }

		this._targets = {};
		this._targets[L.stamp(this._container)] = this;

		var onOff = remove ? 'off' : 'on';

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: Event
		// Fired when the user presses a key from the keyboard while the map is focused.
		L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}

		if (L.Browser.any3d && this.options.transform3DLimit) {
			this[onOff]('moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[L.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && L.DomEvent._isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

		if (type === 'mousedown') {
			// prevents outline when clicking on keyboard-focusable element
			L.DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = L.Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			L.DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target instanceof L.Marker;
			data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = L.bounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
L.map = function (id, options) {
	return new L.Map(id, options);
};




/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


L.Layer = L.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',
		nonBubblingEvents: []  // Array of events that should not be bubbled to DOM parents (like the map)
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map): this
	 * Adds the layer to the given map
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[L.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[L.stamp(targetEl)];
		return this;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	}
});



/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection â€” more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});



/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


L.GridLayer = L.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = depends
		// If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
		updateWhenIdle: L.Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "Â© Mapbox".
		attribution: null,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level that tiles will be loaded at. By default the entire map.
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level that tiles will be loaded at.
		maxZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		options = L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	// @method getContainer: String
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof L.Point ? s : new L.Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (L.Browser.ielt9) { return; }

		L.DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			L.DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) { willPrune = true; }
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
			} else {
				L.DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			L.Util.falseFn(level.el.offsetWidth);
		}

		this._level = level;

		return level;
	},

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			L.DomUtil.remove(this._levels[z].el);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new L.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new L.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = Math.round(zoom);
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(level.el, translate, scale);
		} else {
			L.DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = map.getZoom();

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new L.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if its the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),

		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),

		    nw = map.wrapLatLng(map.unproject(nwPoint, coords.z)),
		    se = map.wrapLatLng(map.unproject(sePoint, coords.z));

		return new L.LatLngBounds(nw, se);
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new L.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		L.DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		L.DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
		}

		L.DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			L.DomUtil.setOpacity(tile.el, 0);
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

		// @event tileload: TileEvent
		// Fired when a tile loads.
		this.fire('tileload', {
			tile: tile.el,
			coords: coords
		});

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (L.Browser.ielt9 || !this._map._fadeAnimated) {
				L.Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(L.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new L.Point(
			this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new L.Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
L.gridLayer = function (options) {
	return new L.GridLayer(options);
};



/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` â€” zoom level, `{x}` and `{y}` â€” tile coordinates. `{r}` can be used to add @2x to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


L.TileLayer = L.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// Minimum zoom number.
		minZoom: 0,

		// @option maxZoom: Number = 18
		// Maximum zoom number.
		maxZoom: 18,

		// @option maxNativeZoom: Number = null
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: null,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
		L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: L.Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return L.Util.template(this._url, L.extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (L.Browser.ielt9) {
			setTimeout(L.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	getTileSize: function () {
		var map = this._map,
		    tileSize = L.GridLayer.prototype.getTileSize.call(this),
		    zoom = this._tileZoom + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom;

		// increase tile size when overscaling
		return zoomN !== null && zoom > zoomN ?
				tileSize.divideBy(map.getZoomScale(zoomN, zoom)).round() :
				tileSize;
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._tileZoom;

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom !== null ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;

				if (!tile.complete) {
					tile.src = L.Util.emptyImageUrl;
					L.DomUtil.remove(tile);
				}
			}
		}
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};



/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data Â© 2012 IEM Nexrad"
 * });
 * ```
 */

L.TileLayer.WMS = L.TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);

		return url +
			L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};



/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

L.ImageOverlay = L.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option attribution: String = null
		// An optional string containing HTML to be shown on the `Attribution control`
		attribution: null,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			L.DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	setBounds: function (bounds) {
		this._bounds = bounds;

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	getBounds: function () {
		return this._bounds;
	},

	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);

		L.DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};



/*
 * @class Icon
 * @aka L.Icon
 * @inherits Layer
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

L.Icon = L.Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = null
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	initialize: function (options) {
		L.setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = L.point(sizeOption),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
L.icon = function (options) {
	return new L.Icon(options);
};



/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + (L.Browser.retina && name === 'icon' ? '-2x' : '') + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src || '';

		if (src.match(leafletRe)) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());



/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

L.Marker = L.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. Set to new `L.Icon.Default()` by default.
		icon: new L.Icon.Default(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// FIXME: shadowPane is no longer a valid option
		nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		L.DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (L.Handler.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new L.Handler.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};



/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

L.DivIcon = L.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = L.point(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
L.divIcon = function (options) {
	return new L.DivIcon(options);
};



/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
L.Map.mergeOptions({
	closePopupOnClick: true
});

// @namespace DivOverlay
L.DivOverlay = L.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option zoomAnimation: Boolean = true
		// Whether to animate the popup on zoom. Disable it if you have
		// problems with Flash content inside popups.
		zoomAnimation: true,

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && this.options.zoomAnimation;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});



/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
L.Popup = L.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when user clicks the map (set globally by
		// the Map's [closePopupOnClick](#map-closepopuponclick) option).
		autoClose: true
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			this._source.on('preclick', L.DomEvent.stopPropagation);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			this._source.off('preclick', L.DomEvent.stopPropagation);
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'));

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		L.DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._zoomAnimated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return L.point(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
L.popup = function (options, source) {
	return new L.Popup(options, source);
};


// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof L.Popup)) {
			popup = new L.Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});



/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
L.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return this._popup.isOpen();
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		L.DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof L.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});



/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor || [0, 0];
	}
});



/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [6, -6], because the tooltip
 *   tip is 6px width and height. Remember to change this value if you override
 *   the tip in CSS.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
L.Tooltip = L.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(6, -6)
		// The offset of the tooltip position. Update it if you customize the
		// tooltip tip in CSS.
		offset: [6, -6],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = L.DomUtil.create('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_updatePosition: function () {
		var map = this._map,
		    pos = map.latLngToLayerPoint(this._latlng),
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(L.point(-tooltipWidth / 2, -tooltipHeight + offset.y + anchor.y));
		} else if (direction === 'bottom') {
			pos = pos.subtract(L.point(tooltipWidth / 2, offset.y));
		} else if (direction === 'center') {
			pos = pos.subtract(L.point(tooltipWidth / 2, tooltipHeight / 2 - anchor.y));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add([offset.x + anchor.x, anchor.y - tooltipHeight / 2]);
		} else {
			direction = 'left';
			pos = pos.subtract(L.point(offset.x + tooltipWidth + anchor.x, tooltipHeight / 2 - anchor.y));
		}

		L.DomUtil.removeClass(container, 'leaflet-tooltip-right');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-left');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-top');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		L.DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		L.DomUtil.setPosition(container, pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), offset;
		if (this.options.offset) {
			offset = L.point(this.options.offset);
			pos = pos.add(offset);
		}
		L.DomUtil.setPosition(this._container, pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return L.point(this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
L.tooltip = function (options, source) {
	return new L.Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof L.Tooltip)) {
			tooltip = new L.Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});



/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
L.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof L.Tooltip) {
			L.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = L.tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent) { this.openTooltip(); }

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove) {
		if (!remove && this._tooltipHandlersAdded) { return; }
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (L.Browser.touch) {
				events.click = this._openTooltip;
			}
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive) {
				L.DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});



/*
 * Tooltip extension to L.Marker, adding tooltip-related methods.
 */

L.Marker.include({
	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});



/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, â€¦): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});


// @factory L.layerGroup(layers: Layer[])
// Create a layer group, optionally given an initial set of layers.
L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};



/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that also has mouse events (propagated from members of the group) and a shared bindPopup method.
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a group!'); })
 * 	.addTo(map);
 * ```
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};



/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 */

L.Renderer = L.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = L.DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			L.DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);
	},

	_update: function () {
		// update pixel bounds of renderer container (for positioning/sizing/clipping later)
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});


L.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});



/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

L.Path = L.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	getEvents: function () {
		return {
			zoomend: this._project,
			moveend: this._update,
			viewreset: this._reset
		};
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in children classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});



/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	pointToSegmentDistance:  function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},


	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	clipSegment: function (a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = this._getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, round);
	},

	_getBitCode: function (p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};



/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[-122.68, 45.51],
 * 	[-122.43, 37.77],
 * 	[-118.2, 34.04]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[-122.68, 45.51],
 * 	 [-122.43, 37.77],
 * 	 [-118.2, 34.04]],
 * 	[[-73.91, 40.78],
 * 	 [-87.62, 41.83],
 * 	 [-96.72, 32.76]]
 * ];
 * ```
 */

L.Polyline = L.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = L.latLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = L.Polyline._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new L.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};

L.Polyline._flat = function (latlngs) {
	// true if it's a flat array of latlngs; false if nested
	return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};



/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

L.PolyUtil = {};

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
L.PolyUtil.clipPolygon = function (points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};



/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one â€” it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *   [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *     [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 *   ],
 *   [ // second polygon
 *     [[-109.05, 37],[-109.03, 41],[-102.05, 41],[-102.04, 37],[-109.05, 38]]
 *   ]
 * ];
 * ```
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		L.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (L.Polyline._flat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};



/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};



/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

L.CircleMarker = L.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};



/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], 200).addTo(map);
 * ```
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = L.extend({}, legacyOptions, {radius: options});
		}
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
L.circle = function (latlng, options, legacyOptions) {
	return new L.Circle(latlng, options, legacyOptions);
};



/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg();
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.SVG = L.Renderer.extend({

	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = L.SVG.create('g');
		this._container.appendChild(this._rootGroup);
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			L.DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		L.DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	}
});


// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:
L.extend(L.SVG, {
	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	create: function (name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	},

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
		    i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

// @namespace Browser; @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);


// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};



/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// @namespace Browser; @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._container);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._container);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}



/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas();
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.Canvas = L.Renderer.extend({

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		this._layers = this._layers || {};

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
			.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		this._drawnLayers = {};

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: L.Util.falseFn,

	_removePath: function (layer) {
		layer._removed = true;
		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		this._redrawBounds = layer._pxBounds;
		this._draw(true);
		layer._project();
		layer._update();
		this._draw();
		this._redrawBounds = null;
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		var padding = (layer.options.weight || 0) + 1;
		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
		this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));

		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_redraw: function () {
		this._redrawRequest = null;

		this._draw(true); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_draw: function (clear) {
		this._clear = clear;
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
			this._ctx.clip();
		}

		for (var id in this._layers) {
			layer = this._layers[id];
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
			if (clear && layer._removed) {
				delete layer._removed;
				delete this._layers[id];
			}
		}
		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		if (ctx.setLineDash) {
			ctx.setLineDash(layer.options && layer.options._dashArray || []);
		}

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var clear = this._clear,
		    options = layer.options;

		ctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';

		if (options.fill) {
			ctx.globalAlpha = clear ? 1 : options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			ctx.globalAlpha = clear ? 1 : options.opacity;

			// if clearing shape, do it with the previously drawn line width
			layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;

			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layers = [], layer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				L.DomEvent._fakeStop(e);
				layers.push(layer);
			}
		}
		if (layers.length)  {
			this._fireEvent(layers, e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseOut(e, point);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e, point) {
		var layer = this._hoveredLayer;
		if (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var id, layer;

		for (id in this._drawnLayers) {
			layer = this._drawnLayers[id];
			if (layer.options.interactive && layer._containsPoint(point)) {
				L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([layer], e, 'mouseover');
				this._hoveredLayer = layer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	// TODO _bringToFront & _bringToBack, pretty tricky

	_bringToFront: L.Util.falseFn,
	_bringToBack: L.Util.falseFn
});

// @namespace Browser; @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @namespace Canvas
// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};



/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJson(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

L.GeoJSON = L.FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to show a feature or not.
	 * The default is to show all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @function addData( <GeoJSON> data ): Layer
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @function resetStyle( <Path> layer ): Layer
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = L.Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @function setStyle( <Function> style ): Layer
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:
L.extend(L.GeoJSON, {
	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	// @function latLngToCoords(latlng: LatLng): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	asFeature: function (geojson) {
		if (geojson.type === 'Feature') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
L.Polyline.prototype.toGeoJSON = function () {
	var multi = !L.Polyline._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
L.Polygon.prototype.toGeoJSON = function () {
	var holes = !L.Polyline._flat(this._latlngs),
	    multi = holes && !L.Polyline._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


// @namespace LayerGroup
L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `GeometryCollection`).
	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
L.geoJSON = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};
// Backward compatibility.
L.geoJson = L.geoJSON;



/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.



var eventsKey = '_leaflet_events';

L.DomEvent = {

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function. If no function is specified,
	// it will remove all the listeners of that particular DOM event from the element.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.addPointerListener(obj, type, handler, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (L.DomEvent._isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel', L.DomEvent.stopPropagation);
	},

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	// @function stop(ev): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` or to the whole page if not specified.
	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	_wheelPxFactor: (L.Browser.win && L.Browser.chrome) ? 2 :
	                L.Browser.gecko ? window.devicePixelRatio :
	                1,

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	getWheelDelta: function (e) {
		return (L.Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / L.DomEvent._wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_isExternalTarget: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		handler(e);
	}
};

// @function addListener(â€¦): this
// Alias to [`L.DomEvent.on`](#domevent-on)
L.DomEvent.addListener = L.DomEvent.on;

// @function removeListener(â€¦): this
// Alias to [`L.DomEvent.off`](#domevent-off)
L.DomEvent.removeListener = L.DomEvent.off;



/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

L.Draggable = L.Evented.extend({

	options: {
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline: Boolean)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches) || !this._enabled) { return; }
		L.Draggable._dragging = true;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			L.DomUtil.preventOutline(this._element);
		}

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);

		L.DomEvent
			.on(document, L.Draggable.MOVE[e.type], this._onMove, this)
			.on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		L.DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
				.off(document, L.Draggable.MOVE[i], this._onMove, this)
				.off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		L.Draggable._dragging = false;
	}
});



/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});



/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !L.Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/secondÂ².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		L.DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-grab');
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDown: function () {
		this._map._stop();
	},

	_onDragStart: function () {
		var map = this._map;

		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = L.latLngBounds(this._map.options.maxBounds);

			this._offsetLimit = L.bounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);



/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

L.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);



/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);



/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				count = L.DomEvent._pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd() {
			if (doubleTap && !touch.cancelBubble) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;
		obj[pre + 'dblclick' + id] = handler;

		obj.addEventListener(touchstart, onTouchStart, false);
		obj.addEventListener(touchend, onTouchEnd, false);

		// On some platforms (notably, chrome on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		if (!L.Browser.edge) {
			obj.addEventListener('dblclick', handler, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    touchstart = obj[pre + this._touchstart + id],
		    touchend = obj[pre + this._touchend + id],
		    dblclick = obj[pre + 'dblclick' + id];

		obj.removeEventListener(this._touchstart, touchstart, false);
		obj.removeEventListener(this._touchend, touchend, false);
		if (!L.Browser.edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}
});



/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
	TAG_WHITE_LIST: ['INPUT', 'SELECT', 'OPTION'],

	_pointers: {},
	_pointersCount: 0,

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (this.TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					L.DomEvent.preventDefault(e);
				} else {
					return;
				}
			}

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!this._pointerDocListener) {
			var pointerUp = L.bind(this._globalPointerUp, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
			document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
			document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
			document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

			this._pointerDocListener = true;
		}
	},

	_globalPointerDown: function (e) {
		this._pointers[e.pointerId] = e;
		this._pointersCount++;
	},

	_globalPointerMove: function (e) {
		if (this._pointers[e.pointerId]) {
			this._pointers[e.pointerId] = e;
		}
	},

	_globalPointerUp: function (e) {
		delete this._pointers[e.pointerId];
		this._pointersCount--;
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});



/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: L.Browser.touch && !L.Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;


		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);

		var moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);

		L.DomEvent.preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when snapZoom is off, so snapZoom becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.snapZoom);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);



/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}



/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_resetState: function () {
		this._moved = false;
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		this._resetState();

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		setTimeout(L.bind(this._resetState, this), 0);

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);



/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
L.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = L.point(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27) {
			map.closePopup();

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);



/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch).
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});



/*
 * @class Control
 * @aka L.Control
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});



/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

L.Control.Zoom = L.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '-'
		// The text set on the 'zoom out' button.
		zoomOutText: '-',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		L.DomEvent
		    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
		    .on(link, 'click', L.DomEvent.stop)
		    .on(link, 'click', fn, this)
		    .on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

L.Control.Attribution = L.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		if (L.DomEvent) {
			L.DomEvent.disableClickPropagation(this._container);
		}

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new L.Control.Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};



/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

L.Control.Scale = L.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
L.control.scale = function (options) {
	return new L.Control.Scale(options);
};



/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control.html)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */


L.Control.Layers = L.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		return this._container;
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(L.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		L.DomEvent.disableClickPropagation(container);
		if (!L.Browser.touch) {
			L.DomEvent.disableScrollPropagation(container);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}

			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this.expand, this);
			} else {
				L.DomEvent.on(link, 'focus', this.expand, this);
			}

			// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this.collapse, this);
			// TODO keyboard accessibility
		} else {
			this.expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return this; }

		L.DomUtil.empty(this._baseLayersList);
		L.DomUtil.empty(this._overlaysList);

		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(L.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				addedLayers.push(layer);

			} else if (!input.checked && hasLayer) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			this._map.removeLayer(removedLayers[i]);
		}
		for (i = 0; i < addedLayers.length; i++) {
			this._map.addLayer(addedLayers[i]);
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};



/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

L.PosAnimation = L.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		L.DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});



/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});



/*
 * Extends L.Map to handle zoom animations.
 */

// @namespace Map
// @section Animation Options
L.Map.mergeOptions({
	// @option zoomAnimation: Boolean = true
	// Whether the map zoom animation is enabled. By default it's enabled
	// in all browsers that support CSS3 Transitions except Android.
	zoomAnimation: true,

	// @option zoomAnimationThreshold: Number = 4
	// Won't animate zoom if the zoom difference exceeds this value.
	zoomAnimationThreshold: 4
});

var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;

if (zoomAnimated) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {

			this._createAnimProxy();

			L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!zoomAnimated ? {} : {

	_createAnimProxy: function () {

		var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = L.DomUtil.TRANSFORM,
			    transform = proxy.style[prop];

			L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    ._moveStart(true)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		L.Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});



// @namespace Map
// @section Methods for modifying map state
L.Map.include({

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/Pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !L.Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = L.latLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = L.Util.requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	}
});



/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

// @namespace Map

L.Map.include({
	// @section Geolocation methods
	_defaultLocateOptions: {
		timeout: 10000,
		watch: false
		// setView: false
		// maxZoom: <Number>
		// maximumAge: 0
		// enableHighAccuracy: false
	},

	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
		    onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	}
});



}(window, document));

},{}],14:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('emitter');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only verison of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pushEncodedKeyValuePair(pairs, key, obj[key]);
    }
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (Array.isArray(val)) {
    return val.forEach(function(v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  } else if (isObject(val)) {
    for(var subkey in val) {
      pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
    }
    return;
  }
  pairs.push(encodeURIComponent(key)
    + '=' + encodeURIComponent(val));
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */),
        key = parts.shift(),
        val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this._setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this._parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype._setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype._setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (res.status < 200 || res.status >= 300) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
        new_err.original = err;
        new_err.response = res;
        new_err.status = res.status;
      }
    } catch(e) {
      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype._timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */

Request.prototype._appendQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self._timeoutError();
      if (self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = 'download';
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  this._appendQueryString();

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn){
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":15,"./request":17,"./request-base":16,"emitter":10}],15:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],16:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

exports.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){
      self.end(function(err, res){
        if (err) innerReject(err); else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
}

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
exports.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

exports.withCredentials = function(){
  // This is browser-only functionality. Node side is no-op.
  this._withCredentials = true;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

exports.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

exports.toJSON = function(){
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

exports._isHost = function _isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

exports.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || this._isHost(data)) return this;

  // default to json
  if (!type) this.type('json');
  return this;
};

},{"./is-object":15}],17:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],18:[function(require,module,exports){
'use strict';

module.exports = TinyQueue;

function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (data) for (var i = Math.floor(this.length / 2); i >= 0; i--) this._down(i);
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

TinyQueue.prototype = {

    push: function (item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    },

    pop: function () {
        var top = this.data[0];
        this.data[0] = this.data[this.length - 1];
        this.length--;
        this.data.pop();
        this._down(0);
        return top;
    },

    peek: function () {
        return this.data[0];
    },

    _up: function (pos) {
        var data = this.data,
            compare = this.compare;

        while (pos > 0) {
            var parent = Math.floor((pos - 1) / 2);
            if (compare(data[pos], data[parent]) < 0) {
                swap(data, parent, pos);
                pos = parent;

            } else break;
        }
    },

    _down: function (pos) {
        var data = this.data,
            compare = this.compare,
            len = this.length;

        while (true) {
            var left = 2 * pos + 1,
                right = left + 1,
                min = pos;

            if (left < len && compare(data[left], data[min]) < 0) min = left;
            if (right < len && compare(data[right], data[min]) < 0) min = right;

            if (min === pos) return;

            swap(data, min, pos);
            pos = min;
        }
    }
};

function swap(data, i, j) {
    var tmp = data[i];
    data[i] = data[j];
    data[j] = tmp;
}

},{}],19:[function(require,module,exports){
var signedArea = require('./signed_area');

/**
 * @param  {SweepEvent} e1
 * @param  {SweepEvent} e2
 * @return {Number}
 */
module.exports = function sweepEventsComp(e1, e2) {
  var p1 = e1.point;
  var p2 = e2.point;

  // Different x-coordinate
  if (p1[0] > p2[0]) return 1;
  if (p1[0] < p2[0]) return -1;

  // Different points, but same x-coordinate
  // Event with lower y-coordinate is processed first
  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;

  return specialCases(e1, e2, p1, p2);
};


function specialCases(e1, e2, p1, p2) {
  // Same coordinates, but one is a left endpoint and the other is
  // a right endpoint. The right endpoint is processed first
  if (e1.left !== e2.left)
    return e1.left ? 1 : -1;

  // Same coordinates, both events
  // are left endpoints or right endpoints.
  // not collinear
  if (signedArea (p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {
    // the event associate to the bottom segment is processed first
    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;
  }

  if (e1.isSubject === e2.isSubject) {
    return e1.contourId > e2.contourId ? -1 : 1;
  }
  return (!e1.isSubject && e2.isSubject) ? 1 : -1;
  //return e1.isSubject ? -1 : 1;
}
},{"./signed_area":25}],20:[function(require,module,exports){
var signedArea    = require('./signed_area');
var compareEvents = require('./compare_events');
var equals        = require('./equals');


/**
 * @param  {SweepEvent} le1
 * @param  {SweepEvent} le2
 * @return {Number}
 */
module.exports = function compareSegments(le1, le2) {
  if (le1 === le2) return 0;

  // Segments are not collinear
  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||
    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {

    // If they share their left endpoint use the right endpoint to sort
    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;

    // Different left endpoint: use the left endpoint to sort
    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;

    // has the line segment associated to e1 been inserted
    // into S after the line segment associated to e2 ?
    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;

    // The line segment associated to e2 has been inserted
    // into S after the line segment associated to e1
    return le1.isBelow(le2.point) ? -1 : 1;
  }

  // Segments are collinear
  if (le1.isSubject !== le2.isSubject) return (le1.isSubject && !le2.isSubject) ? 1 : -1;

  // Just a consistent criterion is used
  if (equals(le1.point, le2.point)) {
    return le1.contourId > le2.contourId ? -1 : 1;
  }

  return compareEvents(le1, le2) === 1 ? 1 : -1;
};

},{"./compare_events":19,"./equals":22,"./signed_area":25}],21:[function(require,module,exports){
module.exports = { 
  NORMAL:               0, 
  NON_CONTRIBUTING:     1, 
  SAME_TRANSITION:      2, 
  DIFFERENT_TRANSITION: 3
};

},{}],22:[function(require,module,exports){
module.exports = function equals(p1, p2) {
  return p1[0] === p2[0] && p1[1] === p2[1];
};
},{}],23:[function(require,module,exports){
var INTERSECTION    = 0;
var UNION           = 1;
var DIFFERENCE      = 2;
var XOR             = 3;

var EMPTY           = [];

var edgeType        = require('./edge_type');

var Queue           = require('tinyqueue');
var Tree            = require('bintrees').RBTree;
var SweepEvent      = require('./sweep_event');

var compareEvents   = require('./compare_events');
var compareSegments = require('./compare_segments');
var intersection    = require('./segment_intersection');
var equals          = require('./equals');

var max = Math.max;
var min = Math.min;

/**
 * @param  {<Array.<Number>} s1
 * @param  {<Array.<Number>} s2
 * @param  {Boolean}         isSubject
 * @param  {Queue}           eventQueue
 * @param  {Array.<Number>}  bbox
 */
function processSegment(s1, s2, isSubject, depth, eventQueue, bbox) {
  // var e = 1e5;
  // s1 = [Math.round(s1[0] * e) / e, Math.round(s1[1] * e) / e];
  // s2 = [Math.round(s2[0] * e) / e, Math.round(s2[1] * e) / e];
  // Possible degenerate condition.
  // if (equals(s1, s2)) return;

  var e1 = new SweepEvent(s1, false, undefined, isSubject);
  var e2 = new SweepEvent(s2, false, e1,        isSubject);
  e1.otherEvent = e2;

  e1.contourId = e2.contourId = depth;

  if (compareEvents(e1, e2) > 0) {
    e2.left = true;
  } else {
    e1.left = true;
  }

  bbox[0] = min(bbox[0], s1[0]);
  bbox[1] = min(bbox[1], s1[1]);
  bbox[2] = max(bbox[2], s1[0]);
  bbox[3] = max(bbox[3], s1[1]);

  // Pushing it so the queue is sorted from left to right,
  // with object on the left having the highest priority.
  eventQueue.push(e1);
  eventQueue.push(e2);
}

var contourId = 0;

function processPolygon(polygon, isSubject, depth, queue, bbox) {
  var i, len;
  if (typeof polygon[0][0] === 'number') {
    for (i = 0, len = polygon.length - 1; i < len; i++) {
      processSegment(polygon[i], polygon[i + 1], isSubject, depth + 1, queue, bbox);
    }
  } else {
    for (i = 0, len = polygon.length; i < len; i++) {
      contourId++;
      processPolygon(polygon[i], isSubject, contourId, queue, bbox);
    }
  }
}


function fillQueue(subject, clipping, sbbox, cbbox) {
  var eventQueue = new Queue(null, compareEvents);
  contourId = 0;

  processPolygon(subject,  true,  0, eventQueue, sbbox);
  processPolygon(clipping, false, 0, eventQueue, cbbox);

  return eventQueue;
}


function computeFields(event, prev, sweepLine, operation) {
  // compute inOut and otherInOut fields
  if (prev === null) {
    event.inOut      = false;
    event.otherInOut = true;

  // previous line segment in sweepline belongs to the same polygon
  } else if (event.isSubject === prev.isSubject) {
    event.inOut      = !prev.inOut;
    event.otherInOut = prev.otherInOut;

  // previous line segment in sweepline belongs to the clipping polygon
  } else {
    event.inOut      = !prev.otherInOut;
    event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;
  }

  // compute prevInResult field
  if (prev) {
    event.prevInResult = (!inResult(prev, operation) || prev.isVertical()) ?
       prev.prevInResult : prev;
  }
  // check if the line segment belongs to the Boolean operation
  event.inResult = inResult(event, operation);
}


function inResult(event, operation) {
  switch (event.type) {
    case edgeType.NORMAL:
      switch (operation) {
        case INTERSECTION:
          return !event.otherInOut;
        case UNION:
          return event.otherInOut;
        case DIFFERENCE:
          return (event.isSubject && event.otherInOut) ||
                 (!event.isSubject && !event.otherInOut);
        case XOR:
          return true;
      }
    case edgeType.SAME_TRANSITION:
      return operation === INTERSECTION || operation === UNION;
    case edgeType.DIFFERENT_TRANSITION:
      return operation === DIFFERENCE;
    case edgeType.NON_CONTRIBUTING:
      return false;
  }
  return false;
}


/**
 * @param  {SweepEvent} se1
 * @param  {SweepEvent} se2
 * @param  {Queue}      queue
 * @return {Number}
 */
function possibleIntersection(se1, se2, queue) {
  // that disallows self-intersecting polygons,
  // did cost us half a day, so I'll leave it
  // out of respect
  // if (se1.isSubject === se2.isSubject) return;

  var inter = intersection(
    se1.point, se1.otherEvent.point,
    se2.point, se2.otherEvent.point
  );

  var nintersections = inter ? inter.length : 0;
  if (nintersections === 0) return 0; // no intersection

  // the line segments intersect at an endpoint of both line segments
  if ((nintersections === 1) &&
      (equals(se1.point, se2.point) ||
       equals(se1.otherEvent.point, se2.otherEvent.point))) {
    return 0;
  }

  if (nintersections === 2 && se1.isSubject === se2.isSubject) {
    // console.warn('Edges of the same polygon overlap',
    //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);
    //throw new Error('Edges of the same polygon overlap');
    return 0;
  }

  // The line segments associated to se1 and se2 intersect
  if (nintersections === 1) {

    // if the intersection point is not an endpoint of se1
    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {
      divideSegment(se1, inter[0], queue);
    }

    // if the intersection point is not an endpoint of se2
    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {
      divideSegment(se2, inter[0], queue);
    }
    return 1;
  }

  // The line segments associated to se1 and se2 overlap
  var events        = [];
  var leftCoincide  = false;
  var rightCoincide = false;

  if (equals(se1.point, se2.point)) {
    leftCoincide = true; // linked
  } else if (compareEvents(se1, se2) === 1) {
    events.push(se2, se1);
  } else {
    events.push(se1, se2);
  }

  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {
    rightCoincide = true;
  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {
    events.push(se2.otherEvent, se1.otherEvent);
  } else {
    events.push(se1.otherEvent, se2.otherEvent);
  }

  if ((leftCoincide && rightCoincide) || leftCoincide) {
    // both line segments are equal or share the left endpoint
    se1.type = edgeType.NON_CONTRIBUTING;
    se2.type = (se1.inOut === se2.inOut) ?
      edgeType.SAME_TRANSITION :
      edgeType.DIFFERENT_TRANSITION;

    if (leftCoincide && !rightCoincide) {
      divideSegment(events[2].otherEvent, events[1].point, queue);
    }
    return 2;
  }

  // the line segments share the right endpoint
  if (rightCoincide) {
    divideSegment(events[0], events[1].point, queue);
    return 3;
  }

  // no line segment includes totally the other one
  if (events[0] !== events[3].otherEvent) {
    divideSegment(events[0], events[1].point, queue);
    divideSegment(events[1], events[2].point, queue);
    return 3;
  }

  // one line segment includes the other one
  divideSegment(events[0], events[1].point, queue);
  divideSegment(events[3].otherEvent, events[2].point, queue);

  return 3;
}


/**
 * @param  {SweepEvent} se
 * @param  {Array.<Number>} p
 * @param  {Queue} queue
 * @return {Queue}
 */
function divideSegment(se, p, queue)  {
  var r = new SweepEvent(p, false, se,            se.isSubject);
  var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);

  // avoid a rounding error. The left event would be processed after the right event
  if (compareEvents(l, se.otherEvent) > 0) {
    se.otherEvent.left = true;
    l.left = false;
  }

  // avoid a rounding error. The left event would be processed after the right event
  // if (compareEvents(se, r) > 0) {}

  se.otherEvent.otherEvent = l;
  se.otherEvent = r;

  queue.push(l);
  queue.push(r);

  return queue;
}


/* eslint-disable no-unused-vars, no-debugger */
function iteratorEquals(it1, it2) {
  return it1._cursor === it2._cursor;
}


function _renderSweepLine(sweepLine, pos, event) {
  var map = window.map;
  if (!map) return;
  if (window.sws) window.sws.forEach(function(p) {
    map.removeLayer(p);
  });
  window.sws = [];
  sweepLine.each(function(e) {
    var poly = L.polyline([e.point.slice().reverse(), e.otherEvent.point.slice().reverse()], { color: 'green' }).addTo(map);
    window.sws.push(poly);
  });

  if (window.vt) map.removeLayer(window.vt);
  var v = pos.slice();
  var b = map.getBounds();
  window.vt = L.polyline([[b.getNorth(), v[0]], [b.getSouth(), v[0]]], {color: 'green', weight: 1}).addTo(map);

  if (window.ps) map.removeLayer(window.ps);
  window.ps = L.polyline([event.point.slice().reverse(), event.otherEvent.point.slice().reverse()], {color: 'black', weight: 9, opacity: 0.4}).addTo(map);
  debugger;
}
/* eslint-enable no-unused-vars, no-debugger */


function subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation) {
  var sortedEvents = [];
  var prev, next;

  var sweepLine = new Tree(compareSegments);
  var sortedEvents = [];

  var rightbound = min(sbbox[2], cbbox[2]);

  var prev, next;

  while (eventQueue.length) {
    var event = eventQueue.pop();
    sortedEvents.push(event);

    // optimization by bboxes for intersection and difference goes here
    if ((operation === INTERSECTION && event.point[0] > rightbound) ||
        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {
      break;
    }

    if (event.left) {
      sweepLine.insert(event);
      // _renderSweepLine(sweepLine, event.point, event);

      next = sweepLine.findIter(event);
      prev = sweepLine.findIter(event);
      event.iterator = sweepLine.findIter(event);

      if (prev.data() !== sweepLine.min()) {
        prev.prev();
      } else {
        prev = sweepLine.findIter(sweepLine.max());
        prev.next();
      }
      next.next();

      computeFields(event, prev.data(), sweepLine, operation);

      if (next.data()) {
        if (possibleIntersection(event, next.data(), eventQueue) === 2) {
          computeFields(event, prev.data(), sweepLine, operation);
          computeFields(event, next.data(), sweepLine, operation);
        }
      }

      if (prev.data()) {
        if (possibleIntersection(prev.data(), event, eventQueue) === 2) {
          var prevprev = sweepLine.findIter(prev.data());
          if (prevprev.data() !== sweepLine.min()) {
            prevprev.prev();
          } else {
            prevprev = sweepLine.findIter(sweepLine.max());
            prevprev.next();
          }
          computeFields(prev.data(), prevprev.data(), sweepLine, operation);
          computeFields(event, prev.data(), sweepLine, operation);
        }
      }
    } else {
      event = event.otherEvent;
      next = sweepLine.findIter(event);
      prev = sweepLine.findIter(event);

      // _renderSweepLine(sweepLine, event.otherEvent.point, event);

      if (!(prev && next)) continue;

      if (prev.data() !== sweepLine.min()) {
        prev.prev();
      } else {
        prev = sweepLine.findIter(sweepLine.max());
        prev.next();
      }
      next.next();
      sweepLine.remove(event);

      //_renderSweepLine(sweepLine, event.otherEvent.point, event);

      if (next.data() && prev.data()) {
        possibleIntersection(prev.data(), next.data(), eventQueue);
      }
    }
  }
  return sortedEvents;
}


function swap (arr, i, n) {
  var temp = arr[i];
  arr[i] = arr[n];
  arr[n] = temp;
}


function changeOrientation(contour) {
  return contour.reverse();
}


function isArray (arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
}


function addHole(contour, idx) {
  if (!isArray(contour[0][0])) {
    contour = [contour];
  }
  contour[idx] = [];
  return contour;
}


function connectEdges(sortedEvents) {
  // copy the events in the result polygon to resultEvents array
  var resultEvents = [];
  var event, i, len;

  for (i = 0, len = sortedEvents.length; i < len; i++) {
    event = sortedEvents[i];
    if ((event.left && event.inResult) ||
      (!event.left && event.otherEvent.inResult)) {
      resultEvents.push(event);
    }
  }

  // Due to overlapping edges the resultEvents array can be not wholly sorted
  var sorted = false;
  while (!sorted) {
    sorted = true;
    for (i = 0, len = resultEvents.length; i < len; i++) {
      if ((i + 1) < len &&
        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {
        swap(resultEvents, i, i + 1);
        sorted = false;
      }
    }
  }

  for (i = 0, len = resultEvents.length; i < len; i++) {
    resultEvents[i].pos = i;
    if (!resultEvents[i].left) {
      var temp = resultEvents[i].pos;
      resultEvents[i].pos = resultEvents[i].otherEvent.pos;
      resultEvents[i].otherEvent.pos = temp;
    }
  }

  // "false"-filled array
  var processed = Array(resultEvents.length);
  var result = [];

  var depth  = [];
  var holeOf = [];
  var isHole = {};

  for (i = 0, len = resultEvents.length; i < len; i++) {
    if (processed[i]) continue;

    var contour = [];
    result.push(contour);

    var contourId = result.length - 1;
    depth.push(0);
    holeOf.push(-1);


    if (resultEvents[i].prevInResult) {
      var lowerContourId = resultEvents[i].prevInResult.contourId;
      if (!resultEvents[i].prevInResult.resultInOut) {
        addHole(result[lowerContourId], contourId);
        holeOf[contourId] = lowerContourId;
        depth[contourId]  = depth[lowerContourId] + 1;
        isHole[contourId] = true;
      } else if (isHole[lowerContourId]) {
        addHole(result[holeOf[lowerContourId]], contourId);
        holeOf[contourId] = holeOf[lowerContourId];
        depth[contourId]  = depth[lowerContourId];
        isHole[contourId] = true;
      }
    }

    var pos = i;
    var initial = resultEvents[i].point;
    contour.push(initial);

    while (pos >= i) {
      processed[pos] = true;

      if (resultEvents[pos].left) {
        resultEvents[pos].resultInOut = false;
        resultEvents[pos].contourId   = contourId;
      } else {
        resultEvents[pos].otherEvent.resultInOut = true;
        resultEvents[pos].otherEvent.contourId   = contourId;
      }

      pos = resultEvents[pos].pos;
      processed[pos] = true;

      contour.push(resultEvents[pos].point);
      pos = nextPos(pos, resultEvents, processed);
    }

    pos = pos === -1 ? i : pos;

    processed[pos] = processed[resultEvents[pos].pos] = true;
    resultEvents[pos].otherEvent.resultInOut = true;
    resultEvents[pos].otherEvent.contourId   = contourId;




    // depth is even
    /* eslint-disable no-bitwise */
    if (depth[contourId] & 1) {
      changeOrientation(contour);
    }
    /* eslint-enable no-bitwise */
  }

  return result;
}


/**
 * @param  {Number} pos
 * @param  {Array.<SweepEvent>} resultEvents
 * @param  {Array.<Boolean>}    processed
 * @return {Number}
 */
function nextPos(pos, resultEvents, processed) {
  var newPos = pos + 1;
  var length = resultEvents.length;
  while (newPos < length &&
         equals(resultEvents[newPos].point, resultEvents[pos].point)) {
    if (!processed[newPos]) {
      return newPos;
    } else {
      newPos = newPos + 1;
    }
  }

  newPos = pos - 1;

  while (processed[newPos]) {
    newPos = newPos - 1;
  }
  return newPos;
}


function trivialOperation(subject, clipping, operation) {
  var result = null;
  if (subject.length * clipping.length === 0) {
    if (operation === INTERSECTION) {
      result = EMPTY;
    } else if (operation === DIFFERENCE) {
      result = subject;
    } else if (operation === UNION || operation === XOR) {
      result = (subject.length === 0) ? clipping : subject;
    }
  }
  return result;
}


function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {
  var result = null;
  if (sbbox[0] > cbbox[2] ||
      cbbox[0] > sbbox[2] ||
      sbbox[1] > cbbox[3] ||
      cbbox[1] > sbbox[3]) {
    if (operation === INTERSECTION) {
      result = EMPTY;
    } else if (operation === DIFFERENCE) {
      result = subject;
    } else if (operation === UNION || operation === XOR) {
      result = subject.concat(clipping);
    }
  }
  return result;
}


function boolean(subject, clipping, operation) {
  var trivial = trivialOperation(subject, clipping, operation);
  if (trivial) {
    return trivial === EMPTY ? null : trivial;
  }
  var sbbox = [Infinity, Infinity, -Infinity, -Infinity];
  var cbbox = [Infinity, Infinity, -Infinity, -Infinity];

  var eventQueue = fillQueue(subject, clipping, sbbox, cbbox);

  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);
  if (trivial) {
    return trivial === EMPTY ? null : trivial;
  }
  var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);
  return connectEdges(sortedEvents);
}


module.exports = boolean;


module.exports.union = function(subject, clipping) {
  return boolean(subject, clipping, UNION);
};


module.exports.diff = function(subject, clipping) {
  return boolean(subject, clipping, DIFFERENCE);
};


module.exports.xor = function(subject, clipping) {
  return boolean(subject, clipping, XOR);
};


module.exports.intersection = function(subject, clipping) {
  return boolean(subject, clipping, INTERSECTION);
};


/**
 * @enum {Number}
 */
module.exports.operations = {
  INTERSECTION: INTERSECTION,
  DIFFERENCE:   DIFFERENCE,
  UNION:        UNION,
  XOR:          XOR
};


// for testing
module.exports.fillQueue            = fillQueue;
module.exports.computeFields        = computeFields;
module.exports.subdivideSegments    = subdivideSegments;
module.exports.divideSegment        = divideSegment;
module.exports.possibleIntersection = possibleIntersection;

},{"./compare_events":19,"./compare_segments":20,"./edge_type":21,"./equals":22,"./segment_intersection":24,"./sweep_event":26,"bintrees":6,"tinyqueue":18}],24:[function(require,module,exports){
var EPSILON = 1e-9;

/**
 * Finds the magnitude of the cross product of two vectors (if we pretend
 * they're in three dimensions)
 *
 * @param {Object} a First vector
 * @param {Object} b Second vector
 * @private
 * @returns {Number} The magnitude of the cross product
 */
function krossProduct(a, b) {
  return a[0] * b[1] - a[1] * b[0];
}

/**
 * Finds the dot product of two vectors.
 *
 * @param {Object} a First vector
 * @param {Object} b Second vector
 * @private
 * @returns {Number} The dot product
 */
function dotProduct(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Finds the intersection (if any) between two line segments a and b, given the
 * line segments' end points a1, a2 and b1, b2.
 *
 * This algorithm is based on Schneider and Eberly.
 * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf
 * Page 244.
 *
 * @param {Array.<Number>} a1 point of first line
 * @param {Array.<Number>} a2 point of first line
 * @param {Array.<Number>} b1 point of second line
 * @param {Array.<Number>} b2 point of second line
 * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints
 *                                         (meaning connected segments) as
 *                                         intersections
 * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of
 * intersection. If they overlap, the two end points of the overlapping segment.
 * Otherwise, null.
 */
module.exports = function(a1, a2, b1, b2, noEndpointTouch) {
  // The algorithm expects our lines in the form P + sd, where P is a point,
  // s is on the interval [0, 1], and d is a vector.
  // We are passed two points. P can be the first point of each pair. The
  // vector, then, could be thought of as the distance (in x and y components)
  // from the first point to the second point.
  // So first, let's make our vectors:
  var va = [a2[0] - a1[0], a2[1] - a1[1]];
  var vb = [b2[0] - b1[0], b2[1] - b1[1]];
  // We also define a function to convert back to regular point form:

  /* eslint-disable arrow-body-style */

  function toPoint(p, s, d) {
    return [
      p[0] + s * d[0],
      p[1] + s * d[1]
    ];
  }

  /* eslint-enable arrow-body-style */

  // The rest is pretty much a straight port of the algorithm.
  var e = [b1[0] - a1[0], b1[1] - a1[1]];
  var kross = krossProduct(va, vb);
  var sqrKross = kross * kross;
  var sqrLenA = dotProduct(va, va);
  var sqrLenB = dotProduct(vb, vb);

  // Check for line intersection. This works because of the properties of the
  // cross product -- specifically, two vectors are parallel if and only if the
  // cross product is the 0 vector. The full calculation involves relative error
  // to account for possible very small line segments. See Schneider & Eberly
  // for details.
  if (sqrKross > EPSILON * sqrLenA * sqrLenB) {
    // If they're not parallel, then (because these are line segments) they
    // still might not actually intersect. This code checks that the
    // intersection point of the lines is actually on both line segments.
    var s = krossProduct(e, vb) / kross;
    if (s < 0 || s > 1) {
      // not on line segment a
      return null;
    }
    var t = krossProduct(e, va) / kross;
    if (t < 0 || t > 1) {
      // not on line segment b
      return null;
    }
    return noEndpointTouch ? null : [toPoint(a1, s, va)];
  }

  // If we've reached this point, then the lines are either parallel or the
  // same, but the segments could overlap partially or fully, or not at all.
  // So we need to find the overlap, if any. To do that, we can use e, which is
  // the (vector) difference between the two initial points. If this is parallel
  // with the line itself, then the two lines are the same line, and there will
  // be overlap.
  var sqrLenE = dotProduct(e, e);
  kross = krossProduct(e, va);
  sqrKross = kross * kross;

  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {
    // Lines are just parallel, not the same. No overlap.
    return null;
  }

  var sa = dotProduct(va, e) / sqrLenA;
  var sb = sa + dotProduct(va, vb) / sqrLenA;
  var smin = Math.min(sa, sb);
  var smax = Math.max(sa, sb);

  // this is, essentially, the FindIntersection acting on floats from
  // Schneider & Eberly, just inlined into this function.
  if (smin <= 1 && smax >= 0) {

    // overlap on an end point
    if (smin === 1) {
      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];
    }

    if (smax === 0) {
      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];
    }

    if (noEndpointTouch && smin === 0 && smax === 1) return null;

    // There's overlap on a segment -- two points of intersection. Return both.
    return [
      toPoint(a1, smin > 0 ? smin : 0, va),
      toPoint(a1, smax < 1 ? smax : 1, va),
    ];
  }

  return null;
};

},{}],25:[function(require,module,exports){
/**
 * Signed area of the triangle (p0, p1, p2)
 * @param  {Array.<Number>} p0
 * @param  {Array.<Number>} p1
 * @param  {Array.<Number>} p2
 * @return {Number}
 */
module.exports = function signedArea(p0, p1, p2) {
  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);
};

},{}],26:[function(require,module,exports){
var signedArea = require('./signed_area');
var EdgeType   = require('./edge_type');


/**
 * Sweepline event
 *
 * @param {Array.<Number>}  point
 * @param {Boolean}         left
 * @param {SweepEvent=}     otherEvent
 * @param {Boolean}         isSubject
 * @param {Number}          edgeType
 */
function SweepEvent(point, left, otherEvent, isSubject, edgeType) {

  /**
   * Is left endpoint?
   * @type {Boolean}
   */
  this.left = left;

  /**
   * @type {Array.<Number>}
   */
  this.point = point;

  /**
   * Other edge reference
   * @type {SweepEvent}
   */
  this.otherEvent = otherEvent;

  /**
   * Belongs to source or clipping polygon
   * @type {Boolean}
   */
  this.isSubject = isSubject;

  /**
   * Edge contribution type
   * @type {Number}
   */
  this.type = edgeType || EdgeType.NORMAL;


  /**
   * In-out transition for the sweepline crossing polygon
   * @type {Boolean}
   */
  this.inOut = false;


  /**
   * @type {Boolean}
   */
  this.otherInOut = false;

  /**
   * Previous event in result?
   * @type {SweepEvent}
   */
  this.prevInResult = null;

  /**
   * Does event belong to result?
   * @type {Boolean}
   */
  this.inResult = false;


  // connection step

  /**
   * @type {Boolean}
   */
  this.resultInOut = false;
}


SweepEvent.prototype = {

  /**
   * @param  {Array.<Number>}  p
   * @return {Boolean}
   */
  isBelow: function(p) {
    return this.left ?
      signedArea (this.point, this.otherEvent.point, p) > 0 :
      signedArea (this.otherEvent.point, this.point, p) > 0;
  },


  /**
   * @param  {Array.<Number>}  p
   * @return {Boolean}
   */
  isAbove: function(p) {
    return !this.isBelow(p);
  },


  /**
   * @return {Boolean}
   */
  isVertical: function() {
    return this.point[0] === this.otherEvent.point[0];
  }
};

module.exports = SweepEvent;

},{"./edge_type":21,"./signed_area":25}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vL2pzL2Jvb2xlYW5vcGNvbnRyb2wuanMiLCJkZW1vL2pzL2Nvb3JkaW5hdGVzLmpzIiwiZGVtby9qcy9pbmRleC5qcyIsImRlbW8vanMvcG9seWdvbmNvbnRyb2wuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW50cmVlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW50cmVlcy9saWIvYmludHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9iaW50cmVlcy9saWIvcmJ0cmVlLmpzIiwibm9kZV9tb2R1bGVzL2JpbnRyZWVzL2xpYi90cmVlYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3RzL2Rpc3QvanN0cy5taW4uanMiLCJub2RlX21vZHVsZXMvbGVhZmxldC1lZGl0YWJsZS9zcmMvTGVhZmxldC5FZGl0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy90aW55cXVldWUvaW5kZXguanMiLCJzcmMvY29tcGFyZV9ldmVudHMuanMiLCJzcmMvY29tcGFyZV9zZWdtZW50cy5qcyIsInNyYy9lZGdlX3R5cGUuanMiLCJzcmMvZXF1YWxzLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3NlZ21lbnRfaW50ZXJzZWN0aW9uLmpzIiwic3JjL3NpZ25lZF9hcmVhLmpzIiwic3JjL3N3ZWVwX2V2ZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy83Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3NaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIkwuQm9vbGVhbkNvbnRyb2wgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcbiAgb3B0aW9uczoge1xuICAgIHBvc2l0aW9uOiAndG9wcmlnaHQnXG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1iYXInKTtcbiAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuYmFja2dyb3VuZCA9ICcjZmZmZmZmJztcbiAgICB0aGlzLl9jb250YWluZXIuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gW1xuICAgICAgJzxmb3JtPicsXG4gICAgICAgICc8dWwgc3R5bGU9XCJsaXN0LXN0eWxlOm5vbmU7IHBhZGRpbmctbGVmdDogMFwiPicsXG4gICAgICAgICAgJzxsaT4nLCc8bGFiZWw+JywgJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwib3BcIiB2YWx1ZT1cIjBcIiBjaGVja2VkIC8+JywgICcgSW50ZXJzZWN0aW9uJywgJzwvbGFiZWw+JywgJzwvbGk+JyxcbiAgICAgICAgICAnPGxpPicsJzxsYWJlbD4nLCAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJvcFwiIHZhbHVlPVwiMVwiIC8+JywgICcgVW5pb24nLCAnPC9sYWJlbD4nLCAnPC9saT4nLFxuICAgICAgICAgICc8bGk+JywnPGxhYmVsPicsICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cIm9wXCIgdmFsdWU9XCIyXCIgLz4nLCAgJyBEaWZmZXJlbmNlJywgJzwvbGFiZWw+JywgJzwvbGk+JyxcbiAgICAgICAgICAnPGxpPicsJzxsYWJlbD4nLCAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJvcFwiIHZhbHVlPVwiM1wiIC8+JywgICcgWG9yJywgJzwvbGFiZWw+JywgJzwvbGk+JyxcbiAgICAgICAgJzwvdWw+JyxcbiAgICAgICAgJzxpbnB1dCB0eXBlPVwic3VibWl0XCIgdmFsdWU9XCJSdW5cIj4nLCAnPGlucHV0IG5hbWU9XCJjbGVhclwiIHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIkNsZWFyIGxheWVyc1wiPicsXG4gICAgICAnPC9mb3JtPiddLmpvaW4oJycpO1xuICAgIHZhciBmb3JtID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2Zvcm0nKTtcbiAgICBMLkRvbUV2ZW50XG4gICAgICAub24oZm9ybSwgJ3N1Ym1pdCcsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgTC5Eb21FdmVudC5zdG9wKGV2dCk7XG4gICAgICAgIHZhciByYWRpb3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICAgICAgICBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9cmFkaW9dJykpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmFkaW9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJhZGlvc1tpXS5jaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2FsbGJhY2socGFyc2VJbnQocmFkaW9zW2ldLnZhbHVlKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpXG4gICAgICAub24oZm9ybVsnY2xlYXInXSwgJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIEwuRG9tRXZlbnQuc3RvcChldnQpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuY2xlYXIoKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgTC5Eb21FdmVudFxuICAgICAgLmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcilcbiAgICAgIC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICB9XG5cbn0pOyIsIkwuQ29vcmRpbmF0ZXMgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcbiAgb3B0aW9uczoge1xuICAgIHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnXG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWJhcicpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kID0gJyNmZmZmZmYnO1xuICAgIG1hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIH0sXG5cbiAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9ICc8c3BhbiBzdHlsZT1cInBhZGRpbmc6IDVweFwiPicgK1xuICAgICAgZS5sYXRsbmcubG5nLnRvRml4ZWQoMykgKyAnLCAnICsgZS5sYXRsbmcubGF0LnRvRml4ZWQoMykgKyAnPC9zcGFuPic7XG4gIH1cblxufSk7IiwidmFyIEwgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG52YXIgTGVhZmxldEVkaXRhYmxlID0gcmVxdWlyZSgnbGVhZmxldC1lZGl0YWJsZScpO1xucmVxdWlyZSgnLi9jb29yZGluYXRlcycpO1xucmVxdWlyZSgnLi9wb2x5Z29uY29udHJvbCcpO1xucmVxdWlyZSgnLi9ib29sZWFub3Bjb250cm9sJyk7XG52YXIgbWFydGluZXogPSByZXF1aXJlKCcuLi8uLi8nKTtcbi8vdmFyIG1hcnRpbmV6ID0gcmVxdWlyZSgnLi4vLi4vZGlzdC9tYXJ0aW5lei5taW4nKTtcbnZhciB4aHIgPSByZXF1aXJlKCdzdXBlcmFnZW50Jyk7XG4vLyB2YXIgdHVyZiA9IHJlcXVpcmUoJ3R1cmYnKTtcbnZhciBqc3RzID0gd2luZG93LmpzdHMgPSByZXF1aXJlKCdqc3RzJyk7XG5cbnZhciBtb2RlID0gL2dlby8udGVzdCh3aW5kb3cubG9jYXRpb24uaGFzaCkgPyAnZ2VvJyA6ICdvcnRob2dvbmFsJztcblxuY29uc29sZS5sb2cobW9kZSk7XG5cbnZhciBwYXRoID0gJy4uL3Rlc3QvZml4dHVyZXMvJztcbnZhciBmaWxlID0gbW9kZSA9PT0gJ2dlbycgPyAnYXNpYS5qc29uJyA6ICdob3JzZXNob2UuanNvbic7XG5cblxuXG52YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5kaXYuaWQgPSAnaW1hZ2UtbWFwJztcbmRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cbi8vIGNyZWF0ZSB0aGUgc2xpcHB5IG1hcFxudmFyIG1hcCA9IHdpbmRvdy5tYXAgPSBMLm1hcCgnaW1hZ2UtbWFwJywge1xuICBtaW5ab29tOiAxLFxuICBtYXhab29tOiAyMCxcbiAgY2VudGVyOiBbMCwgMF0sXG4gIHpvb206IDEsXG4gIGNyczogbW9kZSA9PT0gJ2dlbycgPyBMLkNSUy5FUFNHNDMyNiA6IEwuQ1JTLlNpbXBsZSxcbiAgZWRpdGFibGU6IHRydWVcbn0pO1xuXG5tYXAuYWRkQ29udHJvbChuZXcgTC5OZXdQb2x5Z29uQ29udHJvbCh7XG4gIGNhbGxiYWNrOiBtYXAuZWRpdFRvb2xzLnN0YXJ0UG9seWdvblxufSkpO1xubWFwLmFkZENvbnRyb2wobmV3IEwuQ29vcmRpbmF0ZXMoKSk7XG5tYXAuYWRkQ29udHJvbChuZXcgTC5Cb29sZWFuQ29udHJvbCh7XG4gIGNhbGxiYWNrOiBydW4sXG4gIGNsZWFyOiBjbGVhclxufSkpO1xuXG52YXIgZHJhd25JdGVtcyA9IHdpbmRvdy5kcmF3bkl0ZW1zID0gTC5nZW9Kc29uKCkuYWRkVG8obWFwKTtcblxuZnVuY3Rpb24gbG9hZERhdGEocGF0aCkge1xuICBjb25zb2xlLmxvZyhwYXRoKTtcbiAgLy8gdmFyIHR3b190cmlhbmdsZXMgPSByZXF1aXJlKCcuLi8uLi90ZXN0L2ZpeHR1cmVzL3R3b19zaGFwZXMuanNvbicpO1xuICAvLyB2YXIgb25lSW5zaWRlID0gcmVxdWlyZSgnLi4vLi4vdGVzdC9maXh0dXJlcy9vbmVfaW5zaWRlLmpzb24nKTtcbiAgLy8gdmFyIHR3b1BvaW50ZWRUcmlhbmdsZXMgPSByZXF1aXJlKCcuLi8uLi90ZXN0L2ZpeHR1cmVzL3R3b19wb2ludGVkX3RyaWFuZ2xlcy5qc29uJyk7XG4gIC8vIHZhciBzZWxmSW50ZXJzZWN0aW5nID0gcmVxdWlyZSgnLi4vLi4vdGVzdC9maXh0dXJlcy9zZWxmX2ludGVyc2VjdGluZy5qc29uJyk7XG4gIC8vIHZhciBob2xlcyA9IHJlcXVpcmUoJy4uLy4uL3Rlc3QvZml4dHVyZXMvaG9sZV9ob2xlLmpzb24nKTtcbiAgLy92YXIgZGF0YSA9ICByZXF1aXJlKCcuLi8uLi90ZXN0L2ZpeHR1cmVzL2luZG9uZXNpYS5qc29uJyk7XG4gIHhoclxuICAgIC5nZXQocGF0aClcbiAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgLmVuZChmdW5jdGlvbihlLCByKSB7XG4gICAgICBpZiAoIWUpIHtcbiAgICAgICAgZHJhd25JdGVtcy5hZGREYXRhKHIuYm9keSk7XG4gICAgICAgIG1hcC5maXRCb3VuZHMoZHJhd25JdGVtcy5nZXRCb3VuZHMoKS5wYWQoMC4wNSksIHsgYW5pbWF0ZTogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBkcmF3bkl0ZW1zLmNsZWFyTGF5ZXJzKCk7XG4gIHJlc3VsdHMuY2xlYXJMYXllcnMoKTtcbn1cblxudmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05SZWFkZXIoKTtcbnZhciB3cml0ZXIgPSBuZXcganN0cy5pby5HZW9KU09OV3JpdGVyKCk7XG5cblxuZnVuY3Rpb24gcnVuIChvcCkge1xuICB2YXIgbGF5ZXJzID0gZHJhd25JdGVtcy5nZXRMYXllcnMoKTtcbiAgaWYgKGxheWVycy5sZW5ndGggPCAyKSByZXR1cm47XG4gIHZhciBzdWJqZWN0ID0gbGF5ZXJzWzBdLnRvR2VvSlNPTigpO1xuICB2YXIgY2xpcHBpbmcgPSBsYXllcnNbMV0udG9HZW9KU09OKCk7XG5cbiAgY29uc29sZS5sb2coJ2lucHV0Jywgc3ViamVjdCwgY2xpcHBpbmcsIG9wKTtcblxuICBzdWJqZWN0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdWJqZWN0KSk7XG4gIGNsaXBwaW5nID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjbGlwcGluZykpO1xuXG5cbiAgY29uc29sZS50aW1lKCdtYXJ0aW5leicpO1xuICB2YXIgcmVzdWx0ID0gbWFydGluZXooc3ViamVjdC5nZW9tZXRyeS5jb29yZGluYXRlcywgY2xpcHBpbmcuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIG9wKTtcbiAgY29uc29sZS50aW1lRW5kKCdtYXJ0aW5leicpO1xuXG4gIGNvbnNvbGUudGltZSgnanN0cycpO1xuICB2YXIgcyA9IHJlYWRlci5yZWFkKHN1YmplY3QpO1xuICB2YXIgYyA9IHJlYWRlci5yZWFkKGNsaXBwaW5nKTtcbiAgdmFyIHJlcyA9IHdyaXRlci53cml0ZShzLmdlb21ldHJ5LmludGVyc2VjdGlvbihjLmdlb21ldHJ5KSk7XG5cbiAgY29uc29sZS50aW1lRW5kKCdqc3RzJyk7XG5cbiAgLy9jb25zb2xlLmxvZygncmVzdWx0JywgcmVzdWx0LCByZXMpO1xuXG4gIHJlc3VsdHMuY2xlYXJMYXllcnMoKTtcbiAgcmVzdWx0cy5hZGREYXRhKHtcbiAgICAndHlwZSc6ICdGZWF0dXJlJyxcbiAgICAnZ2VvbWV0cnknOiB7XG4gICAgICAndHlwZSc6ICdQb2x5Z29uJyxcbiAgICAgICdjb29yZGluYXRlcyc6IHJlc3VsdFxuICAgIH1cbiAgfSk7XG59XG5cbi8vZHJhd25JdGVtcy5hZGREYXRhKG9uZUluc2lkZSk7XG4vL2RyYXduSXRlbXMuYWRkRGF0YSh0d29Qb2ludGVkVHJpYW5nbGVzKTtcbi8vZHJhd25JdGVtcy5hZGREYXRhKHNlbGZJbnRlcnNlY3RpbmcpO1xuLy9kcmF3bkl0ZW1zLmFkZERhdGEoaG9sZXMpO1xuLy9kcmF3bkl0ZW1zLmFkZERhdGEoZGF0YSk7XG5cbm1hcC5vbignZWRpdGFibGU6Y3JlYXRlZCcsIGZ1bmN0aW9uKGV2dCkge1xuICBkcmF3bkl0ZW1zLmFkZExheWVyKGV2dC5sYXllcik7XG4gIGV2dC5sYXllci5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKChlLm9yaWdpbmFsRXZlbnQuY3RybEtleSB8fCBlLm9yaWdpbmFsRXZlbnQubWV0YUtleSkgJiYgdGhpcy5lZGl0RW5hYmxlZCgpKSB7XG4gICAgICB0aGlzLmVkaXRvci5uZXdIb2xlKGUubGF0bG5nKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciByZXN1bHRzID0gd2luZG93LnJlc3VsdHMgPSBMLmdlb0pzb24obnVsbCwge1xuICBzdHlsZTogZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICB3ZWlnaHQ6IDFcbiAgICB9O1xuICB9XG59KS5hZGRUbyhtYXApO1xuXG5sb2FkRGF0YShwYXRoICsgZmlsZSk7XG4iLCJMLkVkaXRDb250cm9sID0gTC5Db250cm9sLmV4dGVuZCh7XG5cbiAgb3B0aW9uczoge1xuICAgIHBvc2l0aW9uOiAndG9wbGVmdCcsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAga2luZDogJycsXG4gICAgaHRtbDogJydcbiAgfSxcblxuICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgIHZhciBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1jb250cm9sIGxlYWZsZXQtYmFyJyksXG4gICAgICAgIGxpbmsgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgJycsIGNvbnRhaW5lcik7XG5cbiAgICBsaW5rLmhyZWYgPSAnIyc7XG4gICAgbGluay50aXRsZSA9ICdDcmVhdGUgYSBuZXcgJyArIHRoaXMub3B0aW9ucy5raW5kO1xuICAgIGxpbmsuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmh0bWw7XG4gICAgTC5Eb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBMLkRvbUV2ZW50LnN0b3ApXG4gICAgICAgICAgICAgIC5vbihsaW5rLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LkxBWUVSID0gdGhpcy5vcHRpb25zLmNhbGxiYWNrLmNhbGwobWFwLmVkaXRUb29scyk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG59KTtcblxuTC5OZXdQb2x5Z29uQ29udHJvbCA9IEwuRWRpdENvbnRyb2wuZXh0ZW5kKHtcbiAgb3B0aW9uczoge1xuICAgIHBvc2l0aW9uOiAndG9wbGVmdCcsXG4gICAga2luZDogJ3BvbHlnb24nLFxuICAgIGh0bWw6ICfilrAnXG4gIH1cbn0pOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvaW5kZXgnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFJCVHJlZTogcmVxdWlyZSgnLi9saWIvcmJ0cmVlJyksXG4gICAgQmluVHJlZTogcmVxdWlyZSgnLi9saWIvYmludHJlZScpXG59O1xuIiwiXG52YXIgVHJlZUJhc2UgPSByZXF1aXJlKCcuL3RyZWViYXNlJyk7XG5cbmZ1bmN0aW9uIE5vZGUoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbn1cblxuTm9kZS5wcm90b3R5cGUuZ2V0X2NoaWxkID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgcmV0dXJuIGRpciA/IHRoaXMucmlnaHQgOiB0aGlzLmxlZnQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRfY2hpbGQgPSBmdW5jdGlvbihkaXIsIHZhbCkge1xuICAgIGlmKGRpcikge1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdmFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gdmFsO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEJpblRyZWUoY29tcGFyYXRvcikge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG59XG5cbkJpblRyZWUucHJvdG90eXBlID0gbmV3IFRyZWVCYXNlKCk7XG5cbi8vIHJldHVybnMgdHJ1ZSBpZiBpbnNlcnRlZCwgZmFsc2UgaWYgZHVwbGljYXRlXG5CaW5UcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYodGhpcy5fcm9vdCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBlbXB0eSB0cmVlXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBkaXIgPSAwO1xuXG4gICAgLy8gc2V0dXBcbiAgICB2YXIgcCA9IG51bGw7IC8vIHBhcmVudFxuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcblxuICAgIC8vIHNlYXJjaCBkb3duXG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBpZihub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpbnNlcnQgbmV3IG5vZGUgYXQgdGhlIGJvdHRvbVxuICAgICAgICAgICAgbm9kZSA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgcC5zZXRfY2hpbGQoZGlyLCBub2RlKTtcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcCBpZiBmb3VuZFxuICAgICAgICBpZih0aGlzLl9jb21wYXJhdG9yKG5vZGUuZGF0YSwgZGF0YSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpciA9IHRoaXMuX2NvbXBhcmF0b3Iobm9kZS5kYXRhLCBkYXRhKSA8IDA7XG5cbiAgICAgICAgLy8gdXBkYXRlIGhlbHBlcnNcbiAgICAgICAgcCA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmdldF9jaGlsZChkaXIpO1xuICAgIH1cbn07XG5cbi8vIHJldHVybnMgdHJ1ZSBpZiByZW1vdmVkLCBmYWxzZSBpZiBub3QgZm91bmRcbkJpblRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZih0aGlzLl9yb290ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaGVhZCA9IG5ldyBOb2RlKHVuZGVmaW5lZCk7IC8vIGZha2UgdHJlZSByb290XG4gICAgdmFyIG5vZGUgPSBoZWFkO1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLl9yb290O1xuICAgIHZhciBwID0gbnVsbDsgLy8gcGFyZW50XG4gICAgdmFyIGZvdW5kID0gbnVsbDsgLy8gZm91bmQgaXRlbVxuICAgIHZhciBkaXIgPSAxO1xuXG4gICAgd2hpbGUobm9kZS5nZXRfY2hpbGQoZGlyKSAhPT0gbnVsbCkge1xuICAgICAgICBwID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0X2NoaWxkKGRpcik7XG4gICAgICAgIHZhciBjbXAgPSB0aGlzLl9jb21wYXJhdG9yKGRhdGEsIG5vZGUuZGF0YSk7XG4gICAgICAgIGRpciA9IGNtcCA+IDA7XG5cbiAgICAgICAgaWYoY21wID09PSAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3VuZCAhPT0gbnVsbCkge1xuICAgICAgICBmb3VuZC5kYXRhID0gbm9kZS5kYXRhO1xuICAgICAgICBwLnNldF9jaGlsZChwLnJpZ2h0ID09PSBub2RlLCBub2RlLmdldF9jaGlsZChub2RlLmxlZnQgPT09IG51bGwpKTtcblxuICAgICAgICB0aGlzLl9yb290ID0gaGVhZC5yaWdodDtcbiAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmluVHJlZTtcblxuIiwiXG52YXIgVHJlZUJhc2UgPSByZXF1aXJlKCcuL3RyZWViYXNlJyk7XG5cbmZ1bmN0aW9uIE5vZGUoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnJlZCA9IHRydWU7XG59XG5cbk5vZGUucHJvdG90eXBlLmdldF9jaGlsZCA9IGZ1bmN0aW9uKGRpcikge1xuICAgIHJldHVybiBkaXIgPyB0aGlzLnJpZ2h0IDogdGhpcy5sZWZ0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0X2NoaWxkID0gZnVuY3Rpb24oZGlyLCB2YWwpIHtcbiAgICBpZihkaXIpIHtcbiAgICAgICAgdGhpcy5yaWdodCA9IHZhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHZhbDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBSQlRyZWUoY29tcGFyYXRvcikge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG59XG5cblJCVHJlZS5wcm90b3R5cGUgPSBuZXcgVHJlZUJhc2UoKTtcblxuLy8gcmV0dXJucyB0cnVlIGlmIGluc2VydGVkLCBmYWxzZSBpZiBkdXBsaWNhdGVcblJCVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciByZXQgPSBmYWxzZTtcblxuICAgIGlmKHRoaXMuX3Jvb3QgPT09IG51bGwpIHtcbiAgICAgICAgLy8gZW1wdHkgdHJlZVxuICAgICAgICB0aGlzLl9yb290ID0gbmV3IE5vZGUoZGF0YSk7XG4gICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGhlYWQgPSBuZXcgTm9kZSh1bmRlZmluZWQpOyAvLyBmYWtlIHRyZWUgcm9vdFxuXG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICB2YXIgbGFzdCA9IDA7XG5cbiAgICAgICAgLy8gc2V0dXBcbiAgICAgICAgdmFyIGdwID0gbnVsbDsgLy8gZ3JhbmRwYXJlbnRcbiAgICAgICAgdmFyIGdncCA9IGhlYWQ7IC8vIGdyYW5kLWdyYW5kLXBhcmVudFxuICAgICAgICB2YXIgcCA9IG51bGw7IC8vIHBhcmVudFxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIGdncC5yaWdodCA9IHRoaXMuX3Jvb3Q7XG5cbiAgICAgICAgLy8gc2VhcmNoIGRvd25cbiAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgaWYobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBuZXcgbm9kZSBhdCB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHAuc2V0X2NoaWxkKGRpciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaXNfcmVkKG5vZGUubGVmdCkgJiYgaXNfcmVkKG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sb3IgZmxpcFxuICAgICAgICAgICAgICAgIG5vZGUucmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQucmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodC5yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZml4IHJlZCB2aW9sYXRpb25cbiAgICAgICAgICAgIGlmKGlzX3JlZChub2RlKSAmJiBpc19yZWQocCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyMiA9IGdncC5yaWdodCA9PT0gZ3A7XG5cbiAgICAgICAgICAgICAgICBpZihub2RlID09PSBwLmdldF9jaGlsZChsYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBnZ3Auc2V0X2NoaWxkKGRpcjIsIHNpbmdsZV9yb3RhdGUoZ3AsICFsYXN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZ3Auc2V0X2NoaWxkKGRpcjIsIGRvdWJsZV9yb3RhdGUoZ3AsICFsYXN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY21wID0gdGhpcy5fY29tcGFyYXRvcihub2RlLmRhdGEsIGRhdGEpO1xuXG4gICAgICAgICAgICAvLyBzdG9wIGlmIGZvdW5kXG4gICAgICAgICAgICBpZihjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdCA9IGRpcjtcbiAgICAgICAgICAgIGRpciA9IGNtcCA8IDA7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBoZWxwZXJzXG4gICAgICAgICAgICBpZihncCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdncCA9IGdwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3AgPSBwO1xuICAgICAgICAgICAgcCA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5nZXRfY2hpbGQoZGlyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSByb290XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBoZWFkLnJpZ2h0O1xuICAgIH1cblxuICAgIC8vIG1ha2Ugcm9vdCBibGFja1xuICAgIHRoaXMuX3Jvb3QucmVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxuLy8gcmV0dXJucyB0cnVlIGlmIHJlbW92ZWQsIGZhbHNlIGlmIG5vdCBmb3VuZFxuUkJUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYodGhpcy5fcm9vdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGhlYWQgPSBuZXcgTm9kZSh1bmRlZmluZWQpOyAvLyBmYWtlIHRyZWUgcm9vdFxuICAgIHZhciBub2RlID0gaGVhZDtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgcCA9IG51bGw7IC8vIHBhcmVudFxuICAgIHZhciBncCA9IG51bGw7IC8vIGdyYW5kIHBhcmVudFxuICAgIHZhciBmb3VuZCA9IG51bGw7IC8vIGZvdW5kIGl0ZW1cbiAgICB2YXIgZGlyID0gMTtcblxuICAgIHdoaWxlKG5vZGUuZ2V0X2NoaWxkKGRpcikgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBkaXI7XG5cbiAgICAgICAgLy8gdXBkYXRlIGhlbHBlcnNcbiAgICAgICAgZ3AgPSBwO1xuICAgICAgICBwID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0X2NoaWxkKGRpcik7XG5cbiAgICAgICAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmF0b3IoZGF0YSwgbm9kZS5kYXRhKTtcblxuICAgICAgICBkaXIgPSBjbXAgPiAwO1xuXG4gICAgICAgIC8vIHNhdmUgZm91bmQgbm9kZVxuICAgICAgICBpZihjbXAgPT09IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1c2ggdGhlIHJlZCBub2RlIGRvd25cbiAgICAgICAgaWYoIWlzX3JlZChub2RlKSAmJiAhaXNfcmVkKG5vZGUuZ2V0X2NoaWxkKGRpcikpKSB7XG4gICAgICAgICAgICBpZihpc19yZWQobm9kZS5nZXRfY2hpbGQoIWRpcikpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNyID0gc2luZ2xlX3JvdGF0ZShub2RlLCBkaXIpO1xuICAgICAgICAgICAgICAgIHAuc2V0X2NoaWxkKGxhc3QsIHNyKTtcbiAgICAgICAgICAgICAgICBwID0gc3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKCFpc19yZWQobm9kZS5nZXRfY2hpbGQoIWRpcikpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBwLmdldF9jaGlsZCghbGFzdCk7XG4gICAgICAgICAgICAgICAgaWYoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZighaXNfcmVkKHNpYmxpbmcuZ2V0X2NoaWxkKCFsYXN0KSkgJiYgIWlzX3JlZChzaWJsaW5nLmdldF9jaGlsZChsYXN0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbG9yIGZsaXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHAucmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyMiA9IGdwLnJpZ2h0ID09PSBwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpc19yZWQoc2libGluZy5nZXRfY2hpbGQobGFzdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3Auc2V0X2NoaWxkKGRpcjIsIGRvdWJsZV9yb3RhdGUocCwgbGFzdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpc19yZWQoc2libGluZy5nZXRfY2hpbGQoIWxhc3QpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdwLnNldF9jaGlsZChkaXIyLCBzaW5nbGVfcm90YXRlKHAsIGxhc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGNvcnJlY3QgY29sb3JpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncGMgPSBncC5nZXRfY2hpbGQoZGlyMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBncGMucmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdwYy5sZWZ0LnJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3BjLnJpZ2h0LnJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSBhbmQgcmVtb3ZlIGlmIGZvdW5kXG4gICAgaWYoZm91bmQgIT09IG51bGwpIHtcbiAgICAgICAgZm91bmQuZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgcC5zZXRfY2hpbGQocC5yaWdodCA9PT0gbm9kZSwgbm9kZS5nZXRfY2hpbGQobm9kZS5sZWZ0ID09PSBudWxsKSk7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSByb290IGFuZCBtYWtlIGl0IGJsYWNrXG4gICAgdGhpcy5fcm9vdCA9IGhlYWQucmlnaHQ7XG4gICAgaWYodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yb290LnJlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VuZCAhPT0gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGlzX3JlZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgIT09IG51bGwgJiYgbm9kZS5yZWQ7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZV9yb3RhdGUocm9vdCwgZGlyKSB7XG4gICAgdmFyIHNhdmUgPSByb290LmdldF9jaGlsZCghZGlyKTtcblxuICAgIHJvb3Quc2V0X2NoaWxkKCFkaXIsIHNhdmUuZ2V0X2NoaWxkKGRpcikpO1xuICAgIHNhdmUuc2V0X2NoaWxkKGRpciwgcm9vdCk7XG5cbiAgICByb290LnJlZCA9IHRydWU7XG4gICAgc2F2ZS5yZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiBzYXZlO1xufVxuXG5mdW5jdGlvbiBkb3VibGVfcm90YXRlKHJvb3QsIGRpcikge1xuICAgIHJvb3Quc2V0X2NoaWxkKCFkaXIsIHNpbmdsZV9yb3RhdGUocm9vdC5nZXRfY2hpbGQoIWRpciksICFkaXIpKTtcbiAgICByZXR1cm4gc2luZ2xlX3JvdGF0ZShyb290LCBkaXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJCVHJlZTtcbiIsIlxuZnVuY3Rpb24gVHJlZUJhc2UoKSB7fVxuXG4vLyByZW1vdmVzIGFsbCBub2RlcyBmcm9tIHRoZSB0cmVlXG5UcmVlQmFzZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLnNpemUgPSAwO1xufTtcblxuLy8gcmV0dXJucyBub2RlIGRhdGEgaWYgZm91bmQsIG51bGwgb3RoZXJ3aXNlXG5UcmVlQmFzZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5fcm9vdDtcblxuICAgIHdoaWxlKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuX2NvbXBhcmF0b3IoZGF0YSwgcmVzLmRhdGEpO1xuICAgICAgICBpZihjID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgPSByZXMuZ2V0X2NoaWxkKGMgPiAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuLy8gcmV0dXJucyBpdGVyYXRvciB0byBub2RlIGlmIGZvdW5kLCBudWxsIG90aGVyd2lzZVxuVHJlZUJhc2UucHJvdG90eXBlLmZpbmRJdGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciByZXMgPSB0aGlzLl9yb290O1xuICAgIHZhciBpdGVyID0gdGhpcy5pdGVyYXRvcigpO1xuXG4gICAgd2hpbGUocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5fY29tcGFyYXRvcihkYXRhLCByZXMuZGF0YSk7XG4gICAgICAgIGlmKGMgPT09IDApIHtcbiAgICAgICAgICAgIGl0ZXIuX2N1cnNvciA9IHJlcztcbiAgICAgICAgICAgIHJldHVybiBpdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlci5fYW5jZXN0b3JzLnB1c2gocmVzKTtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5nZXRfY2hpbGQoYyA+IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRvIHRoZSB0cmVlIG5vZGUgYXQgb3IgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGl0ZW1cblRyZWVCYXNlLnByb3RvdHlwZS5sb3dlckJvdW5kID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHZhciBjdXIgPSB0aGlzLl9yb290O1xuICAgIHZhciBpdGVyID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIHZhciBjbXAgPSB0aGlzLl9jb21wYXJhdG9yO1xuXG4gICAgd2hpbGUoY3VyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjID0gY21wKGl0ZW0sIGN1ci5kYXRhKTtcbiAgICAgICAgaWYoYyA9PT0gMCkge1xuICAgICAgICAgICAgaXRlci5fY3Vyc29yID0gY3VyO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaXRlci5fYW5jZXN0b3JzLnB1c2goY3VyKTtcbiAgICAgICAgY3VyID0gY3VyLmdldF9jaGlsZChjID4gMCk7XG4gICAgfVxuXG4gICAgZm9yKHZhciBpPWl0ZXIuX2FuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjdXIgPSBpdGVyLl9hbmNlc3RvcnNbaV07XG4gICAgICAgIGlmKGNtcChpdGVtLCBjdXIuZGF0YSkgPCAwKSB7XG4gICAgICAgICAgICBpdGVyLl9jdXJzb3IgPSBjdXI7XG4gICAgICAgICAgICBpdGVyLl9hbmNlc3RvcnMubGVuZ3RoID0gaTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXRlci5fYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIGl0ZXI7XG59O1xuXG4vLyBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRvIHRoZSB0cmVlIG5vZGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGl0ZW1cblRyZWVCYXNlLnByb3RvdHlwZS51cHBlckJvdW5kID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHZhciBpdGVyID0gdGhpcy5sb3dlckJvdW5kKGl0ZW0pO1xuICAgIHZhciBjbXAgPSB0aGlzLl9jb21wYXJhdG9yO1xuXG4gICAgd2hpbGUoaXRlci5kYXRhKCkgIT09IG51bGwgJiYgY21wKGl0ZXIuZGF0YSgpLCBpdGVtKSA9PT0gMCkge1xuICAgICAgICBpdGVyLm5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcjtcbn07XG5cbi8vIHJldHVybnMgbnVsbCBpZiB0cmVlIGlzIGVtcHR5XG5UcmVlQmFzZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYocmVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlKHJlcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgIHJlcyA9IHJlcy5sZWZ0O1xuICAgIH1cblxuICAgIHJldHVybiByZXMuZGF0YTtcbn07XG5cbi8vIHJldHVybnMgbnVsbCBpZiB0cmVlIGlzIGVtcHR5XG5UcmVlQmFzZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYocmVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlKHJlcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICByZXMgPSByZXMucmlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5kYXRhO1xufTtcblxuLy8gcmV0dXJucyBhIG51bGwgaXRlcmF0b3Jcbi8vIGNhbGwgbmV4dCgpIG9yIHByZXYoKSB0byBwb2ludCB0byBhbiBlbGVtZW50XG5UcmVlQmFzZS5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMpO1xufTtcblxuLy8gY2FsbHMgY2Igb24gZWFjaCBub2RlJ3MgZGF0YSwgaW4gb3JkZXJcblRyZWVCYXNlLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oY2IpIHtcbiAgICB2YXIgaXQ9dGhpcy5pdGVyYXRvcigpLCBkYXRhO1xuICAgIHdoaWxlKChkYXRhID0gaXQubmV4dCgpKSAhPT0gbnVsbCkge1xuICAgICAgICBjYihkYXRhKTtcbiAgICB9XG59O1xuXG4vLyBjYWxscyBjYiBvbiBlYWNoIG5vZGUncyBkYXRhLCBpbiByZXZlcnNlIG9yZGVyXG5UcmVlQmFzZS5wcm90b3R5cGUucmVhY2ggPSBmdW5jdGlvbihjYikge1xuICAgIHZhciBpdD10aGlzLml0ZXJhdG9yKCksIGRhdGE7XG4gICAgd2hpbGUoKGRhdGEgPSBpdC5wcmV2KCkpICE9PSBudWxsKSB7XG4gICAgICAgIGNiKGRhdGEpO1xuICAgIH1cbn07XG5cblxuZnVuY3Rpb24gSXRlcmF0b3IodHJlZSkge1xuICAgIHRoaXMuX3RyZWUgPSB0cmVlO1xuICAgIHRoaXMuX2FuY2VzdG9ycyA9IFtdO1xuICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnNvciAhPT0gbnVsbCA/IHRoaXMuX2N1cnNvci5kYXRhIDogbnVsbDtcbn07XG5cbi8vIGlmIG51bGwtaXRlcmF0b3IsIHJldHVybnMgZmlyc3Qgbm9kZVxuLy8gb3RoZXJ3aXNlLCByZXR1cm5zIG5leHQgbm9kZVxuSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9jdXJzb3IgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl90cmVlLl9yb290O1xuICAgICAgICBpZihyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9taW5Ob2RlKHJvb3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZih0aGlzLl9jdXJzb3IucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIGdyZWF0ZXIgbm9kZSBpbiBzdWJ0cmVlLCBnbyB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgIC8vIGlmIGNvbWluZyBmcm9tIGEgcmlnaHQgY2hpbGQsIGNvbnRpbnVlIHVwIHRoZSBzdGFja1xuICAgICAgICAgICAgdmFyIHNhdmU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgc2F2ZSA9IHRoaXMuX2N1cnNvcjtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9hbmNlc3RvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHRoaXMuX2FuY2VzdG9ycy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUodGhpcy5fY3Vyc29yLnJpZ2h0ID09PSBzYXZlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHN1YnRyZWVcbiAgICAgICAgICAgIHRoaXMuX2FuY2VzdG9ycy5wdXNoKHRoaXMuX2N1cnNvcik7XG4gICAgICAgICAgICB0aGlzLl9taW5Ob2RlKHRoaXMuX2N1cnNvci5yaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2N1cnNvciAhPT0gbnVsbCA/IHRoaXMuX2N1cnNvci5kYXRhIDogbnVsbDtcbn07XG5cbi8vIGlmIG51bGwtaXRlcmF0b3IsIHJldHVybnMgbGFzdCBub2RlXG4vLyBvdGhlcndpc2UsIHJldHVybnMgcHJldmlvdXMgbm9kZVxuSXRlcmF0b3IucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9jdXJzb3IgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl90cmVlLl9yb290O1xuICAgICAgICBpZihyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhOb2RlKHJvb3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZih0aGlzLl9jdXJzb3IubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHNhdmU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgc2F2ZSA9IHRoaXMuX2N1cnNvcjtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9hbmNlc3RvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHRoaXMuX2FuY2VzdG9ycy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUodGhpcy5fY3Vyc29yLmxlZnQgPT09IHNhdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW5jZXN0b3JzLnB1c2godGhpcy5fY3Vyc29yKTtcbiAgICAgICAgICAgIHRoaXMuX21heE5vZGUodGhpcy5fY3Vyc29yLmxlZnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jdXJzb3IgIT09IG51bGwgPyB0aGlzLl9jdXJzb3IuZGF0YSA6IG51bGw7XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUuX21pbk5vZGUgPSBmdW5jdGlvbihzdGFydCkge1xuICAgIHdoaWxlKHN0YXJ0LmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fYW5jZXN0b3JzLnB1c2goc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHN0YXJ0LmxlZnQ7XG4gICAgfVxuICAgIHRoaXMuX2N1cnNvciA9IHN0YXJ0O1xufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLl9tYXhOb2RlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgICB3aGlsZShzdGFydC5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9hbmNlc3RvcnMucHVzaChzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmlnaHQ7XG4gICAgfVxuICAgIHRoaXMuX2N1cnNvciA9IHN0YXJ0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlQmFzZTtcblxuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLy8gSlNUUy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbi8vIExpY2Vuc2VzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VETHYxLnR4dFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VQTHYxLnR4dFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0xJQ0VOU0VfRVM2X0NPTExFQ1RJT05TLnR4dFxuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sZSk6ZSh0LmpzdHM9dC5qc3RzfHx7fSl9KHRoaXMsZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZSh0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pfWZ1bmN0aW9uIG4oKXt9ZnVuY3Rpb24gaSgpe31mdW5jdGlvbiByKCl7fWZ1bmN0aW9uIHMoKXt9ZnVuY3Rpb24gbygpe31mdW5jdGlvbiBhKCl7fWZ1bmN0aW9uIHUoKXt9ZnVuY3Rpb24gbCh0KXt0aGlzLm1lc3NhZ2U9dH1mdW5jdGlvbiBoKHQsZSl7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dH1mdW5jdGlvbiBjKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpbC5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyx0KX19ZnVuY3Rpb24gZigpe31mdW5jdGlvbiBnKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy56PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpZy5jYWxsKHRoaXMsMCwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zy5jYWxsKHRoaXMsdC54LHQueSx0LnopfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtnLmNhbGwodGhpcyxlLG4sZy5OVUxMX09SRElOQVRFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy54PWksdGhpcy55PXIsdGhpcy56PXN9fWZ1bmN0aW9uIGQoKXtpZih0aGlzLmRpbWVuc2lvbnNUb1Rlc3Q9MiwwPT09YXJndW1lbnRzLmxlbmd0aClkLmNhbGwodGhpcywyKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07aWYoMiE9PXQmJjMhPT10KXRocm93IG5ldyBpKFwib25seSAyIG9yIDMgZGltZW5zaW9ucyBtYXkgYmUgc3BlY2lmaWVkXCIpO3RoaXMuZGltZW5zaW9uc1RvVGVzdD10fX1mdW5jdGlvbiBwKCl7fWZ1bmN0aW9uIHYoKXt9ZnVuY3Rpb24gbSh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiB5KCl7fWZ1bmN0aW9uIHgodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gRSh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBJKCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB2JiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfWZ1bmN0aW9uIE4oKXtpZihJLmFwcGx5KHRoaXMpLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lbnN1cmVDYXBhY2l0eSh0Lmxlbmd0aCksdGhpcy5hZGQodCwhMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuZW5zdXJlQ2FwYWNpdHkoZS5sZW5ndGgpLHRoaXMuYWRkKGUsbil9fWZ1bmN0aW9uIEMoKXtpZih0aGlzLm1pbng9bnVsbCx0aGlzLm1heHg9bnVsbCx0aGlzLm1pbnk9bnVsbCx0aGlzLm1heHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuaW5pdChlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaW5pdChuLngsaS54LG4ueSxpLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXTt0aGlzLmluaXQocixzLG8sYSl9fWZ1bmN0aW9uIFMoKXt9ZnVuY3Rpb24gdygpe1MuY2FsbCh0aGlzLFwiUHJvamVjdGl2ZSBwb2ludCBub3QgcmVwcmVzZW50YWJsZSBvbiB0aGUgQ2FydGVzaWFuIHBsYW5lLlwiKX1mdW5jdGlvbiBMKCl7fWZ1bmN0aW9uIFIodCxlKXtyZXR1cm4gdC5pbnRlcmZhY2VzXyYmdC5pbnRlcmZhY2VzXygpLmluZGV4T2YoZSk+LTF9ZnVuY3Rpb24gVCgpe31mdW5jdGlvbiBQKHQpe3RoaXMuc3RyPXR9ZnVuY3Rpb24gYih0KXt0aGlzLnZhbHVlPXR9ZnVuY3Rpb24gTygpe31mdW5jdGlvbiBfKCl7aWYodGhpcy5oaT0wLHRoaXMubG89MCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuaW5pdChlKX1lbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBuPWFyZ3VtZW50c1swXTtfLmNhbGwodGhpcyxfLnBhcnNlKG4pKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3RoaXMuaW5pdChpLHIpfX1mdW5jdGlvbiBNKCl7fWZ1bmN0aW9uIEQoKXt9ZnVuY3Rpb24gQSgpe31mdW5jdGlvbiBGKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy53PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy54PTAsdGhpcy55PTAsdGhpcy53PTE7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLnc9MX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy54PWUsdGhpcy55PW4sdGhpcy53PTF9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEYmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgRil7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3RoaXMueD1pLnkqci53LXIueSppLncsdGhpcy55PXIueCppLnctaS54KnIudyx0aGlzLnc9aS54KnIueS1yLngqaS55fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXTt0aGlzLng9cy55LW8ueSx0aGlzLnk9by54LXMueCx0aGlzLnc9cy54Km8ueS1vLngqcy55fX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV0sbD1hcmd1bWVudHNbMl07dGhpcy54PWEsdGhpcy55PXUsdGhpcy53PWx9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGg9YXJndW1lbnRzWzBdLGM9YXJndW1lbnRzWzFdLGY9YXJndW1lbnRzWzJdLGQ9YXJndW1lbnRzWzNdLHA9aC55LWMueSx2PWMueC1oLngsbT1oLngqYy55LWMueCpoLnkseT1mLnktZC55LHg9ZC54LWYueCxFPWYueCpkLnktZC54KmYueTt0aGlzLng9dipFLXgqbSx0aGlzLnk9eSptLXAqRSx0aGlzLnc9cCp4LXkqdn19ZnVuY3Rpb24gRygpe31mdW5jdGlvbiBxKCl7fWZ1bmN0aW9uIEIoKXt0aGlzLmVudmVsb3BlPW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5TUklEPW51bGwsdGhpcy51c2VyRGF0YT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dCx0aGlzLlNSSUQ9dC5nZXRTUklEKCl9ZnVuY3Rpb24geigpe31mdW5jdGlvbiBWKCl7fWZ1bmN0aW9uIGsoKXt9ZnVuY3Rpb24gWSgpe31mdW5jdGlvbiBVKCl7fWZ1bmN0aW9uIFgoKXt9ZnVuY3Rpb24gSCgpe31mdW5jdGlvbiBXKCl7fWZ1bmN0aW9uIGooKXt9ZnVuY3Rpb24gSygpe31mdW5jdGlvbiBaKCl7fWZ1bmN0aW9uIFEoKXt9ZnVuY3Rpb24gSigpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1mdW5jdGlvbiAkKHQpe3JldHVybiBudWxsPT10PyRzOnQuY29sb3J9ZnVuY3Rpb24gdHQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnBhcmVudH1mdW5jdGlvbiBldCh0LGUpe251bGwhPT10JiYodC5jb2xvcj1lKX1mdW5jdGlvbiBudCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQubGVmdH1mdW5jdGlvbiBpdCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucmlnaHR9ZnVuY3Rpb24gcnQoKXt0aGlzLnJvb3RfPW51bGwsdGhpcy5zaXplXz0wfWZ1bmN0aW9uIHN0KCl7fWZ1bmN0aW9uIG90KCl7fWZ1bmN0aW9uIGF0KCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB2JiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfWZ1bmN0aW9uIHV0KCl7fWZ1bmN0aW9uIGx0KCl7fWZ1bmN0aW9uIGh0KCl7fWZ1bmN0aW9uIGN0KCl7fWZ1bmN0aW9uIGZ0KCl7dGhpcy5nZW9tZXRyaWVzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKEIuY2FsbCh0aGlzLGUpLG51bGw9PT10JiYodD1bXSksQi5oYXNOdWxsRWxlbWVudHModCkpdGhyb3cgbmV3IGkoXCJnZW9tZXRyaWVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTt0aGlzLmdlb21ldHJpZXM9dH1mdW5jdGlvbiBndCgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmdC5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBkdCgpe2lmKHRoaXMuZ2VvbT1udWxsLHRoaXMuZ2VvbUZhY3Q9bnVsbCx0aGlzLmJuUnVsZT1udWxsLHRoaXMuZW5kcG9pbnRNYXA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2R0LmNhbGwodGhpcyx0LFYuTU9EMl9CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5nZW9tPWUsdGhpcy5nZW9tRmFjdD1lLmdldEZhY3RvcnkoKSx0aGlzLmJuUnVsZT1ufX1mdW5jdGlvbiBwdCgpe3RoaXMuY291bnQ9bnVsbH1mdW5jdGlvbiB2dCgpe31mdW5jdGlvbiBtdCgpe31mdW5jdGlvbiB5dCgpe31mdW5jdGlvbiB4dCgpe31mdW5jdGlvbiBFdCgpe31mdW5jdGlvbiBJdCgpe31mdW5jdGlvbiBOdCgpe31mdW5jdGlvbiBDdCgpe31mdW5jdGlvbiBTdCgpe3RoaXMucG9pbnRzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0IuY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX1mdW5jdGlvbiB3dCgpe31mdW5jdGlvbiBMdCgpe3RoaXMuY29vcmRpbmF0ZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Qi5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfWZ1bmN0aW9uIFJ0KCl7fWZ1bmN0aW9uIFR0KCl7dGhpcy5zaGVsbD1udWxsLHRoaXMuaG9sZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoQi5jYWxsKHRoaXMsbiksbnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoKSksbnVsbD09PWUmJihlPVtdKSxCLmhhc051bGxFbGVtZW50cyhlKSl0aHJvdyBuZXcgaShcImhvbGVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTtpZih0LmlzRW1wdHkoKSYmQi5oYXNOb25FbXB0eUVsZW1lbnRzKGUpKXRocm93IG5ldyBpKFwic2hlbGwgaXMgZW1wdHkgYnV0IGhvbGVzIGFyZSBub3RcIik7dGhpcy5zaGVsbD10LHRoaXMuaG9sZXM9ZX1mdW5jdGlvbiBQdCgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmdC5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBidCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBpZSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2J0LmNhbGwodGhpcyxlLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCksZSl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxEKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBpZSl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO1N0LmNhbGwodGhpcyxuLGkpLHRoaXMudmFsaWRhdGVDb25zdHJ1Y3Rpb24oKX19ZnVuY3Rpb24gT3QoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZnQuY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gX3QoKXtpZih0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmlzVXNlckRhdGFDb3BpZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dH19ZnVuY3Rpb24gTXQoKXt9ZnVuY3Rpb24gRHQoKXt9ZnVuY3Rpb24gQXQoKXt9ZnVuY3Rpb24gRnQoKXt9ZnVuY3Rpb24gR3QoKXtpZih0aGlzLmRpbWVuc2lvbj0zLHRoaXMuY29vcmRpbmF0ZXM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO0d0LmNhbGwodGhpcyx0LDMpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtmb3IodmFyIG49MDtlPm47bisrKXRoaXMuY29vcmRpbmF0ZXNbbl09bmV3IGd9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGk9YXJndW1lbnRzWzBdO2lmKG51bGw9PT1pKXJldHVybiB0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7dGhpcy5kaW1lbnNpb249aS5nZXREaW1lbnNpb24oKSx0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheShpLnNpemUoKSkuZmlsbChudWxsKTtmb3IodmFyIG49MDtuPHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO24rKyl0aGlzLmNvb3JkaW5hdGVzW25dPWkuZ2V0Q29vcmRpbmF0ZUNvcHkobil9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV07dGhpcy5jb29yZGluYXRlcz1yLHRoaXMuZGltZW5zaW9uPXMsbnVsbD09PXImJih0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV07dGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkobykuZmlsbChudWxsKSx0aGlzLmRpbWVuc2lvbj1hO2Zvcih2YXIgbj0wO28+bjtuKyspdGhpcy5jb29yZGluYXRlc1tuXT1uZXcgZ319ZnVuY3Rpb24gcXQoKXt9ZnVuY3Rpb24gQnQodCxlKXtyZXR1cm4gdD09PWV8fHQhPT10JiZlIT09ZX1mdW5jdGlvbiB6dCh0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIHRoaXMmJnRoaXMuY29uc3RydWN0b3I9PT1uPyh0aGlzLl9rZXlzPVtdLHRoaXMuX3ZhbHVlcz1bXSx0aGlzLl9pdHA9W10sdGhpcy5vYmplY3RPbmx5PWUsdm9pZCh0JiZWdC5jYWxsKHRoaXMsdCkpKTpuZXcgbih0KX1yZXR1cm4gZXx8aW8odCxcInNpemVcIix7Z2V0Okp0fSksdC5jb25zdHJ1Y3Rvcj1uLG4ucHJvdG90eXBlPXQsbn1mdW5jdGlvbiBWdCh0KXt0aGlzLmFkZD90LmZvckVhY2godGhpcy5hZGQsdGhpcyk6dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3RoaXMuc2V0KHRbMF0sdFsxXSl9LHRoaXMpfWZ1bmN0aW9uIGt0KHQpe3JldHVybiB0aGlzLmhhcyh0KSYmKHRoaXMuX2tleXMuc3BsaWNlKG5vLDEpLHRoaXMuX3ZhbHVlcy5zcGxpY2Uobm8sMSksdGhpcy5faXRwLmZvckVhY2goZnVuY3Rpb24odCl7bm88dFswXSYmdFswXS0tfSkpLG5vPi0xfWZ1bmN0aW9uIFl0KHQpe3JldHVybiB0aGlzLmhhcyh0KT90aGlzLl92YWx1ZXNbbm9dOnZvaWQgMH1mdW5jdGlvbiBVdCh0LGUpe2lmKHRoaXMub2JqZWN0T25seSYmZSE9PU9iamVjdChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB2YWx1ZSB1c2VkIGFzIHdlYWsgY29sbGVjdGlvbiBrZXlcIik7aWYoZSE9PWV8fDA9PT1lKWZvcihubz10Lmxlbmd0aDtuby0tJiYhQnQodFtub10sZSk7KTtlbHNlIG5vPXQuaW5kZXhPZihlKTtyZXR1cm4gbm8+LTF9ZnVuY3Rpb24gWHQodCl7cmV0dXJuIFV0LmNhbGwodGhpcyx0aGlzLl9rZXlzLHQpfWZ1bmN0aW9uIEh0KHQsZSl7cmV0dXJuIHRoaXMuaGFzKHQpP3RoaXMuX3ZhbHVlc1tub109ZTp0aGlzLl92YWx1ZXNbdGhpcy5fa2V5cy5wdXNoKHQpLTFdPWUsdGhpc31mdW5jdGlvbiBXdCgpeyh0aGlzLl9rZXlzfHwwKS5sZW5ndGg9dGhpcy5fdmFsdWVzLmxlbmd0aD0wfWZ1bmN0aW9uIGp0KCl7cmV0dXJuIFF0KHRoaXMuX2l0cCx0aGlzLl9rZXlzKX1mdW5jdGlvbiBLdCgpe3JldHVybiBRdCh0aGlzLl9pdHAsdGhpcy5fdmFsdWVzKX1mdW5jdGlvbiBadCgpe3JldHVybiBRdCh0aGlzLl9pdHAsdGhpcy5fa2V5cyx0aGlzLl92YWx1ZXMpfWZ1bmN0aW9uIFF0KHQsZSxuKXt2YXIgaT1bMF0scj0hMTtyZXR1cm4gdC5wdXNoKGkpLHtuZXh0OmZ1bmN0aW9uKCl7dmFyIHMsbz1pWzBdO3JldHVybiFyJiZvPGUubGVuZ3RoPyhzPW4/W2Vbb10sbltvXV06ZVtvXSxpWzBdKyspOihyPSEwLHQuc3BsaWNlKHQuaW5kZXhPZihpKSwxKSkse2RvbmU6cix2YWx1ZTpzfX19fWZ1bmN0aW9uIEp0KCl7cmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGh9ZnVuY3Rpb24gJHQodCxlKXtmb3IodmFyIG49dGhpcy5lbnRyaWVzKCk7Oyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5kb25lKWJyZWFrO3QuY2FsbChlLGkudmFsdWVbMV0saS52YWx1ZVswXSx0aGlzKX19ZnVuY3Rpb24gdGUoKXt0aGlzLm1hcF89bmV3IHNvfWZ1bmN0aW9uIGVlKCl7aWYodGhpcy5tb2RlbFR5cGU9bnVsbCx0aGlzLnNjYWxlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5tb2RlbFR5cGU9ZWUuRkxPQVRJTkc7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG5lKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tb2RlbFR5cGU9dCx0PT09ZWUuRklYRUQmJnRoaXMuc2V0U2NhbGUoMSl9ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5tb2RlbFR5cGU9ZWUuRklYRUQsdGhpcy5zZXRTY2FsZShlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe3ZhciBuPWFyZ3VtZW50c1swXTt0aGlzLm1vZGVsVHlwZT1uLm1vZGVsVHlwZSx0aGlzLnNjYWxlPW4uc2NhbGV9fWZ1bmN0aW9uIG5lKCl7dGhpcy5uYW1lPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubmFtZT10LG5lLm5hbWVUb1R5cGVNYXAucHV0KHQsdGhpcyl9ZnVuY3Rpb24gaWUoKXtpZih0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW51bGwsdGhpcy5TUklEPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpaWUuY2FsbCh0aGlzLG5ldyBlZSwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSxHKSl7dmFyIHQ9YXJndW1lbnRzWzBdO2llLmNhbGwodGhpcyxuZXcgZWUsMCx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe3ZhciBlPWFyZ3VtZW50c1swXTtpZS5jYWxsKHRoaXMsZSwwLGllLmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07aWUuY2FsbCh0aGlzLG4saSxpZS5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5wcmVjaXNpb25Nb2RlbD1yLHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1vLHRoaXMuU1JJRD1zfX1mdW5jdGlvbiByZSh0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgaWV9ZnVuY3Rpb24gc2UodCl7dGhpcy5wYXJzZXI9bmV3IHJlKHQpfWZ1bmN0aW9uIG9lKCl7dGhpcy5yZXN1bHQ9bnVsbCx0aGlzLmlucHV0TGluZXM9QXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgyKX0pLHRoaXMuaW50UHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5pbnRMaW5lSW5kZXg9bnVsbCx0aGlzLl9pc1Byb3Blcj1udWxsLHRoaXMucGE9bnVsbCx0aGlzLnBiPW51bGwsdGhpcy5wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuaW50UHRbMF09bmV3IGcsdGhpcy5pbnRQdFsxXT1uZXcgZyx0aGlzLnBhPXRoaXMuaW50UHRbMF0sdGhpcy5wYj10aGlzLmludFB0WzFdLHRoaXMucmVzdWx0PTB9ZnVuY3Rpb24gYWUoKXtvZS5hcHBseSh0aGlzKX1mdW5jdGlvbiB1ZSgpe31mdW5jdGlvbiBsZSgpe3RoaXMucD1udWxsLHRoaXMuY3Jvc3NpbmdDb3VudD0wLHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wPXR9ZnVuY3Rpb24gaGUoKXt9ZnVuY3Rpb24gY2UoKXtpZih0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWNlLmNhbGwodGhpcyxuZXcgZyxuZXcgZyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2NlLmNhbGwodGhpcyx0LnAwLHQucDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnAwPWUsdGhpcy5wMT1ufWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxvPWFyZ3VtZW50c1szXTtjZS5jYWxsKHRoaXMsbmV3IGcoaSxyKSxuZXcgZyhzLG8pKX19ZnVuY3Rpb24gZmUoKXtpZih0aGlzLm1hdHJpeD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMubWF0cml4PUFycmF5KDMpLmZpbGwoKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkoMyl9KSx0aGlzLnNldEFsbChsdC5GQUxTRSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07ZmUuY2FsbCh0aGlzKSx0aGlzLnNldCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZmUpe3ZhciBlPWFyZ3VtZW50c1swXTtmZS5jYWxsKHRoaXMpLHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdPWUubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdLHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldPWUubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldLHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdPWUubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdLHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdPWUubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdLHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldPWUubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldLHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuRVhURVJJT1JdPWUubWF0cml4W0wuQk9VTkRBUlldW0wuRVhURVJJT1JdLHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPWUubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdLHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPWUubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldLHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuRVhURVJJT1JdPWUubWF0cml4W0wuRVhURVJJT1JdW0wuRVhURVJJT1JdfX1mdW5jdGlvbiBnZSgpe3RoaXMuYXJlYUJhc2VQdD1udWxsLHRoaXMudHJpYW5nbGVDZW50Mz1uZXcgZyx0aGlzLmFyZWFzdW0yPTAsdGhpcy5jZzM9bmV3IGcsdGhpcy5saW5lQ2VudFN1bT1uZXcgZyx0aGlzLnRvdGFsTGVuZ3RoPTAsdGhpcy5wdENvdW50PTAsdGhpcy5wdENlbnRTdW09bmV3IGc7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYXJlYUJhc2VQdD1udWxsLHRoaXMuYWRkKHQpfWZ1bmN0aW9uIGRlKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIHBlKCl7dGhpcy5hcnJheV89W119ZnVuY3Rpb24gdmUoKXt0aGlzLnRyZWVTZXQ9bmV3IGF0LHRoaXMubGlzdD1uZXcgSX1mdW5jdGlvbiBtZSgpe2lmKHRoaXMuZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLmlucHV0UHRzPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTttZS5jYWxsKHRoaXMsbWUuZXh0cmFjdENvb3JkaW5hdGVzKHQpLHQuZ2V0RmFjdG9yeSgpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbnB1dFB0cz12ZS5maWx0ZXJDb29yZGluYXRlcyhlKSx0aGlzLmdlb21GYWN0b3J5PW59fWZ1bmN0aW9uIHllKCl7dGhpcy5vcmlnaW49bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5vcmlnaW49dH1mdW5jdGlvbiB4ZSgpe3RoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5wcnVuZUVtcHR5R2VvbWV0cnk9ITAsdGhpcy5wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU9ITAsdGhpcy5wcmVzZXJ2ZUNvbGxlY3Rpb25zPSExLHRoaXMucHJlc2VydmVUeXBlPSExfWZ1bmN0aW9uIEVlKCl7aWYodGhpcy5zbmFwVG9sZXJhbmNlPTAsdGhpcy5zcmNQdHM9bnVsbCx0aGlzLnNlZz1uZXcgY2UsdGhpcy5hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz0hMSx0aGlzLl9pc0Nsb3NlZD0hMSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07RWUuY2FsbCh0aGlzLHQuZ2V0Q29vcmRpbmF0ZXMoKSxlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLnNyY1B0cz1uLHRoaXMuX2lzQ2xvc2VkPUVlLmlzQ2xvc2VkKG4pLHRoaXMuc25hcFRvbGVyYW5jZT1pfX1mdW5jdGlvbiBJZSgpe3RoaXMuc3JjR2VvbT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNyY0dlb209dH1mdW5jdGlvbiBOZSgpe2lmKHhlLmFwcGx5KHRoaXMpLHRoaXMuc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuc25hcFB0cz1udWxsLHRoaXMuaXNTZWxmU25hcD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc25hcFRvbGVyYW5jZT10LHRoaXMuc25hcFB0cz1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLnNuYXBUb2xlcmFuY2U9bix0aGlzLnNuYXBQdHM9aSx0aGlzLmlzU2VsZlNuYXA9cn19ZnVuY3Rpb24gQ2UoKXt0aGlzLmlzRmlyc3Q9ITAsdGhpcy5jb21tb25NYW50aXNzYUJpdHNDb3VudD01Myx0aGlzLmNvbW1vbkJpdHM9MCx0aGlzLmNvbW1vblNpZ25FeHA9bnVsbH1mdW5jdGlvbiBTZSgpe3RoaXMuY29tbW9uQ29vcmQ9bnVsbCx0aGlzLmNjRmlsdGVyPW5ldyB3ZX1mdW5jdGlvbiB3ZSgpe3RoaXMuY29tbW9uQml0c1g9bmV3IENlLHRoaXMuY29tbW9uQml0c1k9bmV3IENlfWZ1bmN0aW9uIExlKCl7dGhpcy50cmFucz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRyYW5zPXR9ZnVuY3Rpb24gUmUoKXt0aGlzLnBhcmVudD1udWxsLHRoaXMuYXRTdGFydD1udWxsLHRoaXMubWF4PW51bGwsdGhpcy5pbmRleD1udWxsLHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucGFyZW50PXQsdGhpcy5hdFN0YXJ0PSEwLHRoaXMuaW5kZXg9MCx0aGlzLm1heD10LmdldE51bUdlb21ldHJpZXMoKX1mdW5jdGlvbiBUZSgpe2lmKHRoaXMuYm91bmRhcnlSdWxlPVYuT0dDX1NGU19CT1VOREFSWV9SVUxFLHRoaXMuaXNJbj1udWxsLHRoaXMubnVtQm91bmRhcmllcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpdGhyb3cgbmV3IGkoXCJSdWxlIG11c3QgYmUgbm9uLW51bGxcIik7dGhpcy5ib3VuZGFyeVJ1bGU9dH19ZnVuY3Rpb24gUGUoKXt9ZnVuY3Rpb24gYmUoKXt9ZnVuY3Rpb24gT2UoKXt0aGlzLnB0cz1udWxsLHRoaXMuZGF0YT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz10LHRoaXMuZGF0YT1lfWZ1bmN0aW9uIF9lKCl7fWZ1bmN0aW9uIE1lKCl7dGhpcy5ib3VuZHM9bnVsbCx0aGlzLml0ZW09bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5ib3VuZHM9dCx0aGlzLml0ZW09ZX1mdW5jdGlvbiBEZSgpe3RoaXMuX3NpemU9bnVsbCx0aGlzLml0ZW1zPW51bGwsdGhpcy5fc2l6ZT0wLHRoaXMuaXRlbXM9bmV3IEksdGhpcy5pdGVtcy5hZGQobnVsbCl9ZnVuY3Rpb24gQWUoKXt9ZnVuY3Rpb24gRmUoKXt9ZnVuY3Rpb24gR2UoKXtpZih0aGlzLmNoaWxkQm91bmRhYmxlcz1uZXcgSSx0aGlzLmJvdW5kcz1udWxsLHRoaXMubGV2ZWw9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGV2ZWw9dH19ZnVuY3Rpb24gcWUoKXt0aGlzLmJvdW5kYWJsZTE9bnVsbCx0aGlzLmJvdW5kYWJsZTI9bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuaXRlbURpc3RhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuYm91bmRhYmxlMT10LHRoaXMuYm91bmRhYmxlMj1lLHRoaXMuaXRlbURpc3RhbmNlPW4sdGhpcy5fZGlzdGFuY2U9dGhpcy5kaXN0YW5jZSgpfWZ1bmN0aW9uIEJlKCl7aWYodGhpcy5yb290PW51bGwsdGhpcy5idWlsdD0hMSx0aGlzLml0ZW1Cb3VuZGFibGVzPW5ldyBJLHRoaXMubm9kZUNhcGFjaXR5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpQmUuY2FsbCh0aGlzLEJlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2YuaXNUcnVlKHQ+MSxcIk5vZGUgY2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKSx0aGlzLm5vZGVDYXBhY2l0eT10fX1mdW5jdGlvbiB6ZSgpe31mdW5jdGlvbiBWZSgpe31mdW5jdGlvbiBrZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWtlLmNhbGwodGhpcyxrZS5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtCZS5jYWxsKHRoaXMsdCl9fWZ1bmN0aW9uIFllKCl7dmFyIHQ9YXJndW1lbnRzWzBdO0dlLmNhbGwodGhpcyx0KX1mdW5jdGlvbiBVZSgpe31mdW5jdGlvbiBYZSgpe3RoaXMuc2VnU3RyaW5nPW51bGwsdGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5zZWdtZW50T2N0YW50PW51bGwsdGhpcy5faXNJbnRlcmlvcj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0aGlzLnNlZ1N0cmluZz10LHRoaXMuY29vcmQ9bmV3IGcoZSksdGhpcy5zZWdtZW50SW5kZXg9bix0aGlzLnNlZ21lbnRPY3RhbnQ9aSx0aGlzLl9pc0ludGVyaW9yPSFlLmVxdWFsczJEKHQuZ2V0Q29vcmRpbmF0ZShuKSl9ZnVuY3Rpb24gSGUoKXt0aGlzLm5vZGVNYXA9bmV3IHJ0LHRoaXMuZWRnZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmVkZ2U9dH1mdW5jdGlvbiBXZSgpe3RoaXMubm9kZUxpc3Q9bnVsbCx0aGlzLmVkZ2U9bnVsbCx0aGlzLm5vZGVJdD1udWxsLHRoaXMuY3Vyck5vZGU9bnVsbCx0aGlzLm5leHROb2RlPW51bGwsdGhpcy5jdXJyU2VnSW5kZXg9MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlTGlzdD10LHRoaXMuZWRnZT10LmdldEVkZ2UoKSx0aGlzLm5vZGVJdD10Lml0ZXJhdG9yKCksdGhpcy5yZWFkTmV4dE5vZGUoKX1mdW5jdGlvbiBqZSgpe31mdW5jdGlvbiBLZSgpe3RoaXMubm9kZUxpc3Q9bmV3IEhlKHRoaXMpLHRoaXMucHRzPW51bGwsdGhpcy5kYXRhPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucHRzPXQsdGhpcy5kYXRhPWV9ZnVuY3Rpb24gWmUoKXt0aGlzLnRlbXBFbnYxPW5ldyBDLHRoaXMudGVtcEVudjI9bmV3IEMsdGhpcy5vdmVybGFwU2VnMT1uZXcgY2UsdGhpcy5vdmVybGFwU2VnMj1uZXcgY2V9ZnVuY3Rpb24gUWUoKXt0aGlzLnB0cz1udWxsLHRoaXMuc3RhcnQ9bnVsbCx0aGlzLmVuZD1udWxsLHRoaXMuZW52PW51bGwsdGhpcy5jb250ZXh0PW51bGwsdGhpcy5pZD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0aGlzLnB0cz10LHRoaXMuc3RhcnQ9ZSx0aGlzLmVuZD1uLHRoaXMuY29udGV4dD1pfWZ1bmN0aW9uIEplKCl7fWZ1bmN0aW9uICRlKCl7fWZ1bmN0aW9uIHRuKCl7fWZ1bmN0aW9uIGVuKCl7aWYodGhpcy5zZWdJbnQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0U2VnbWVudEludGVyc2VjdG9yKHQpfX1mdW5jdGlvbiBubigpe2lmKHRoaXMubW9ub0NoYWlucz1uZXcgSSx0aGlzLmluZGV4PW5ldyBrZSx0aGlzLmlkQ291bnRlcj0wLHRoaXMubm9kZWRTZWdTdHJpbmdzPW51bGwsdGhpcy5uT3ZlcmxhcHM9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2VuLmNhbGwodGhpcyx0KX19ZnVuY3Rpb24gcm4oKXtaZS5hcHBseSh0aGlzKSx0aGlzLnNpPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2k9dH1mdW5jdGlvbiBzbigpe2lmKHRoaXMucHQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2wuY2FsbCh0aGlzLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtsLmNhbGwodGhpcyxzbi5tc2dXaXRoQ29vcmQoZSxuKSksdGhpcy5wdD1uZXcgZyhuKX19ZnVuY3Rpb24gb24oKXt9ZnVuY3Rpb24gYW4oKXt0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuaXNDaGVja0VuZFNlZ21lbnRzT25seT0hMSx0aGlzLmxpPW51bGwsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbj1udWxsLHRoaXMuaW50U2VnbWVudHM9bnVsbCx0aGlzLmludGVyc2VjdGlvbnM9bmV3IEksdGhpcy5pbnRlcnNlY3Rpb25Db3VudD0wLHRoaXMua2VlcEludGVyc2VjdGlvbnM9ITA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGk9dCx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uPW51bGx9ZnVuY3Rpb24gdW4oKXt0aGlzLmxpPW5ldyBhZSx0aGlzLnNlZ1N0cmluZ3M9bnVsbCx0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuc2VnSW50PW51bGwsdGhpcy5faXNWYWxpZD0hMDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZWdTdHJpbmdzPXR9ZnVuY3Rpb24gbG4oKXt0aGlzLm52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubnY9bmV3IHVuKGxuLnRvU2VnbWVudFN0cmluZ3ModCkpfWZ1bmN0aW9uIGhuKCl7dGhpcy5tYXBPcD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1hcE9wPXR9ZnVuY3Rpb24gY24oKXt9ZnVuY3Rpb24gZm4oKXtpZih0aGlzLmxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5sZW5ndGgpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5pbml0KDEpLHRoaXMubG9jYXRpb25bY24uT05dPWV9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZuKXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5pbml0KG4ubG9jYXRpb24ubGVuZ3RoKSxudWxsIT09bilmb3IodmFyIGk9MDtpPHRoaXMubG9jYXRpb24ubGVuZ3RoO2krKyl0aGlzLmxvY2F0aW9uW2ldPW4ubG9jYXRpb25baV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTt0aGlzLmluaXQoMyksdGhpcy5sb2NhdGlvbltjbi5PTl09cix0aGlzLmxvY2F0aW9uW2NuLkxFRlRdPXMsdGhpcy5sb2NhdGlvbltjbi5SSUdIVF09b319ZnVuY3Rpb24gZ24oKXtpZih0aGlzLmVsdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IGZuKHQpLHRoaXMuZWx0WzFdPW5ldyBmbih0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ24pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgZm4oZS5lbHRbMF0pLHRoaXMuZWx0WzFdPW5ldyBmbihlLmVsdFsxXSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFswXT1uZXcgZm4oTC5OT05FKSx0aGlzLmVsdFsxXT1uZXcgZm4oTC5OT05FKSx0aGlzLmVsdFtuXS5zZXRMb2NhdGlvbihpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5lbHRbMF09bmV3IGZuKHIscyxvKSx0aGlzLmVsdFsxXT1uZXcgZm4ocixzLG8pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXSxsPWFyZ3VtZW50c1syXSxoPWFyZ3VtZW50c1szXTt0aGlzLmVsdFswXT1uZXcgZm4oTC5OT05FLEwuTk9ORSxMLk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBmbihMLk5PTkUsTC5OT05FLEwuTk9ORSksdGhpcy5lbHRbYV0uc2V0TG9jYXRpb25zKHUsbCxoKX19ZnVuY3Rpb24gZG4oKXt0aGlzLnN0YXJ0RGU9bnVsbCx0aGlzLm1heE5vZGVEZWdyZWU9LTEsdGhpcy5lZGdlcz1uZXcgSSx0aGlzLnB0cz1uZXcgSSx0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpLHRoaXMucmluZz1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuc2hlbGw9bnVsbCx0aGlzLmhvbGVzPW5ldyBJLHRoaXMuZ2VvbWV0cnlGYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5jb21wdXRlUG9pbnRzKHQpLHRoaXMuY29tcHV0ZVJpbmcoKX1mdW5jdGlvbiBwbigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtkbi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiB2bigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtkbi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBtbigpe2lmKHRoaXMubGFiZWw9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzQ292ZXJlZD0hMSx0aGlzLl9pc0NvdmVyZWRTZXQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5sYWJlbD10fX1mdW5jdGlvbiB5bigpe21uLmFwcGx5KHRoaXMpLHRoaXMuY29vcmQ9bnVsbCx0aGlzLmVkZ2VzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuY29vcmQ9dCx0aGlzLmVkZ2VzPWUsdGhpcy5sYWJlbD1uZXcgZ24oMCxMLk5PTkUpfWZ1bmN0aW9uIHhuKCl7dGhpcy5ub2RlTWFwPW5ldyBydCx0aGlzLm5vZGVGYWN0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUZhY3Q9dH1mdW5jdGlvbiBFbigpe2lmKHRoaXMuZWRnZT1udWxsLHRoaXMubGFiZWw9bnVsbCx0aGlzLm5vZGU9bnVsbCx0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMuZHg9bnVsbCx0aGlzLmR5PW51bGwsdGhpcy5xdWFkcmFudD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lZGdlPXR9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9YXJndW1lbnRzWzJdO0VuLmNhbGwodGhpcyxlLG4saSxudWxsKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM107RW4uY2FsbCh0aGlzLHIpLHRoaXMuaW5pdChzLG8pLHRoaXMubGFiZWw9YX19ZnVuY3Rpb24gSW4oKXt0aGlzLl9pc0ZvcndhcmQ9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLnN5bT1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMubmV4dE1pbj1udWxsLHRoaXMuZWRnZVJpbmc9bnVsbCx0aGlzLm1pbkVkZ2VSaW5nPW51bGwsdGhpcy5kZXB0aD1bMCwtOTk5LC05OTldO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihFbi5jYWxsKHRoaXMsdCksdGhpcy5faXNGb3J3YXJkPWUsZSl0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKDApLHQuZ2V0Q29vcmRpbmF0ZSgxKSk7ZWxzZXt2YXIgbj10LmdldE51bVBvaW50cygpLTE7dGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZShuKSx0LmdldENvb3JkaW5hdGUobi0xKSl9dGhpcy5jb21wdXRlRGlyZWN0ZWRMYWJlbCgpfWZ1bmN0aW9uIE5uKCl7fWZ1bmN0aW9uIENuKCl7aWYodGhpcy5lZGdlcz1uZXcgSSx0aGlzLm5vZGVzPW51bGwsdGhpcy5lZGdlRW5kTGlzdD1uZXcgSSwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLm5vZGVzPW5ldyB4bihuZXcgTm4pO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVzPW5ldyB4bih0KX19ZnVuY3Rpb24gU24oKXt0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuc2hlbGxMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fWZ1bmN0aW9uIHduKCl7dGhpcy5vcD1udWxsLHRoaXMuZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5wdExvY2F0b3I9bnVsbCx0aGlzLmxpbmVFZGdlc0xpc3Q9bmV3IEksdGhpcy5yZXN1bHRMaW5lTGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5vcD10LHRoaXMuZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5wdExvY2F0b3I9bn1mdW5jdGlvbiBMbigpe3RoaXMub3A9bnVsbCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMucmVzdWx0UG9pbnRMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl07dGhpcy5vcD10LHRoaXMuZ2VvbWV0cnlGYWN0b3J5PWV9ZnVuY3Rpb24gUm4oKXt9ZnVuY3Rpb24gVG4oKXt0aGlzLmdlb209bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tPXR9ZnVuY3Rpb24gUG4oKXt0aGlzLmVkZ2VNYXA9bmV3IHJ0LHRoaXMuZWRnZUxpc3Q9bnVsbCx0aGlzLnB0SW5BcmVhTG9jYXRpb249W0wuTk9ORSxMLk5PTkVdfWZ1bmN0aW9uIGJuKCl7UG4uYXBwbHkodGhpcyksdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Q9bnVsbCx0aGlzLmxhYmVsPW51bGwsdGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkc9MSx0aGlzLkxJTktJTkdfVE9fT1VUR09JTkc9Mn1mdW5jdGlvbiBPbigpe05uLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIF9uKCl7dGhpcy5tY2U9bnVsbCx0aGlzLmNoYWluSW5kZXg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5tY2U9dCx0aGlzLmNoYWluSW5kZXg9ZX1mdW5jdGlvbiBNbigpe2lmKHRoaXMubGFiZWw9bnVsbCx0aGlzLnhWYWx1ZT1udWxsLHRoaXMuZXZlbnRUeXBlPW51bGwsdGhpcy5pbnNlcnRFdmVudD1udWxsLHRoaXMuZGVsZXRlRXZlbnRJbmRleD1udWxsLHRoaXMub2JqPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmV2ZW50VHlwZT1Nbi5ERUxFVEUsdGhpcy54VmFsdWU9dCx0aGlzLmluc2VydEV2ZW50PWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuZXZlbnRUeXBlPU1uLklOU0VSVCx0aGlzLmxhYmVsPW4sdGhpcy54VmFsdWU9aSx0aGlzLm9iaj1yfX1mdW5jdGlvbiBEbigpe31mdW5jdGlvbiBBbigpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLmhhc1Byb3Blcj0hMSx0aGlzLmhhc1Byb3BlckludGVyaW9yPSExLHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLmxpPW51bGwsdGhpcy5pbmNsdWRlUHJvcGVyPW51bGwsdGhpcy5yZWNvcmRJc29sYXRlZD1udWxsLHRoaXMuaXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wLHRoaXMuYmR5Tm9kZXM9bnVsbCx0aGlzLl9pc0RvbmU9ITEsdGhpcy5pc0RvbmVXaGVuUHJvcGVySW50PSExO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmxpPXQsdGhpcy5pbmNsdWRlUHJvcGVyPWUsdGhpcy5yZWNvcmRJc29sYXRlZD1ufWZ1bmN0aW9uIEZuKCl7RG4uYXBwbHkodGhpcyksdGhpcy5ldmVudHM9bmV3IEksdGhpcy5uT3ZlcmxhcHM9bnVsbH1mdW5jdGlvbiBHbigpe3RoaXMubWluPXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5tYXg9ci5ORUdBVElWRV9JTkZJTklUWX1mdW5jdGlvbiBxbigpe31mdW5jdGlvbiBCbigpe0duLmFwcGx5KHRoaXMpLHRoaXMuaXRlbT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLm1pbj10LHRoaXMubWF4PWUsdGhpcy5pdGVtPW59ZnVuY3Rpb24gem4oKXtHbi5hcHBseSh0aGlzKSx0aGlzLm5vZGUxPW51bGwsdGhpcy5ub2RlMj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm5vZGUxPXQsdGhpcy5ub2RlMj1lLHRoaXMuYnVpbGRFeHRlbnQodGhpcy5ub2RlMSx0aGlzLm5vZGUyKX1mdW5jdGlvbiBWbigpe3RoaXMubGVhdmVzPW5ldyBJLHRoaXMucm9vdD1udWxsLHRoaXMubGV2ZWw9MH1mdW5jdGlvbiBrbigpe2lmKHRoaXMubGluZXM9bnVsbCx0aGlzLmlzRm9yY2VkVG9MaW5lU3RyaW5nPSExLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lcz10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmxpbmVzPWUsdGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZz1ufX1mdW5jdGlvbiBZbigpe3RoaXMuaXRlbXM9bmV3IEl9ZnVuY3Rpb24gVW4oKXt0aGlzLmluZGV4PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKCFSKHQsUnQpKXRocm93IG5ldyBpKFwiQXJndW1lbnQgbXVzdCBiZSBQb2x5Z29uYWxcIik7dGhpcy5pbmRleD1uZXcgSG4odCl9ZnVuY3Rpb24gWG4oKXt0aGlzLmNvdW50ZXI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb3VudGVyPXR9ZnVuY3Rpb24gSG4oKXt0aGlzLmluZGV4PW5ldyBWbjt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWZ1bmN0aW9uIFduKCl7dGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5kaXN0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuY29vcmQ9bmV3IGcodCksdGhpcy5zZWdtZW50SW5kZXg9ZSx0aGlzLmRpc3Q9bn1mdW5jdGlvbiBqbigpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5lZGdlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fWZ1bmN0aW9uIEtuKCl7fWZ1bmN0aW9uIFpuKCl7dGhpcy5lPW51bGwsdGhpcy5wdHM9bnVsbCx0aGlzLnN0YXJ0SW5kZXg9bnVsbCx0aGlzLmVudjE9bmV3IEMsdGhpcy5lbnYyPW5ldyBDO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmU9dCx0aGlzLnB0cz10LmdldENvb3JkaW5hdGVzKCk7dmFyIGU9bmV3IEtuO3RoaXMuc3RhcnRJbmRleD1lLmdldENoYWluU3RhcnRJbmRpY2VzKHRoaXMucHRzKX1mdW5jdGlvbiBRbigpe3RoaXMuZGVwdGg9QXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgzKX0pO2Zvcih2YXIgdD0wOzI+dDt0KyspZm9yKHZhciBlPTA7Mz5lO2UrKyl0aGlzLmRlcHRoW3RdW2VdPVFuLk5VTExfVkFMVUV9ZnVuY3Rpb24gSm4oKXtpZihtbi5hcHBseSh0aGlzKSx0aGlzLnB0cz1udWxsLHRoaXMuZW52PW51bGwsdGhpcy5laUxpc3Q9bmV3IGpuKHRoaXMpLHRoaXMubmFtZT1udWxsLHRoaXMubWNlPW51bGwsdGhpcy5faXNJc29sYXRlZD0hMCx0aGlzLmRlcHRoPW5ldyBRbix0aGlzLmRlcHRoRGVsdGE9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0puLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz1lLHRoaXMubGFiZWw9bn19ZnVuY3Rpb24gJG4oKXtpZihDbi5hcHBseSh0aGlzKSx0aGlzLnBhcmVudEdlb209bnVsbCx0aGlzLmxpbmVFZGdlTWFwPW5ldyB0ZSx0aGlzLmJvdW5kYXJ5Tm9kZVJ1bGU9bnVsbCx0aGlzLnVzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITAsdGhpcy5hcmdJbmRleD1udWxsLHRoaXMuYm91bmRhcnlOb2Rlcz1udWxsLHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMSx0aGlzLmludmFsaWRQb2ludD1udWxsLHRoaXMuYXJlYVB0TG9jYXRvcj1udWxsLHRoaXMucHRMb2NhdG9yPW5ldyBUZSwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdOyRuLmNhbGwodGhpcyx0LGUsVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmFyZ0luZGV4PW4sdGhpcy5wYXJlbnRHZW9tPWksdGhpcy5ib3VuZGFyeU5vZGVSdWxlPXIsbnVsbCE9PWkmJnRoaXMuYWRkKGkpfX1mdW5jdGlvbiB0aSgpe2lmKHRoaXMubGk9bmV3IGFlLHRoaXMucmVzdWx0UHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmFyZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuYXJnPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLHRoaXMuYXJnWzBdPW5ldyAkbigwLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsZSxuLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07aS5nZXRQcmVjaXNpb25Nb2RlbCgpLmNvbXBhcmVUbyhyLmdldFByZWNpc2lvbk1vZGVsKCkpPj0wP3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oaS5nZXRQcmVjaXNpb25Nb2RlbCgpKTp0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHIuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5hcmc9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5hcmdbMF09bmV3ICRuKDAsaSxzKSx0aGlzLmFyZ1sxXT1uZXcgJG4oMSxyLHMpfX1mdW5jdGlvbiBlaSgpe3RoaXMucHRzPW51bGwsdGhpcy5fb3JpZW50YXRpb249bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9dCx0aGlzLl9vcmllbnRhdGlvbj1laS5vcmllbnRhdGlvbih0KX1mdW5jdGlvbiBuaSgpe3RoaXMuZWRnZXM9bmV3IEksdGhpcy5vY2FNYXA9bmV3IHJ0fWZ1bmN0aW9uIGlpKCl7dGhpcy5wdExvY2F0b3I9bmV3IFRlLHRoaXMuZ2VvbUZhY3Q9bnVsbCx0aGlzLnJlc3VsdEdlb209bnVsbCx0aGlzLmdyYXBoPW51bGwsdGhpcy5lZGdlTGlzdD1uZXcgbmksdGhpcy5yZXN1bHRQb2x5TGlzdD1uZXcgSSx0aGlzLnJlc3VsdExpbmVMaXN0PW5ldyBJLHRoaXMucmVzdWx0UG9pbnRMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsdCxlKSx0aGlzLmdyYXBoPW5ldyBDbihuZXcgT24pLHRoaXMuZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCl9ZnVuY3Rpb24gcmkoKXt0aGlzLmdlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5jYnI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5nZW9tWzBdPXQsdGhpcy5nZW9tWzFdPWUsdGhpcy5jb21wdXRlU25hcFRvbGVyYW5jZSgpfWZ1bmN0aW9uIHNpKCl7dGhpcy5nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21bMF09dCx0aGlzLmdlb21bMV09ZX1mdW5jdGlvbiBvaSgpe3RoaXMuZmFjdG9yeT1udWxsLHRoaXMuaW50ZXJpb3JQb2ludD1udWxsLHRoaXMubWF4V2lkdGg9MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHRoaXMuYWRkKHQpfWZ1bmN0aW9uIGFpKCl7dGhpcy5wb2x5PW51bGwsdGhpcy5jZW50cmVZPW51bGwsdGhpcy5oaVk9ci5NQVhfVkFMVUUsdGhpcy5sb1k9LXIuTUFYX1ZBTFVFO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBvbHk9dCx0aGlzLmhpWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNYXhZKCksdGhpcy5sb1k9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWluWSgpLHRoaXMuY2VudHJlWT1vaS5hdmcodGhpcy5sb1ksdGhpcy5oaVkpfWZ1bmN0aW9uIHVpKCl7dGhpcy5jZW50cm9pZD1udWxsLHRoaXMubWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5pbnRlcmlvclBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY2VudHJvaWQ9dC5nZXRDZW50cm9pZCgpLmdldENvb3JkaW5hdGUoKSx0aGlzLmFkZEludGVyaW9yKHQpLG51bGw9PT10aGlzLmludGVyaW9yUG9pbnQmJnRoaXMuYWRkRW5kcG9pbnRzKHQpfWZ1bmN0aW9uIGxpKCl7dGhpcy5jZW50cm9pZD1udWxsLHRoaXMubWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5pbnRlcmlvclBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY2VudHJvaWQ9dC5nZXRDZW50cm9pZCgpLmdldENvb3JkaW5hdGUoKSx0aGlzLmFkZCh0KX1mdW5jdGlvbiBoaSgpe31mdW5jdGlvbiBjaSgpe3RoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5wMj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLnAwPXQsdGhpcy5wMT1lLHRoaXMucDI9bn1mdW5jdGlvbiBmaSgpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLmV4dHJlbWFsUHRzPW51bGwsdGhpcy5jZW50cmU9bnVsbCx0aGlzLnJhZGl1cz0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0PXR9ZnVuY3Rpb24gZ2koKXtpZih0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuaXNDb252ZXg9bnVsbCx0aGlzLmNvbnZleEh1bGxQdHM9bnVsbCx0aGlzLm1pbkJhc2VTZWc9bmV3IGNlLHRoaXMubWluV2lkdGhQdD1udWxsLHRoaXMubWluUHRJbmRleD1udWxsLHRoaXMubWluV2lkdGg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2dpLmNhbGwodGhpcyx0LCExKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbnB1dEdlb209ZSx0aGlzLmlzQ29udmV4PW59fWZ1bmN0aW9uIGRpKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZnVuY3Rpb24gcGkoKXt4ZS5hcHBseSh0aGlzKSx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH1mdW5jdGlvbiB2aSgpe3RoaXMuX29yaWc9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuX29yaWc9dH1mdW5jdGlvbiBtaSgpe3RoaXMuX2lzTWFya2VkPSExO3ZhciB0PWFyZ3VtZW50c1swXTt2aS5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24geWkoKXt0aGlzLnZlcnRleE1hcD1uZXcgdGV9ZnVuY3Rpb24geGkoKXt0aGlzLl9pc1N0YXJ0PSExO3ZhciB0PWFyZ3VtZW50c1swXTttaS5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24gRWkoKXt5aS5hcHBseSh0aGlzKX1mdW5jdGlvbiBJaSgpe3RoaXMucmVzdWx0PW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5ncmFwaD1udWxsLHRoaXMubGluZXM9bmV3IEksdGhpcy5ub2RlRWRnZVN0YWNrPW5ldyBwZSx0aGlzLnJpbmdTdGFydEVkZ2U9bnVsbCx0aGlzLmdyYXBoPW5ldyBFaX1mdW5jdGlvbiBOaSgpe3RoaXMuaXRlbXM9bmV3IEksdGhpcy5zdWJub2RlPW5ldyBBcnJheSg0KS5maWxsKG51bGwpfWZ1bmN0aW9uIENpKCl7fWZ1bmN0aW9uIFNpKHQsZSl7dmFyIG4saSxyLHMsbz17MzI6e2Q6MTI3LGM6MTI4LGI6MCxhOjB9LDY0OntkOjMyNzUyLGM6MCxiOjAsYTowfX0sYT17MzI6OCw2NDoxMX1bdF07aWYoc3x8KG49MD5lfHwwPjEvZSxpc0Zpbml0ZShlKXx8KHM9b1t0XSxuJiYocy5kKz0xPDx0LzQtMSksaT1NYXRoLnBvdygyLGEpLTEscj0wKSksIXMpe2ZvcihpPXszMjoxMjcsNjQ6MTAyM31bdF0scj1NYXRoLmFicyhlKTtyPj0yOylpKyssci89Mjtmb3IoOzE+ciYmaT4wOylpLS0scio9MjswPj1pJiYoci89MiksMzI9PT10JiZpPjI1NCYmKHM9e2Q6bj8yNTU6MTI3LGM6MTI4LGI6MCxhOjB9LGk9TWF0aC5wb3coMixhKS0xLHI9MCl9cmV0dXJuIGl9ZnVuY3Rpb24gd2koKXt0aGlzLnB0PW5ldyBnLHRoaXMubGV2ZWw9MCx0aGlzLmVudj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXB1dGVLZXkodCl9ZnVuY3Rpb24gTGkoKXtOaS5hcHBseSh0aGlzKSx0aGlzLmVudj1udWxsLHRoaXMuY2VudHJleD1udWxsLHRoaXMuY2VudHJleT1udWxsLHRoaXMubGV2ZWw9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbnY9dCx0aGlzLmxldmVsPWUsdGhpcy5jZW50cmV4PSh0LmdldE1pblgoKSt0LmdldE1heFgoKSkvMix0aGlzLmNlbnRyZXk9KHQuZ2V0TWluWSgpK3QuZ2V0TWF4WSgpKS8yfWZ1bmN0aW9uIFJpKCl7fWZ1bmN0aW9uIFRpKCl7TmkuYXBwbHkodGhpcyl9ZnVuY3Rpb24gUGkoKXt0aGlzLnJvb3Q9bnVsbCx0aGlzLm1pbkV4dGVudD0xLHRoaXMucm9vdD1uZXcgVGl9ZnVuY3Rpb24gYmkodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllfWZ1bmN0aW9uIE9pKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZSx0aGlzLnByZWNpc2lvbk1vZGVsPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCksdGhpcy5wYXJzZXI9bmV3IGJpKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX1mdW5jdGlvbiBfaSgpe3RoaXMucGFyc2VyPW5ldyBiaSh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9ZnVuY3Rpb24gTWkodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllLHRoaXMucHJlY2lzaW9uTW9kZWw9dGhpcy5nZW9tZXRyeUZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKSx0aGlzLnBhcnNlcj1uZXcgcmUodGhpcy5nZW9tZXRyeUZhY3RvcnkpfWZ1bmN0aW9uIERpKHQpe3JldHVyblt0LngsdC55XX1mdW5jdGlvbiBBaSh0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgaWV9ZnVuY3Rpb24gRmkoKXtpZih0aGlzLm5vZGVyPW51bGwsdGhpcy5zY2FsZUZhY3Rvcj1udWxsLHRoaXMub2Zmc2V0WD1udWxsLHRoaXMub2Zmc2V0WT1udWxsLHRoaXMuaXNTY2FsZWQ9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtGaS5jYWxsKHRoaXMsdCxlLDAsMCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1syXSxhcmd1bWVudHNbM107dGhpcy5ub2Rlcj1uLHRoaXMuc2NhbGVGYWN0b3I9aSx0aGlzLmlzU2NhbGVkPSF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpfX1mdW5jdGlvbiBHaSgpe2lmKHRoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9ITAsdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbnB1dEdlb209ZSx0aGlzLmlzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hbi5pc0luQm91bmRhcnkoMil9fWZ1bmN0aW9uIHFpKCl7dGhpcy5wdD1udWxsLHRoaXMuaXNDbG9zZWQ9bnVsbCx0aGlzLmRlZ3JlZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnB0PXQsdGhpcy5pc0Nsb3NlZD0hMSx0aGlzLmRlZ3JlZT0wfWZ1bmN0aW9uIEJpKCl7aWYodGhpcy5xdWFkcmFudFNlZ21lbnRzPUJpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMsdGhpcy5lbmRDYXBTdHlsZT1CaS5DQVBfUk9VTkQsdGhpcy5qb2luU3R5bGU9QmkuSk9JTl9ST1VORCx0aGlzLm1pdHJlTGltaXQ9QmkuREVGQVVMVF9NSVRSRV9MSU1JVCx0aGlzLl9pc1NpbmdsZVNpZGVkPSExLHRoaXMuc2ltcGxpZnlGYWN0b3I9QmkuREVGQVVMVF9TSU1QTElGWV9GQUNUT1IsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhlKSx0aGlzLnNldEVuZENhcFN0eWxlKG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxvPWFyZ3VtZW50c1szXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHMoaSksdGhpcy5zZXRFbmRDYXBTdHlsZShyKSx0aGlzLnNldEpvaW5TdHlsZShzKSx0aGlzLnNldE1pdHJlTGltaXQobyl9fWZ1bmN0aW9uIHppKCl7dGhpcy5taW5JbmRleD0tMSx0aGlzLm1pbkNvb3JkPW51bGwsdGhpcy5taW5EZT1udWxsLHRoaXMub3JpZW50ZWREZT1udWxsfWZ1bmN0aW9uIFZpKCl7dGhpcy5hcnJheV89W119ZnVuY3Rpb24ga2koKXt0aGlzLmZpbmRlcj1udWxsLHRoaXMuZGlyRWRnZUxpc3Q9bmV3IEksdGhpcy5ub2Rlcz1uZXcgSSx0aGlzLnJpZ2h0TW9zdENvb3JkPW51bGwsdGhpcy5lbnY9bnVsbCx0aGlzLmZpbmRlcj1uZXcgeml9ZnVuY3Rpb24gWWkoKXt0aGlzLmlucHV0TGluZT1udWxsLFxudGhpcy5kaXN0YW5jZVRvbD1udWxsLHRoaXMuaXNEZWxldGVkPW51bGwsdGhpcy5hbmdsZU9yaWVudGF0aW9uPWhlLkNPVU5URVJDTE9DS1dJU0U7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRMaW5lPXR9ZnVuY3Rpb24gVWkoKXt0aGlzLnB0TGlzdD1udWxsLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLm1pbmltaW1WZXJ0ZXhEaXN0YW5jZT0wLHRoaXMucHRMaXN0PW5ldyBJfWZ1bmN0aW9uIFhpKCl7dGhpcy5tYXhDdXJ2ZVNlZ21lbnRFcnJvcj0wLHRoaXMuZmlsbGV0QW5nbGVRdWFudHVtPW51bGwsdGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPTEsdGhpcy5zZWdMaXN0PW51bGwsdGhpcy5kaXN0YW5jZT0wLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmJ1ZlBhcmFtcz1udWxsLHRoaXMubGk9bnVsbCx0aGlzLnMwPW51bGwsdGhpcy5zMT1udWxsLHRoaXMuczI9bnVsbCx0aGlzLnNlZzA9bmV3IGNlLHRoaXMuc2VnMT1uZXcgY2UsdGhpcy5vZmZzZXQwPW5ldyBjZSx0aGlzLm9mZnNldDE9bmV3IGNlLHRoaXMuc2lkZT0wLHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5wcmVjaXNpb25Nb2RlbD10LHRoaXMuYnVmUGFyYW1zPWUsdGhpcy5saT1uZXcgYWUsdGhpcy5maWxsZXRBbmdsZVF1YW50dW09TWF0aC5QSS8yL2UuZ2V0UXVhZHJhbnRTZWdtZW50cygpLGUuZ2V0UXVhZHJhbnRTZWdtZW50cygpPj04JiZlLmdldEpvaW5TdHlsZSgpPT09QmkuSk9JTl9ST1VORCYmKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj1YaS5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUiksdGhpcy5pbml0KG4pfWZ1bmN0aW9uIEhpKCl7dGhpcy5kaXN0YW5jZT0wLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmJ1ZlBhcmFtcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnByZWNpc2lvbk1vZGVsPXQsdGhpcy5idWZQYXJhbXM9ZX1mdW5jdGlvbiBXaSgpe3RoaXMuc3ViZ3JhcGhzPW51bGwsdGhpcy5zZWc9bmV3IGNlLHRoaXMuY2dhPW5ldyBoZTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zdWJncmFwaHM9dH1mdW5jdGlvbiBqaSgpe3RoaXMudXB3YXJkU2VnPW51bGwsdGhpcy5sZWZ0RGVwdGg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy51cHdhcmRTZWc9bmV3IGNlKHQpLHRoaXMubGVmdERlcHRoPWV9ZnVuY3Rpb24gS2koKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZGlzdGFuY2U9bnVsbCx0aGlzLmN1cnZlQnVpbGRlcj1udWxsLHRoaXMuY3VydmVMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmlucHV0R2VvbT10LHRoaXMuZGlzdGFuY2U9ZSx0aGlzLmN1cnZlQnVpbGRlcj1ufWZ1bmN0aW9uIFppKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuaGFzUHJvcGVyPSExLHRoaXMuaGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5oYXNJbnRlcmlvcj0hMSx0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5saT1udWxsLHRoaXMuaXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGk9dH1mdW5jdGlvbiBRaSgpe3RoaXMuYnVmUGFyYW1zPW51bGwsdGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLndvcmtpbmdOb2Rlcj1udWxsLHRoaXMuZ2VvbUZhY3Q9bnVsbCx0aGlzLmdyYXBoPW51bGwsdGhpcy5lZGdlTGlzdD1uZXcgbmk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYnVmUGFyYW1zPXR9ZnVuY3Rpb24gSmkoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLnNlZ1N0cmluZ3M9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZWdTdHJpbmdzPXR9ZnVuY3Rpb24gJGkoKXt0aGlzLmxpPW51bGwsdGhpcy5wdD1udWxsLHRoaXMub3JpZ2luYWxQdD1udWxsLHRoaXMucHRTY2FsZWQ9bnVsbCx0aGlzLnAwU2NhbGVkPW51bGwsdGhpcy5wMVNjYWxlZD1udWxsLHRoaXMuc2NhbGVGYWN0b3I9bnVsbCx0aGlzLm1pbng9bnVsbCx0aGlzLm1heHg9bnVsbCx0aGlzLm1pbnk9bnVsbCx0aGlzLm1heHk9bnVsbCx0aGlzLmNvcm5lcj1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLnNhZmVFbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodGhpcy5vcmlnaW5hbFB0PXQsdGhpcy5wdD10LHRoaXMuc2NhbGVGYWN0b3I9ZSx0aGlzLmxpPW4sMD49ZSl0aHJvdyBuZXcgaShcIlNjYWxlIGZhY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpOzEhPT1lJiYodGhpcy5wdD1uZXcgZyh0aGlzLnNjYWxlKHQueCksdGhpcy5zY2FsZSh0LnkpKSx0aGlzLnAwU2NhbGVkPW5ldyBnLHRoaXMucDFTY2FsZWQ9bmV3IGcpLHRoaXMuaW5pdENvcm5lcnModGhpcy5wdCl9ZnVuY3Rpb24gdHIoKXt0aGlzLnRlbXBFbnYxPW5ldyBDLHRoaXMuc2VsZWN0ZWRTZWdtZW50PW5ldyBjZX1mdW5jdGlvbiBlcigpe3RoaXMuaW5kZXg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbmRleD10fWZ1bmN0aW9uIG5yKCl7dHIuYXBwbHkodGhpcyksdGhpcy5ob3RQaXhlbD1udWxsLHRoaXMucGFyZW50RWRnZT1udWxsLHRoaXMuaG90UGl4ZWxWZXJ0ZXhJbmRleD1udWxsLHRoaXMuX2lzTm9kZUFkZGVkPSExO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmhvdFBpeGVsPXQsdGhpcy5wYXJlbnRFZGdlPWUsdGhpcy5ob3RQaXhlbFZlcnRleEluZGV4PW59ZnVuY3Rpb24gaXIoKXt0aGlzLmxpPW51bGwsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbnM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saT10LHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zPW5ldyBJfWZ1bmN0aW9uIHJyKCl7dGhpcy5wbT1udWxsLHRoaXMubGk9bnVsbCx0aGlzLnNjYWxlRmFjdG9yPW51bGwsdGhpcy5ub2Rlcj1udWxsLHRoaXMucG9pbnRTbmFwcGVyPW51bGwsdGhpcy5ub2RlZFNlZ1N0cmluZ3M9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wbT10LHRoaXMubGk9bmV3IGFlLHRoaXMubGkuc2V0UHJlY2lzaW9uTW9kZWwodCksdGhpcy5zY2FsZUZhY3Rvcj10LmdldFNjYWxlKCl9ZnVuY3Rpb24gc3IoKXtpZih0aGlzLmFyZ0dlb209bnVsbCx0aGlzLmRpc3RhbmNlPW51bGwsdGhpcy5idWZQYXJhbXM9bmV3IEJpLHRoaXMucmVzdWx0R2VvbWV0cnk9bnVsbCx0aGlzLnNhdmVFeGNlcHRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYXJnR2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmFyZ0dlb209ZSx0aGlzLmJ1ZlBhcmFtcz1ufX1mdW5jdGlvbiBvcigpe3RoaXMuY29tcHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wcz10fWZ1bmN0aW9uIGFyKCl7aWYodGhpcy5jb21wb25lbnQ9bnVsbCx0aGlzLnNlZ0luZGV4PW51bGwsdGhpcy5wdD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXIuY2FsbCh0aGlzLHQsYXIuSU5TSURFX0FSRUEsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuY29tcG9uZW50PW4sdGhpcy5zZWdJbmRleD1pLHRoaXMucHQ9cn19ZnVuY3Rpb24gdXIoKXt0aGlzLnB0cz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnB0cz10fWZ1bmN0aW9uIGxyKCl7dGhpcy5sb2NhdGlvbnM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5sb2NhdGlvbnM9dH1mdW5jdGlvbiBocigpe2lmKHRoaXMuZ2VvbT1udWxsLHRoaXMudGVybWluYXRlRGlzdGFuY2U9MCx0aGlzLnB0TG9jYXRvcj1uZXcgVGUsdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uPW51bGwsdGhpcy5taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2hyLmNhbGwodGhpcyx0LGUsMCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMuZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmdlb21bMF09bix0aGlzLmdlb21bMV09aSx0aGlzLnRlcm1pbmF0ZURpc3RhbmNlPXN9fWZ1bmN0aW9uIGNyKCl7dGhpcy5mYWN0b3J5PW51bGwsdGhpcy5kaXJlY3RlZEVkZ2VzPW5ldyBJLHRoaXMuY29vcmRpbmF0ZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXR9ZnVuY3Rpb24gZnIoKXt0aGlzLl9pc01hcmtlZD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5kYXRhPW51bGx9ZnVuY3Rpb24gZ3IoKXtmci5hcHBseSh0aGlzKSx0aGlzLnBhcmVudEVkZ2U9bnVsbCx0aGlzLmZyb209bnVsbCx0aGlzLnRvPW51bGwsdGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLnN5bT1udWxsLHRoaXMuZWRnZURpcmVjdGlvbj1udWxsLHRoaXMucXVhZHJhbnQ9bnVsbCx0aGlzLmFuZ2xlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3RoaXMuZnJvbT10LHRoaXMudG89ZSx0aGlzLmVkZ2VEaXJlY3Rpb249aSx0aGlzLnAwPXQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMucDE9bjt2YXIgcj10aGlzLnAxLngtdGhpcy5wMC54LHM9dGhpcy5wMS55LXRoaXMucDAueTt0aGlzLnF1YWRyYW50PUplLnF1YWRyYW50KHIscyksdGhpcy5hbmdsZT1NYXRoLmF0YW4yKHMscil9ZnVuY3Rpb24gZHIoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107Z3IuY2FsbCh0aGlzLHQsZSxuLGkpfWZ1bmN0aW9uIHByKCl7aWYoZnIuYXBwbHkodGhpcyksdGhpcy5kaXJFZGdlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNldERpcmVjdGVkRWRnZXModCxlKX19ZnVuY3Rpb24gdnIoKXt0aGlzLm91dEVkZ2VzPW5ldyBJLHRoaXMuc29ydGVkPSExfWZ1bmN0aW9uIG1yKCl7aWYoZnIuYXBwbHkodGhpcyksdGhpcy5wdD1udWxsLHRoaXMuZGVTdGFyPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTttci5jYWxsKHRoaXMsdCxuZXcgdnIpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnB0PWUsdGhpcy5kZVN0YXI9bn19ZnVuY3Rpb24geXIoKXtwci5hcHBseSh0aGlzKSx0aGlzLmxpbmU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lPXR9ZnVuY3Rpb24geHIoKXt0aGlzLm5vZGVNYXA9bmV3IHJ0fWZ1bmN0aW9uIEVyKCl7dGhpcy5lZGdlcz1uZXcgSix0aGlzLmRpckVkZ2VzPW5ldyBKLHRoaXMubm9kZU1hcD1uZXcgeHJ9ZnVuY3Rpb24gSXIoKXtFci5hcHBseSh0aGlzKX1mdW5jdGlvbiBOcigpe3RoaXMuZ3JhcGg9bmV3IElyLHRoaXMubWVyZ2VkTGluZVN0cmluZ3M9bnVsbCx0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmVkZ2VTdHJpbmdzPW51bGx9ZnVuY3Rpb24gQ3IoKXt0aGlzLmVkZ2VSaW5nPW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5sYWJlbD0tMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107Z3IuY2FsbCh0aGlzLHQsZSxuLGkpfWZ1bmN0aW9uIFNyKCl7cHIuYXBwbHkodGhpcyksdGhpcy5saW5lPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGluZT10fWZ1bmN0aW9uIHdyKCl7dGhpcy5mYWN0b3J5PW51bGwsdGhpcy5kZUxpc3Q9bmV3IEksdGhpcy5sb3dlc3RFZGdlPW51bGwsdGhpcy5yaW5nPW51bGwsdGhpcy5yaW5nUHRzPW51bGwsdGhpcy5ob2xlcz1udWxsLHRoaXMuc2hlbGw9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9pc1Byb2Nlc3NlZD0hMSx0aGlzLl9pc0luY2x1ZGVkU2V0PSExLHRoaXMuX2lzSW5jbHVkZWQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fWZ1bmN0aW9uIExyKCl7fWZ1bmN0aW9uIFJyKCl7RXIuYXBwbHkodGhpcyksdGhpcy5mYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fWZ1bmN0aW9uIFRyKCl7aWYodGhpcy5saW5lU3RyaW5nQWRkZXI9bmV3IFByKHRoaXMpLHRoaXMuZ3JhcGg9bnVsbCx0aGlzLmRhbmdsZXM9bmV3IEksdGhpcy5jdXRFZGdlcz1uZXcgSSx0aGlzLmludmFsaWRSaW5nTGluZXM9bmV3IEksdGhpcy5ob2xlTGlzdD1udWxsLHRoaXMuc2hlbGxMaXN0PW51bGwsdGhpcy5wb2x5TGlzdD1udWxsLHRoaXMuaXNDaGVja2luZ1JpbmdzVmFsaWQ9ITAsdGhpcy5leHRyYWN0T25seVBvbHlnb25hbD1udWxsLHRoaXMuZ2VvbUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClUci5jYWxsKHRoaXMsITEpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3RPbmx5UG9seWdvbmFsPXR9fWZ1bmN0aW9uIFByKCl7dGhpcy5wPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucD10fWZ1bmN0aW9uIGJyKCl7fWZ1bmN0aW9uIE9yKCl7aWYodGhpcy5lZGdlRW5kcz1uZXcgSSwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO09yLmNhbGwodGhpcyxudWxsLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKTtFbi5jYWxsKHRoaXMsZS5nZXRFZGdlKCksZS5nZXRDb29yZGluYXRlKCksZS5nZXREaXJlY3RlZENvb3JkaW5hdGUoKSxuZXcgZ24oZS5nZXRMYWJlbCgpKSksdGhpcy5pbnNlcnQoZSl9fWZ1bmN0aW9uIF9yKCl7UG4uYXBwbHkodGhpcyl9ZnVuY3Rpb24gTXIoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07eW4uY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gRHIoKXtObi5hcHBseSh0aGlzKX1mdW5jdGlvbiBBcigpe3RoaXMubGk9bmV3IGFlLHRoaXMucHRMb2NhdG9yPW5ldyBUZSx0aGlzLmFyZz1udWxsLHRoaXMubm9kZXM9bmV3IHhuKG5ldyBEciksdGhpcy5pbT1udWxsLHRoaXMuaXNvbGF0ZWRFZGdlcz1uZXcgSSx0aGlzLmludmFsaWRQb2ludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFyZz10fWZ1bmN0aW9uIEZyKCl7dGhpcy5yZWN0RW52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1mdW5jdGlvbiBHcigpe3RoaXMubGk9bmV3IGFlLHRoaXMucmVjdEVudj1udWxsLHRoaXMuZGlhZ1VwMD1udWxsLHRoaXMuZGlhZ1VwMT1udWxsLHRoaXMuZGlhZ0Rvd24wPW51bGwsdGhpcy5kaWFnRG93bjE9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXQsdGhpcy5kaWFnVXAwPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSx0aGlzLmRpYWdVcDE9bmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLHRoaXMuZGlhZ0Rvd24wPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSx0aGlzLmRpYWdEb3duMT1uZXcgZyh0LmdldE1heFgoKSx0LmdldE1pblkoKSl9ZnVuY3Rpb24gcXIoKXt0aGlzLl9pc0RvbmU9ITF9ZnVuY3Rpb24gQnIoKXt0aGlzLnJlY3RhbmdsZT1udWxsLHRoaXMucmVjdEVudj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RhbmdsZT10LHRoaXMucmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1mdW5jdGlvbiB6cigpe3FyLmFwcGx5KHRoaXMpLHRoaXMucmVjdEVudj1udWxsLHRoaXMuX2ludGVyc2VjdHM9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdEVudj10fWZ1bmN0aW9uIFZyKCl7cXIuYXBwbHkodGhpcyksdGhpcy5yZWN0U2VxPW51bGwsdGhpcy5yZWN0RW52PW51bGwsdGhpcy5fY29udGFpbnNQb2ludD0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0U2VxPXQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWZ1bmN0aW9uIGtyKCl7cXIuYXBwbHkodGhpcyksdGhpcy5yZWN0RW52PW51bGwsdGhpcy5yZWN0SW50ZXJzZWN0b3I9bnVsbCx0aGlzLmhhc0ludGVyc2VjdGlvbj0hMSx0aGlzLnAwPW5ldyBnLHRoaXMucDE9bmV3IGc7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKSx0aGlzLnJlY3RJbnRlcnNlY3Rvcj1uZXcgR3IodGhpcy5yZWN0RW52KX1mdW5jdGlvbiBZcigpe2lmKHRoaXMuX3JlbGF0ZT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGkuY2FsbCh0aGlzLHQsZSksdGhpcy5fcmVsYXRlPW5ldyBBcih0aGlzLmFyZyl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RpLmNhbGwodGhpcyxuLGksciksdGhpcy5fcmVsYXRlPW5ldyBBcih0aGlzLmFyZyl9fWZ1bmN0aW9uIFVyKCl7dGhpcy5nZW9tRmFjdG9yeT1udWxsLHRoaXMuc2tpcEVtcHR5PSExLHRoaXMuaW5wdXRHZW9tcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21GYWN0b3J5PVVyLmV4dHJhY3RGYWN0b3J5KHQpLHRoaXMuaW5wdXRHZW9tcz10fWZ1bmN0aW9uIFhyKCl7dGhpcy5wb2ludEdlb209bnVsbCx0aGlzLm90aGVyR2VvbT1udWxsLHRoaXMuZ2VvbUZhY3Q9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wb2ludEdlb209dCx0aGlzLm90aGVyR2VvbT1lLHRoaXMuZ2VvbUZhY3Q9ZS5nZXRGYWN0b3J5KCl9ZnVuY3Rpb24gSHIoKXt0aGlzLnNvcnRJbmRleD0tMSx0aGlzLmNvbXBzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc29ydEluZGV4PXQsdGhpcy5jb21wcz1lfWZ1bmN0aW9uIFdyKCl7dGhpcy5pbnB1dFBvbHlzPW51bGwsdGhpcy5nZW9tRmFjdG9yeT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0UG9seXM9dCxudWxsPT09dGhpcy5pbnB1dFBvbHlzJiYodGhpcy5pbnB1dFBvbHlzPW5ldyBJKX1mdW5jdGlvbiBqcigpe2lmKHRoaXMucG9seWdvbnM9bmV3IEksdGhpcy5saW5lcz1uZXcgSSx0aGlzLnBvaW50cz1uZXcgSSx0aGlzLmdlb21GYWN0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLHYpKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5nZW9tRmFjdD1pLHRoaXMuZXh0cmFjdChuKX19ZnVuY3Rpb24gS3IoKXt0aGlzLmdlb21ldHJ5RmFjdG9yeT1uZXcgaWUsdGhpcy5nZW9tR3JhcGg9bnVsbCx0aGlzLmRpc2Nvbm5lY3RlZFJpbmdjb29yZD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21HcmFwaD10fWZ1bmN0aW9uIFpyKCl7dGhpcy5pdGVtcz1uZXcgSSx0aGlzLnN1Ym5vZGU9W251bGwsbnVsbF19ZnVuY3Rpb24gUXIoKXtpZih0aGlzLm1pbj1udWxsLHRoaXMubWF4PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5taW49MCx0aGlzLm1heD0wO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5taW4sdC5tYXgpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQoZSxuKX19ZnVuY3Rpb24gSnIoKXt0aGlzLnB0PTAsdGhpcy5sZXZlbD0wLHRoaXMuaW50ZXJ2YWw9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfWZ1bmN0aW9uICRyKCl7WnIuYXBwbHkodGhpcyksdGhpcy5pbnRlcnZhbD1udWxsLHRoaXMuY2VudHJlPW51bGwsdGhpcy5sZXZlbD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmludGVydmFsPXQsdGhpcy5sZXZlbD1lLHRoaXMuY2VudHJlPSh0LmdldE1pbigpK3QuZ2V0TWF4KCkpLzJ9ZnVuY3Rpb24gdHMoKXtaci5hcHBseSh0aGlzKX1mdW5jdGlvbiBlcygpe3RoaXMucm9vdD1udWxsLHRoaXMubWluRXh0ZW50PTEsdGhpcy5yb290PW5ldyB0c31mdW5jdGlvbiBucygpe31mdW5jdGlvbiBpcygpe3RoaXMucmluZz1udWxsLHRoaXMudHJlZT1udWxsLHRoaXMuY3Jvc3NpbmdzPTAsdGhpcy5pbnRlcnZhbD1uZXcgUXI7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmluZz10LHRoaXMuYnVpbGRJbmRleCgpfWZ1bmN0aW9uIHJzKCl7dHIuYXBwbHkodGhpcyksdGhpcy5tY3A9bnVsbCx0aGlzLnA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5tY3A9dCx0aGlzLnA9ZX1mdW5jdGlvbiBzcygpe3RoaXMubm9kZXM9bmV3IHhuKG5ldyBEcil9ZnVuY3Rpb24gb3MoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLmdlb21HcmFwaD1udWxsLHRoaXMubm9kZUdyYXBoPW5ldyBzcyx0aGlzLmludmFsaWRQb2ludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21HcmFwaD10fWZ1bmN0aW9uIGFzKCl7dGhpcy5ncmFwaD1udWxsLHRoaXMucmluZ3M9bmV3IEksdGhpcy50b3RhbEVudj1uZXcgQyx0aGlzLmluZGV4PW51bGwsdGhpcy5uZXN0ZWRQdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdyYXBoPXR9ZnVuY3Rpb24gdXMoKXtpZih0aGlzLmVycm9yVHlwZT1udWxsLHRoaXMucHQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3VzLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmVycm9yVHlwZT1lLG51bGwhPT1uJiYodGhpcy5wdD1uLmNvcHkoKSl9fWZ1bmN0aW9uIGxzKCl7dGhpcy5wYXJlbnRHZW9tZXRyeT1udWxsLHRoaXMuaXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD0hMSx0aGlzLnZhbGlkRXJyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucGFyZW50R2VvbWV0cnk9dH1mdW5jdGlvbiBocygpe190LkNvb3JkaW5hdGVPcGVyYXRpb24uYXBwbHkodGhpcyksdGhpcy50YXJnZXRQTT1udWxsLHRoaXMucmVtb3ZlQ29sbGFwc2VkPSEwO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnRhcmdldFBNPXQsdGhpcy5yZW1vdmVDb2xsYXBzZWQ9ZX1mdW5jdGlvbiBjcygpe3RoaXMudGFyZ2V0UE09bnVsbCx0aGlzLnJlbW92ZUNvbGxhcHNlZD0hMCx0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsPSExLHRoaXMuaXNQb2ludHdpc2U9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMudGFyZ2V0UE09dH1mdW5jdGlvbiBmcygpe3RoaXMucHRzPW51bGwsdGhpcy51c2VQdD1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLnNlZz1uZXcgY2U7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPXR9ZnVuY3Rpb24gZ3MoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1mdW5jdGlvbiBkcygpe3hlLmFwcGx5KHRoaXMpLHRoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPWV9ZnVuY3Rpb24gcHMoKXtpZih0aGlzLnBhcmVudD1udWxsLHRoaXMuaW5kZXg9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3BzLmNhbGwodGhpcyx0LGUsbnVsbCwtMSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2NlLmNhbGwodGhpcyxuLGkpLHRoaXMucGFyZW50PXIsdGhpcy5pbmRleD1zfX1mdW5jdGlvbiB2cygpe2lmKHRoaXMucGFyZW50TGluZT1udWxsLHRoaXMuc2Vncz1udWxsLHRoaXMucmVzdWx0U2Vncz1uZXcgSSx0aGlzLm1pbmltdW1TaXplPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt2cy5jYWxsKHRoaXMsdCwyKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wYXJlbnRMaW5lPWUsdGhpcy5taW5pbXVtU2l6ZT1uLHRoaXMuaW5pdCgpfX1mdW5jdGlvbiBtcygpe3RoaXMuaW5kZXg9bmV3IFBpfWZ1bmN0aW9uIHlzKCl7dGhpcy5xdWVyeVNlZz1udWxsLHRoaXMuaXRlbXM9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucXVlcnlTZWc9dH1mdW5jdGlvbiB4cygpe3RoaXMubGk9bmV3IGFlLHRoaXMuaW5wdXRJbmRleD1uZXcgbXMsdGhpcy5vdXRwdXRJbmRleD1uZXcgbXMsdGhpcy5saW5lPW51bGwsdGhpcy5saW5lUHRzPW51bGwsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT0wO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmlucHV0SW5kZXg9dCx0aGlzLm91dHB1dEluZGV4PWV9ZnVuY3Rpb24gRXMoKXt0aGlzLmlucHV0SW5kZXg9bmV3IG1zLHRoaXMub3V0cHV0SW5kZXg9bmV3IG1zLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9MH1mdW5jdGlvbiBJcygpe3RoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5saW5lU2ltcGxpZmllcj1uZXcgRXMsdGhpcy5saW5lc3RyaW5nTWFwPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZnVuY3Rpb24gTnMoKXt4ZS5hcHBseSh0aGlzKSx0aGlzLmxpbmVzdHJpbmdNYXA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lc3RyaW5nTWFwPXR9ZnVuY3Rpb24gQ3MoKXt0aGlzLnRwcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRwcz10fWZ1bmN0aW9uIFNzKCl7dGhpcy5zZWc9bnVsbCx0aGlzLnNlZ0xlbj1udWxsLHRoaXMuc3BsaXRQdD1udWxsLHRoaXMubWluaW11bUxlbj0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNlZz10LHRoaXMuc2VnTGVuPXQuZ2V0TGVuZ3RoKCl9ZnVuY3Rpb24gd3MoKXt9ZnVuY3Rpb24gTHMoKXt9ZnVuY3Rpb24gUnMoKXt9ZnVuY3Rpb24gVHMoKXtpZih0aGlzLnA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucD1uZXcgZyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wPW5ldyBnKGUsbil9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMucD1uZXcgZyhpLHIscyl9fWZ1bmN0aW9uIFBzKCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9bnVsbCx0aGlzLmNvbnN0cmFpbnQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07VHMuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIGJzKCl7dGhpcy5fcm90PW51bGwsdGhpcy52ZXJ0ZXg9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLmRhdGE9bnVsbH1mdW5jdGlvbiBPcygpe3RoaXMuc3ViZGl2PW51bGwsdGhpcy5pc1VzaW5nVG9sZXJhbmNlPSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnN1YmRpdj10LHRoaXMuaXNVc2luZ1RvbGVyYW5jZT10LmdldFRvbGVyYW5jZSgpPjB9ZnVuY3Rpb24gX3MoKXt9ZnVuY3Rpb24gTXMoKXt0aGlzLnN1YmRpdj1udWxsLHRoaXMubGFzdEVkZ2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zdWJkaXY9dCx0aGlzLmluaXQoKX1mdW5jdGlvbiBEcygpe2lmKHRoaXMuc2VnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciBlPWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyxcIkxvY2F0ZSBmYWlsZWQgdG8gY29udmVyZ2UgKGF0IGVkZ2U6IFwiK2UrXCIpLiAgUG9zc2libGUgY2F1c2VzIGluY2x1ZGUgaW52YWxpZCBTdWJkaXZpc2lvbiB0b3BvbG9neSBvciB2ZXJ5IGNsb3NlIHNpdGVzXCIpLHRoaXMuc2VnPW5ldyBjZShlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2wuY2FsbCh0aGlzLERzLm1zZ1dpdGhTcGF0aWFsKG4saSkpLHRoaXMuc2VnPW5ldyBjZShpKX19ZnVuY3Rpb24gQXMoKXt9ZnVuY3Rpb24gRnMoKXt0aGlzLnZpc2l0ZWRLZXk9MCx0aGlzLnF1YWRFZGdlcz1uZXcgSSx0aGlzLnN0YXJ0aW5nRWRnZT1udWxsLHRoaXMudG9sZXJhbmNlPW51bGwsdGhpcy5lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLmZyYW1lVmVydGV4PW5ldyBBcnJheSgzKS5maWxsKG51bGwpLHRoaXMuZnJhbWVFbnY9bnVsbCx0aGlzLmxvY2F0b3I9bnVsbCx0aGlzLnNlZz1uZXcgY2UsdGhpcy50cmlFZGdlcz1uZXcgQXJyYXkoMykuZmlsbChudWxsKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy50b2xlcmFuY2U9ZSx0aGlzLmVkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1lL0ZzLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUix0aGlzLmNyZWF0ZUZyYW1lKHQpLHRoaXMuc3RhcnRpbmdFZGdlPXRoaXMuaW5pdFN1YmRpdigpLHRoaXMubG9jYXRvcj1uZXcgTXModGhpcyl9ZnVuY3Rpb24gR3MoKXt9ZnVuY3Rpb24gcXMoKXt0aGlzLnRyaUxpc3Q9bmV3IEl9ZnVuY3Rpb24gQnMoKXt0aGlzLnRyaUxpc3Q9bmV3IEl9ZnVuY3Rpb24genMoKXt0aGlzLmNvb3JkTGlzdD1uZXcgTix0aGlzLnRyaUNvb3Jkcz1uZXcgSX1mdW5jdGlvbiBWcygpe2lmKHRoaXMubHM9bnVsbCx0aGlzLmRhdGE9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubHM9bmV3IGNlKHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMubHM9bmV3IGNlKG4saSksdGhpcy5kYXRhPXJ9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9YXJndW1lbnRzWzJdLHU9YXJndW1lbnRzWzNdLGw9YXJndW1lbnRzWzRdLGg9YXJndW1lbnRzWzVdO1ZzLmNhbGwodGhpcyxuZXcgZyhzLG8sYSksbmV3IGcodSxsLGgpKX1lbHNlIGlmKDc9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYz1hcmd1bWVudHNbMF0sZj1hcmd1bWVudHNbMV0sZD1hcmd1bWVudHNbMl0scD1hcmd1bWVudHNbM10sdj1hcmd1bWVudHNbNF0sbT1hcmd1bWVudHNbNV0seT1hcmd1bWVudHNbNl07VnMuY2FsbCh0aGlzLG5ldyBnKGMsZixkKSxuZXcgZyhwLHYsbSkseSl9fWZ1bmN0aW9uIGtzKCl7fWZ1bmN0aW9uIFlzKCl7aWYodGhpcy5wPW51bGwsdGhpcy5kYXRhPW51bGwsdGhpcy5sZWZ0PW51bGwsdGhpcy5yaWdodD1udWxsLHRoaXMuY291bnQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucD1uZXcgZyh0KSx0aGlzLmxlZnQ9bnVsbCx0aGlzLnJpZ2h0PW51bGwsdGhpcy5jb3VudD0xLHRoaXMuZGF0YT1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLnA9bmV3IGcobixpKSx0aGlzLmxlZnQ9bnVsbCx0aGlzLnJpZ2h0PW51bGwsdGhpcy5jb3VudD0xLHRoaXMuZGF0YT1yfX1mdW5jdGlvbiBVcygpe2lmKHRoaXMucm9vdD1udWxsLHRoaXMubnVtYmVyT2ZOb2Rlcz1udWxsLHRoaXMudG9sZXJhbmNlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpVXMuY2FsbCh0aGlzLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRvbGVyYW5jZT10fX1mdW5jdGlvbiBYcygpe3RoaXMudG9sZXJhbmNlPW51bGwsdGhpcy5tYXRjaE5vZGU9bnVsbCx0aGlzLm1hdGNoRGlzdD0wLHRoaXMucD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnA9dCx0aGlzLnRvbGVyYW5jZT1lfWZ1bmN0aW9uIEhzKCl7dGhpcy5pbml0aWFsVmVydGljZXM9bnVsbCx0aGlzLnNlZ1ZlcnRpY2VzPW51bGwsdGhpcy5zZWdtZW50cz1uZXcgSSx0aGlzLnN1YmRpdj1udWxsLHRoaXMuaW5jRGVsPW51bGwsdGhpcy5jb252ZXhIdWxsPW51bGwsdGhpcy5zcGxpdEZpbmRlcj1uZXcgTHMsdGhpcy5rZHQ9bnVsbCx0aGlzLnZlcnRleEZhY3Rvcnk9bnVsbCx0aGlzLmNvbXB1dGVBcmVhRW52PW51bGwsdGhpcy5zcGxpdFB0PW51bGwsdGhpcy50b2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0aWFsVmVydGljZXM9bmV3IEkodCksdGhpcy50b2xlcmFuY2U9ZSx0aGlzLmtkdD1uZXcgVXMoZSl9ZnVuY3Rpb24gV3MoKXt0aGlzLnNpdGVDb29yZHM9bnVsbCx0aGlzLnRvbGVyYW5jZT0wLHRoaXMuc3ViZGl2PW51bGx9ZnVuY3Rpb24ganMoKXt0aGlzLnNpdGVDb29yZHM9bnVsbCx0aGlzLmNvbnN0cmFpbnRMaW5lcz1udWxsLHRoaXMudG9sZXJhbmNlPTAsdGhpcy5zdWJkaXY9bnVsbCx0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXA9bmV3IHJ0fWZ1bmN0aW9uIEtzKCl7dGhpcy5zaXRlQ29vcmRzPW51bGwsdGhpcy50b2xlcmFuY2U9MCx0aGlzLnN1YmRpdj1udWxsLHRoaXMuY2xpcEVudj1udWxsLHRoaXMuZGlhZ3JhbUVudj1udWxsfWZ1bmN0aW9uIFpzKCl7fUFycmF5LnByb3RvdHlwZS5maWxsfHwoQXJyYXkucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU9iamVjdCh0aGlzKSxuPXBhcnNlSW50KGUubGVuZ3RoLDEwKSxpPWFyZ3VtZW50c1sxXSxyPXBhcnNlSW50KGksMTApfHwwLHM9MD5yP01hdGgubWF4KG4rciwwKTpNYXRoLm1pbihyLG4pLG89YXJndW1lbnRzWzJdLGE9dm9pZCAwPT09bz9uOnBhcnNlSW50KG8sMTApfHwwLHU9MD5hP01hdGgubWF4KG4rYSwwKTpNYXRoLm1pbihhLG4pO3U+cztzKyspZVtzXT10O3JldHVybiBlfSksTnVtYmVyLmlzRmluaXRlPU51bWJlci5pc0Zpbml0ZXx8ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJmlzRmluaXRlKHQpfSxOdW1iZXIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KSYmTWF0aC5mbG9vcih0KT09PXR9LE51bWJlci5wYXJzZUZsb2F0PU51bWJlci5wYXJzZUZsb2F0fHxwYXJzZUZsb2F0LE51bWJlci5pc05hTj1OdW1iZXIuaXNOYU58fGZ1bmN0aW9uKHQpe3JldHVybiB0IT09dH0sTWF0aC50cnVuYz1NYXRoLnRydW5jfHxmdW5jdGlvbih0KXtyZXR1cm4gMD50P01hdGguY2VpbCh0KTpNYXRoLmZsb29yKHQpfSxlKG4ucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBufX0pLG4uZXF1YWxzV2l0aFRvbGVyYW5jZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE1hdGguYWJzKHQtZSk8PW59LHIuaXNOYU49ZnVuY3Rpb24odCl7cmV0dXJuIE51bWJlci5pc05hTih0KX0sci5kb3VibGVUb0xvbmdCaXRzPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxyLmxvbmdCaXRzVG9Eb3VibGU9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHIuaXNJbmZpbml0ZT1mdW5jdGlvbih0KXtyZXR1cm4hTnVtYmVyLmlzRmluaXRlKHQpfSxyLk1BWF9WQUxVRT1OdW1iZXIuTUFYX1ZBTFVFLGgoYyxsKSxlKGMucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjfX0pLGUoZi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZ9fSksZi5zaG91bGROZXZlclJlYWNoSGVyZT1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUobnVsbCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3Rocm93IG5ldyBjKFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIisobnVsbCE9PXQ/XCI6IFwiK3Q6XCJcIikpfX0sZi5pc1RydWU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2YuaXNUcnVlKHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKCFlKXRocm93IG51bGw9PT1uP25ldyBjOm5ldyBjKG4pfX0sZi5lcXVhbHM9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2YuZXF1YWxzKHQsZSxudWxsKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07aWYoIWkuZXF1YWxzKG4pKXRocm93IG5ldyBjKFwiRXhwZWN0ZWQgXCIrbitcIiBidXQgZW5jb3VudGVyZWQgXCIraSsobnVsbCE9PXI/XCI6IFwiK3I6XCJcIikpfX0sZShnLnByb3RvdHlwZSx7c2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlKXtzd2l0Y2godCl7Y2FzZSBnLlg6dGhpcy54PWU7YnJlYWs7Y2FzZSBnLlk6dGhpcy55PWU7YnJlYWs7Y2FzZSBnLlo6dGhpcy56PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgaShcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX0sZXF1YWxzMkQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnghPT10Lng/ITE6dGhpcy55PT09dC55fWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIG4uZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLngsZS54LGkpPyEhbi5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueSxlLnksaSk6ITF9fSxnZXRPcmRpbmF0ZTpmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSBnLlg6cmV0dXJuIHRoaXMueDtjYXNlIGcuWTpyZXR1cm4gdGhpcy55O2Nhc2UgZy5aOnJldHVybiB0aGlzLnp9dGhyb3cgbmV3IGkoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX0sZXF1YWxzM0Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55JiYodGhpcy56PT09dC56fHxyLmlzTmFOKHRoaXMueikmJnIuaXNOYU4odC56KSl9LGVxdWFsczpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGc/dGhpcy5lcXVhbHMyRCh0KTohMX0sZXF1YWxJblo6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbi5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueix0LnosZSl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLng8ZS54Py0xOnRoaXMueD5lLng/MTp0aGlzLnk8ZS55Py0xOnRoaXMueT5lLnk/MTowfSxjbG9uZTpmdW5jdGlvbigpe3RyeXt2YXIgdD1udWxsO3JldHVybiB0fWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gZi5zaG91bGROZXZlclJlYWNoSGVyZShcInRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoaXMgY2xhc3MgaXMgQ2xvbmVhYmxlXCIpLG51bGw7dGhyb3cgdH1maW5hbGx5e319LGNvcHk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGcodGhpcyl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIsIFwiK3RoaXMueitcIilcIn0sZGlzdGFuY2UzRDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLngtdC54LG49dGhpcy55LXQueSxpPXRoaXMuei10Lno7cmV0dXJuIE1hdGguc3FydChlKmUrbipuK2kqaSl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMueC10Lngsbj10aGlzLnktdC55O3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9MTc7cmV0dXJuIHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMueCksdD0zNyp0K2cuaGFzaENvZGUodGhpcy55KX0sc2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuen0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyxvLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBnfX0pLGcuaGFzaENvZGU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9ci5kb3VibGVUb0xvbmdCaXRzKHQpO3JldHVybiBNYXRoLnRydW5jKGVeZT4+PjMyKX19LGUoZC5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZSxyPWQuY29tcGFyZShuLngsaS54KTtpZigwIT09cilyZXR1cm4gcjt2YXIgcz1kLmNvbXBhcmUobi55LGkueSk7aWYoMCE9PXMpcmV0dXJuIHM7aWYodGhpcy5kaW1lbnNpb25zVG9UZXN0PD0yKXJldHVybiAwO3ZhciBvPWQuY29tcGFyZShuLnosaS56KTtyZXR1cm4gb30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGR9fSksZC5jb21wYXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU+dD8tMTp0PmU/MTpyLmlzTmFOKHQpP3IuaXNOYU4oZSk/MDotMTpyLmlzTmFOKGUpPzE6MH0sZy5EaW1lbnNpb25hbENvbXBhcmF0b3I9ZCxnLnNlcmlhbFZlcnNpb25VSUQ9MHg1Y2JmMmMyMzVjN2U1ODAwLGcuTlVMTF9PUkRJTkFURT1yLk5hTixnLlg9MCxnLlk9MSxnLlo9MixwLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7fSxwLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7fSxwLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLmFkZD1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7fSxtLnByb3RvdHlwZT1uZXcgRXJyb3IsbS5wcm90b3R5cGUubmFtZT1cIkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25cIix5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHYucHJvdG90eXBlKSx5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj15LHkucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe30seS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKCl7fSx5LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7fSx4LnByb3RvdHlwZT1uZXcgRXJyb3IseC5wcm90b3R5cGUubmFtZT1cIk5vU3VjaEVsZW1lbnRFeGNlcHRpb25cIixFLnByb3RvdHlwZT1uZXcgRXJyb3IsRS5wcm90b3R5cGUubmFtZT1cIk9wZXJhdGlvbk5vdFN1cHBvcnRlZFwiLEkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoeS5wcm90b3R5cGUpLEkucHJvdG90eXBlLmNvbnN0cnVjdG9yPUksSS5wcm90b3R5cGUuZW5zdXJlQ2FwYWNpdHk9ZnVuY3Rpb24oKXt9LEkucHJvdG90eXBlLmludGVyZmFjZXNfPWZ1bmN0aW9uKCl7cmV0dXJuW3ksdl19LEkucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSwhMH0sSS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmFycmF5Xz1bXX0sSS5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sSS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5hcnJheV9bdF07cmV0dXJuIHRoaXMuYXJyYXlfW3RdPWUsbn0sSS5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFFzKHRoaXMpfSxJLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYoMD50fHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgbTtyZXR1cm4gdGhpcy5hcnJheV9bdF19LEkucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sSS5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LEkucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sSS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0hMSxuPTAsaT10aGlzLmFycmF5Xy5sZW5ndGg7aT5uO24rKylpZih0aGlzLmFycmF5X1tuXT09PXQpe3RoaXMuYXJyYXlfLnNwbGljZShuLDEpLGU9ITA7YnJlYWt9cmV0dXJuIGV9O3ZhciBRcz1mdW5jdGlvbih0KXt0aGlzLmFycmF5TGlzdF89dCx0aGlzLnBvc2l0aW9uXz0wfTtRcy5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5hcnJheUxpc3RfLnNpemUoKSl0aHJvdyBuZXcgeDtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXysrKX0sUXMucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy5hcnJheUxpc3RfLnNpemUoKX0sUXMucHJvdG90eXBlLnNldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLnNldCh0aGlzLnBvc2l0aW9uXy0xLHQpfSxRcy5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEV9LGgoTixJKSxlKE4ucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sYWRkQWxsOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj0hMSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspdGhpcy5hZGQoaS5uZXh0KCksZSksbj0hMDtyZXR1cm4gbn1yZXR1cm4gSS5wcm90b3R5cGUuYWRkQWxsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sY2xvbmU6ZnVuY3Rpb24gdCgpe2Zvcih2YXIgdD1JLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpLGU9MDtlPHRoaXMuc2l6ZSgpO2UrKyl0LmFkZChlLHRoaXMuZ2V0KGUpLmNvcHkoKSk7cmV0dXJuIHR9LHRvQ29vcmRpbmF0ZUFycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9BcnJheShOLmNvb3JkQXJyYXlUeXBlKX0sYWRkOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtJLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKGUsbiwhMCksITB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO2lmKCFyJiZ0aGlzLnNpemUoKT49MSl7dmFyIHM9dGhpcy5nZXQodGhpcy5zaXplKCktMSk7aWYocy5lcXVhbHMyRChpKSlyZXR1cm4gbnVsbH1JLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKG8sYSksITB9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdLGg9YXJndW1lbnRzWzJdO2lmKGgpZm9yKHZhciBjPTA7Yzx1Lmxlbmd0aDtjKyspdGhpcy5hZGQodVtjXSxsKTtlbHNlIGZvcih2YXIgYz11Lmxlbmd0aC0xO2M+PTA7Yy0tKXRoaXMuYWRkKHVbY10sbCk7cmV0dXJuITB9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgZj1hcmd1bWVudHNbMF0sZD1hcmd1bWVudHNbMV0scD1hcmd1bWVudHNbMl07aWYoIXApe3ZhciB2PXRoaXMuc2l6ZSgpO2lmKHY+MCl7aWYoZj4wKXt2YXIgbT10aGlzLmdldChmLTEpO2lmKG0uZXF1YWxzMkQoZCkpcmV0dXJuIG51bGx9aWYodj5mKXt2YXIgeT10aGlzLmdldChmKTtpZih5LmVxdWFsczJEKGQpKXJldHVybiBudWxsfX19SS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcyxmLGQpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgeD1hcmd1bWVudHNbMF0sRT1hcmd1bWVudHNbMV0sTj1hcmd1bWVudHNbMl0sQz1hcmd1bWVudHNbM10sUz0xO04+QyYmKFM9LTEpO2Zvcih2YXIgYz1OO2MhPT1DO2MrPVMpdGhpcy5hZGQoeFtjXSxFKTtyZXR1cm4hMH19LGNsb3NlUmluZzpmdW5jdGlvbigpe3RoaXMuc2l6ZSgpPjAmJnRoaXMuYWRkKG5ldyBnKHRoaXMuZ2V0KDApKSwhMSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE59fSksTi5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxlKEMucHJvdG90eXBlLHtnZXRBcmVhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSp0aGlzLmdldEhlaWdodCgpfSxlcXVhbHM6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgQykpcmV0dXJuITE7dmFyIGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpOnRoaXMubWF4eD09PWUuZ2V0TWF4WCgpJiZ0aGlzLm1heHk9PT1lLmdldE1heFkoKSYmdGhpcy5taW54PT09ZS5nZXRNaW5YKCkmJnRoaXMubWlueT09PWUuZ2V0TWluWSgpfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7aWYodGhpcy5pc051bGwoKXx8dC5pc051bGwoKXx8IXRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gbmV3IEM7dmFyIGU9dGhpcy5taW54PnQubWlueD90aGlzLm1pbng6dC5taW54LG49dGhpcy5taW55PnQubWlueT90aGlzLm1pbnk6dC5taW55LGk9dGhpcy5tYXh4PHQubWF4eD90aGlzLm1heHg6dC5tYXh4LHI9dGhpcy5tYXh5PHQubWF4eT90aGlzLm1heHk6dC5tYXh5O3JldHVybiBuZXcgQyhlLGksbixyKX0saXNOdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4eDx0aGlzLm1pbnh9LGdldE1heFg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh4fSxjb3ZlcnM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQueCx0LnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTnVsbCgpfHxlLmlzTnVsbCgpPyExOmUuZ2V0TWluWCgpPj10aGlzLm1pbngmJmUuZ2V0TWF4WCgpPD10aGlzLm1heHgmJmUuZ2V0TWluWSgpPj10aGlzLm1pbnkmJmUuZ2V0TWF4WSgpPD10aGlzLm1heHl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc051bGwoKT8hMTpuPj10aGlzLm1pbngmJm48PXRoaXMubWF4eCYmaT49dGhpcy5taW55JiZpPD10aGlzLm1heHl9fSxpbnRlcnNlY3RzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTnVsbCgpfHx0LmlzTnVsbCgpPyExOiEodC5taW54PnRoaXMubWF4eHx8dC5tYXh4PHRoaXMubWlueHx8dC5taW55PnRoaXMubWF4eXx8dC5tYXh5PHRoaXMubWlueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW50ZXJzZWN0cyhlLngsZS55KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzTnVsbCgpPyExOiEobj50aGlzLm1heHh8fG48dGhpcy5taW54fHxpPnRoaXMubWF4eXx8aTx0aGlzLm1pbnkpfX0sZ2V0TWluWTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbnl9LGdldE1pblg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW54fSxleHBhbmRUb0luY2x1ZGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRUb0luY2x1ZGUodC54LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciBlPWFyZ3VtZW50c1swXTtpZihlLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaXNOdWxsKCk/KHRoaXMubWlueD1lLmdldE1pblgoKSx0aGlzLm1heHg9ZS5nZXRNYXhYKCksdGhpcy5taW55PWUuZ2V0TWluWSgpLHRoaXMubWF4eT1lLmdldE1heFkoKSk6KGUubWlueDx0aGlzLm1pbngmJih0aGlzLm1pbng9ZS5taW54KSxlLm1heHg+dGhpcy5tYXh4JiYodGhpcy5tYXh4PWUubWF4eCksZS5taW55PHRoaXMubWlueSYmKHRoaXMubWlueT1lLm1pbnkpLGUubWF4eT50aGlzLm1heHkmJih0aGlzLm1heHk9ZS5tYXh5KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmlzTnVsbCgpPyh0aGlzLm1pbng9bix0aGlzLm1heHg9bix0aGlzLm1pbnk9aSx0aGlzLm1heHk9aSk6KG48dGhpcy5taW54JiYodGhpcy5taW54PW4pLG4+dGhpcy5tYXh4JiYodGhpcy5tYXh4PW4pLGk8dGhpcy5taW55JiYodGhpcy5taW55PWkpLGk+dGhpcy5tYXh5JiYodGhpcy5tYXh5PWkpKX19LG1pbkV4dGVudDpmdW5jdGlvbigpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7dmFyIHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gZT50P3Q6ZX0sZ2V0V2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMubWF4eC10aGlzLm1pbnh9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk/MDotMTplLmlzTnVsbCgpPzE6dGhpcy5taW54PGUubWlueD8tMTp0aGlzLm1pbng+ZS5taW54PzE6dGhpcy5taW55PGUubWlueT8tMTp0aGlzLm1pbnk+ZS5taW55PzE6dGhpcy5tYXh4PGUubWF4eD8tMTp0aGlzLm1heHg+ZS5tYXh4PzE6dGhpcy5tYXh5PGUubWF4eT8tMTp0aGlzLm1heHk+ZS5tYXh5PzE6MH0sdHJhbnNsYXRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/bnVsbDp2b2lkIHRoaXMuaW5pdCh0aGlzLmdldE1pblgoKSt0LHRoaXMuZ2V0TWF4WCgpK3QsdGhpcy5nZXRNaW5ZKCkrZSx0aGlzLmdldE1heFkoKStlKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkVudltcIit0aGlzLm1pbngrXCIgOiBcIit0aGlzLm1heHgrXCIsIFwiK3RoaXMubWlueStcIiA6IFwiK3RoaXMubWF4eStcIl1cIn0sc2V0VG9OdWxsOmZ1bmN0aW9uKCl7dGhpcy5taW54PTAsdGhpcy5tYXh4PS0xLHRoaXMubWlueT0wLHRoaXMubWF4eT0tMX0sZ2V0SGVpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLm1heHktdGhpcy5taW55fSxtYXhFeHRlbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO3ZhciB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ+ZT90OmV9LGV4cGFuZEJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZEJ5KHQsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5taW54LT1lLHRoaXMubWF4eCs9ZSx0aGlzLm1pbnktPW4sdGhpcy5tYXh5Kz1uLCh0aGlzLm1pbng+dGhpcy5tYXh4fHx0aGlzLm1pbnk+dGhpcy5tYXh5KSYmdGhpcy5zZXRUb051bGwoKX19LGNvbnRhaW5zOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnMoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb3ZlcnMobixpKX19LGNlbnRyZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6bmV3IGcoKHRoaXMuZ2V0TWluWCgpK3RoaXMuZ2V0TWF4WCgpKS8yLCh0aGlzLmdldE1pblkoKSt0aGlzLmdldE1heFkoKSkvMil9LGluaXQ6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnNldFRvTnVsbCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5taW54PWUubWlueCx0aGlzLm1heHg9ZS5tYXh4LHRoaXMubWlueT1lLm1pbnksdGhpcy5tYXh5PWUubWF4eX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaW5pdChuLngsaS54LG4ueSxpLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXTtzPnI/KHRoaXMubWlueD1yLHRoaXMubWF4eD1zKToodGhpcy5taW54PXMsdGhpcy5tYXh4PXIpLGE+bz8odGhpcy5taW55PW8sdGhpcy5tYXh5PWEpOih0aGlzLm1pbnk9YSx0aGlzLm1heHk9byl9fSxnZXRNYXhZOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4eX0sZGlzdGFuY2U6ZnVuY3Rpb24odCl7aWYodGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiAwO3ZhciBlPTA7dGhpcy5tYXh4PHQubWlueD9lPXQubWlueC10aGlzLm1heHg6dGhpcy5taW54PnQubWF4eCYmKGU9dGhpcy5taW54LXQubWF4eCk7dmFyIG49MDtyZXR1cm4gdGhpcy5tYXh5PHQubWlueT9uPXQubWlueS10aGlzLm1heHk6dGhpcy5taW55PnQubWF4eSYmKG49dGhpcy5taW55LXQubWF4eSksMD09PWU/bjowPT09bj9lOk1hdGguc3FydChlKmUrbipuKX0saGFzaENvZGU6ZnVuY3Rpb24oKXt2YXIgdD0xNztyZXR1cm4gdD0zNyp0K2cuaGFzaENvZGUodGhpcy5taW54KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLm1heHgpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMubWlueSksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5tYXh5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ319KSxDLmludGVyc2VjdHM9ZnVuY3Rpb24oKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuLng+PSh0Lng8ZS54P3QueDplLngpJiZuLng8PSh0Lng+ZS54P3QueDplLngpJiZuLnk+PSh0Lnk8ZS55P3QueTplLnkpJiZuLnk8PSh0Lnk+ZS55P3QueTplLnkpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbz1hcmd1bWVudHNbM10sYT1NYXRoLm1pbihzLngsby54KSx1PU1hdGgubWF4KHMueCxvLngpLGw9TWF0aC5taW4oaS54LHIueCksaD1NYXRoLm1heChpLngsci54KTtyZXR1cm4gbD51PyExOmE+aD8hMTooYT1NYXRoLm1pbihzLnksby55KSx1PU1hdGgubWF4KHMueSxvLnkpLGw9TWF0aC5taW4oaS55LHIueSksaD1NYXRoLm1heChpLnksci55KSxsPnU/ITE6IShhPmgpKX19LEMuc2VyaWFsVmVyc2lvblVJRD0weDUxODQ1Y2Q1NTIxODk4MDAsaCh3LFMpLGUody5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHd9fSksZShMLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTH19KSxMLnRvTG9jYXRpb25TeW1ib2w9ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UgTC5FWFRFUklPUjpyZXR1cm5cImVcIjtjYXNlIEwuQk9VTkRBUlk6cmV0dXJuXCJiXCI7Y2FzZSBMLklOVEVSSU9SOnJldHVyblwiaVwiO2Nhc2UgTC5OT05FOnJldHVyblwiLVwifXRocm93IG5ldyBpKFwiVW5rbm93biBsb2NhdGlvbiB2YWx1ZTogXCIrdCl9LEwuSU5URVJJT1I9MCxMLkJPVU5EQVJZPTEsTC5FWFRFUklPUj0yLEwuTk9ORT0tMSxlKFQucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUfX0pLFQubG9nMTA9ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5sb2codCk7cmV0dXJuIHIuaXNJbmZpbml0ZShlKT9lOnIuaXNOYU4oZSk/ZTplL1QuTE9HXzEwfSxULm1pbj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj10O3JldHVybiByPmUmJihyPWUpLHI+biYmKHI9bikscj5pJiYocj1pKSxyfSxULmNsYW1wPWZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBlPnQ/ZTp0Pm4/bjp0fWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtyZXR1cm4gcj5pP3I6aT5zP3M6aX19LFQud3JhcD1mdW5jdGlvbih0LGUpe3JldHVybiAwPnQ/ZS0gLXQlZTp0JWV9LFQubWF4PWZ1bmN0aW9uKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPXQ7cmV0dXJuIGU+aSYmKGk9ZSksbj5pJiYoaT1uKSxpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM10saT1yO3JldHVybiBzPmkmJihpPXMpLG8+aSYmKGk9byksYT5pJiYoaT1hKSxpfX0sVC5hdmVyYWdlPWZ1bmN0aW9uKHQsZSl7XG5yZXR1cm4odCtlKS8yfSxULkxPR18xMD1NYXRoLmxvZygxMCksUC5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKHQpe3RoaXMuc3RyKz10fSxQLnByb3RvdHlwZS5zZXRDaGFyQXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX0sUC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RyfSxiLnByb3RvdHlwZS5pbnRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxiLnByb3RvdHlwZS5jb21wYXJlVG89ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudmFsdWU8dD8tMTp0aGlzLnZhbHVlPnQ/MTowfSxiLmlzTmFOPWZ1bmN0aW9uKHQpe3JldHVybiBOdW1iZXIuaXNOYU4odCl9LE8uaXNXaGl0ZXNwYWNlPWZ1bmN0aW9uKHQpe3JldHVybiAzMj49dCYmdD49MHx8MTI3PT10fSxPLnRvVXBwZXJDYXNlPWZ1bmN0aW9uKHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9LGUoXy5wcm90b3R5cGUse2xlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhpPHQuaGl8fHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPD10LmxvfSxleHRyYWN0U2lnbmlmaWNhbnREaWdpdHM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmFicygpLGk9Xy5tYWduaXR1ZGUobi5oaSkscj1fLlRFTi5wb3coaSk7bj1uLmRpdmlkZShyKSxuLmd0KF8uVEVOKT8obj1uLmRpdmlkZShfLlRFTiksaSs9MSk6bi5sdChfLk9ORSkmJihuPW4ubXVsdGlwbHkoXy5URU4pLGktPTEpO2Zvcih2YXIgcz1pKzEsbz1uZXcgUCxhPV8uTUFYX1BSSU5UX0RJR0lUUy0xLHU9MDthPj11O3UrKyl7dCYmdT09PXMmJm8uYXBwZW5kKFwiLlwiKTt2YXIgbD1NYXRoLnRydW5jKG4uaGkpO2lmKDA+bClicmVhazt2YXIgaD0hMSxjPTA7bD45PyhoPSEwLGM9XCI5XCIpOmM9XCIwXCIrbCxvLmFwcGVuZChjKSxuPW4uc3VidHJhY3QoXy52YWx1ZU9mKGwpKS5tdWx0aXBseShfLlRFTiksaCYmbi5zZWxmQWRkKF8uVEVOKTt2YXIgZj0hMCxnPV8ubWFnbml0dWRlKG4uaGkpO2lmKDA+ZyYmTWF0aC5hYnMoZyk+PWEtdSYmKGY9ITEpLCFmKWJyZWFrfXJldHVybiBlWzBdPWksby50b1N0cmluZygpfSxzcXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWx0aXBseSh0aGlzKX0sZG91YmxlVmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaSt0aGlzLmxvfSxzdWJ0cmFjdDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCh0Lm5lZ2F0ZSgpKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKC1lKX19LGVxdWFsczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPT09dC5sb319LGlzWmVybzpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5oaSYmMD09PXRoaXMubG99LHNlbGZTdWJ0cmFjdDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQuaGksLXQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC1lLDApfX0sZ2V0U3BlY2lhbE51bWJlclN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzWmVybygpP1wiMC4wXCI6dGhpcy5pc05hTigpP1wiTmFOIFwiOm51bGx9LG1pbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sZSh0KT90aGlzOnR9LHNlbGZEaXZpZGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKGUsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGwsdT1udWxsLGw9bnVsbCxoPW51bGwsYz1udWxsO3JldHVybiB1PXRoaXMuaGkvbixsPV8uU1BMSVQqdSxyPWwtdSxjPV8uU1BMSVQqbixyPWwtcixzPXUtcixvPWMtbixoPXUqbixvPWMtbyxhPW4tbyxjPXIqby1oK3IqYStzKm8rcyphLGw9KHRoaXMuaGktaC1jK3RoaXMubG8tdSppKS9uLGM9dStsLHRoaXMuaGk9Yyx0aGlzLmxvPXUtYytsLHRoaXN9fSxkdW1wOmZ1bmN0aW9uKCl7cmV0dXJuXCJERDxcIit0aGlzLmhpK1wiLCBcIit0aGlzLmxvK1wiPlwifSxkaXZpZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXSxlPW51bGwsbj1udWxsLGk9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbCx1PW51bGwsbD1udWxsO289dGhpcy5oaS90LmhpLGE9Xy5TUExJVCpvLGU9YS1vLGw9Xy5TUExJVCp0LmhpLGU9YS1lLG49by1lLGk9bC10LmhpLHU9byp0LmhpLGk9bC1pLHM9dC5oaS1pLGw9ZSppLXUrZSpzK24qaStuKnMsYT0odGhpcy5oaS11LWwrdGhpcy5sby1vKnQubG8pL3QuaGksbD1vK2E7dmFyIGg9bCxjPW8tbCthO3JldHVybiBuZXcgXyhoLGMpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBmPWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTihmKT9fLmNyZWF0ZU5hTigpOl8uY29weSh0aGlzKS5zZWxmRGl2aWRlKGYsMCl9fSxnZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaT50LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbz49dC5sb30scG93OmZ1bmN0aW9uKHQpe2lmKDA9PT10KXJldHVybiBfLnZhbHVlT2YoMSk7dmFyIGU9bmV3IF8odGhpcyksbj1fLnZhbHVlT2YoMSksaT1NYXRoLmFicyh0KTtpZihpPjEpZm9yKDtpPjA7KWklMj09PTEmJm4uc2VsZk11bHRpcGx5KGUpLGkvPTIsaT4wJiYoZT1lLnNxcigpKTtlbHNlIG49ZTtyZXR1cm4gMD50P24ucmVjaXByb2NhbCgpOm59LGNlaWw6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIF8uTmFOO3ZhciB0PU1hdGguY2VpbCh0aGlzLmhpKSxlPTA7cmV0dXJuIHQ9PT10aGlzLmhpJiYoZT1NYXRoLmNlaWwodGhpcy5sbykpLG5ldyBfKHQsZSl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmhpPGUuaGk/LTE6dGhpcy5oaT5lLmhpPzE6dGhpcy5sbzxlLmxvPy0xOnRoaXMubG8+ZS5sbz8xOjB9LHJpbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIHRoaXM7dmFyIHQ9dGhpcy5hZGQoLjUpO3JldHVybiB0LmZsb29yKCl9LHNldFZhbHVlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KGUpLHRoaXN9fSxtYXg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2UodCk/dGhpczp0fSxzcXJ0OmZ1bmN0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gXy52YWx1ZU9mKDApO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBfLk5hTjt2YXIgdD0xL01hdGguc3FydCh0aGlzLmhpKSxlPXRoaXMuaGkqdCxuPV8udmFsdWVPZihlKSxpPXRoaXMuc3VidHJhY3Qobi5zcXIoKSkscj1pLmhpKiguNSp0KTtyZXR1cm4gbi5hZGQocil9LHNlbGZBZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkFkZCh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXSxuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyZXR1cm4gcj10aGlzLmhpK2Usbz1yLXRoaXMuaGkscz1yLW8scz1lLW8rKHRoaXMuaGktcyksYT1zK3RoaXMubG8sbj1yK2EsaT1hKyhyLW4pLHRoaXMuaGk9bitpLHRoaXMubG89aSsobi10aGlzLmhpKSx0aGlzfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdT1hcmd1bWVudHNbMF0sbD1hcmd1bWVudHNbMV0sbj1udWxsLGk9bnVsbCxoPW51bGwsYz1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyPXRoaXMuaGkrdSxoPXRoaXMubG8rbCxvPXItdGhpcy5oaSxhPWgtdGhpcy5sbyxzPXItbyxjPWgtYSxzPXUtbysodGhpcy5oaS1zKSxjPWwtYSsodGhpcy5sby1jKSxvPXMraCxuPXIrbyxpPW8rKHItbiksbz1jK2k7dmFyIGY9bitvLGc9bysobi1mKTtyZXR1cm4gdGhpcy5oaT1mLHRoaXMubG89Zyx0aGlzfX0sc2VsZk11bHRpcGx5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkoZSwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbCx1PW51bGwsbD1udWxsO3U9Xy5TUExJVCp0aGlzLmhpLHI9dS10aGlzLmhpLGw9Xy5TUExJVCpuLHI9dS1yLHM9dGhpcy5oaS1yLG89bC1uLHU9dGhpcy5oaSpuLG89bC1vLGE9bi1vLGw9cipvLXUrciphK3MqbytzKmErKHRoaXMuaGkqaSt0aGlzLmxvKm4pO3ZhciBoPXUrbDtyPXUtaDt2YXIgYz1sK3I7cmV0dXJuIHRoaXMuaGk9aCx0aGlzLmxvPWMsdGhpc319LHNlbGZTcXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodGhpcyl9LGZsb29yOmZ1bmN0aW9uKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBfLk5hTjt2YXIgdD1NYXRoLmZsb29yKHRoaXMuaGkpLGU9MDtyZXR1cm4gdD09PXRoaXMuaGkmJihlPU1hdGguZmxvb3IodGhpcy5sbykpLG5ldyBfKHQsZSl9LG5lZ2F0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczpuZXcgXygtdGhpcy5oaSwtdGhpcy5sbyl9LGNsb25lOmZ1bmN0aW9uKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gbnVsbDt0aHJvdyB0fWZpbmFsbHl7fX0sbXVsdGlwbHk6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5pc05hTigpP18uY3JlYXRlTmFOKCk6Xy5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHIuaXNOYU4oZSk/Xy5jcmVhdGVOYU4oKTpfLmNvcHkodGhpcykuc2VsZk11bHRpcGx5KGUsMCl9fSxpc05hTjpmdW5jdGlvbigpe3JldHVybiByLmlzTmFOKHRoaXMuaGkpfSxpbnRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBNYXRoLnRydW5jKHRoaXMuaGkpfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PV8ubWFnbml0dWRlKHRoaXMuaGkpO3JldHVybiB0Pj0tMyYmMjA+PXQ/dGhpcy50b1N0YW5kYXJkTm90YXRpb24oKTp0aGlzLnRvU2NpTm90YXRpb24oKX0sdG9TdGFuZGFyZE5vdGF0aW9uOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7dmFyIGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMCxlKSxpPWVbMF0rMSxyPW47aWYoXCIuXCI9PT1uLmNoYXJBdCgwKSlyPVwiMFwiK247ZWxzZSBpZigwPmkpcj1cIjAuXCIrXy5zdHJpbmdPZkNoYXIoXCIwXCIsLWkpK247ZWxzZSBpZigtMT09PW4uaW5kZXhPZihcIi5cIikpe3ZhciBzPWktbi5sZW5ndGgsbz1fLnN0cmluZ09mQ2hhcihcIjBcIixzKTtyPW4rbytcIi4wXCJ9cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK3I6cn0scmVjaXByb2NhbDpmdW5jdGlvbigpe3ZhciB0PW51bGwsZT1udWxsLG49bnVsbCxpPW51bGwscj1udWxsLHM9bnVsbCxvPW51bGwsYT1udWxsO3I9MS90aGlzLmhpLHM9Xy5TUExJVCpyLHQ9cy1yLGE9Xy5TUExJVCp0aGlzLmhpLHQ9cy10LGU9ci10LG49YS10aGlzLmhpLG89cip0aGlzLmhpLG49YS1uLGk9dGhpcy5oaS1uLGE9dCpuLW8rdCppK2UqbitlKmkscz0oMS1vLWEtcip0aGlzLmxvKS90aGlzLmhpO3ZhciB1PXIrcyxsPXItdStzO3JldHVybiBuZXcgXyh1LGwpfSx0b1NjaU5vdGF0aW9uOmZ1bmN0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gXy5TQ0lfTk9UX1pFUk87dmFyIHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7dmFyIGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMSxlKSxpPV8uU0NJX05PVF9FWFBPTkVOVF9DSEFSK2VbMF07aWYoXCIwXCI9PT1uLmNoYXJBdCgwKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiRm91bmQgbGVhZGluZyB6ZXJvOiBcIituKTt2YXIgcj1cIlwiO24ubGVuZ3RoPjEmJihyPW4uc3Vic3RyaW5nKDEpKTt2YXIgcz1uLmNoYXJBdCgwKStcIi5cIityO3JldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIitzK2k6cytpfSxhYnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc05hTigpP18uTmFOOnRoaXMuaXNOZWdhdGl2ZSgpP3RoaXMubmVnYXRlKCk6bmV3IF8odGhpcyl9LGlzUG9zaXRpdmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaT4wfHwwPT09dGhpcy5oaSYmdGhpcy5sbz4wfSxsdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaTx0LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbzx0LmxvfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gXy5jb3B5KHRoaXMpLnNlbGZBZGQodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBfLmNvcHkodGhpcykuc2VsZkFkZChlKX19LGluaXQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaGk9dCx0aGlzLmxvPTB9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmhpPWUuaGksdGhpcy5sbz1lLmxvfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5oaT1uLHRoaXMubG89aX19LGd0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhpPnQuaGl8fHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPnQubG99LGlzTmVnYXRpdmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaTwwfHwwPT09dGhpcy5oaSYmdGhpcy5sbzwwfSx0cnVuYzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTmFOKCk/Xy5OYU46dGhpcy5pc1Bvc2l0aXZlKCk/dGhpcy5mbG9vcigpOnRoaXMuY2VpbCgpfSxzaWdudW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaT4wPzE6dGhpcy5oaTwwPy0xOnRoaXMubG8+MD8xOnRoaXMubG88MD8tMTowfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1LHMsb119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF99fSksXy5zcXI9ZnVuY3Rpb24odCl7cmV0dXJuIF8udmFsdWVPZih0KS5zZWxmTXVsdGlwbHkodCl9LF8udmFsdWVPZj1mdW5jdGlvbigpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gXy5wYXJzZSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBfKGUpfX0sXy5zcXJ0PWZ1bmN0aW9uKHQpe3JldHVybiBfLnZhbHVlT2YodCkuc3FydCgpfSxfLnBhcnNlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dC5sZW5ndGg7Ty5pc1doaXRlc3BhY2UodC5jaGFyQXQoZSkpOyllKys7dmFyIGk9ITE7aWYobj5lKXt2YXIgcj10LmNoYXJBdChlKTtcIi1cIiE9PXImJlwiK1wiIT09cnx8KGUrKyxcIi1cIj09PXImJihpPSEwKSl9Zm9yKHZhciBzPW5ldyBfLG89MCxhPTAsdT0wOzspe2lmKGU+PW4pYnJlYWs7dmFyIGw9dC5jaGFyQXQoZSk7aWYoZSsrLE8uaXNEaWdpdChsKSl7dmFyIGg9bC1cIjBcIjtzLnNlbGZNdWx0aXBseShfLlRFTikscy5zZWxmQWRkKGgpLG8rK31lbHNle2lmKFwiLlwiIT09bCl7aWYoXCJlXCI9PT1sfHxcIkVcIj09PWwpe3ZhciBjPXQuc3Vic3RyaW5nKGUpO3RyeXt1PWIucGFyc2VJbnQoYyl9Y2F0Y2goZSl7dGhyb3cgZSBpbnN0YW5jZW9mIE51bWJlckZvcm1hdEV4Y2VwdGlvbj9uZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiSW52YWxpZCBleHBvbmVudCBcIitjK1wiIGluIHN0cmluZyBcIit0KTplfWZpbmFsbHl7fWJyZWFrfXRocm93IG5ldyBOdW1iZXJGb3JtYXRFeGNlcHRpb24oXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIrbCtcIicgYXQgcG9zaXRpb24gXCIrZStcIiBpbiBzdHJpbmcgXCIrdCl9YT1vfX12YXIgZj1zLGc9by1hLXU7aWYoMD09PWcpZj1zO2Vsc2UgaWYoZz4wKXt2YXIgZD1fLlRFTi5wb3coZyk7Zj1zLmRpdmlkZShkKX1lbHNlIGlmKDA+Zyl7dmFyIGQ9Xy5URU4ucG93KC1nKTtmPXMubXVsdGlwbHkoZCl9cmV0dXJuIGk/Zi5uZWdhdGUoKTpmfSxfLmNyZWF0ZU5hTj1mdW5jdGlvbigpe3JldHVybiBuZXcgXyhyLk5hTixyLk5hTil9LF8uY29weT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IF8odCl9LF8ubWFnbml0dWRlPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguYWJzKHQpLG49TWF0aC5sb2coZSkvTWF0aC5sb2coMTApLGk9TWF0aC50cnVuYyhNYXRoLmZsb29yKG4pKSxyPU1hdGgucG93KDEwLGkpO3JldHVybiBlPj0xMCpyJiYoaSs9MSksaX0sXy5zdHJpbmdPZkNoYXI9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IFAsaT0wO2U+aTtpKyspbi5hcHBlbmQodCk7cmV0dXJuIG4udG9TdHJpbmcoKX0sXy5QST1uZXcgXygzLjE0MTU5MjY1MzU4OTc5MywxLjIyNDY0Njc5OTE0NzM1MzJlLTE2KSxfLlRXT19QST1uZXcgXyg2LjI4MzE4NTMwNzE3OTU4NiwyLjQ0OTI5MzU5ODI5NDcwNjRlLTE2KSxfLlBJXzI9bmV3IF8oMS41NzA3OTYzMjY3OTQ4OTY2LDYuMTIzMjMzOTk1NzM2NzY2ZS0xNyksXy5FPW5ldyBfKDIuNzE4MjgxODI4NDU5MDQ1LDEuNDQ1NjQ2ODkxNzI5MjUwMmUtMTYpLF8uTmFOPW5ldyBfKHIuTmFOLHIuTmFOKSxfLkVQUz0xLjIzMjU5NTE2NDQwNzgzZS0zMixfLlNQTElUPTEzNDIxNzcyOSxfLk1BWF9QUklOVF9ESUdJVFM9MzIsXy5URU49Xy52YWx1ZU9mKDEwKSxfLk9ORT1fLnZhbHVlT2YoMSksXy5TQ0lfTk9UX0VYUE9ORU5UX0NIQVI9XCJFXCIsXy5TQ0lfTk9UX1pFUk89XCIwLjBFMFwiLGUoTS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE19fSksTS5vcmllbnRhdGlvbkluZGV4PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1NLm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pO2lmKDE+PWkpcmV0dXJuIGk7dmFyIHI9Xy52YWx1ZU9mKGUueCkuc2VsZkFkZCgtdC54KSxzPV8udmFsdWVPZihlLnkpLnNlbGZBZGQoLXQueSksbz1fLnZhbHVlT2Yobi54KS5zZWxmQWRkKC1lLngpLGE9Xy52YWx1ZU9mKG4ueSkuc2VsZkFkZCgtZS55KTtyZXR1cm4gci5zZWxmTXVsdGlwbHkoYSkuc2VsZlN1YnRyYWN0KHMuc2VsZk11bHRpcGx5KG8pKS5zaWdudW0oKX0sTS5zaWduT2ZEZXQyeDI9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dC5tdWx0aXBseShpKS5zZWxmU3VidHJhY3QoZS5tdWx0aXBseShuKSk7cmV0dXJuIHIuc2lnbnVtKCl9LE0uaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8udmFsdWVPZihpLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KSkscz1fLnZhbHVlT2YoaS54KS5zZWxmU3VidHJhY3Qobi54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkpLG89ci5zdWJ0cmFjdChzKSxhPV8udmFsdWVPZihpLngpLnNlbGZTdWJ0cmFjdChuLngpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3Qobi55KSksdT1fLnZhbHVlT2YoaS55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KG4ueCkpLGw9YS5zdWJ0cmFjdCh1KSxoPWwuc2VsZkRpdmlkZShvKS5kb3VibGVWYWx1ZSgpLGM9Xy52YWx1ZU9mKHQueCkuc2VsZkFkZChfLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoaCkpLmRvdWJsZVZhbHVlKCksZj1fLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLGQ9Xy52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxwPWYuc3VidHJhY3QoZCksdj1wLnNlbGZEaXZpZGUobykuZG91YmxlVmFsdWUoKSxtPV8udmFsdWVPZihuLnkpLnNlbGZBZGQoXy52YWx1ZU9mKGkueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KHYpKS5kb3VibGVWYWx1ZSgpO3JldHVybiBuZXcgZyhjLG0pfSxNLm9yaWVudGF0aW9uSW5kZXhGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW51bGwscj0odC54LW4ueCkqKGUueS1uLnkpLHM9KHQueS1uLnkpKihlLngtbi54KSxvPXItcztpZihyPjApe2lmKDA+PXMpcmV0dXJuIE0uc2lnbnVtKG8pO2k9citzfWVsc2V7aWYoISgwPnIpKXJldHVybiBNLnNpZ251bShvKTtpZihzPj0wKXJldHVybiBNLnNpZ251bShvKTtpPS1yLXN9dmFyIGE9TS5EUF9TQUZFX0VQU0lMT04qaTtyZXR1cm4gbz49YXx8LW8+PWE/TS5zaWdudW0obyk6Mn0sTS5zaWdudW09ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD8xOjA+dD8tMTowfSxNLkRQX1NBRkVfRVBTSUxPTj0xZS0xNSxlKEQucHJvdG90eXBlLHtzZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUsbil7fSxzaXplOmZ1bmN0aW9uKCl7fSxnZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUpe30sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX19LGdldENvb3JkaW5hdGVDb3B5OmZ1bmN0aW9uKHQpe30sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7fSxnZXRYOmZ1bmN0aW9uKHQpe30sY2xvbmU6ZnVuY3Rpb24oKXt9LGV4cGFuZEVudmVsb3BlOmZ1bmN0aW9uKHQpe30sY29weTpmdW5jdGlvbigpe30sZ2V0WTpmdW5jdGlvbih0KXt9LHRvQ29vcmRpbmF0ZUFycmF5OmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRH19KSxELlg9MCxELlk9MSxELlo9MixELk09MyxBLmFycmF5Y29weT1mdW5jdGlvbih0LGUsbixpLHIpe2Zvcih2YXIgcz0wLG89ZTtlK3I+bztvKyspbltpK3NdPXRbb10scysrfSxBLmdldFByb3BlcnR5PWZ1bmN0aW9uKHQpe3JldHVybntcImxpbmUuc2VwYXJhdG9yXCI6XCJcXG5cIn1bdF19LGUoRi5wcm90b3R5cGUse2dldFk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnkvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdztyZXR1cm4gdH0sZ2V0WDpmdW5jdGlvbigpe3ZhciB0PXRoaXMueC90aGlzLnc7aWYoci5pc05hTih0KXx8ci5pc0luZmluaXRlKHQpKXRocm93IG5ldyB3O3JldHVybiB0fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGc7cmV0dXJuIHQueD10aGlzLmdldFgoKSx0Lnk9dGhpcy5nZXRZKCksdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRn19KSxGLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcz10LnktZS55LG89ZS54LXQueCxhPXQueCplLnktZS54KnQueSx1PW4ueS1pLnksbD1pLngtbi54LGg9bi54KmkueS1pLngqbi55LGM9bypoLWwqYSxmPXUqYS1zKmgsZD1zKmwtdSpvLHA9Yy9kLHY9Zi9kO2lmKHIuaXNOYU4ocCl8fHIuaXNJbmZpbml0ZShwKXx8ci5pc05hTih2KXx8ci5pc0luZmluaXRlKHYpKXRocm93IG5ldyB3O3JldHVybiBuZXcgZyhwLHYpfSxlKEcucHJvdG90eXBlLHtjcmVhdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7YXJndW1lbnRzWzBdfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sRCkpe2FyZ3VtZW50c1swXX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEd9fSksZShxLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcX19KSxlKEIucHJvdG90eXBlLHtpc0dlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OfSxnZXRGYWN0b3J5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmFjdG9yeX0sZ2V0R2VvbWV0cnlOOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzfSxnZXRBcmVhOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LGlzUmVjdGFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVxdWFsczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbnVsbD09PXQ/ITE6dGhpcy5lcXVhbHNUb3BvKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0KXt2YXIgZT1hcmd1bWVudHNbMF07aWYoIShlIGluc3RhbmNlb2YgQikpcmV0dXJuITE7dmFyIG49ZTtyZXR1cm4gdGhpcy5lcXVhbHNFeGFjdChuKX19fSxlcXVhbHNFeGFjdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcz09PXR8fHRoaXMuZXF1YWxzRXhhY3QodCwwKX0sZ2VvbWV0cnlDaGFuZ2VkOmZ1bmN0aW9uKCl7dGhpcy5hcHBseShCLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcil9LGdlb21ldHJ5Q2hhbmdlZEFjdGlvbjpmdW5jdGlvbigpe3RoaXMuZW52ZWxvcGU9bnVsbH0sZXF1YWxzTm9ybTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXQ/ITE6dGhpcy5ub3JtKCkuZXF1YWxzRXhhY3QodC5ub3JtKCkpfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZ2V0TnVtR2VvbWV0cmllczpmdW5jdGlvbigpe3JldHVybiAxfSxjb21wYXJlVG86ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dDtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSE9PWUuZ2V0U29ydEluZGV4KCk/dGhpcy5nZXRTb3J0SW5kZXgoKS1lLmdldFNvcnRJbmRleCgpOnRoaXMuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOmUuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3ModCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW47cmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkhPT1lLmdldFNvcnRJbmRleCgpP3RoaXMuZ2V0U29ydEluZGV4KCktZS5nZXRTb3J0SW5kZXgoKTp0aGlzLmlzRW1wdHkoKSYmZS5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTplLmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKG4saSl9fSxnZXRVc2VyRGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVzZXJEYXRhfSxnZXRTUklEOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuU1JJRH0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeSh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9LGNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHQuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04pdGhyb3cgbmV3IGkoXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIil9LGVxdWFsOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gMD09PW4/dC5lcXVhbHMoZSk6dC5kaXN0YW5jZShlKTw9bn0sbm9ybTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY29weSgpO3JldHVybiB0Lm5vcm1hbGl6ZSgpLHR9LGdldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfSxnZXRFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmVudmVsb3BlJiYodGhpcy5lbnZlbG9wZT10aGlzLmNvbXB1dGVFbnZlbG9wZUludGVybmFsKCkpLG5ldyBDKHRoaXMuZW52ZWxvcGUpfSxzZXRTUklEOmZ1bmN0aW9uKHQpe3RoaXMuU1JJRD10fSxzZXRVc2VyRGF0YTpmdW5jdGlvbih0KXt0aGlzLnVzZXJEYXRhPXR9LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pdGVyYXRvcigpLGk9ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpJiZpLmhhc05leHQoKTspe3ZhciByPW4ubmV4dCgpLHM9aS5uZXh0KCksbz1yLmNvbXBhcmVUbyhzKTtpZigwIT09bylyZXR1cm4gb31yZXR1cm4gbi5oYXNOZXh0KCk/MTppLmhhc05leHQoKT8tMTowfSxoYXNoQ29kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5oYXNoQ29kZSgpfSxpc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OfHx0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfTVVMVElQT0lOVHx8dGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX01VTFRJTElORVNUUklOR3x8dGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX01VTFRJUE9MWUdPTn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bbyxzLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCfX0pLEIuaGFzTm9uRW1wdHlFbGVtZW50cz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKylpZighdFtlXS5pc0VtcHR5KCkpcmV0dXJuITA7cmV0dXJuITF9LEIuaGFzTnVsbEVsZW1lbnRzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKG51bGw9PT10W2VdKXJldHVybiEwO3JldHVybiExfSxCLnNlcmlhbFZlcnNpb25VSUQ9MHg3OTllYTQ2NTIyODU0YzAwLEIuU09SVElOREVYX1BPSU5UPTAsQi5TT1JUSU5ERVhfTVVMVElQT0lOVD0xLEIuU09SVElOREVYX0xJTkVTVFJJTkc9MixCLlNPUlRJTkRFWF9MSU5FQVJSSU5HPTMsQi5TT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HPTQsQi5TT1JUSU5ERVhfUE9MWUdPTj01LEIuU09SVElOREVYX01VTFRJUE9MWUdPTj02LEIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTj03LEIuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZmlsdGVyOmZ1bmN0aW9uKHQpe3QuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl9fSxlKHoucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6fX0pLGUoVi5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZ9fSksZShrLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0JTI9PT0xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltWXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga319KSxlKFkucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bVl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFl9fSksZShVLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0PjF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVfX0pLGUoWC5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtyZXR1cm4gMT09PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYfX0pLFYuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGU9ayxWLkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1ZLFYuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9VSxWLk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9WCxWLk1PRDJfQk9VTkRBUllfUlVMRT1uZXcgayxWLkVORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IFksVi5NVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBVLFYuTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBYLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFPVYuTU9EMl9CT1VOREFSWV9SVUxFLGUoSC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEh9fSksSC5pc1Jpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoPDQ/ITE6ISF0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfSxILnB0Tm90SW5MaXN0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07aWYoSC5pbmRleE9mKGksZSk8MClyZXR1cm4gaX1yZXR1cm4gbnVsbH0sSC5zY3JvbGw9ZnVuY3Rpb24odCxlKXt2YXIgbj1ILmluZGV4T2YoZSx0KTtpZigwPm4pcmV0dXJuIG51bGw7dmFyIGk9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO0EuYXJyYXljb3B5KHQsbixpLDAsdC5sZW5ndGgtbiksQS5hcnJheWNvcHkodCwwLGksdC5sZW5ndGgtbixuKSxBLmFycmF5Y29weShpLDAsdCwwLHQubGVuZ3RoKX0sSC5lcXVhbHM9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlW25dKSlyZXR1cm4hMTtyZXR1cm4hMH1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO2lmKGk9PT1yKXJldHVybiEwO2lmKG51bGw9PT1pfHxudWxsPT09cilyZXR1cm4hMTtpZihpLmxlbmd0aCE9PXIubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248aS5sZW5ndGg7bisrKWlmKDAhPT1zLmNvbXBhcmUoaVtuXSxyW25dKSlyZXR1cm4hMTtyZXR1cm4hMH19LEguaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBOLGk9MDtpPHQubGVuZ3RoO2krKyllLmludGVyc2VjdHModFtpXSkmJm4uYWRkKHRbaV0sITApO3JldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9LEguaGFzUmVwZWF0ZWRQb2ludHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTx0Lmxlbmd0aDtlKyspaWYodFtlLTFdLmVxdWFscyh0W2VdKSlyZXR1cm4hMDtyZXR1cm4hMX0sSC5yZW1vdmVSZXBlYXRlZFBvaW50cz1mdW5jdGlvbih0KXtpZighSC5oYXNSZXBlYXRlZFBvaW50cyh0KSlyZXR1cm4gdDt2YXIgZT1uZXcgTih0LCExKTtyZXR1cm4gZS50b0Nvb3JkaW5hdGVBcnJheSgpfSxILnJldmVyc2U9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLTEsbj1NYXRoLnRydW5jKGUvMiksaT0wO24+PWk7aSsrKXt2YXIgcj10W2ldO3RbaV09dFtlLWldLHRbZS1pXT1yfX0sSC5yZW1vdmVOdWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoO24rKyludWxsIT09dFtuXSYmZSsrO3ZhciBpPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2lmKDA9PT1lKXJldHVybiBpO2Zvcih2YXIgcj0wLG49MDtuPHQubGVuZ3RoO24rKyludWxsIT09dFtuXSYmKGlbcisrXT10W25dKTtyZXR1cm4gaX0sSC5jb3B5RGVlcD1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPHQubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfWlmKDU9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbz1hcmd1bWVudHNbM10sYT1hcmd1bWVudHNbNF0sbj0wO2E+bjtuKyspc1tvK25dPW5ldyBnKGlbcituXSl9LEguaXNFcXVhbFJldmVyc2VkPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl0scj1lW3QubGVuZ3RoLW4tMV07aWYoMCE9PWkuY29tcGFyZVRvKHIpKXJldHVybiExfXJldHVybiEwfSxILmVudmVsb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQyxuPTA7bjx0Lmxlbmd0aDtuKyspZS5leHBhbmRUb0luY2x1ZGUodFtuXSk7cmV0dXJuIGV9LEgudG9Db29yZGluYXRlQXJyYXk9ZnVuY3Rpb24odCl7cmV0dXJuIHQudG9BcnJheShILmNvb3JkQXJyYXlUeXBlKX0sSC5hdExlYXN0TkNvb3JkaW5hdGVzT3JOb3RoaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUubGVuZ3RoPj10P2U6W119LEguaW5kZXhPZj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKWlmKHQuZXF1YWxzKGVbbl0pKXJldHVybiBuO3JldHVybi0xfSxILmluY3JlYXNpbmdEaXJlY3Rpb249ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTxNYXRoLnRydW5jKHQubGVuZ3RoLzIpO2UrKyl7dmFyIG49dC5sZW5ndGgtMS1lLGk9dFtlXS5jb21wYXJlVG8odFtuXSk7aWYoMCE9PWkpcmV0dXJuIGl9cmV0dXJuIDF9LEguY29tcGFyZT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGgmJm48ZS5sZW5ndGg7KXt2YXIgaT10W25dLmNvbXBhcmVUbyhlW25dKTtpZigwIT09aSlyZXR1cm4gaTtuKyt9cmV0dXJuIG48ZS5sZW5ndGg/LTE6bjx0Lmxlbmd0aD8xOjB9LEgubWluQ29vcmRpbmF0ZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPTA7bjx0Lmxlbmd0aDtuKyspKG51bGw9PT1lfHxlLmNvbXBhcmVUbyh0W25dKT4wKSYmKGU9dFtuXSk7cmV0dXJuIGV9LEguZXh0cmFjdD1mdW5jdGlvbih0LGUsbil7ZT1ULmNsYW1wKGUsMCx0Lmxlbmd0aCksbj1ULmNsYW1wKG4sLTEsdC5sZW5ndGgpO3ZhciBpPW4tZSsxOzA+biYmKGk9MCksZT49dC5sZW5ndGgmJihpPTApLGU+biYmKGk9MCk7dmFyIHI9bmV3IEFycmF5KGkpLmZpbGwobnVsbCk7aWYoMD09PWkpcmV0dXJuIHI7Zm9yKHZhciBzPTAsbz1lO24+PW87bysrKXJbcysrXT10W29dO3JldHVybiByfSxlKFcucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWU7cmV0dXJuIEguY29tcGFyZShuLGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV319KSxlKGoucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWU7aWYobi5sZW5ndGg8aS5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+aS5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO3ZhciByPUguY29tcGFyZShuLGkpLHM9SC5pc0VxdWFsUmV2ZXJzZWQobixpKTtyZXR1cm4gcz8wOnJ9LE9MRGNvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtpZihuLmxlbmd0aDxpLmxlbmd0aClyZXR1cm4tMTtpZihuLmxlbmd0aD5pLmxlbmd0aClyZXR1cm4gMTtpZigwPT09bi5sZW5ndGgpcmV0dXJuIDA7Zm9yKHZhciByPUguaW5jcmVhc2luZ0RpcmVjdGlvbihuKSxzPUguaW5jcmVhc2luZ0RpcmVjdGlvbihpKSxvPXI+MD8wOm4ubGVuZ3RoLTEsYT1zPjA/MDpuLmxlbmd0aC0xLHU9MDt1PG4ubGVuZ3RoO3UrKyl7dmFyIGw9bltvXS5jb21wYXJlVG8oaVthXSk7aWYoMCE9PWwpcmV0dXJuIGw7bys9cixhKz1zfXJldHVybiAwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gan19KSxILkZvcndhcmRDb21wYXJhdG9yPVcsSC5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvcj1qLEguY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCksSy5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe30sSy5wcm90b3R5cGUuZW50cnlTZXQ9ZnVuY3Rpb24oKXt9LFoucHJvdG90eXBlPW5ldyBLLFEucHJvdG90eXBlPW5ldyB2LFEucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKCl7fSxKLnByb3RvdHlwZT1uZXcgUSxKLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXt2YXIgaT10aGlzLmFycmF5X1tlXTtpZihpPT09dClyZXR1cm4hMH1yZXR1cm4hMX0sSi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnRhaW5zKHQpPyExOih0aGlzLmFycmF5Xy5wdXNoKHQpLCEwKX0sSi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sSi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBqYXZhc2NyaXB0LnV0aWwuT3BlcmF0aW9uTm90U3VwcG9ydGVkfSxKLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sSi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxKLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LEoucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBKcyh0aGlzKX07dmFyIEpzPWZ1bmN0aW9uKHQpe3RoaXMuaGFzaFNldF89dCx0aGlzLnBvc2l0aW9uXz0wfTtKcy5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5oYXNoU2V0Xy5zaXplKCkpdGhyb3cgbmV3IHg7cmV0dXJuIHRoaXMuaGFzaFNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdfSxKcy5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLmhhc2hTZXRfLnNpemUoKX0sSnMucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBFfTt2YXIgJHM9MCx0bz0xO3J0LnByb3RvdHlwZT1uZXcgWixydC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnJvb3RfO251bGwhPT1lOyl7dmFyIG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKDA+billPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4gZS52YWx1ZTtlPWUucmlnaHR9fXJldHVybiBudWxsfSxydC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXRoaXMucm9vdF8pcmV0dXJuIHRoaXMucm9vdF89e2tleTp0LHZhbHVlOmUsbGVmdDpudWxsLHJpZ2h0Om51bGwscGFyZW50Om51bGwsY29sb3I6JHMsZ2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5fX0sdGhpcy5zaXplXz0xLG51bGw7dmFyIG4saSxyPXRoaXMucm9vdF87ZG8gaWYobj1yLGk9dC5jb21wYXJlVG8oci5rZXkpLDA+aSlyPXIubGVmdDtlbHNle2lmKCEoaT4wKSl7dmFyIHM9ci52YWx1ZTtyZXR1cm4gci52YWx1ZT1lLHN9cj1yLnJpZ2h0fXdoaWxlKG51bGwhPT1yKTt2YXIgbz17a2V5OnQsbGVmdDpudWxsLHJpZ2h0Om51bGwsdmFsdWU6ZSxwYXJlbnQ6bixjb2xvcjokcyxnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXl9fTtyZXR1cm4gMD5pP24ubGVmdD1vOm4ucmlnaHQ9byx0aGlzLmZpeEFmdGVySW5zZXJ0aW9uKG8pLHRoaXMuc2l6ZV8rKyxudWxsfSxydC5wcm90b3R5cGUuZml4QWZ0ZXJJbnNlcnRpb249ZnVuY3Rpb24odCl7Zm9yKHQuY29sb3I9dG87bnVsbCE9dCYmdCE9dGhpcy5yb290XyYmdC5wYXJlbnQuY29sb3I9PXRvOylpZih0dCh0KT09bnQodHQodHQodCkpKSl7dmFyIGU9aXQodHQodHQodCkpKTskKGUpPT10bz8oZXQodHQodCksJHMpLGV0KGUsJHMpLGV0KHR0KHR0KHQpKSx0byksdD10dCh0dCh0KSkpOih0PT1pdCh0dCh0KSkmJih0PXR0KHQpLHRoaXMucm90YXRlTGVmdCh0KSksZXQodHQodCksJHMpLGV0KHR0KHR0KHQpKSx0byksdGhpcy5yb3RhdGVSaWdodCh0dCh0dCh0KSkpKX1lbHNle3ZhciBlPW50KHR0KHR0KHQpKSk7JChlKT09dG8/KGV0KHR0KHQpLCRzKSxldChlLCRzKSxldCh0dCh0dCh0KSksdG8pLHQ9dHQodHQodCkpKToodD09bnQodHQodCkpJiYodD10dCh0KSx0aGlzLnJvdGF0ZVJpZ2h0KHQpKSxldCh0dCh0KSwkcyksZXQodHQodHQodCkpLHRvKSx0aGlzLnJvdGF0ZUxlZnQodHQodHQodCkpKSl9dGhpcy5yb290Xy5jb2xvcj0kc30scnQucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe3ZhciB0PW5ldyBJLGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUudmFsdWUpO251bGwhPT0oZT1ydC5zdWNjZXNzb3IoZSkpOyl0LmFkZChlLnZhbHVlKTtyZXR1cm4gdH0scnQucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEosZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZSk7bnVsbCE9PShlPXJ0LnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUpO3JldHVybiB0fSxydC5wcm90b3R5cGUucm90YXRlTGVmdD1mdW5jdGlvbih0KXtpZihudWxsIT10KXt2YXIgZT10LnJpZ2h0O3QucmlnaHQ9ZS5sZWZ0LG51bGwhPWUubGVmdCYmKGUubGVmdC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LmxlZnQ9PXQ/dC5wYXJlbnQubGVmdD1lOnQucGFyZW50LnJpZ2h0PWUsZS5sZWZ0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5yb3RhdGVSaWdodD1mdW5jdGlvbih0KXtpZihudWxsIT10KXt2YXIgZT10LmxlZnQ7dC5sZWZ0PWUucmlnaHQsbnVsbCE9ZS5yaWdodCYmKGUucmlnaHQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5yaWdodD09dD90LnBhcmVudC5yaWdodD1lOnQucGFyZW50LmxlZnQ9ZSxlLnJpZ2h0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5nZXRGaXJzdEVudHJ5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yb290XztpZihudWxsIT10KWZvcig7bnVsbCE9dC5sZWZ0Oyl0PXQubGVmdDtyZXR1cm4gdH0scnQuc3VjY2Vzc29yPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2lmKG51bGwhPT10LnJpZ2h0KXtmb3IodmFyIGU9dC5yaWdodDtudWxsIT09ZS5sZWZ0OyllPWUubGVmdDtyZXR1cm4gZX1mb3IodmFyIGU9dC5wYXJlbnQsbj10O251bGwhPT1lJiZuPT09ZS5yaWdodDspbj1lLGU9ZS5wYXJlbnQ7cmV0dXJuIGV9LHJ0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV99LGUoc3QucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzdH19KSxvdC5wcm90b3R5cGU9bmV3IFEsYXQucHJvdG90eXBlPW5ldyBvdCxhdC5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl7dmFyIGk9dGhpcy5hcnJheV9bZV07aWYoMD09PWkuY29tcGFyZVRvKHQpKXJldHVybiEwfXJldHVybiExfSxhdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe2lmKHRoaXMuY29udGFpbnModCkpcmV0dXJuITE7Zm9yKHZhciBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl7dmFyIGk9dGhpcy5hcnJheV9bZV07aWYoMT09PWkuY29tcGFyZVRvKHQpKXJldHVybiB0aGlzLmFycmF5Xy5zcGxpY2UoZSwwLHQpLCEwfXJldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxhdC5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sYXQucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRX0sYXQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxhdC5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGVvKHRoaXMpfTt2YXIgZW89ZnVuY3Rpb24odCl7dGhpcy50cmVlU2V0Xz10LHRoaXMucG9zaXRpb25fPTB9O2VvLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLnRyZWVTZXRfLnNpemUoKSl0aHJvdyBuZXcgeDtyZXR1cm4gdGhpcy50cmVlU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK119LGVvLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25fPHRoaXMudHJlZVNldF8uc2l6ZSgpfSxlby5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEV9LHV0LnNvcnQ9ZnVuY3Rpb24oKXt2YXIgdCxlLG4saSxyPWFyZ3VtZW50c1swXTtpZigxPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKX0sdm9pZCByLnNvcnQoaSk7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpbj1hcmd1bWVudHNbMV0saT1mdW5jdGlvbih0LGUpe3JldHVybiBuLmNvbXBhcmUodCxlKX0sci5zb3J0KGkpO2Vsc2V7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2U9ci5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxlLnNvcnQoKTt2YXIgcz1yLnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQoZSxyLnNsaWNlKGFyZ3VtZW50c1syXSxyLmxlbmd0aCkpO2ZvcihyLnNwbGljZSgwLHIubGVuZ3RoKSx0PTA7dDxzLmxlbmd0aDt0Kyspci5wdXNoKHNbdF0pO3JldHVybn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGU9ci5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxuPWFyZ3VtZW50c1szXSxpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uY29tcGFyZSh0LGUpfSxlLnNvcnQoaSkscz1yLnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQoZSxyLnNsaWNlKGFyZ3VtZW50c1syXSxyLmxlbmd0aCkpLHIuc3BsaWNlKDAsci5sZW5ndGgpLHQ9MDt0PHMubGVuZ3RoO3QrKylyLnB1c2goc1t0XSk7cmV0dXJufX19LHV0LmFzTGlzdD1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wLGk9dC5sZW5ndGg7aT5uO24rKyllLmFkZCh0W25dKTtyZXR1cm4gZX0sZShsdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGx0fX0pLGx0LnRvRGltZW5zaW9uU3ltYm9sPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIGx0LkZBTFNFOnJldHVybiBsdC5TWU1fRkFMU0U7Y2FzZSBsdC5UUlVFOnJldHVybiBsdC5TWU1fVFJVRTtjYXNlIGx0LkRPTlRDQVJFOnJldHVybiBsdC5TWU1fRE9OVENBUkU7Y2FzZSBsdC5QOnJldHVybiBsdC5TWU1fUDtjYXNlIGx0Lkw6cmV0dXJuIGx0LlNZTV9MO2Nhc2UgbHQuQTpyZXR1cm4gbHQuU1lNX0F9dGhyb3cgbmV3IGkoXCJVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogXCIrdCl9LGx0LnRvRGltZW5zaW9uVmFsdWU9ZnVuY3Rpb24odCl7c3dpdGNoKE8udG9VcHBlckNhc2UodCkpe2Nhc2UgbHQuU1lNX0ZBTFNFOnJldHVybiBsdC5GQUxTRTtjYXNlIGx0LlNZTV9UUlVFOnJldHVybiBsdC5UUlVFO2Nhc2UgbHQuU1lNX0RPTlRDQVJFOnJldHVybiBsdC5ET05UQ0FSRTtjYXNlIGx0LlNZTV9QOnJldHVybiBsdC5QO2Nhc2UgbHQuU1lNX0w6cmV0dXJuIGx0Lkw7Y2FzZSBsdC5TWU1fQTpyZXR1cm4gbHQuQX10aHJvdyBuZXcgaShcIlVua25vd24gZGltZW5zaW9uIHN5bWJvbDogXCIrdCl9LGx0LlA9MCxsdC5MPTEsbHQuQT0yLGx0LkZBTFNFPS0xLGx0LlRSVUU9LTIsbHQuRE9OVENBUkU9LTMsbHQuU1lNX0ZBTFNFPVwiRlwiLGx0LlNZTV9UUlVFPVwiVFwiLGx0LlNZTV9ET05UQ0FSRT1cIipcIixsdC5TWU1fUD1cIjBcIixsdC5TWU1fTD1cIjFcIixsdC5TWU1fQT1cIjJcIixlKGh0LnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHR9fSksZShjdC5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0LGUpe30saXNEb25lOmZ1bmN0aW9uKCl7fSxpc0dlb21ldHJ5Q2hhbmdlZDpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY3R9fSksaChmdCxCKSxlKGZ0LnByb3RvdHlwZSx7Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEMsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5nZW9tZXRyaWVzW2VdLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIHR9LGdldEdlb21ldHJ5TjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyaWVzW3RdfSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKSxlPS0xLG49MDtuPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWZvcih2YXIgaT10aGlzLmdlb21ldHJpZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKSxyPTA7cjxpLmxlbmd0aDtyKyspZSsrLHRbZV09aVtyXTtyZXR1cm4gdH0sZ2V0QXJlYTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuZ2VvbWV0cmllc1tlXS5nZXRBcmVhKCk7cmV0dXJuIHR9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10O2lmKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGghPT1uLmdlb21ldHJpZXMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgaT0wO2k8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtpKyspaWYoIXRoaXMuZ2VvbWV0cmllc1tpXS5lcXVhbHNFeGFjdChuLmdlb21ldHJpZXNbaV0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO3QrKyl0aGlzLmdlb21ldHJpZXNbdF0ubm9ybWFsaXplKCk7dXQuc29ydCh0aGlzLmdlb21ldHJpZXMpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZW9tZXRyaWVzWzBdLmdldENvb3JkaW5hdGUoKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bHQuRkFMU0UsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdD1NYXRoLm1heCh0LHRoaXMuZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKTtyZXR1cm4gdH0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWx0LkZBTFNFLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLmdlb21ldHJpZXNbZV0uZ2V0RGltZW5zaW9uKCkpO3JldHVybiB0fSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmdlb21ldHJpZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9LGdldE51bVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuZ2VvbWV0cmllc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH0sZ2V0TnVtR2VvbWV0cmllczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb21ldHJpZXMubGVuZ3RofSxyZXZlcnNlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKyllW25dPXRoaXMuZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBhdCh1dC5hc0xpc3QodGhpcy5nZW9tZXRyaWVzKSksbj1uZXcgYXQodXQuYXNMaXN0KHQuZ2VvbWV0cmllcykpO3JldHVybiB0aGlzLmNvbXBhcmUoZSxuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWksbz10aGlzLmdldE51bUdlb21ldHJpZXMoKSxhPXMuZ2V0TnVtR2VvbWV0cmllcygpLHU9MDtvPnUmJmE+dTspe3ZhciBsPXRoaXMuZ2V0R2VvbWV0cnlOKHUpLGg9cy5nZXRHZW9tZXRyeU4odSksYz1sLmNvbXBhcmVUb1NhbWVDbGFzcyhoLHIpO2lmKDAhPT1jKXJldHVybiBjO3UrK31yZXR1cm4gbz51PzE6YT51Py0xOjB9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KHQpO2Vsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoJiYodGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KG4pLCFuLmlzRG9uZSgpKTtlKyspO24uaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGh0KSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpO2Zvcih2YXIgZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KGkpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0scSkpe3ZhciByPWFyZ3VtZW50c1swXTtyLmZpbHRlcih0aGlzKTtmb3IodmFyIGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseShyKX19LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksZi5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9Qi5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTt0Lmdlb21ldHJpZXM9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Lmdlb21ldHJpZXNbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNsb25lKCk7cmV0dXJuIHR9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiR2VvbWV0cnlDb2xsZWN0aW9uXCJ9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCksZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGZ0KHQsdGhpcy5mYWN0b3J5KX0saXNFbXB0eTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuZ2VvbWV0cmllc1t0XS5pc0VtcHR5KCkpcmV0dXJuITE7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZ0fX0pLGZ0LnNlcmlhbFZlcnNpb25VSUQ9LTB4NGYwN2JjYjFmODU3ZDgwMCxoKGd0LGZ0KSxlKGd0LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX01VTFRJTElORVNUUklOR30sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpP2Z0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKTohMX1yZXR1cm4gZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpP2x0LkZBTFNFOjB9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuITE7Zm9yKHZhciB0PTA7dDx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5nZW9tZXRyaWVzW3RdLmlzQ2xvc2VkKCkpcmV0dXJuITE7cmV0dXJuITB9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxyZXZlcnNlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKyllW3QtMS1uXT10aGlzLmdlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBkdCh0aGlzKS5nZXRCb3VuZGFyeSgpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIk11bHRpTGluZVN0cmluZ1wifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBndCh0LHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7XG5yZXR1cm5bc3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBndH19KSxndC5zZXJpYWxWZXJzaW9uVUlEPTB4NzE1NWQyYWI0YWZhODAwMCxlKGR0LnByb3RvdHlwZSx7Ym91bmRhcnlNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7aWYodGhpcy5nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTt2YXIgZT10aGlzLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpO3JldHVybiAxPT09ZS5sZW5ndGg/dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2ludChlWzBdKTp0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKGUpfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb20gaW5zdGFuY2VvZiBTdD90aGlzLmJvdW5kYXJ5TGluZVN0cmluZyh0aGlzLmdlb20pOnRoaXMuZ2VvbSBpbnN0YW5jZW9mIGd0P3RoaXMuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcodGhpcy5nZW9tKTp0aGlzLmdlb20uZ2V0Qm91bmRhcnkoKX0sYm91bmRhcnlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7aWYodC5pc0Nsb3NlZCgpKXt2YXIgZT10aGlzLmJuUnVsZS5pc0luQm91bmRhcnkoMik7cmV0dXJuIGU/dC5nZXRTdGFydFBvaW50KCk6dGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9cmV0dXJuIHRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludChbdC5nZXRTdGFydFBvaW50KCksdC5nZXRFbmRQb2ludCgpXSl9LGdldEVtcHR5TXVsdGlQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX0sY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEk7dGhpcy5lbmRwb2ludE1hcD1uZXcgcnQ7Zm9yKHZhciBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pOzAhPT1pLmdldE51bVBvaW50cygpJiYodGhpcy5hZGRFbmRwb2ludChpLmdldENvb3JkaW5hdGVOKDApKSx0aGlzLmFkZEVuZHBvaW50KGkuZ2V0Q29vcmRpbmF0ZU4oaS5nZXROdW1Qb2ludHMoKS0xKSkpfWZvcih2YXIgcj10aGlzLmVuZHBvaW50TWFwLmVudHJ5U2V0KCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89cy5nZXRWYWx1ZSgpLGE9by5jb3VudDt0aGlzLmJuUnVsZS5pc0luQm91bmRhcnkoYSkmJmUuYWRkKHMuZ2V0S2V5KCkpfXJldHVybiBILnRvQ29vcmRpbmF0ZUFycmF5KGUpfSxhZGRFbmRwb2ludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVuZHBvaW50TWFwLmdldCh0KTtudWxsPT09ZSYmKGU9bmV3IHB0LHRoaXMuZW5kcG9pbnRNYXAucHV0KHQsZSkpLGUuY291bnQrK30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZHR9fSksZHQuZ2V0Qm91bmRhcnk9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IGR0KHQpO3JldHVybiBlLmdldEJvdW5kYXJ5KCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW5ldyBkdChuLGkpO3JldHVybiBlLmdldEJvdW5kYXJ5KCl9fSxlKHB0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHR9fSksZShOdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE50fX0pLE50LmNoYXJzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpLGk9MDtlPmk7aSsrKW5baV09dDtyZXR1cm4gbmV3IFN0cmluZyhuKX0sTnQuZ2V0U3RhY2tUcmFjZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgeHQsbj1uZXcgdnQoZSk7cmV0dXJuIHQucHJpbnRTdGFja1RyYWNlKG4pLGUudG9TdHJpbmcoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPVwiXCIsbz1uZXcgbXQoTnQuZ2V0U3RhY2tUcmFjZShpKSksYT1uZXcgSXQobyksdT0wO3I+dTt1KyspdHJ5e3MrPWEucmVhZExpbmUoKStOdC5ORVdMSU5FfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIEV0KSl0aHJvdyB0O2Yuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1maW5hbGx5e31yZXR1cm4gc319LE50LnNwbGl0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUubGVuZ3RoLGk9bmV3IEkscj1cIlwiK3Qscz1yLmluZGV4T2YoZSk7cz49MDspe3ZhciBvPXIuc3Vic3RyaW5nKDAscyk7aS5hZGQobykscj1yLnN1YnN0cmluZyhzK24pLHM9ci5pbmRleE9mKGUpfXIubGVuZ3RoPjAmJmkuYWRkKHIpO2Zvcih2YXIgYT1uZXcgQXJyYXkoaS5zaXplKCkpLmZpbGwobnVsbCksdT0wO3U8YS5sZW5ndGg7dSsrKWFbdV09aS5nZXQodSk7cmV0dXJuIGF9LE50LnRvU3RyaW5nPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTnQuU0lNUExFX09SRElOQVRFX0ZPUk1BVC5mb3JtYXQodCl9fSxOdC5zcGFjZXM9ZnVuY3Rpb24odCl7cmV0dXJuIE50LmNoYXJzKFwiIFwiLHQpfSxOdC5ORVdMSU5FPUEuZ2V0UHJvcGVydHkoXCJsaW5lLnNlcGFyYXRvclwiKSxOdC5TSU1QTEVfT1JESU5BVEVfRk9STUFUPW5ldyB5dChcIjAuI1wiKSxlKEN0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ3R9fSksQ3QuY29weUNvb3JkPWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLG4uZ2V0RGltZW5zaW9uKCkpLHM9MDtyPnM7cysrKW4uc2V0T3JkaW5hdGUoaSxzLHQuZ2V0T3JkaW5hdGUoZSxzKSl9LEN0LmlzUmluZz1mdW5jdGlvbih0KXt2YXIgZT10LnNpemUoKTtyZXR1cm4gMD09PWU/ITA6Mz49ZT8hMTp0LmdldE9yZGluYXRlKDAsRC5YKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEQuWCkmJnQuZ2V0T3JkaW5hdGUoMCxELlkpPT09dC5nZXRPcmRpbmF0ZShlLTEsRC5ZKX0sQ3QuaXNFcXVhbD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuc2l6ZSgpLGk9ZS5zaXplKCk7aWYobiE9PWkpcmV0dXJuITE7Zm9yKHZhciBzPU1hdGgubWluKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSksbz0wO24+bztvKyspZm9yKHZhciBhPTA7cz5hO2ErKyl7dmFyIHU9dC5nZXRPcmRpbmF0ZShvLGEpLGw9ZS5nZXRPcmRpbmF0ZShvLGEpO2lmKCEodC5nZXRPcmRpbmF0ZShvLGEpPT09ZS5nZXRPcmRpbmF0ZShvLGEpfHxyLmlzTmFOKHUpJiZyLmlzTmFOKGwpKSlyZXR1cm4hMX1yZXR1cm4hMH0sQ3QuZXh0ZW5kPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLHI9ZS5zaXplKCk7aWYoQ3QuY29weShlLDAsaSwwLHIpLHI+MClmb3IodmFyIHM9cjtuPnM7cysrKUN0LmNvcHkoZSxyLTEsaSxzLDEpO3JldHVybiBpfSxDdC5yZXZlcnNlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnNpemUoKS0xLG49TWF0aC50cnVuYyhlLzIpLGk9MDtuPj1pO2krKylDdC5zd2FwKHQsaSxlLWkpfSxDdC5zd2FwPWZ1bmN0aW9uKHQsZSxuKXtpZihlPT09bilyZXR1cm4gbnVsbDtmb3IodmFyIGk9MDtpPHQuZ2V0RGltZW5zaW9uKCk7aSsrKXt2YXIgcj10LmdldE9yZGluYXRlKGUsaSk7dC5zZXRPcmRpbmF0ZShlLGksdC5nZXRPcmRpbmF0ZShuLGkpKSx0LnNldE9yZGluYXRlKG4saSxyKX19LEN0LmNvcHk9ZnVuY3Rpb24odCxlLG4saSxyKXtmb3IodmFyIHM9MDtyPnM7cysrKUN0LmNvcHlDb29yZCh0LGUrcyxuLGkrcyl9LEN0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQuc2l6ZSgpO2lmKDA9PT1lKXJldHVyblwiKClcIjt2YXIgbj10LmdldERpbWVuc2lvbigpLGk9bmV3IFA7aS5hcHBlbmQoXCIoXCIpO2Zvcih2YXIgcj0wO2U+cjtyKyspe3I+MCYmaS5hcHBlbmQoXCIgXCIpO2Zvcih2YXIgcz0wO24+cztzKyspcz4wJiZpLmFwcGVuZChcIixcIiksaS5hcHBlbmQoTnQudG9TdHJpbmcodC5nZXRPcmRpbmF0ZShyLHMpKSl9cmV0dXJuIGkuYXBwZW5kKFwiKVwiKSxpLnRvU3RyaW5nKCl9fSxDdC5lbnN1cmVWYWxpZFJpbmc9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNpemUoKTtpZigwPT09bilyZXR1cm4gZTtpZigzPj1uKXJldHVybiBDdC5jcmVhdGVDbG9zZWRSaW5nKHQsZSw0KTt2YXIgaT1lLmdldE9yZGluYXRlKDAsRC5YKT09PWUuZ2V0T3JkaW5hdGUobi0xLEQuWCkmJmUuZ2V0T3JkaW5hdGUoMCxELlkpPT09ZS5nZXRPcmRpbmF0ZShuLTEsRC5ZKTtyZXR1cm4gaT9lOkN0LmNyZWF0ZUNsb3NlZFJpbmcodCxlLG4rMSl9LEN0LmNyZWF0ZUNsb3NlZFJpbmc9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuY3JlYXRlKG4sZS5nZXREaW1lbnNpb24oKSkscj1lLnNpemUoKTtDdC5jb3B5KGUsMCxpLDAscik7Zm9yKHZhciBzPXI7bj5zO3MrKylDdC5jb3B5KGUsMCxpLHMsMSk7cmV0dXJuIGl9LGgoU3QsQiksZShTdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP25ldyBDOnRoaXMucG9pbnRzLmV4cGFuZEVudmVsb3BlKG5ldyBDKX0saXNSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKSYmdGhpcy5pc1NpbXBsZSgpfSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTElORVNUUklOR30sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2ludHMudG9Db29yZGluYXRlQXJyYXkoKX0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO3ZhciBuPXQ7aWYodGhpcy5wb2ludHMuc2l6ZSgpIT09bi5wb2ludHMuc2l6ZSgpKXJldHVybiExO2Zvcih2YXIgaT0wO2k8dGhpcy5wb2ludHMuc2l6ZSgpO2krKylpZighdGhpcy5lcXVhbCh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGkpLG4ucG9pbnRzLmdldENvb3JkaW5hdGUoaSksZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxNYXRoLnRydW5jKHRoaXMucG9pbnRzLnNpemUoKS8yKTt0Kyspe3ZhciBlPXRoaXMucG9pbnRzLnNpemUoKS0xLXQ7aWYoIXRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUodCkuZXF1YWxzKHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoZSkpKXJldHVybiB0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpLmNvbXBhcmVUbyh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpKT4wJiZDdC5yZXZlcnNlKHRoaXMucG9pbnRzKSxudWxsfX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoMCl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT9sdC5GQUxTRTowfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8hMTp0aGlzLmdldENvb3JkaW5hdGVOKDApLmVxdWFsczJEKHRoaXMuZ2V0Q29vcmRpbmF0ZU4odGhpcy5nZXROdW1Qb2ludHMoKS0xKSl9LGdldEVuZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4odGhpcy5nZXROdW1Qb2ludHMoKS0xKX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDF9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiBoZS5jb21wdXRlTGVuZ3RoKHRoaXMucG9pbnRzKX0sZ2V0TnVtUG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnRzLnNpemUoKX0scmV2ZXJzZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucG9pbnRzLmNvcHkoKTtDdC5yZXZlcnNlKHQpO3ZhciBlPXRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodCk7cmV0dXJuIGV9LGNvbXBhcmVUb1NhbWVDbGFzczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dCxuPTAsaT0wO248dGhpcy5wb2ludHMuc2l6ZSgpJiZpPGUucG9pbnRzLnNpemUoKTspe3ZhciByPXRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUobikuY29tcGFyZVRvKGUucG9pbnRzLmdldENvb3JkaW5hdGUoaSkpO2lmKDAhPT1yKXJldHVybiByO24rKyxpKyt9cmV0dXJuIG48dGhpcy5wb2ludHMuc2l6ZSgpPzE6aTxlLnBvaW50cy5zaXplKCk/LTE6MH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGU9cztyZXR1cm4gby5jb21wYXJlKHRoaXMucG9pbnRzLGUucG9pbnRzKX19LGFwcGx5OmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0seikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0aGlzLnBvaW50cy5zaXplKCk7ZSsrKXQuZmlsdGVyKHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoZSkpO2Vsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMucG9pbnRzLnNpemUoKSlyZXR1cm4gbnVsbDtmb3IodmFyIGU9MDtlPHRoaXMucG9pbnRzLnNpemUoKSYmKG4uZmlsdGVyKHRoaXMucG9pbnRzLGUpLCFuLmlzRG9uZSgpKTtlKyspO24uaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGh0KSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0scSkpe3ZhciByPWFyZ3VtZW50c1swXTtyLmZpbHRlcih0aGlzKX19LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBkdCh0aGlzKS5nZXRCb3VuZGFyeSgpfSxpc0VxdWl2YWxlbnRDbGFzczpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFN0fSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQucG9pbnRzPXRoaXMucG9pbnRzLmNsb25lKCksdH0sZ2V0Q29vcmRpbmF0ZU46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUodCl9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTGluZVN0cmluZ1wifSxjb3B5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTdCh0aGlzLnBvaW50cy5jb3B5KCksdGhpcy5mYWN0b3J5KX0sZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnRzfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLnBvaW50cy5zaXplKCl9LGluaXQ6ZnVuY3Rpb24odCl7aWYobnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSwxPT09dC5zaXplKCkpdGhyb3cgbmV3IGkoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZVN0cmluZyAoZm91bmQgXCIrdC5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gMilcIik7dGhpcy5wb2ludHM9dH0saXNDb29yZGluYXRlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5wb2ludHMuc2l6ZSgpO2UrKylpZih0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpLmVxdWFscyh0KSlyZXR1cm4hMDtyZXR1cm4hMX0sZ2V0U3RhcnRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2V0UG9pbnROKDApfSxnZXRQb2ludE46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUodCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFN0fX0pLFN0LnNlcmlhbFZlcnNpb25VSUQ9MHgyYjJiNTFiYTQzNWM4ZTAwLGUod3QucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3dH19KSxoKEx0LEIpLGUoTHQucHJvdG90eXBlLHtjb21wdXRlRW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBuZXcgQzt2YXIgdD1uZXcgQztyZXR1cm4gdC5leHBhbmRUb0luY2x1ZGUodGhpcy5jb29yZGluYXRlcy5nZXRYKDApLHRoaXMuY29vcmRpbmF0ZXMuZ2V0WSgwKSksdH0sZ2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX1BPSU5UfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9bXTpbdGhpcy5nZXRDb29yZGluYXRlKCldfSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCk/dGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpPyEwOnRoaXMuaXNFbXB0eSgpIT09dC5pc0VtcHR5KCk/ITE6dGhpcy5lcXVhbCh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmdldENvb3JkaW5hdGUoKSxlKTohMX1yZXR1cm4gQi5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXt9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMuY29vcmRpbmF0ZXMuc2l6ZSgpP3RoaXMuY29vcmRpbmF0ZXMuZ2V0Q29vcmRpbmF0ZSgwKTpudWxsfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiBsdC5GQUxTRX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LGdldE51bVBvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8wOjF9LHJldmVyc2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb3B5KCl9LGdldFg6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFggY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS54fSxjb21wYXJlVG9TYW1lQ2xhc3M6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dDtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKGUuZ2V0Q29vcmRpbmF0ZSgpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLGU9bjtyZXR1cm4gaS5jb21wYXJlKHRoaXMuY29vcmRpbmF0ZXMsZS5jb29yZGluYXRlcyl9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgZT1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7ZS5maWx0ZXIodGhpcy5jb29yZGluYXRlcywwKSxlLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBuPWFyZ3VtZW50c1swXTtuLmZpbHRlcih0aGlzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgaT1hcmd1bWVudHNbMF07aS5maWx0ZXIodGhpcyl9fSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9Qi5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5jb29yZGluYXRlcz10aGlzLmNvb3JkaW5hdGVzLmNsb25lKCksdH0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJQb2ludFwifSxjb3B5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBMdCh0aGlzLmNvb3JkaW5hdGVzLmNvcHkoKSx0aGlzLmZhY3RvcnkpfSxnZXRDb29yZGluYXRlU2VxdWVuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc30sZ2V0WTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiZ2V0WSBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuY29vcmRpbmF0ZXMuc2l6ZSgpfSxpbml0OmZ1bmN0aW9uKHQpe251bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksZi5pc1RydWUodC5zaXplKCk8PTEpLHRoaXMuY29vcmRpbmF0ZXM9dH0saXNTaW1wbGU6ZnVuY3Rpb24oKXtyZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bd3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMdH19KSxMdC5zZXJpYWxWZXJzaW9uVUlEPTB4NDQwNzdiYWQxNjFjYmMwMCxlKFJ0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUnR9fSksaChUdCxCKSxlKFR0LnByb3RvdHlwZSx7Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbC5nZXRFbnZlbG9wZUludGVybmFsKCl9LGdldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9QT0xZR09OfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybltdO2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKSxlPS0xLG49dGhpcy5zaGVsbC5nZXRDb29yZGluYXRlcygpLGk9MDtpPG4ubGVuZ3RoO2krKyllKyssdFtlXT1uW2ldO2Zvcih2YXIgcj0wO3I8dGhpcy5ob2xlcy5sZW5ndGg7cisrKWZvcih2YXIgcz10aGlzLmhvbGVzW3JdLmdldENvb3JkaW5hdGVzKCksbz0wO288cy5sZW5ndGg7bysrKWUrKyx0W2VdPXNbb107cmV0dXJuIHR9LGdldEFyZWE6ZnVuY3Rpb24oKXt2YXIgdD0wO3QrPU1hdGguYWJzKGhlLnNpZ25lZEFyZWEodGhpcy5zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQtPU1hdGguYWJzKGhlLnNpZ25lZEFyZWEodGhpcy5ob2xlc1tlXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkpO3JldHVybiB0fSxpc1JlY3RhbmdsZTpmdW5jdGlvbigpe2lmKDAhPT10aGlzLmdldE51bUludGVyaW9yUmluZygpKXJldHVybiExO2lmKG51bGw9PT10aGlzLnNoZWxsKXJldHVybiExO2lmKDUhPT10aGlzLnNoZWxsLmdldE51bVBvaW50cygpKXJldHVybiExO2Zvcih2YXIgdD10aGlzLnNoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLGU9dGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCksbj0wOzU+bjtuKyspe3ZhciBpPXQuZ2V0WChuKTtpZihpIT09ZS5nZXRNaW5YKCkmJmkhPT1lLmdldE1heFgoKSlyZXR1cm4hMTt2YXIgcj10LmdldFkobik7aWYociE9PWUuZ2V0TWluWSgpJiZyIT09ZS5nZXRNYXhZKCkpcmV0dXJuITF9Zm9yKHZhciBzPXQuZ2V0WCgwKSxvPXQuZ2V0WSgwKSxuPTE7ND49bjtuKyspe3ZhciBpPXQuZ2V0WChuKSxyPXQuZ2V0WShuKSxhPWkhPT1zLHU9ciE9PW87aWYoYT09PXUpcmV0dXJuITE7cz1pLG89cn1yZXR1cm4hMH0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO3ZhciBuPXQsaT10aGlzLnNoZWxsLHI9bi5zaGVsbDtpZighaS5lcXVhbHNFeGFjdChyLGUpKXJldHVybiExO2lmKHRoaXMuaG9sZXMubGVuZ3RoIT09bi5ob2xlcy5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBzPTA7czx0aGlzLmhvbGVzLmxlbmd0aDtzKyspaWYoIXRoaXMuaG9sZXNbc10uZXF1YWxzRXhhY3Qobi5ob2xlc1tzXSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gQi5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5ub3JtYWxpemUodGhpcy5zaGVsbCwhMCk7Zm9yKHZhciB0PTA7dDx0aGlzLmhvbGVzLmxlbmd0aDt0KyspdGhpcy5ub3JtYWxpemUodGhpcy5ob2xlc1t0XSwhMSk7dXQuc29ydCh0aGlzLmhvbGVzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIGk9bmV3IEFycmF5KGUuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSkuZmlsbChudWxsKTtBLmFycmF5Y29weShlLmdldENvb3JkaW5hdGVzKCksMCxpLDAsaS5sZW5ndGgpO3ZhciByPUgubWluQ29vcmRpbmF0ZShlLmdldENvb3JkaW5hdGVzKCkpO0guc2Nyb2xsKGksciksQS5hcnJheWNvcHkoaSwwLGUuZ2V0Q29vcmRpbmF0ZXMoKSwwLGkubGVuZ3RoKSxlLmdldENvb3JkaW5hdGVzKClbaS5sZW5ndGhdPWlbMF0saGUuaXNDQ1coZS5nZXRDb29yZGluYXRlcygpKT09PW4mJkgucmV2ZXJzZShlLmdldENvb3JkaW5hdGVzKCkpfX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsLmdldENvb3JkaW5hdGUoKX0sZ2V0TnVtSW50ZXJpb3JSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaG9sZXMubGVuZ3RofSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMn0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7dmFyIHQ9MDt0Kz10aGlzLnNoZWxsLmdldExlbmd0aCgpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQrPXRoaXMuaG9sZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9LGdldE51bVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLnNoZWxsLmdldE51bVBvaW50cygpLGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmhvbGVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb3B5KCk7dC5zaGVsbD10aGlzLnNoZWxsLmNvcHkoKS5yZXZlcnNlKCksdC5ob2xlcz1uZXcgQXJyYXkodGhpcy5ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdC5ob2xlc1tlXT10aGlzLmhvbGVzW2VdLmNvcHkoKS5yZXZlcnNlKCk7cmV0dXJuIHR9LGNvbnZleEh1bGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFeHRlcmlvclJpbmcoKS5jb252ZXhIdWxsKCl9LGNvbXBhcmVUb1NhbWVDbGFzczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLnNoZWxsLG49dC5zaGVsbDtyZXR1cm4gZS5jb21wYXJlVG9TYW1lQ2xhc3Mobil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWksZT10aGlzLnNoZWxsLG49cy5zaGVsbCxvPWUuY29tcGFyZVRvU2FtZUNsYXNzKG4scik7aWYoMCE9PW8pcmV0dXJuIG87Zm9yKHZhciBhPXRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCksdT1zLmdldE51bUludGVyaW9yUmluZygpLGw9MDthPmwmJnU+bDspe3ZhciBoPXRoaXMuZ2V0SW50ZXJpb3JSaW5nTihsKSxjPXMuZ2V0SW50ZXJpb3JSaW5nTihsKSxmPWguY29tcGFyZVRvU2FtZUNsYXNzKGMscik7aWYoMCE9PWYpcmV0dXJuIGY7bCsrfXJldHVybiBhPmw/MTp1Pmw/LTE6MH19LGFwcGx5OmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0seikpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNoZWxsLmFwcGx5KHQpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuaG9sZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxjdCkpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLnNoZWxsLmFwcGx5KG4pLCFuLmlzRG9uZSgpKWZvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGgmJih0aGlzLmhvbGVzW2VdLmFwcGx5KG4pLCFuLmlzRG9uZSgpKTtlKyspO24uaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGh0KSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0scSkpe3ZhciByPWFyZ3VtZW50c1swXTtyLmZpbHRlcih0aGlzKSx0aGlzLnNoZWxsLmFwcGx5KHIpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuaG9sZXNbZV0uYXBwbHkocil9fSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTt2YXIgdD1uZXcgQXJyYXkodGhpcy5ob2xlcy5sZW5ndGgrMSkuZmlsbChudWxsKTt0WzBdPXRoaXMuc2hlbGw7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdFtlKzFdPXRoaXMuaG9sZXNbZV07cmV0dXJuIHQubGVuZ3RoPD0xP3RoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodFswXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk6dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7dC5zaGVsbD10aGlzLnNoZWxsLmNsb25lKCksdC5ob2xlcz1uZXcgQXJyYXkodGhpcy5ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdC5ob2xlc1tlXT10aGlzLmhvbGVzW2VdLmNsb25lKCk7cmV0dXJuIHR9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiUG9seWdvblwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuc2hlbGwuY29weSgpLGU9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPXRoaXMuaG9sZXNbbl0uY29weSgpO3JldHVybiBuZXcgVHQodCxlLHRoaXMuZmFjdG9yeSl9LGdldEV4dGVyaW9yUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hlbGwuaXNFbXB0eSgpfSxnZXRJbnRlcmlvclJpbmdOOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhvbGVzW3RdfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFR0fX0pLFR0LnNlcmlhbFZlcnNpb25VSUQ9LTB4MzA3ZmZlZmQ4ZGM5NzIwMCxoKFB0LGZ0KSxlKFB0LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX01VTFRJUE9JTlR9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpP2Z0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKTohMX1yZXR1cm4gZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2VvbWV0cmllc1t0XS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIGZ0LnByb3RvdHlwZS5nZXRDb29yZGluYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAwfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCl9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTXVsdGlQb2ludFwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBQdCh0LHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3d0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUHR9fSksUHQuc2VyaWFsVmVyc2lvblVJRD0tMHg2ZmIxZWQ0MTYyZTBmYzAwLGgoYnQsU3QpLGUoYnQucHJvdG90eXBlLHtnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTElORUFSUklOR30sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpPyEwOlN0LnByb3RvdHlwZS5pc0Nsb3NlZC5jYWxsKHRoaXMpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb2ludHMuY29weSgpO0N0LnJldmVyc2UodCk7dmFyIGU9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh0KTtyZXR1cm4gZX0sdmFsaWRhdGVDb25zdHJ1Y3Rpb246ZnVuY3Rpb24oKXtpZighdGhpcy5pc0VtcHR5KCkmJiFTdC5wcm90b3R5cGUuaXNDbG9zZWQuY2FsbCh0aGlzKSl0aHJvdyBuZXcgaShcIlBvaW50cyBvZiBMaW5lYXJSaW5nIGRvIG5vdCBmb3JtIGEgY2xvc2VkIGxpbmVzdHJpbmdcIik7aWYodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk+PTEmJnRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPGJ0Lk1JTklNVU1fVkFMSURfU0laRSl0aHJvdyBuZXcgaShcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lYXJSaW5nIChmb3VuZCBcIit0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSA0KVwiKX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJMaW5lYXJSaW5nXCJ9LGNvcHk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGJ0KHRoaXMucG9pbnRzLmNvcHkoKSx0aGlzLmZhY3RvcnkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBidH19KSxidC5NSU5JTVVNX1ZBTElEX1NJWkU9NCxidC5zZXJpYWxWZXJzaW9uVUlEPS0weDNiMjI5ZTI2MjM2N2E2MDAsaChPdCxmdCksZShPdC5wcm90b3R5cGUse2dldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9NVUxUSVBPTFlHT059LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KT9mdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSk6ITF9cmV0dXJuIGZ0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDF9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAyfSxyZXZlcnNlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKyllW25dPXRoaXMuZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihlKX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Zm9yKHZhciB0PW5ldyBJLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKWZvcih2YXIgbj10aGlzLmdlb21ldHJpZXNbZV0saT1uLmdldEJvdW5kYXJ5KCkscj0wO3I8aS5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXQuYWRkKGkuZ2V0R2VvbWV0cnlOKHIpKTt2YXIgcz1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0LnRvQXJyYXkocykpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIk11bHRpUG9seWdvblwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBPdCh0LHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1J0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT3R9fSksT3Quc2VyaWFsVmVyc2lvblVJRD0tMHg3YTVhYTEzNjkxNzE5ODAsZShfdC5wcm90b3R5cGUse3NldENvcHlVc2VyRGF0YTpmdW5jdGlvbih0KXt0aGlzLmlzVXNlckRhdGFDb3BpZWQ9dH0sZWRpdDpmdW5jdGlvbih0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO3ZhciBuPXRoaXMuZWRpdEludGVybmFsKHQsZSk7cmV0dXJuIHRoaXMuaXNVc2VyRGF0YUNvcGllZCYmbi5zZXRVc2VyRGF0YSh0LmdldFVzZXJEYXRhKCkpLG59LGVkaXRJbnRlcm5hbDpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dGhpcy5mYWN0b3J5JiYodGhpcy5mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0IGluc3RhbmNlb2YgZnQ/dGhpcy5lZGl0R2VvbWV0cnlDb2xsZWN0aW9uKHQsZSk6dCBpbnN0YW5jZW9mIFR0P3RoaXMuZWRpdFBvbHlnb24odCxlKTp0IGluc3RhbmNlb2YgTHQ/ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KTp0IGluc3RhbmNlb2YgU3Q/ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KTooZi5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuc3VwcG9ydGVkIEdlb21ldHJ5IGNsYXNzOiBcIit0LmdldENsYXNzKCkuZ2V0TmFtZSgpKSxudWxsKX0sZWRpdEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLmVkaXQodCx0aGlzLmZhY3RvcnkpLGk9bmV3IEkscj0wO3I8bi5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXt2YXIgcz10aGlzLmVkaXQobi5nZXRHZW9tZXRyeU4ociksZSk7bnVsbD09PXN8fHMuaXNFbXB0eSgpfHxpLmFkZChzKX1yZXR1cm4gbi5nZXRDbGFzcygpPT09UHQ/dGhpcy5mYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoaS50b0FycmF5KFtdKSk6bi5nZXRDbGFzcygpPT09Z3Q/dGhpcy5mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhpLnRvQXJyYXkoW10pKTpuLmdldENsYXNzKCk9PT1PdD90aGlzLmZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGkudG9BcnJheShbXSkpOnRoaXMuZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaS50b0FycmF5KFtdKSl9LGVkaXRQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KTtpZihudWxsPT09biYmKG49dGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24obnVsbCkpLG4uaXNFbXB0eSgpKXJldHVybiBuO3ZhciBpPXRoaXMuZWRpdChuLmdldEV4dGVyaW9yUmluZygpLGUpO2lmKG51bGw9PT1pfHxpLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKTtmb3IodmFyIHI9bmV3IEkscz0wO3M8bi5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe3ZhciBvPXRoaXMuZWRpdChuLmdldEludGVyaW9yUmluZ04ocyksZSk7bnVsbD09PW98fG8uaXNFbXB0eSgpfHxyLmFkZChvKX1yZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24oaSxyLnRvQXJyYXkoW10pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX3R9fSksX3QuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb249TXQsZShEdC5wcm90b3R5cGUse2VkaXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTXRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEdH19KSxlKEF0LnByb3RvdHlwZSx7ZWRpdDpmdW5jdGlvbih0LGUpe2lmKHQgaW5zdGFuY2VvZiBidClyZXR1cm4gZS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZWRpdENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSk7aWYodCBpbnN0YW5jZW9mIFN0KXJldHVybiBlLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5lZGl0Q29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpLHQpKTtpZih0IGluc3RhbmNlb2YgTHQpe3ZhciBuPXRoaXMuZWRpdENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KTtyZXR1cm4gbi5sZW5ndGg+MD9lLmNyZWF0ZVBvaW50KG5bMF0pOmUuY3JlYXRlUG9pbnQoKX1yZXR1cm4gdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTXRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBdH19KSxlKEZ0LnByb3RvdHlwZSx7ZWRpdDpmdW5jdGlvbih0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgYnQ/ZS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgU3Q/ZS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgTHQ/ZS5jcmVhdGVQb2ludCh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTXRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGdH19KSxfdC5Ob09wR2VvbWV0cnlPcGVyYXRpb249RHQsX3QuQ29vcmRpbmF0ZU9wZXJhdGlvbj1BdCxfdC5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb249RnQsZShHdC5wcm90b3R5cGUse3NldE9yZGluYXRlOmZ1bmN0aW9uKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBELlg6dGhpcy5jb29yZGluYXRlc1t0XS54PW47YnJlYWs7Y2FzZSBELlk6dGhpcy5jb29yZGluYXRlc1t0XS55PW47YnJlYWs7Y2FzZSBELlo6dGhpcy5jb29yZGluYXRlc1t0XS56PW47YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgaShcImludmFsaWQgb3JkaW5hdGVJbmRleFwiKX19LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlcy5sZW5ndGh9LGdldE9yZGluYXRlOmZ1bmN0aW9uKHQsZSl7c3dpdGNoKGUpe2Nhc2UgRC5YOnJldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLng7Y2FzZSBELlk6cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0ueTtjYXNlIEQuWjpyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS56fXJldHVybiByLk5hTn0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF19aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtuLng9dGhpcy5jb29yZGluYXRlc1tlXS54LG4ueT10aGlzLmNvb3JkaW5hdGVzW2VdLnksbi56PXRoaXMuY29vcmRpbmF0ZXNbZV0uen19LGdldENvb3JkaW5hdGVDb3B5OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyh0aGlzLmNvb3JkaW5hdGVzW3RdKX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGltZW5zaW9ufSxnZXRYOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLnh9LGNsb25lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKSxlPTA7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdFtlXT10aGlzLmNvb3JkaW5hdGVzW2VdLmNsb25lKCk7cmV0dXJuIG5ldyBHdCh0LHRoaXMuZGltZW5zaW9uKX0sZXhwYW5kRW52ZWxvcGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5jb29yZGluYXRlc1tlXSk7cmV0dXJuIHR9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuc2l6ZSgpKS5maWxsKG51bGwpLGU9MDtlPHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0W2VdPXRoaXMuY29vcmRpbmF0ZXNbZV0uY29weSgpO3JldHVybiBuZXcgR3QodCx0aGlzLmRpbWVuc2lvbil9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7aWYodGhpcy5jb29yZGluYXRlcy5sZW5ndGg+MCl7dmFyIHQ9bmV3IFAoMTcqdGhpcy5jb29yZGluYXRlcy5sZW5ndGgpO3QuYXBwZW5kKFwiKFwiKSx0LmFwcGVuZCh0aGlzLmNvb3JkaW5hdGVzWzBdKTtmb3IodmFyIGU9MTtlPHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmFwcGVuZChcIiwgXCIpLHQuYXBwZW5kKHRoaXMuY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0LmFwcGVuZChcIilcIiksdC50b1N0cmluZygpfXJldHVyblwiKClcIn0sZ2V0WTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS55fSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltELHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHdH19KSxHdC5zZXJpYWxWZXJzaW9uVUlEPS0weGNiNDRhNzc4ZGIxOGUwMCxlKHF0LnByb3RvdHlwZSx7cmVhZFJlc29sdmU6ZnVuY3Rpb24oKXtyZXR1cm4gcXQuaW5zdGFuY2UoKX0sY3JlYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IEd0KHQpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBHdChlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiBpPjMmJihpPTMpLDI+aT9uZXcgR3Qobik6bmV3IEd0KG4saSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltHLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxdH19KSxxdC5pbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBxdC5pbnN0YW5jZU9iamVjdH0scXQuc2VyaWFsVmVyc2lvblVJRD0tMHgzOGU0OWZhNmNmNmYyZTAwLHF0Lmluc3RhbmNlT2JqZWN0PW5ldyBxdDt2YXIgbm8saW89T2JqZWN0LmRlZmluZVByb3BlcnR5LHJvPXp0KHtkZWxldGU6a3QsaGFzOlh0LGdldDpZdCxzZXQ6SHQsa2V5czpqdCx2YWx1ZXM6S3QsZW50cmllczpadCxmb3JFYWNoOiR0LGNsZWFyOld0fSksc289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIE1hcCYmTWFwLnByb3RvdHlwZS52YWx1ZXM/TWFwOnJvO3RlLnByb3RvdHlwZT1uZXcgSyx0ZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1hcF8uZ2V0KHQpfHxudWxsfSx0ZS5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubWFwXy5zZXQodCxlKSxlfSx0ZS5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5tYXBfLnZhbHVlcygpLG49ZS5uZXh0KCk7IW4uZG9uZTspdC5hZGQobi52YWx1ZSksbj1lLm5leHQoKTtyZXR1cm4gdH0sdGUucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEo7cmV0dXJuIHRoaXMubWFwXy5lbnRyaWVzKCkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hZGQoZSl9KSx0fSx0ZS5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8uc2l6ZSgpfSxlKGVlLnByb3RvdHlwZSx7ZXF1YWxzOmZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIGVlKSlyZXR1cm4hMTt2YXIgZT10O3JldHVybiB0aGlzLm1vZGVsVHlwZT09PWUubW9kZWxUeXBlJiZ0aGlzLnNjYWxlPT09ZS5zY2FsZX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10aGlzLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpLGk9ZS5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKTtyZXR1cm4gbmV3IGIobikuY29tcGFyZVRvKG5ldyBiKGkpKX0sZ2V0U2NhbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zY2FsZX0saXNGbG9hdGluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HfHx0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HX1NJTkdMRX0sZ2V0VHlwZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGVsVHlwZX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1cIlVOS05PV05cIjtyZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElORz90PVwiRmxvYXRpbmdcIjp0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HX1NJTkdMRT90PVwiRmxvYXRpbmctU2luZ2xlXCI6dGhpcy5tb2RlbFR5cGU9PT1lZS5GSVhFRCYmKHQ9XCJGaXhlZCAoU2NhbGU9XCIrdGhpcy5nZXRTY2FsZSgpK1wiKVwiKSx0fSxtYWtlUHJlY2lzZTpmdW5jdGlvbigpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtpZihyLmlzTmFOKHQpKXJldHVybiB0O2lmKHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkdfU0lOR0xFKXt2YXIgZT10O3JldHVybiBlfXJldHVybiB0aGlzLm1vZGVsVHlwZT09PWVlLkZJWEVEP01hdGgucm91bmQodCp0aGlzLnNjYWxlKS90aGlzLnNjYWxlOnR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElORylyZXR1cm4gbnVsbDtuLng9dGhpcy5tYWtlUHJlY2lzZShuLngpLG4ueT10aGlzLm1ha2VQcmVjaXNlKG4ueSl9fSxnZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHM6ZnVuY3Rpb24oKXt2YXIgdD0xNjtyZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElORz90PTE2OnRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkdfU0lOR0xFP3Q9Njp0aGlzLm1vZGVsVHlwZT09PWVlLkZJWEVEJiYodD0xK01hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGgubG9nKHRoaXMuZ2V0U2NhbGUoKSkvTWF0aC5sb2coMTApKSkpLHR9LHNldFNjYWxlOmZ1bmN0aW9uKHQpe3RoaXMuc2NhbGU9TWF0aC5hYnModCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3Usc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVlfX0pLGVlLm1vc3RQcmVjaXNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY29tcGFyZVRvKGUpPj0wP3Q6ZX0sZShuZS5wcm90b3R5cGUse3JlYWRSZXNvbHZlOmZ1bmN0aW9uKCl7cmV0dXJuIG5lLm5hbWVUb1R5cGVNYXAuZ2V0KHRoaXMubmFtZSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5lfX0pLG5lLnNlcmlhbFZlcnNpb25VSUQ9LTU1Mjg2MDI2MzE3MzE1OWU0LG5lLm5hbWVUb1R5cGVNYXA9bmV3IHRlLGVlLlR5cGU9bmUsZWUuc2VyaWFsVmVyc2lvblVJRD0weDZiZWU2NDA0ZTlhMjVjMDAsZWUuRklYRUQ9bmV3IG5lKFwiRklYRURcIiksZWUuRkxPQVRJTkc9bmV3IG5lKFwiRkxPQVRJTkdcIiksZWUuRkxPQVRJTkdfU0lOR0xFPW5ldyBuZShcIkZMT0FUSU5HIFNJTkdMRVwiKSxlZS5tYXhpbXVtUHJlY2lzZVZhbHVlPTkwMDcxOTkyNTQ3NDA5OTIsZShpZS5wcm90b3R5cGUse3RvR2VvbWV0cnk6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNOdWxsKCk/dGhpcy5jcmVhdGVQb2ludChudWxsKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpJiZ0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlUG9pbnQobmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpfHx0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlTGluZVN0cmluZyhbbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKV0pOnRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoW25ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1pblgoKSx0LmdldE1heFkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSldKSxudWxsKX0sY3JlYXRlTGluZVN0cmluZzpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgU3QoZSx0aGlzKX19fSxjcmVhdGVNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IGd0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IGd0KHQsdGhpcyl9fSxidWlsZEdlb21ldHJ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49ITEsaT0hMSxyPXQuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89cy5nZXRDbGFzcygpO251bGw9PT1lJiYoZT1vKSxvIT09ZSYmKG49ITApLHMuaXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQoKSYmKGk9ITApfWlmKG51bGw9PT1lKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKG58fGkpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheSh0KSk7dmFyIGE9dC5pdGVyYXRvcigpLm5leHQoKSx1PXQuc2l6ZSgpPjE7aWYodSl7aWYoYSBpbnN0YW5jZW9mIFR0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9seWdvbihpZS50b1BvbHlnb25BcnJheSh0KSk7aWYoYSBpbnN0YW5jZW9mIFN0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpTGluZVN0cmluZyhpZS50b0xpbmVTdHJpbmdBcnJheSh0KSk7aWYoYSBpbnN0YW5jZW9mIEx0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoaWUudG9Qb2ludEFycmF5KHQpKTtmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5oYW5kbGVkIGNsYXNzOiBcIithLmdldENsYXNzKCkuZ2V0TmFtZSgpKX1yZXR1cm4gYX0sY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9LGNyZWF0ZVBvaW50OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbdF0pOm51bGwpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBMdChlLHRoaXMpfX19LGdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5fSxjcmVhdGVQb2x5Z29uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBUdChudWxsLG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcodCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhlKSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCl7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24obixudWxsKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgVHQoaSxyLHRoaXMpfX0sZ2V0U1JJRDpmdW5jdGlvbigpe3JldHVybiB0aGlzLlNSSUR9LGNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgZnQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgZnQodCx0aGlzKX19LGNyZWF0ZUdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBfdCh0aGlzKTtyZXR1cm4gZS5lZGl0KHQse2VkaXQ6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2FyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LmNyZWF0ZSh0KX19fSl9LGdldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWx9LGNyZWF0ZUxpbmVhclJpbmc6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IGJ0KGUsdGhpcyl9fX0sY3JlYXRlTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBPdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBPdCh0LHRoaXMpfX0sY3JlYXRlTXVsdGlQb2ludDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgUHQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgUHQodCx0aGlzKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChudWxsIT09ZT90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoZSk6bnVsbCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBuPWFyZ3VtZW50c1swXTtpZihudWxsPT09bilyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKTtmb3IodmFyIGk9bmV3IEFycmF5KG4uc2l6ZSgpKS5maWxsKG51bGwpLHI9MDtyPG4uc2l6ZSgpO3IrKyl7dmFyIHM9dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKDEsbi5nZXREaW1lbnNpb24oKSk7Q3QuY29weShuLHIscywwLDEpLGlbcl09dGhpcy5jcmVhdGVQb2ludChzKX1yZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGkpfX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3VdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBpZX19KSxpZS50b011bHRpUG9seWdvbkFycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b0dlb21ldHJ5QXJyYXk9ZnVuY3Rpb24odCl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PWZ1bmN0aW9uKCl7cmV0dXJuIHF0Lmluc3RhbmNlKCl9LGllLnRvTXVsdGlMaW5lU3RyaW5nQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvTGluZVN0cmluZ0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b011bHRpUG9pbnRBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9MaW5lYXJSaW5nQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvUG9pbnRBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9Qb2x5Z29uQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfSxpZS5zZXJpYWxWZXJzaW9uVUlEPS0weDVlYTc1ZjIwNTFlZWI0MDA7dmFyIG9vPXt0eXBlU3RyOi9eXFxzKihcXHcrKVxccypcXChcXHMqKC4qKVxccypcXClcXHMqJC8sZW1wdHlUeXBlU3RyOi9eXFxzKihcXHcrKVxccypFTVBUWVxccyokLyxzcGFjZXM6L1xccysvLHBhcmVuQ29tbWE6L1xcKVxccyosXFxzKlxcKC8sZG91YmxlUGFyZW5Db21tYTovXFwpXFxzKlxcKVxccyosXFxzKlxcKFxccypcXCgvLHRyaW1QYXJlbnM6L15cXHMqXFwoPyguKj8pXFwpP1xccyokL307ZShyZS5wcm90b3R5cGUse3JlYWQ6ZnVuY3Rpb24odCl7dmFyIGUsbixpO3Q9dC5yZXBsYWNlKC9bXFxuXFxyXS9nLFwiIFwiKTt2YXIgcj1vby50eXBlU3RyLmV4ZWModCk7aWYoLTEhPT10LnNlYXJjaChcIkVNUFRZXCIpJiYocj1vby5lbXB0eVR5cGVTdHIuZXhlYyh0KSxyWzJdPXZvaWQgMCksciYmKG49clsxXS50b0xvd2VyQ2FzZSgpLGk9clsyXSx1b1tuXSYmKGU9dW9bbl0uYXBwbHkodGhpcyxbaV0pKSksdm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgV0tUIFwiK3QpO3JldHVybiBlfSx3cml0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5leHRyYWN0R2VvbWV0cnkodCl9LGV4dHJhY3RHZW9tZXRyeTpmdW5jdGlvbih0KXt2YXIgZT10LmdldEdlb21ldHJ5VHlwZSgpLnRvTG93ZXJDYXNlKCk7aWYoIWFvW2VdKXJldHVybiBudWxsO3ZhciBuLGk9ZS50b1VwcGVyQ2FzZSgpO3JldHVybiBuPXQuaXNFbXB0eSgpP2krXCIgRU1QVFlcIjppK1wiKFwiK2FvW2VdLmFwcGx5KHRoaXMsW3RdKStcIilcIn19KTt2YXIgYW89e2Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQueCtcIiBcIit0Lnl9LHBvaW50OmZ1bmN0aW9uKHQpe1xucmV0dXJuIGFvLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuY29vcmRpbmF0ZXMuY29vcmRpbmF0ZXNbMF0pfSxtdWx0aXBvaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLnBvaW50LmFwcGx5KHRoaXMsW3QuZ2VvbWV0cmllc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbGluZXN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5wb2ludHMuY29vcmRpbmF0ZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKGFvLmNvb3JkaW5hdGUuYXBwbHkodGhpcyxbdC5wb2ludHMuY29vcmRpbmF0ZXNbbl1dKSk7cmV0dXJuIGUuam9pbihcIixcIil9LGxpbmVhcnJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQucG9pbnRzLmNvb3JkaW5hdGVzLmxlbmd0aDtpPm47KytuKWUucHVzaChhby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3QucG9pbnRzLmNvb3JkaW5hdGVzW25dXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxtdWx0aWxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQuZ2VvbWV0cmllcy5sZW5ndGg7aT5uOysrbillLnB1c2goXCIoXCIrYW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFt0Lmdlb21ldHJpZXNbbl1dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LHBvbHlnb246ZnVuY3Rpb24odCl7dmFyIGU9W107ZS5wdXNoKFwiKFwiK2FvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbdC5zaGVsbF0pK1wiKVwiKTtmb3IodmFyIG49MCxpPXQuaG9sZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbdC5ob2xlc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbXVsdGlwb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLnBvbHlnb24uYXBwbHkodGhpcyxbdC5nZW9tZXRyaWVzW25dXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxnZW9tZXRyeWNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQuZ2VvbWV0cmllcy5sZW5ndGg7aT5uOysrbillLnB1c2godGhpcy5leHRyYWN0R2VvbWV0cnkodC5nZW9tZXRyaWVzW25dKSk7cmV0dXJuIGUuam9pbihcIixcIil9fSx1bz17cG9pbnQ6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoKTt2YXIgZT10LnRyaW0oKS5zcGxpdChvby5zcGFjZXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChuZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSkpfSxtdWx0aXBvaW50OmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChcIixcIiksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS5yZXBsYWNlKG9vLnRyaW1QYXJlbnMsXCIkMVwiKSxpLnB1c2godW8ucG9pbnQuYXBwbHkodGhpcyxbZV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChpKX0sbGluZXN0cmluZzpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQoXCIsXCIpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0udHJpbSgpLnNwbGl0KG9vLnNwYWNlcyksaS5wdXNoKG5ldyBnKE51bWJlci5wYXJzZUZsb2F0KGVbMF0pLE51bWJlci5wYXJzZUZsb2F0KGVbMV0pKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoaSl9LGxpbmVhcnJpbmc6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZygpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3M+cjsrK3IpZT1uW3JdLnRyaW0oKS5zcGxpdChvby5zcGFjZXMpLGkucHVzaChuZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGkpfSxtdWx0aWxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQob28ucGFyZW5Db21tYSksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS5yZXBsYWNlKG9vLnRyaW1QYXJlbnMsXCIkMVwiKSxpLnB1c2godW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFtlXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoaSl9LHBvbHlnb246ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbigpO2Zvcih2YXIgZSxuLGkscixzPXQudHJpbSgpLnNwbGl0KG9vLnBhcmVuQ29tbWEpLG89W10sYT0wLHU9cy5sZW5ndGg7dT5hOysrYSllPXNbYV0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksbj11by5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW2VdKSxpPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobi5wb2ludHMpLDA9PT1hP3I9aTpvLnB1c2goaSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24ocixvKX0sbXVsdGlwb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbigpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KG9vLmRvdWJsZVBhcmVuQ29tbWEpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksaS5wdXNoKHVvLnBvbHlnb24uYXBwbHkodGhpcyxbZV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGkpfSxnZW9tZXRyeWNvbGxlY3Rpb246ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7dD10LnJlcGxhY2UoLyxcXHMqKFtBLVphLXpdKS9nLFwifCQxXCIpO2Zvcih2YXIgZT10LnRyaW0oKS5zcGxpdChcInxcIiksbj1bXSxpPTAscj1lLmxlbmd0aDtyPmk7KytpKW4ucHVzaCh0aGlzLnJlYWQoZVtpXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9fTtlKHNlLnByb3RvdHlwZSx7d3JpdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfX0pLGUoc2Use3RvTGluZVN0cmluZzpmdW5jdGlvbih0LGUpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtyZXR1cm5cIkxJTkVTVFJJTkcgKCBcIit0LngrXCIgXCIrdC55K1wiLCBcIitlLngrXCIgXCIrZS55K1wiIClcIn19KSxlKG9lLnByb3RvdHlwZSx7Z2V0SW5kZXhBbG9uZ1NlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5pbnRMaW5lSW5kZXhbdF1bZV19LGdldFRvcG9sb2d5U3VtbWFyeTpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3JldHVybiB0aGlzLmlzRW5kUG9pbnQoKSYmdC5hcHBlbmQoXCIgZW5kcG9pbnRcIiksdGhpcy5faXNQcm9wZXImJnQuYXBwZW5kKFwiIHByb3BlclwiKSx0aGlzLmlzQ29sbGluZWFyKCkmJnQuYXBwZW5kKFwiIGNvbGxpbmVhclwiKSx0LnRvU3RyaW5nKCl9LGNvbXB1dGVJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dGhpcy5pbnB1dExpbmVzWzBdWzBdPXQsdGhpcy5pbnB1dExpbmVzWzBdWzFdPWUsdGhpcy5pbnB1dExpbmVzWzFdWzBdPW4sdGhpcy5pbnB1dExpbmVzWzFdWzFdPWksdGhpcy5yZXN1bHQ9dGhpcy5jb21wdXRlSW50ZXJzZWN0KHQsZSxuLGkpfSxnZXRJbnRlcnNlY3Rpb25OdW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHR9LGNvbXB1dGVJbnRMaW5lSW5kZXg6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCludWxsPT09dGhpcy5pbnRMaW5lSW5kZXgmJih0aGlzLmludExpbmVJbmRleD1BcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5KDIpfSksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDApLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgxKSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwwKSxuPXRoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMSk7ZT5uPyh0aGlzLmludExpbmVJbmRleFt0XVswXT0wLHRoaXMuaW50TGluZUluZGV4W3RdWzFdPTEpOih0aGlzLmludExpbmVJbmRleFt0XVswXT0xLHRoaXMuaW50TGluZUluZGV4W3RdWzFdPTApfX0saXNQcm9wZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5faXNQcm9wZXJ9LHNldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKHQpe3RoaXMucHJlY2lzaW9uTW9kZWw9dH0saXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMCk/ITA6ISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5yZXN1bHQ7ZSsrKWlmKCF0aGlzLmludFB0W2VdLmVxdWFsczJEKHRoaXMuaW5wdXRMaW5lc1t0XVswXSkmJiF0aGlzLmludFB0W2VdLmVxdWFsczJEKHRoaXMuaW5wdXRMaW5lc1t0XVsxXSkpcmV0dXJuITA7cmV0dXJuITF9fSxnZXRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW50UHRbdF19LGlzRW5kUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmIXRoaXMuX2lzUHJvcGVyfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHQhPT1vZS5OT19JTlRFUlNFQ1RJT059LGdldEVkZ2VEaXN0YW5jZTpmdW5jdGlvbih0LGUpe3ZhciBuPW9lLmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5pbnRQdFtlXSx0aGlzLmlucHV0TGluZXNbdF1bMF0sdGhpcy5pbnB1dExpbmVzW3RdWzFdKTtyZXR1cm4gbn0saXNDb2xsaW5lYXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHQ9PT1vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcodGhpcy5pbnB1dExpbmVzWzBdWzBdLHRoaXMuaW5wdXRMaW5lc1swXVsxXSkrXCIgLSBcIitzZS50b0xpbmVTdHJpbmcodGhpcy5pbnB1dExpbmVzWzFdWzBdLHRoaXMuaW5wdXRMaW5lc1sxXVsxXSkrdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKX0sZ2V0RW5kcG9pbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5pbnB1dExpbmVzW3RdW2VdfSxpc0ludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMucmVzdWx0O2UrKylpZih0aGlzLmludFB0W2VdLmVxdWFsczJEKHQpKXJldHVybiEwO3JldHVybiExfSxnZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5pbnRQdFt0aGlzLmludExpbmVJbmRleFt0XVtlXV19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfX0pLG9lLmNvbXB1dGVFZGdlRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPU1hdGguYWJzKG4ueC1lLngpLHI9TWF0aC5hYnMobi55LWUueSkscz0tMTtpZih0LmVxdWFscyhlKSlzPTA7ZWxzZSBpZih0LmVxdWFscyhuKSlzPWk+cj9pOnI7ZWxzZXt2YXIgbz1NYXRoLmFicyh0LngtZS54KSxhPU1hdGguYWJzKHQueS1lLnkpO3M9aT5yP286YSwwIT09c3x8dC5lcXVhbHMoZSl8fChzPU1hdGgubWF4KG8sYSkpfXJldHVybiBmLmlzVHJ1ZSghKDA9PT1zJiYhdC5lcXVhbHMoZSkpLFwiQmFkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHN9LG9lLm5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9TWF0aC5zcXJ0KGkqaStyKnIpO3JldHVybiBmLmlzVHJ1ZSghKDA9PT1zJiYhdC5lcXVhbHMoZSkpLFwiSW52YWxpZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxzfSxvZS5ET05UX0lOVEVSU0VDVD0wLG9lLkRPX0lOVEVSU0VDVD0xLG9lLkNPTExJTkVBUj0yLG9lLk5PX0lOVEVSU0VDVElPTj0wLG9lLlBPSU5UX0lOVEVSU0VDVElPTj0xLG9lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT049MixoKGFlLG9lKSxlKGFlLnByb3RvdHlwZSx7aXNJblNlZ21lbnRFbnZlbG9wZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEModGhpcy5pbnB1dExpbmVzWzBdWzBdLHRoaXMuaW5wdXRMaW5lc1swXVsxXSksbj1uZXcgQyh0aGlzLmlucHV0TGluZXNbMV1bMF0sdGhpcy5pbnB1dExpbmVzWzFdWzFdKTtyZXR1cm4gZS5jb250YWlucyh0KSYmbi5jb250YWlucyh0KX0sY29tcHV0ZUludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDMhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBvZS5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLl9pc1Byb3Blcj0hMSxDLmludGVyc2VjdHMoZSxuLHQpJiYwPT09aGUub3JpZW50YXRpb25JbmRleChlLG4sdCkmJjA9PT1oZS5vcmllbnRhdGlvbkluZGV4KG4sZSx0KT8odGhpcy5faXNQcm9wZXI9ITAsKHQuZXF1YWxzKGUpfHx0LmVxdWFscyhuKSkmJih0aGlzLl9pc1Byb3Blcj0hMSksdGhpcy5yZXN1bHQ9b2UuUE9JTlRfSU5URVJTRUNUSU9OLG51bGwpOnZvaWQodGhpcy5yZXN1bHQ9b2UuTk9fSU5URVJTRUNUSU9OKX0sbm9ybWFsaXplVG9NaW5pbXVtOmZ1bmN0aW9uKHQsZSxuLGkscil7ci54PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueCxlLngsbi54LGkueCksci55PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueSxlLnksbi55LGkueSksdC54LT1yLngsdC55LT1yLnksZS54LT1yLngsZS55LT1yLnksbi54LT1yLngsbi55LT1yLnksaS54LT1yLngsaS55LT1yLnl9LHNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1udWxsO3RyeXtyPUYuaW50ZXJzZWN0aW9uKHQsZSxuLGkpfWNhdGNoKHMpe2lmKCEocyBpbnN0YW5jZW9mIHcpKXRocm93IHM7cj1hZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4saSl9ZmluYWxseXt9cmV0dXJuIHJ9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLmludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uKHQsZSxuLGkpO3JldHVybiB0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKHIpfHwocj1uZXcgZyhhZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4saSkpKSxudWxsIT09dGhpcy5wcmVjaXNpb25Nb2RlbCYmdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShyKSxyfSxzbWFsbGVzdEluQWJzVmFsdWU6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPU1hdGguYWJzKHIpO3JldHVybiBNYXRoLmFicyhlKTxzJiYocj1lLHM9TWF0aC5hYnMoZSkpLE1hdGguYWJzKG4pPHMmJihyPW4scz1NYXRoLmFicyhuKSksTWF0aC5hYnMoaSk8cyYmKHI9aSkscn0sY2hlY2tERDpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPU0uaW50ZXJzZWN0aW9uKHQsZSxuLGkpLG89dGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhzKTtBLm91dC5wcmludGxuKFwiREQgaW4gZW52ID0gXCIrbytcIiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFwiK3MpLHIuZGlzdGFuY2Uocyk+MWUtNCYmQS5vdXQucHJpbnRsbihcIkRpc3RhbmNlID0gXCIrci5kaXN0YW5jZShzKSl9LGludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBnKHQpLHM9bmV3IGcoZSksbz1uZXcgZyhuKSxhPW5ldyBnKGkpLHU9bmV3IGc7dGhpcy5ub3JtYWxpemVUb0VudkNlbnRyZShyLHMsbyxhLHUpO3ZhciBsPXRoaXMuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpO3JldHVybiBsLngrPXUueCxsLnkrPXUueSxsfSxjb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPUMuaW50ZXJzZWN0cyh0LGUsbikscz1DLmludGVyc2VjdHModCxlLGkpLG89Qy5pbnRlcnNlY3RzKG4saSx0KSxhPUMuaW50ZXJzZWN0cyhuLGksZSk7cmV0dXJuIHImJnM/KHRoaXMuaW50UHRbMF09bix0aGlzLmludFB0WzFdPWksb2UuQ09MTElORUFSX0lOVEVSU0VDVElPTik6byYmYT8odGhpcy5pbnRQdFswXT10LHRoaXMuaW50UHRbMV09ZSxvZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTpyJiZvPyh0aGlzLmludFB0WzBdPW4sdGhpcy5pbnRQdFsxXT10LCFuLmVxdWFscyh0KXx8c3x8YT9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6ciYmYT8odGhpcy5pbnRQdFswXT1uLHRoaXMuaW50UHRbMV09ZSwhbi5lcXVhbHMoZSl8fHN8fG8/b2UuQ09MTElORUFSX0lOVEVSU0VDVElPTjpvZS5QT0lOVF9JTlRFUlNFQ1RJT04pOnMmJm8/KHRoaXMuaW50UHRbMF09aSx0aGlzLmludFB0WzFdPXQsIWkuZXF1YWxzKHQpfHxyfHxhP29lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT046b2UuUE9JTlRfSU5URVJTRUNUSU9OKTpzJiZhPyh0aGlzLmludFB0WzBdPWksdGhpcy5pbnRQdFsxXT1lLCFpLmVxdWFscyhlKXx8cnx8bz9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6b2UuTk9fSU5URVJTRUNUSU9OfSxub3JtYWxpemVUb0VudkNlbnRyZTpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPXQueDxlLng/dC54OmUueCxvPXQueTxlLnk/dC55OmUueSxhPXQueD5lLng/dC54OmUueCx1PXQueT5lLnk/dC55OmUueSxsPW4ueDxpLng/bi54OmkueCxoPW4ueTxpLnk/bi55OmkueSxjPW4ueD5pLng/bi54OmkueCxmPW4ueT5pLnk/bi55OmkueSxnPXM+bD9zOmwsZD1jPmE/YTpjLHA9bz5oP286aCx2PWY+dT91OmYsbT0oZytkKS8yLHk9KHArdikvMjtyLng9bSxyLnk9eSx0LngtPXIueCx0LnktPXIueSxlLngtPXIueCxlLnktPXIueSxuLngtPXIueCxuLnktPXIueSxpLngtPXIueCxpLnktPXIueX0sY29tcHV0ZUludGVyc2VjdDpmdW5jdGlvbih0LGUsbixpKXtpZih0aGlzLl9pc1Byb3Blcj0hMSwhQy5pbnRlcnNlY3RzKHQsZSxuLGkpKXJldHVybiBvZS5OT19JTlRFUlNFQ1RJT047dmFyIHI9aGUub3JpZW50YXRpb25JbmRleCh0LGUsbikscz1oZS5vcmllbnRhdGlvbkluZGV4KHQsZSxpKTtpZihyPjAmJnM+MHx8MD5yJiYwPnMpcmV0dXJuIG9lLk5PX0lOVEVSU0VDVElPTjt2YXIgbz1oZS5vcmllbnRhdGlvbkluZGV4KG4saSx0KSxhPWhlLm9yaWVudGF0aW9uSW5kZXgobixpLGUpO2lmKG8+MCYmYT4wfHwwPm8mJjA+YSlyZXR1cm4gb2UuTk9fSU5URVJTRUNUSU9OO3ZhciB1PTA9PT1yJiYwPT09cyYmMD09PW8mJjA9PT1hO3JldHVybiB1P3RoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixpKTooMD09PXJ8fDA9PT1zfHwwPT09b3x8MD09PWE/KHRoaXMuX2lzUHJvcGVyPSExLHQuZXF1YWxzMkQobil8fHQuZXF1YWxzMkQoaSk/dGhpcy5pbnRQdFswXT10OmUuZXF1YWxzMkQobil8fGUuZXF1YWxzMkQoaSk/dGhpcy5pbnRQdFswXT1lOjA9PT1yP3RoaXMuaW50UHRbMF09bmV3IGcobik6MD09PXM/dGhpcy5pbnRQdFswXT1uZXcgZyhpKTowPT09bz90aGlzLmludFB0WzBdPW5ldyBnKHQpOjA9PT1hJiYodGhpcy5pbnRQdFswXT1uZXcgZyhlKSkpOih0aGlzLl9pc1Byb3Blcj0hMCx0aGlzLmludFB0WzBdPXRoaXMuaW50ZXJzZWN0aW9uKHQsZSxuLGkpKSxvZS5QT0lOVF9JTlRFUlNFQ1RJT04pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhZX19KSxhZS5uZWFyZXN0RW5kcG9pbnQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPWhlLmRpc3RhbmNlUG9pbnRMaW5lKHQsbixpKSxvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsbixpKTtyZXR1cm4gcz5vJiYocz1vLHI9ZSksbz1oZS5kaXN0YW5jZVBvaW50TGluZShuLHQsZSkscz5vJiYocz1vLHI9biksbz1oZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSkscz5vJiYocz1vLHI9aSkscn0sZSh1ZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVlfX0pLHVlLm9yaWVudGF0aW9uSW5kZXg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9bi54LWUueCxvPW4ueS1lLnk7cmV0dXJuIHVlLnNpZ25PZkRldDJ4MihpLHIscyxvKX0sdWUuc2lnbk9mRGV0MngyPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW51bGwscz1udWxsLG89bnVsbCxhPTA7aWYocj0xLDA9PT10fHwwPT09aSlyZXR1cm4gMD09PWV8fDA9PT1uPzA6ZT4wP24+MD8tcjpyOm4+MD9yOi1yO2lmKDA9PT1lfHwwPT09bilyZXR1cm4gaT4wP3Q+MD9yOi1yOnQ+MD8tcjpyO2lmKGU+MD9pPjA/aT49ZXx8KHI9LXIscz10LHQ9bixuPXMscz1lLGU9aSxpPXMpOi1pPj1lPyhyPS1yLG49LW4saT0taSk6KHM9dCx0PS1uLG49cyxzPWUsZT0taSxpPXMpOmk+MD9pPj0tZT8ocj0tcix0PS10LGU9LWUpOihzPS10LHQ9bixuPXMscz0tZSxlPWksaT1zKTplPj1pPyh0PS10LGU9LWUsbj0tbixpPS1pKToocj0tcixzPS10LHQ9LW4sbj1zLHM9LWUsZT0taSxpPXMpLHQ+MCl7aWYoIShuPjApKXJldHVybiByO2lmKCEobj49dCkpcmV0dXJuIHJ9ZWxzZXtpZihuPjApcmV0dXJuLXI7aWYoISh0Pj1uKSlyZXR1cm4tcjtyPS1yLHQ9LXQsbj0tbn1mb3IoOzspe2lmKGErPTEsbz1NYXRoLmZsb29yKG4vdCksbi09byp0LGktPW8qZSwwPmkpcmV0dXJuLXI7aWYoaT5lKXJldHVybiByO2lmKHQ+bituKXtpZihpK2k+ZSlyZXR1cm4gcn1lbHNle2lmKGU+aStpKXJldHVybi1yO249dC1uLGk9ZS1pLHI9LXJ9aWYoMD09PWkpcmV0dXJuIDA9PT1uPzA6LXI7aWYoMD09PW4pcmV0dXJuIHI7aWYobz1NYXRoLmZsb29yKHQvbiksdC09bypuLGUtPW8qaSwwPmUpcmV0dXJuIHI7aWYoZT5pKXJldHVybi1yO2lmKG4+dCt0KXtpZihlK2U+aSlyZXR1cm4tcn1lbHNle2lmKGk+ZStlKXJldHVybiByO3Q9bi10LGU9aS1lLHI9LXJ9aWYoMD09PWUpcmV0dXJuIDA9PT10PzA6cjtpZigwPT09dClyZXR1cm4tcn19LGUobGUucHJvdG90eXBlLHtjb3VudFNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtpZih0Lng8dGhpcy5wLngmJmUueDx0aGlzLnAueClyZXR1cm4gbnVsbDtpZih0aGlzLnAueD09PWUueCYmdGhpcy5wLnk9PT1lLnkpcmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2lmKHQueT09PXRoaXMucC55JiZlLnk9PT10aGlzLnAueSl7dmFyIG49dC54LGk9ZS54O3JldHVybiBuPmkmJihuPWUueCxpPXQueCksdGhpcy5wLng+PW4mJnRoaXMucC54PD1pJiYodGhpcy5pc1BvaW50T25TZWdtZW50PSEwKSxudWxsfWlmKHQueT50aGlzLnAueSYmZS55PD10aGlzLnAueXx8ZS55PnRoaXMucC55JiZ0Lnk8PXRoaXMucC55KXt2YXIgcj10LngtdGhpcy5wLngscz10LnktdGhpcy5wLnksbz1lLngtdGhpcy5wLngsYT1lLnktdGhpcy5wLnksdT11ZS5zaWduT2ZEZXQyeDIocixzLG8sYSk7aWYoMD09PXUpcmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCxudWxsO3M+YSYmKHU9LXUpLHU+MCYmdGhpcy5jcm9zc2luZ0NvdW50Kyt9fSxpc1BvaW50SW5Qb2x5Z29uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKSE9PUwuRVhURVJJT1J9LGdldExvY2F0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD9MLkJPVU5EQVJZOnRoaXMuY3Jvc3NpbmdDb3VudCUyPT09MT9MLklOVEVSSU9SOkwuRVhURVJJT1J9LGlzT25TZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbGV9fSksbGUubG9jYXRlUG9pbnRJblJpbmc9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJlIoYXJndW1lbnRzWzFdLEQpKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlKHQpLGk9bmV3IGcscj1uZXcgZyxzPTE7czxlLnNpemUoKTtzKyspaWYoZS5nZXRDb29yZGluYXRlKHMsaSksZS5nZXRDb29yZGluYXRlKHMtMSxyKSxuLmNvdW50U2VnbWVudChpLHIpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpO3JldHVybiBuLmdldExvY2F0aW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLG49bmV3IGxlKG8pLHM9MTtzPGEubGVuZ3RoO3MrKyl7dmFyIGk9YVtzXSxyPWFbcy0xXTtpZihuLmNvdW50U2VnbWVudChpLHIpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpfXJldHVybiBuLmdldExvY2F0aW9uKCl9fSxlKGhlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaGV9fSksaGUub3JpZW50YXRpb25JbmRleD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE0ub3JpZW50YXRpb25JbmRleCh0LGUsbil9LGhlLnNpZ25lZEFyZWE9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5sZW5ndGg8MylyZXR1cm4gMDtmb3IodmFyIGU9MCxuPXRbMF0ueCxpPTE7aTx0Lmxlbmd0aC0xO2krKyl7dmFyIHI9dFtpXS54LW4scz10W2krMV0ueSxvPXRbaS0xXS55O2UrPXIqKG8tcyl9cmV0dXJuIGUvMn1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YS5zaXplKCk7aWYoMz51KXJldHVybiAwO3ZhciBsPW5ldyBnLGg9bmV3IGcsYz1uZXcgZzthLmdldENvb3JkaW5hdGUoMCxoKSxhLmdldENvb3JkaW5hdGUoMSxjKTt2YXIgbj1oLng7Yy54LT1uO2Zvcih2YXIgZT0wLGk9MTt1LTE+aTtpKyspbC55PWgueSxoLng9Yy54LGgueT1jLnksYS5nZXRDb29yZGluYXRlKGkrMSxjKSxjLngtPW4sZSs9aC54KihsLnktYy55KTtyZXR1cm4gZS8yfX0saGUuZGlzdGFuY2VMaW5lTGluZT1mdW5jdGlvbih0LGUsbixpKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpO2lmKG4uZXF1YWxzKGkpKXJldHVybiBoZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSk7dmFyIHI9ITE7aWYoQy5pbnRlcnNlY3RzKHQsZSxuLGkpKXt2YXIgcz0oZS54LXQueCkqKGkueS1uLnkpLShlLnktdC55KSooaS54LW4ueCk7aWYoMD09PXMpcj0hMDtlbHNle3ZhciBvPSh0Lnktbi55KSooaS54LW4ueCktKHQueC1uLngpKihpLnktbi55KSxhPSh0Lnktbi55KSooZS54LXQueCktKHQueC1uLngpKihlLnktdC55KSx1PWEvcyxsPW8vczsoMD5sfHxsPjF8fDA+dXx8dT4xKSYmKHI9ITApfX1lbHNlIHI9ITA7cmV0dXJuIHI/VC5taW4oaGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpLGhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsbixpKSxoZS5kaXN0YW5jZVBvaW50TGluZShuLHQsZSksaGUuZGlzdGFuY2VQb2ludExpbmUoaSx0LGUpKTowfSxoZS5pc1BvaW50SW5SaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSkhPT1MLkVYVEVSSU9SfSxoZS5jb21wdXRlTGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc2l6ZSgpO2lmKDE+PWUpcmV0dXJuIDA7dmFyIG49MCxpPW5ldyBnO3QuZ2V0Q29vcmRpbmF0ZSgwLGkpO2Zvcih2YXIgcj1pLngscz1pLnksbz0xO2U+bztvKyspe3QuZ2V0Q29vcmRpbmF0ZShvLGkpO3ZhciBhPWkueCx1PWkueSxsPWEtcixoPXUtcztuKz1NYXRoLnNxcnQobCpsK2gqaCkscj1hLHM9dX1yZXR1cm4gbn0saGUuaXNDQ1c9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGgtMTtpZigzPmUpdGhyb3cgbmV3IGkoXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtmb3IodmFyIG49dFswXSxyPTAscz0xO2U+PXM7cysrKXt2YXIgbz10W3NdO28ueT5uLnkmJihuPW8scj1zKX12YXIgYT1yO2RvIGEtPTEsMD5hJiYoYT1lKTt3aGlsZSh0W2FdLmVxdWFsczJEKG4pJiZhIT09cik7dmFyIHU9cjtkbyB1PSh1KzEpJWU7d2hpbGUodFt1XS5lcXVhbHMyRChuKSYmdSE9PXIpO3ZhciBsPXRbYV0saD10W3VdO2lmKGwuZXF1YWxzMkQobil8fGguZXF1YWxzMkQobil8fGwuZXF1YWxzMkQoaCkpcmV0dXJuITE7dmFyIGM9aGUuY29tcHV0ZU9yaWVudGF0aW9uKGwsbixoKSxmPSExO3JldHVybiBmPTA9PT1jP2wueD5oLng6Yz4wfSxoZS5sb2NhdGVQb2ludEluUmluZz1mdW5jdGlvbih0LGUpe3JldHVybiBsZS5sb2NhdGVQb2ludEluUmluZyh0LGUpfSxoZS5kaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXI9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxyPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL2k7cmV0dXJuIE1hdGguYWJzKHIpKk1hdGguc3FydChpKX0saGUuY29tcHV0ZU9yaWVudGF0aW9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGUub3JpZW50YXRpb25JbmRleCh0LGUsbil9LGhlLmRpc3RhbmNlUG9pbnRMaW5lPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IGkoXCJMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4XCIpO2Zvcih2YXIgbj10LmRpc3RhbmNlKGVbMF0pLHI9MDtyPGUubGVuZ3RoLTE7cisrKXt2YXIgcz1oZS5kaXN0YW5jZVBvaW50TGluZSh0LGVbcl0sZVtyKzFdKTtuPnMmJihuPXMpfXJldHVybiBufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl07aWYoYS54PT09dS54JiZhLnk9PT11LnkpcmV0dXJuIG8uZGlzdGFuY2UoYSk7dmFyIGw9KHUueC1hLngpKih1LngtYS54KSsodS55LWEueSkqKHUueS1hLnkpLGg9KChvLngtYS54KSoodS54LWEueCkrKG8ueS1hLnkpKih1LnktYS55KSkvbDtpZigwPj1oKXJldHVybiBvLmRpc3RhbmNlKGEpO2lmKGg+PTEpcmV0dXJuIG8uZGlzdGFuY2UodSk7dmFyIGM9KChhLnktby55KSoodS54LWEueCktKGEueC1vLngpKih1LnktYS55KSkvbDtyZXR1cm4gTWF0aC5hYnMoYykqTWF0aC5zcXJ0KGwpfX0saGUuaXNPbkxpbmU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IGFlLGk9MTtpPGUubGVuZ3RoO2krKyl7dmFyIHI9ZVtpLTFdLHM9ZVtpXTtpZihuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxyLHMpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITB9cmV0dXJuITF9LGhlLkNMT0NLV0lTRT0tMSxoZS5SSUdIVD1oZS5DTE9DS1dJU0UsaGUuQ09VTlRFUkNMT0NLV0lTRT0xLGhlLkxFRlQ9aGUuQ09VTlRFUkNMT0NLV0lTRSxoZS5DT0xMSU5FQVI9MCxoZS5TVFJBSUdIVD1oZS5DT0xMSU5FQVIsZShjZS5wcm90b3R5cGUse21pblg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC54LHRoaXMucDEueCl9LG9yaWVudGF0aW9uSW5kZXg6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1oZS5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAwKSxuPWhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDEpO3JldHVybiBlPj0wJiZuPj0wP01hdGgubWF4KGUsbik6MD49ZSYmMD49bj9NYXRoLm1heChlLG4pOjB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF07cmV0dXJuIGhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLGkpfX0sdG9HZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdC5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLnAwLHRoaXMucDFdKX0saXNWZXJ0aWNhbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLng9PT10aGlzLnAxLnh9LGVxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBjZSkpcmV0dXJuITE7dmFyIGU9dDtyZXR1cm4gdGhpcy5wMC5lcXVhbHMoZS5wMCkmJnRoaXMucDEuZXF1YWxzKGUucDEpfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFlO3JldHVybiBlLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSksZS5oYXNJbnRlcnNlY3Rpb24oKT9lLmdldEludGVyc2VjdGlvbigwKTpudWxsfSxwcm9qZWN0OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5lcXVhbHModGhpcy5wMCl8fHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiBuZXcgZyh0KTt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCksbj1uZXcgZztyZXR1cm4gbi54PXRoaXMucDAueCtlKih0aGlzLnAxLngtdGhpcy5wMC54KSxuLnk9dGhpcy5wMC55K2UqKHRoaXMucDEueS10aGlzLnAwLnkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKGkucDApLHM9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKGkucDEpO2lmKHI+PTEmJnM+PTEpcmV0dXJuIG51bGw7aWYoMD49ciYmMD49cylyZXR1cm4gbnVsbDt2YXIgbz10aGlzLnByb2plY3QoaS5wMCk7MD5yJiYobz10aGlzLnAwKSxyPjEmJihvPXRoaXMucDEpO3ZhciBhPXRoaXMucHJvamVjdChpLnAxKTtyZXR1cm4gMD5zJiYoYT10aGlzLnAwKSxzPjEmJihhPXRoaXMucDEpLG5ldyBjZShvLGEpfX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7dGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCk8MCYmdGhpcy5yZXZlcnNlKCl9LGFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55LXRoaXMucDAueSx0aGlzLnAxLngtdGhpcy5wMC54KX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQ/dGhpcy5wMDp0aGlzLnAxfSxkaXN0YW5jZVBlcnBlbmRpY3VsYXI6ZnVuY3Rpb24odCl7cmV0dXJuIGhlLmRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhcih0LHRoaXMucDAsdGhpcy5wMSl9LG1pblk6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC55LHRoaXMucDEueSl9LG1pZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIGNlLm1pZFBvaW50KHRoaXMucDAsdGhpcy5wMSl9LHByb2plY3Rpb25GYWN0b3I6ZnVuY3Rpb24odCl7aWYodC5lcXVhbHModGhpcy5wMCkpcmV0dXJuIDA7aWYodC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIDE7dmFyIGU9dGhpcy5wMS54LXRoaXMucDAueCxuPXRoaXMucDEueS10aGlzLnAwLnksaT1lKmUrbipuO2lmKDA+PWkpcmV0dXJuIHIuTmFOO3ZhciBzPSgodC54LXRoaXMucDAueCkqZSsodC55LXRoaXMucDAueSkqbikvaTtyZXR1cm4gc30sY2xvc2VzdFBvaW50czpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyc2VjdGlvbih0KTtpZihudWxsIT09ZSlyZXR1cm5bZSxlXTt2YXIgbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxpPXIuTUFYX1ZBTFVFLHM9bnVsbCxvPXRoaXMuY2xvc2VzdFBvaW50KHQucDApO2k9by5kaXN0YW5jZSh0LnAwKSxuWzBdPW8sblsxXT10LnAwO3ZhciBhPXRoaXMuY2xvc2VzdFBvaW50KHQucDEpO3M9YS5kaXN0YW5jZSh0LnAxKSxpPnMmJihpPXMsblswXT1hLG5bMV09dC5wMSk7dmFyIHU9dC5jbG9zZXN0UG9pbnQodGhpcy5wMCk7cz11LmRpc3RhbmNlKHRoaXMucDApLGk+cyYmKGk9cyxuWzBdPXRoaXMucDAsblsxXT11KTt2YXIgbD10LmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtyZXR1cm4gcz1sLmRpc3RhbmNlKHRoaXMucDEpLGk+cyYmKGk9cyxuWzBdPXRoaXMucDEsblsxXT1sKSxufSxjbG9zZXN0UG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO2lmKGU+MCYmMT5lKXJldHVybiB0aGlzLnByb2plY3QodCk7dmFyIG49dGhpcy5wMC5kaXN0YW5jZSh0KSxpPXRoaXMucDEuZGlzdGFuY2UodCk7cmV0dXJuIGk+bj90aGlzLnAwOnRoaXMucDF9LG1heFg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC54LHRoaXMucDEueCl9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLmRpc3RhbmNlKHRoaXMucDEpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPXRoaXMucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnRoaXMucDEuY29tcGFyZVRvKGUucDEpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wMDt0aGlzLnAwPXRoaXMucDEsdGhpcy5wMT10fSxlcXVhbHNUb3BvOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnAwLmVxdWFscyh0LnAwKSYmdGhpcy5wMS5lcXVhbHModC5wMSl8fHRoaXMucDAuZXF1YWxzKHQucDEpJiZ0aGlzLnAxLmVxdWFscyh0LnAwKX0sbGluZUludGVyc2VjdGlvbjpmdW5jdGlvbih0KXt0cnl7dmFyIGU9Ri5pbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSk7cmV0dXJuIGV9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgdykpdGhyb3cgdH1maW5hbGx5e31yZXR1cm4gbnVsbH0sbWF4WTpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLnksdGhpcy5wMS55KX0scG9pbnRBbG9uZ09mZnNldDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxpPXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxyPXRoaXMucDEueC10aGlzLnAwLngscz10aGlzLnAxLnktdGhpcy5wMC55LG89TWF0aC5zcXJ0KHIqcitzKnMpLGE9MCx1PTA7aWYoMCE9PWUpe2lmKDA+PW8pdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkNhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudFwiKTthPWUqci9vLHU9ZSpzL299dmFyIGw9bi11LGg9aSthLGM9bmV3IGcobCxoKTtyZXR1cm4gY30sc2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29vcmRpbmF0ZXModC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wMC54PWUueCx0aGlzLnAwLnk9ZS55LHRoaXMucDEueD1uLngsdGhpcy5wMS55PW4ueX19LHNlZ21lbnRGcmFjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7cmV0dXJuIDA+ZT9lPTA6KGU+MXx8ci5pc05hTihlKSkmJihlPTEpLGV9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJMSU5FU1RSSU5HKCBcIit0aGlzLnAwLngrXCIgXCIrdGhpcy5wMC55K1wiLCBcIit0aGlzLnAxLngrXCIgXCIrdGhpcy5wMS55K1wiKVwifSxpc0hvcml6b250YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMC55PT09dGhpcy5wMS55fSxkaXN0YW5jZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gaGUuZGlzdGFuY2VMaW5lTGluZSh0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUoZSx0aGlzLnAwLHRoaXMucDEpfX0scG9pbnRBbG9uZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZztyZXR1cm4gZS54PXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxlLnk9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGV9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9amF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7dF49MzEqamF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSk7dmFyIGU9TWF0aC50cnVuYyh0KV5NYXRoLnRydW5jKHQ+PjMyKSxuPWphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO25ePTMxKmphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLnkpO3ZhciBpPU1hdGgudHJ1bmMobileTWF0aC50cnVuYyhuPj4zMik7cmV0dXJuIGVeaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY2V9fSksY2UubWlkUG9pbnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IGcoKHQueCtlLngpLzIsKHQueStlLnkpLzIpfSxjZS5zZXJpYWxWZXJzaW9uVUlEPTB4MmQyMTcyMTM1ZjQxMWMwMCxlKGZlLnByb3RvdHlwZSx7aXNJbnRlcnNlY3RzOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNEaXNqb2ludCgpfSxpc0NvdmVyczpmdW5jdGlvbigpe3ZhciB0PWZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSk7cmV0dXJuIHQmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LGlzQ292ZXJlZEJ5OmZ1bmN0aW9uKCl7dmFyIHQ9ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldKTtyZXR1cm4gdCYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09PT1sdC5GQUxTRX0sc2V0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPU1hdGgudHJ1bmMoZS8zKSxpPWUlMzt0aGlzLm1hdHJpeFtuXVtpXT1sdC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5tYXRyaXhbcl1bc109b319LGlzQ29udGFpbnM6ZnVuY3Rpb24oKXtyZXR1cm4gZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0sc2V0QXRMZWFzdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj1NYXRoLnRydW5jKGUvMyksaT1lJTM7dGhpcy5zZXRBdExlYXN0KG4saSxsdC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMubWF0cml4W3JdW3NdPG8mJih0aGlzLm1hdHJpeFtyXVtzXT1vKX19LHNldEF0TGVhc3RJZlZhbGlkOmZ1bmN0aW9uKHQsZSxuKXt0Pj0wJiZlPj0wJiZ0aGlzLnNldEF0TGVhc3QodCxlLG4pfSxpc1dpdGhpbjpmdW5jdGlvbigpe3JldHVybiBmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZ0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFfSxpc1RvdWNoZXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lP3RoaXMuaXNUb3VjaGVzKGUsdCk6dD09PWx0LkEmJmU9PT1sdC5BfHx0PT09bHQuTCYmZT09PWx0Lkx8fHQ9PT1sdC5MJiZlPT09bHQuQXx8dD09PWx0LlAmJmU9PT1sdC5BfHx0PT09bHQuUCYmZT09PWx0Lkw/dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmKGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSkpOiExfSxpc092ZXJsYXBzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1sdC5QJiZlPT09bHQuUHx8dD09PWx0LkEmJmU9PT1sdC5BP2ZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSk6dD09PWx0LkwmJmU9PT1sdC5MPzE9PT10aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdKTohMX0saXNFcXVhbHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCE9PWU/ITE6ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IFAoXCIxMjM0NTY3ODlcIiksZT0wOzM+ZTtlKyspZm9yKHZhciBuPTA7Mz5uO24rKyl0LnNldENoYXJBdCgzKmUrbixsdC50b0RpbWVuc2lvblN5bWJvbCh0aGlzLm1hdHJpeFtlXVtuXSkpO3JldHVybiB0LnRvU3RyaW5nKCl9LHNldEFsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDszPmU7ZSsrKWZvcih2YXIgbj0wOzM+bjtuKyspdGhpcy5tYXRyaXhbZV1bbl09dH0sZ2V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubWF0cml4W3RdW2VdfSx0cmFuc3Bvc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1hdHJpeFsxXVswXTtyZXR1cm4gdGhpcy5tYXRyaXhbMV1bMF09dGhpcy5tYXRyaXhbMF1bMV0sdGhpcy5tYXRyaXhbMF1bMV09dCx0PXRoaXMubWF0cml4WzJdWzBdLHRoaXMubWF0cml4WzJdWzBdPXRoaXMubWF0cml4WzBdWzJdLHRoaXMubWF0cml4WzBdWzJdPXQsdD10aGlzLm1hdHJpeFsyXVsxXSx0aGlzLm1hdHJpeFsyXVsxXT10aGlzLm1hdHJpeFsxXVsyXSx0aGlzLm1hdHJpeFsxXVsyXT10LHRoaXN9LG1hdGNoZXM6ZnVuY3Rpb24odCl7aWYoOSE9PXQubGVuZ3RoKXRocm93IG5ldyBpKFwiU2hvdWxkIGJlIGxlbmd0aCA5OiBcIit0KTtmb3IodmFyIGU9MDszPmU7ZSsrKWZvcih2YXIgbj0wOzM+bjtuKyspaWYoIWZlLm1hdGNoZXModGhpcy5tYXRyaXhbZV1bbl0sdC5jaGFyQXQoMyplK24pKSlyZXR1cm4hMTtyZXR1cm4hMH0sYWRkOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wOzM+ZTtlKyspZm9yKHZhciBuPTA7Mz5uO24rKyl0aGlzLnNldEF0TGVhc3QoZSxuLHQuZ2V0KGUsbikpfSxpc0Rpc2pvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LGlzQ3Jvc3NlczpmdW5jdGlvbih0LGUpe3JldHVybiB0PT09bHQuUCYmZT09PWx0Lkx8fHQ9PT1sdC5QJiZlPT09bHQuQXx8dD09PWx0LkwmJmU9PT1sdC5BP2ZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSk6dD09PWx0LkwmJmU9PT1sdC5QfHx0PT09bHQuQSYmZT09PWx0LlB8fHQ9PT1sdC5BJiZlPT09bHQuTD9mZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl0pOnQ9PT1sdC5MJiZlPT09bHQuTD8wPT09dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl06ITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmZX19KSxmZS5tYXRjaGVzPWZ1bmN0aW9uKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGU9PT1sdC5TWU1fRE9OVENBUkU/ITA6ZT09PWx0LlNZTV9UUlVFJiYodD49MHx8dD09PWx0LlRSVUUpPyEwOmU9PT1sdC5TWU1fRkFMU0UmJnQ9PT1sdC5GQUxTRT8hMDplPT09bHQuU1lNX1AmJnQ9PT1sdC5QPyEwOmU9PT1sdC5TWU1fTCYmdD09PWx0Lkw/ITA6ZT09PWx0LlNZTV9BJiZ0PT09bHQuQX1pZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1uZXcgZmUobik7cmV0dXJuIHIubWF0Y2hlcyhpKX19LGZlLmlzVHJ1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdD49MHx8dD09PWx0LlRSVUV9O3ZhciBsbz1PYmplY3QuZnJlZXplKHtDb29yZGluYXRlOmcsQ29vcmRpbmF0ZUxpc3Q6TixFbnZlbG9wZTpDLExpbmVTZWdtZW50OmNlLEdlb21ldHJ5RmFjdG9yeTppZSxHZW9tZXRyeTpCLFBvaW50Okx0LExpbmVTdHJpbmc6U3QsTGluZWFyUmluZzpidCxQb2x5Z29uOlR0LEdlb21ldHJ5Q29sbGVjdGlvbjpmdCxNdWx0aVBvaW50OlB0LE11bHRpTGluZVN0cmluZzpndCxNdWx0aVBvbHlnb246T3QsRGltZW5zaW9uOmx0LEludGVyc2VjdGlvbk1hdHJpeDpmZX0pO2UoZ2UucHJvdG90eXBlLHthZGRQb2ludDpmdW5jdGlvbih0KXt0aGlzLnB0Q291bnQrPTEsdGhpcy5wdENlbnRTdW0ueCs9dC54LHRoaXMucHRDZW50U3VtLnkrPXQueX0sc2V0QmFzZVBvaW50OmZ1bmN0aW9uKHQpe251bGw9PT10aGlzLmFyZWFCYXNlUHQmJih0aGlzLmFyZWFCYXNlUHQ9dCl9LGFkZExpbmVTZWdtZW50czpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aC0xO24rKyl7dmFyIGk9dFtuXS5kaXN0YW5jZSh0W24rMV0pO2lmKDAhPT1pKXtlKz1pO3ZhciByPSh0W25dLngrdFtuKzFdLngpLzI7dGhpcy5saW5lQ2VudFN1bS54Kz1pKnI7dmFyIHM9KHRbbl0ueSt0W24rMV0ueSkvMjt0aGlzLmxpbmVDZW50U3VtLnkrPWkqc319dGhpcy50b3RhbExlbmd0aCs9ZSwwPT09ZSYmdC5sZW5ndGg+MCYmdGhpcy5hZGRQb2ludCh0WzBdKX0sYWRkSG9sZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9aGUuaXNDQ1codCksbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLmFyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9LGdldENlbnRyb2lkOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGc7aWYoTWF0aC5hYnModGhpcy5hcmVhc3VtMik+MCl0Lng9dGhpcy5jZzMueC8zL3RoaXMuYXJlYXN1bTIsdC55PXRoaXMuY2czLnkvMy90aGlzLmFyZWFzdW0yO2Vsc2UgaWYodGhpcy50b3RhbExlbmd0aD4wKXQueD10aGlzLmxpbmVDZW50U3VtLngvdGhpcy50b3RhbExlbmd0aCx0Lnk9dGhpcy5saW5lQ2VudFN1bS55L3RoaXMudG90YWxMZW5ndGg7ZWxzZXtpZighKHRoaXMucHRDb3VudD4wKSlyZXR1cm4gbnVsbDt0Lng9dGhpcy5wdENlbnRTdW0ueC90aGlzLnB0Q291bnQsdC55PXRoaXMucHRDZW50U3VtLnkvdGhpcy5wdENvdW50fXJldHVybiB0fSxhZGRTaGVsbDpmdW5jdGlvbih0KXt0Lmxlbmd0aD4wJiZ0aGlzLnNldEJhc2VQb2ludCh0WzBdKTtmb3IodmFyIGU9IWhlLmlzQ0NXKHQpLG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfSxhZGRUcmlhbmdsZTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1pPzE6LTE7Z2UuY2VudHJvaWQzKHQsZSxuLHRoaXMudHJpYW5nbGVDZW50Myk7dmFyIHM9Z2UuYXJlYTIodCxlLG4pO3RoaXMuY2czLngrPXIqcyp0aGlzLnRyaWFuZ2xlQ2VudDMueCx0aGlzLmNnMy55Kz1yKnMqdGhpcy50cmlhbmdsZUNlbnQzLnksdGhpcy5hcmVhc3VtMis9cipzfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hZGRTaGVsbCh0LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspdGhpcy5hZGRIb2xlKHQuZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIG49YXJndW1lbnRzWzBdO2lmKG4uaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKG4gaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KG4uZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiBTdCl0aGlzLmFkZExpbmVTZWdtZW50cyhuLmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYobiBpbnN0YW5jZW9mIFR0KXt2YXIgaT1uO3RoaXMuYWRkKGkpfWVsc2UgaWYobiBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgcj1uLGU9MDtlPHIuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl0aGlzLmFkZChyLmdldEdlb21ldHJ5TihlKSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBnZX19KSxnZS5hcmVhMj1mdW5jdGlvbih0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0obi54LXQueCkqKGUueS10LnkpfSxnZS5jZW50cm9pZDM9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIGkueD10LngrZS54K24ueCxpLnk9dC55K2UueStuLnksbnVsbH0sZ2UuZ2V0Q2VudHJvaWQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGdlKHQpO3JldHVybiBlLmdldENlbnRyb2lkKCl9LGRlLnByb3RvdHlwZT1uZXcgRXJyb3IsZGUucHJvdG90eXBlLm5hbWU9XCJFbXB0eVN0YWNrRXhjZXB0aW9uXCIscGUucHJvdG90eXBlPW5ldyB5LHBlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksITB9LHBlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYoMD50fHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjtyZXR1cm4gdGhpcy5hcnJheV9bdF19LHBlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLHR9LHBlLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMuYXJyYXlfLmxlbmd0aCl0aHJvdyBuZXcgZGU7cmV0dXJuIHRoaXMuYXJyYXlfLnBvcCgpfSxwZS5wcm90b3R5cGUucGVlaz1mdW5jdGlvbigpe2lmKDA9PT10aGlzLmFycmF5Xy5sZW5ndGgpdGhyb3cgbmV3IGRlO3JldHVybiB0aGlzLmFycmF5X1t0aGlzLmFycmF5Xy5sZW5ndGgtMV19LHBlLnByb3RvdHlwZS5lbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxwZS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVtcHR5KCl9LHBlLnByb3RvdHlwZS5zZWFyY2g9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLmluZGV4T2YodCl9LHBlLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0scGUucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sZSh2ZS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0aGlzLnRyZWVTZXQuY29udGFpbnModCl8fCh0aGlzLmxpc3QuYWRkKHQpLHRoaXMudHJlZVNldC5hZGQodCkpfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSh0aGlzLmxpc3Quc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmxpc3QudG9BcnJheSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bel19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZlfX0pLHZlLmZpbHRlckNvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgdmUsbj0wO248dC5sZW5ndGg7bisrKWUuZmlsdGVyKHRbbl0pO3JldHVybiBlLmdldENvb3JkaW5hdGVzKCl9LGUobWUucHJvdG90eXBlLHtwcmVTb3J0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49MTtuPHQubGVuZ3RoO24rKykodFtuXS55PHRbMF0ueXx8dFtuXS55PT09dFswXS55JiZ0W25dLng8dFswXS54KSYmKGU9dFswXSx0WzBdPXRbbl0sdFtuXT1lKTtyZXR1cm4gdXQuc29ydCh0LDEsdC5sZW5ndGgsbmV3IHllKHRbMF0pKSx0fSxjb21wdXRlT2N0UmluZzpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVPY3RQdHModCksbj1uZXcgTjtyZXR1cm4gbi5hZGQoZSwhMSksbi5zaXplKCk8Mz9udWxsOihuLmNsb3NlUmluZygpLG4udG9Db29yZGluYXRlQXJyYXkoKSl9LGxpbmVPclBvbHlnb246ZnVuY3Rpb24odCl7aWYodD10aGlzLmNsZWFuUmluZyh0KSwzPT09dC5sZW5ndGgpcmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbdFswXSx0WzFdXSk7dmFyIGU9dGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpO3JldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZVBvbHlnb24oZSxudWxsKX0sY2xlYW5SaW5nOmZ1bmN0aW9uKHQpe2YuZXF1YWxzKHRbMF0sdFt0Lmxlbmd0aC0xXSk7Zm9yKHZhciBlPW5ldyBJLG49bnVsbCxpPTA7aTw9dC5sZW5ndGgtMjtpKyspe3ZhciByPXRbaV0scz10W2krMV07ci5lcXVhbHMocyl8fG51bGwhPT1uJiZ0aGlzLmlzQmV0d2VlbihuLHIscyl8fChlLmFkZChyKSxuPXIpfWUuYWRkKHRbdC5sZW5ndGgtMV0pO3ZhciBvPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gZS50b0FycmF5KG8pfSxpc0JldHdlZW46ZnVuY3Rpb24odCxlLG4pe2lmKDAhPT1oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLG4pKXJldHVybiExO2lmKHQueCE9PW4ueCl7aWYodC54PD1lLngmJmUueDw9bi54KXJldHVybiEwO2lmKG4ueDw9ZS54JiZlLng8PXQueClyZXR1cm4hMH1pZih0LnkhPT1uLnkpe2lmKHQueTw9ZS55JiZlLnk8PW4ueSlyZXR1cm4hMDtpZihuLnk8PWUueSYmZS55PD10LnkpcmV0dXJuITB9cmV0dXJuITF9LHJlZHVjZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVPY3RSaW5nKHQpO2lmKG51bGw9PT1lKXJldHVybiB0O2Zvcih2YXIgbj1uZXcgYXQsaT0wO2k8ZS5sZW5ndGg7aSsrKW4uYWRkKGVbaV0pO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKWhlLmlzUG9pbnRJblJpbmcodFtpXSxlKXx8bi5hZGQodFtpXSk7dmFyIHI9SC50b0Nvb3JkaW5hdGVBcnJheShuKTtyZXR1cm4gci5sZW5ndGg8Mz90aGlzLnBhZEFycmF5MyhyKTpyfSxnZXRDb252ZXhIdWxsOmZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuaW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKTtpZigxPT09dGhpcy5pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy5pbnB1dFB0c1swXSk7aWYoMj09PXRoaXMuaW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5pbnB1dFB0cyk7dmFyIHQ9dGhpcy5pbnB1dFB0czt0aGlzLmlucHV0UHRzLmxlbmd0aD41MCYmKHQ9dGhpcy5yZWR1Y2UodGhpcy5pbnB1dFB0cykpO3ZhciBlPXRoaXMucHJlU29ydCh0KSxuPXRoaXMuZ3JhaGFtU2NhbihlKSxpPXRoaXMudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHRoaXMubGluZU9yUG9seWdvbihpKX0scGFkQXJyYXkzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspbjx0Lmxlbmd0aD9lW25dPXRbbl06ZVtuXT10WzBdO3JldHVybiBlfSxjb21wdXRlT2N0UHRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkoOCkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10WzBdO2Zvcih2YXIgaT0xO2k8dC5sZW5ndGg7aSsrKXRbaV0ueDxlWzBdLngmJihlWzBdPXRbaV0pLHRbaV0ueC10W2ldLnk8ZVsxXS54LWVbMV0ueSYmKGVbMV09dFtpXSksdFtpXS55PmVbMl0ueSYmKGVbMl09dFtpXSksdFtpXS54K3RbaV0ueT5lWzNdLngrZVszXS55JiYoZVszXT10W2ldKSx0W2ldLng+ZVs0XS54JiYoZVs0XT10W2ldKSx0W2ldLngtdFtpXS55PmVbNV0ueC1lWzVdLnkmJihlWzVdPXRbaV0pLHRbaV0ueTxlWzZdLnkmJihlWzZdPXRbaV0pLHRbaV0ueCt0W2ldLnk8ZVs3XS54K2VbN10ueSYmKGVbN109dFtpXSk7cmV0dXJuIGV9LHRvQ29vcmRpbmF0ZUFycmF5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wO248dC5zaXplKCk7bisrKXt2YXIgaT10LmdldChuKTtlW25dPWl9cmV0dXJuIGV9LGdyYWhhbVNjYW46ZnVuY3Rpb24odCl7dmFyIGU9bnVsbCxuPW5ldyBwZTtlPW4ucHVzaCh0WzBdKSxlPW4ucHVzaCh0WzFdKSxlPW4ucHVzaCh0WzJdKTtmb3IodmFyIGk9MztpPHQubGVuZ3RoO2krKyl7Zm9yKGU9bi5wb3AoKTshbi5lbXB0eSgpJiZoZS5jb21wdXRlT3JpZW50YXRpb24obi5wZWVrKCksZSx0W2ldKT4wOyllPW4ucG9wKCk7ZT1uLnB1c2goZSksZT1uLnB1c2godFtpXSl9cmV0dXJuIGU9bi5wdXNoKHRbMF0pLG59LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1lfX0pLG1lLmV4dHJhY3RDb29yZGluYXRlcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgdmU7cmV0dXJuIHQuYXBwbHkoZSksZS5nZXRDb29yZGluYXRlcygpfSxlKHllLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO3JldHVybiB5ZS5wb2xhckNvbXBhcmUodGhpcy5vcmlnaW4sbixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHllfX0pLHllLnBvbGFyQ29tcGFyZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS54LXQueCxyPWUueS10Lnkscz1uLngtdC54LG89bi55LXQueSxhPWhlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsbik7XG5pZihhPT09aGUuQ09VTlRFUkNMT0NLV0lTRSlyZXR1cm4gMTtpZihhPT09aGUuQ0xPQ0tXSVNFKXJldHVybi0xO3ZhciB1PWkqaStyKnIsbD1zKnMrbypvO3JldHVybiBsPnU/LTE6dT5sPzE6MH0sbWUuUmFkaWFsQ29tcGFyYXRvcj15ZSxlKHhlLnByb3RvdHlwZSx7dHJhbnNmb3JtUG9pbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9LHRyYW5zZm9ybVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj0hMCxpPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEV4dGVyaW9yUmluZygpLHQpO251bGwhPT1pJiZpIGluc3RhbmNlb2YgYnQmJiFpLmlzRW1wdHkoKXx8KG49ITEpO2Zvcih2YXIgcj1uZXcgSSxzPTA7czx0LmdldE51bUludGVyaW9yUmluZygpO3MrKyl7dmFyIG89dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihzKSx0KTtudWxsPT09b3x8by5pc0VtcHR5KCl8fChvIGluc3RhbmNlb2YgYnR8fChuPSExKSxyLmFkZChvKSl9aWYobilyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24oaSxyLnRvQXJyYXkoW10pKTt2YXIgYT1uZXcgSTtyZXR1cm4gbnVsbCE9PWkmJmEuYWRkKGkpLGEuYWRkQWxsKHIpLHRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KGEpfSxjcmVhdGVDb29yZGluYXRlU2VxdWVuY2U6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpfSxnZXRJbnB1dEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5wdXRHZW9tfSx0cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj10aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodC5nZXRHZW9tZXRyeU4oaSksdCk7bnVsbCE9PXImJihyLmlzRW1wdHkoKXx8bi5hZGQocikpfXJldHVybiB0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX0sdHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb3B5KHQpfSx0cmFuc2Zvcm1MaW5lU3RyaW5nOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9LHRyYW5zZm9ybU11bHRpUG9pbnQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj10aGlzLnRyYW5zZm9ybVBvaW50KHQuZ2V0R2VvbWV0cnlOKGkpLHQpO251bGwhPT1yJiYoci5pc0VtcHR5KCl8fG4uYWRkKHIpKX1yZXR1cm4gdGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9LHRyYW5zZm9ybU11bHRpUG9seWdvbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPXRoaXMudHJhbnNmb3JtUG9seWdvbih0LmdldEdlb21ldHJ5TihpKSx0KTtudWxsIT09ciYmKHIuaXNFbXB0eSgpfHxuLmFkZChyKSl9cmV0dXJuIHRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfSxjb3B5OmZ1bmN0aW9uKHQpe3JldHVybiB0LmNvcHkoKX0sdHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9dGhpcy50cmFuc2Zvcm0odC5nZXRHZW9tZXRyeU4oaSkpO251bGwhPT1yJiYodGhpcy5wcnVuZUVtcHR5R2VvbWV0cnkmJnIuaXNFbXB0eSgpfHxuLmFkZChyKSl9cmV0dXJuIHRoaXMucHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlP3RoaXMuZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KG4pKTp0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX0sdHJhbnNmb3JtOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaW5wdXRHZW9tPXQsdGhpcy5mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHQgaW5zdGFuY2VvZiBMdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBQdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGJ0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgU3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBndClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgVHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBPdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgZnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uKHQsbnVsbCk7dGhyb3cgbmV3IGkoXCJVbmtub3duIEdlb21ldHJ5IHN1YnR5cGU6IFwiK3QuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfSx0cmFuc2Zvcm1MaW5lYXJSaW5nOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhudWxsKTt2YXIgaT1uLnNpemUoKTtyZXR1cm4gaT4wJiY0PmkmJiF0aGlzLnByZXNlcnZlVHlwZT90aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhuKTp0aGlzLmZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geGV9fSksZShFZS5wcm90b3R5cGUse3NuYXBWZXJ0aWNlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLl9pc0Nsb3NlZD90LnNpemUoKS0xOnQuc2l6ZSgpLGk9MDtuPmk7aSsrKXt2YXIgcj10LmdldChpKSxzPXRoaXMuZmluZFNuYXBGb3JWZXJ0ZXgocixlKTtudWxsIT09cyYmKHQuc2V0KGksbmV3IGcocykpLDA9PT1pJiZ0aGlzLl9pc0Nsb3NlZCYmdC5zZXQodC5zaXplKCktMSxuZXcgZyhzKSkpfX0sZmluZFNuYXBGb3JWZXJ0ZXg6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7aWYodC5lcXVhbHMyRChlW25dKSlyZXR1cm4gbnVsbDtpZih0LmRpc3RhbmNlKGVbbl0pPHRoaXMuc25hcFRvbGVyYW5jZSlyZXR1cm4gZVtuXX1yZXR1cm4gbnVsbH0sc25hcFRvOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBOKHRoaXMuc3JjUHRzKTt0aGlzLnNuYXBWZXJ0aWNlcyhlLHQpLHRoaXMuc25hcFNlZ21lbnRzKGUsdCk7dmFyIG49ZS50b0Nvb3JkaW5hdGVBcnJheSgpO3JldHVybiBufSxzbmFwU2VnbWVudHM6ZnVuY3Rpb24odCxlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIG49ZS5sZW5ndGg7ZVswXS5lcXVhbHMyRChlW2UubGVuZ3RoLTFdKSYmKG49ZS5sZW5ndGgtMSk7Zm9yKHZhciBpPTA7bj5pO2krKyl7dmFyIHI9ZVtpXSxzPXRoaXMuZmluZFNlZ21lbnRJbmRleFRvU25hcChyLHQpO3M+PTAmJnQuYWRkKHMrMSxuZXcgZyhyKSwhMSl9fSxmaW5kU2VnbWVudEluZGV4VG9TbmFwOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXIuTUFYX1ZBTFVFLGk9LTEscz0wO3M8ZS5zaXplKCktMTtzKyspe2lmKHRoaXMuc2VnLnAwPWUuZ2V0KHMpLHRoaXMuc2VnLnAxPWUuZ2V0KHMrMSksdGhpcy5zZWcucDAuZXF1YWxzMkQodCl8fHRoaXMuc2VnLnAxLmVxdWFsczJEKHQpKXtpZih0aGlzLmFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKWNvbnRpbnVlO3JldHVybi0xfXZhciBvPXRoaXMuc2VnLmRpc3RhbmNlKHQpO288dGhpcy5zbmFwVG9sZXJhbmNlJiZuPm8mJihuPW8saT1zKX1yZXR1cm4gaX0sc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM6ZnVuY3Rpb24odCl7dGhpcy5hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFZX19KSxFZS5pc0Nsb3NlZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5sZW5ndGg8PTE/ITE6dFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX0sZShJZS5wcm90b3R5cGUse3NuYXBUbzpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHQpLGk9bmV3IE5lKGUsbik7cmV0dXJuIGkudHJhbnNmb3JtKHRoaXMuc3JjR2VvbSl9LHNuYXBUb1NlbGY6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0aGlzLnNyY0dlb20pLGk9bmV3IE5lKHQsbiwhMCkscj1pLnRyYW5zZm9ybSh0aGlzLnNyY0dlb20pLHM9cjtyZXR1cm4gZSYmUihzLFJ0KSYmKHM9ci5idWZmZXIoMCkpLHN9LGNvbXB1dGVTbmFwVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpLG49ZS8xMDtyZXR1cm4gbn0sZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgYXQsbj10LmdldENvb3JkaW5hdGVzKCksaT0wO2k8bi5sZW5ndGg7aSsrKWUuYWRkKG5baV0pO3JldHVybiBlLnRvQXJyYXkobmV3IEFycmF5KDApLmZpbGwobnVsbCkpfSxjb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGg6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXIuTUFYX1ZBTFVFLG49MDtuPHQubGVuZ3RoLTE7bisrKXt2YXIgaT10W25dLmRpc3RhbmNlKHRbbisxXSk7ZT5pJiYoZT1pKX1yZXR1cm4gZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSWV9fSksSWUuc25hcD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEFycmF5KDIpLmZpbGwobnVsbCkscj1uZXcgSWUodCk7aVswXT1yLnNuYXBUbyhlLG4pO3ZhciBzPW5ldyBJZShlKTtyZXR1cm4gaVsxXT1zLnNuYXBUbyhpWzBdLG4pLGl9LEllLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1JZS5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KSxuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKTtpZihuLmdldFR5cGUoKT09PWVlLkZJWEVEKXt2YXIgaT0xL24uZ2V0U2NhbGUoKSoyLzEuNDE1O2k+ZSYmKGU9aSl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXTtyZXR1cm4gTWF0aC5taW4oSWUuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHIpLEllLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShzKSl9fSxJZS5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZT1mdW5jdGlvbih0KXt2YXIgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxuPU1hdGgubWluKGUuZ2V0SGVpZ2h0KCksZS5nZXRXaWR0aCgpKSxpPW4qSWUuU05BUF9QUkVDSVNJT05fRkFDVE9SO3JldHVybiBpfSxJZS5zbmFwVG9TZWxmPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgSWUodCk7cmV0dXJuIGkuc25hcFRvU2VsZihlLG4pfSxJZS5TTkFQX1BSRUNJU0lPTl9GQUNUT1I9MWUtOSxoKE5lLHhlKSxlKE5lLnByb3RvdHlwZSx7c25hcExpbmU6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgRWUodCx0aGlzLnNuYXBUb2xlcmFuY2UpO3JldHVybiBuLnNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHRoaXMuaXNTZWxmU25hcCksbi5zbmFwVG8oZSl9LHRyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC50b0Nvb3JkaW5hdGVBcnJheSgpLGk9dGhpcy5zbmFwTGluZShuLHRoaXMuc25hcFB0cyk7cmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOZX19KSxlKENlLnByb3RvdHlwZSx7Z2V0Q29tbW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHIubG9uZ0JpdHNUb0RvdWJsZSh0aGlzLmNvbW1vbkJpdHMpfSxhZGQ6ZnVuY3Rpb24odCl7dmFyIGU9ci5kb3VibGVUb0xvbmdCaXRzKHQpO2lmKHRoaXMuaXNGaXJzdClyZXR1cm4gdGhpcy5jb21tb25CaXRzPWUsdGhpcy5jb21tb25TaWduRXhwPUNlLnNpZ25FeHBCaXRzKHRoaXMuY29tbW9uQml0cyksdGhpcy5pc0ZpcnN0PSExLG51bGw7dmFyIG49Q2Uuc2lnbkV4cEJpdHMoZSk7cmV0dXJuIG4hPT10aGlzLmNvbW1vblNpZ25FeHA/KHRoaXMuY29tbW9uQml0cz0wLG51bGwpOih0aGlzLmNvbW1vbk1hbnRpc3NhQml0c0NvdW50PUNlLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModGhpcy5jb21tb25CaXRzLGUpLHZvaWQodGhpcy5jb21tb25CaXRzPUNlLnplcm9Mb3dlckJpdHModGhpcy5jb21tb25CaXRzLDY0LSgxMit0aGlzLmNvbW1vbk1hbnRpc3NhQml0c0NvdW50KSkpKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9ci5sb25nQml0c1RvRG91YmxlKHQpLG49TG9uZy50b0JpbmFyeVN0cmluZyh0KSxpPVwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiK24scz1pLnN1YnN0cmluZyhpLmxlbmd0aC02NCksbz1zLnN1YnN0cmluZygwLDEpK1wiICBcIitzLnN1YnN0cmluZygxLDEyKStcIihleHApIFwiK3Muc3Vic3RyaW5nKDEyKStcIiBbIFwiK2UrXCIgXVwiO3JldHVybiBvfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ2V9fSksQ2UuZ2V0Qml0PWZ1bmN0aW9uKHQsZSl7dmFyIG49MTw8ZTtyZXR1cm4gMCE9PSh0Jm4pPzE6MH0sQ2Uuc2lnbkV4cEJpdHM9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+PjUyfSxDZS56ZXJvTG93ZXJCaXRzPWZ1bmN0aW9uKHQsZSl7dmFyIG49KDE8PGUpLTEsaT1+bixyPXQmaTtyZXR1cm4gcn0sQ2UubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLGk9NTI7aT49MDtpLS0pe2lmKENlLmdldEJpdCh0LGkpIT09Q2UuZ2V0Qml0KGUsaSkpcmV0dXJuIG47bisrfXJldHVybiA1Mn0sZShTZS5wcm90b3R5cGUse2FkZENvbW1vbkJpdHM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IExlKHRoaXMuY29tbW9uQ29vcmQpO3QuYXBwbHkoZSksdC5nZW9tZXRyeUNoYW5nZWQoKX0scmVtb3ZlQ29tbW9uQml0czpmdW5jdGlvbih0KXtpZigwPT09dGhpcy5jb21tb25Db29yZC54JiYwPT09dGhpcy5jb21tb25Db29yZC55KXJldHVybiB0O3ZhciBlPW5ldyBnKHRoaXMuY29tbW9uQ29vcmQpO2UueD0tZS54LGUueT0tZS55O3ZhciBuPW5ldyBMZShlKTtyZXR1cm4gdC5hcHBseShuKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpLHR9LGdldENvbW1vbkNvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21tb25Db29yZH0sYWRkOmZ1bmN0aW9uKHQpe3QuYXBwbHkodGhpcy5jY0ZpbHRlciksdGhpcy5jb21tb25Db29yZD10aGlzLmNjRmlsdGVyLmdldENvbW1vbkNvb3JkaW5hdGUoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU2V9fSksZSh3ZS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0aGlzLmNvbW1vbkJpdHNYLmFkZCh0LngpLHRoaXMuY29tbW9uQml0c1kuYWRkKHQueSl9LGdldENvbW1vbkNvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGcodGhpcy5jb21tb25CaXRzWC5nZXRDb21tb24oKSx0aGlzLmNvbW1vbkJpdHNZLmdldENvbW1vbigpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bel19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdlfX0pLGUoTGUucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldE9yZGluYXRlKGUsMCkrdGhpcy50cmFucy54LGk9dC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMudHJhbnMueTt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxpKX0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGlzR2VvbWV0cnlDaGFuZ2VkOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2N0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTGV9fSksU2UuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlcj13ZSxTZS5UcmFuc2xhdGVyPUxlLGUoUmUucHJvdG90eXBlLHtuZXh0OmZ1bmN0aW9uKCl7aWYodGhpcy5hdFN0YXJ0KXJldHVybiB0aGlzLmF0U3RhcnQ9ITEsUmUuaXNBdG9taWModGhpcy5wYXJlbnQpJiZ0aGlzLmluZGV4KyssdGhpcy5wYXJlbnQ7aWYobnVsbCE9PXRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuIHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKTt0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfWlmKHRoaXMuaW5kZXg+PXRoaXMubWF4KXRocm93IG5ldyB4O3ZhciB0PXRoaXMucGFyZW50LmdldEdlb21ldHJ5Tih0aGlzLmluZGV4KyspO3JldHVybiB0IGluc3RhbmNlb2YgZnQ/KHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW5ldyBSZSh0KSx0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCkpOnR9LHJlbW92ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKX0saGFzTmV4dDpmdW5jdGlvbigpe2lmKHRoaXMuYXRTdGFydClyZXR1cm4hMDtpZihudWxsIT09dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSlyZXR1cm4hMDt0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfXJldHVybiEodGhpcy5pbmRleD49dGhpcy5tYXgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltwXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUmV9fSksUmUuaXNBdG9taWM9ZnVuY3Rpb24odCl7cmV0dXJuISh0IGluc3RhbmNlb2YgZnQpfSxlKFRlLnByb3RvdHlwZSx7bG9jYXRlSW50ZXJuYWw6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVHQpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gTC5FWFRFUklPUjt2YXIgbj1lLmdldEV4dGVyaW9yUmluZygpLGk9dGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHQsbik7aWYoaT09PUwuRVhURVJJT1IpcmV0dXJuIEwuRVhURVJJT1I7aWYoaT09PUwuQk9VTkRBUlkpcmV0dXJuIEwuQk9VTkRBUlk7Zm9yKHZhciByPTA7cjxlLmdldE51bUludGVyaW9yUmluZygpO3IrKyl7dmFyIHM9ZS5nZXRJbnRlcmlvclJpbmdOKHIpLG89dGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHQscyk7aWYobz09PUwuSU5URVJJT1IpcmV0dXJuIEwuRVhURVJJT1I7aWYobz09PUwuQk9VTkRBUlkpcmV0dXJuIEwuQk9VTkRBUll9cmV0dXJuIEwuSU5URVJJT1J9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFN0KXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV07aWYoIXUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoYSkpcmV0dXJuIEwuRVhURVJJT1I7dmFyIGw9dS5nZXRDb29yZGluYXRlcygpO3JldHVybiB1LmlzQ2xvc2VkKCl8fCFhLmVxdWFscyhsWzBdKSYmIWEuZXF1YWxzKGxbbC5sZW5ndGgtMV0pP2hlLmlzT25MaW5lKGEsbCk/TC5JTlRFUklPUjpMLkVYVEVSSU9SOkwuQk9VTkRBUll9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEx0KXt2YXIgaD1hcmd1bWVudHNbMF0sYz1hcmd1bWVudHNbMV0sZj1jLmdldENvb3JkaW5hdGUoKTtyZXR1cm4gZi5lcXVhbHMyRChoKT9MLklOVEVSSU9SOkwuRVhURVJJT1J9fSxsb2NhdGVJblBvbHlnb25SaW5nOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/aGUubG9jYXRlUG9pbnRJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOkwuRVhURVJJT1J9LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5sb2NhdGUodCxlKSE9PUwuRVhURVJJT1J9LHVwZGF0ZUxvY2F0aW9uSW5mbzpmdW5jdGlvbih0KXt0PT09TC5JTlRFUklPUiYmKHRoaXMuaXNJbj0hMCksdD09PUwuQk9VTkRBUlkmJnRoaXMubnVtQm91bmRhcmllcysrfSxjb21wdXRlTG9jYXRpb246ZnVuY3Rpb24odCxlKXtpZihlIGluc3RhbmNlb2YgTHQmJnRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxlKSksZSBpbnN0YW5jZW9mIFN0KXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgVHQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbCh0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBndClmb3IodmFyIG49ZSxpPTA7aTxuLmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPW4uZ2V0R2VvbWV0cnlOKGkpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxyKSl9ZWxzZSBpZihlIGluc3RhbmNlb2YgT3QpZm9yKHZhciBzPWUsaT0wO2k8cy5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgbz1zLmdldEdlb21ldHJ5TihpKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsbykpfWVsc2UgaWYoZSBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgYT1uZXcgUmUoZSk7YS5oYXNOZXh0KCk7KXt2YXIgdT1hLm5leHQoKTt1IT09ZSYmdGhpcy5jb21wdXRlTG9jYXRpb24odCx1KX19LGxvY2F0ZTpmdW5jdGlvbih0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9MLkVYVEVSSU9SOmUgaW5zdGFuY2VvZiBTdD90aGlzLmxvY2F0ZUludGVybmFsKHQsZSk6ZSBpbnN0YW5jZW9mIFR0P3RoaXMubG9jYXRlSW50ZXJuYWwodCxlKToodGhpcy5pc0luPSExLHRoaXMubnVtQm91bmRhcmllcz0wLHRoaXMuY29tcHV0ZUxvY2F0aW9uKHQsZSksdGhpcy5ib3VuZGFyeVJ1bGUuaXNJbkJvdW5kYXJ5KHRoaXMubnVtQm91bmRhcmllcyk/TC5CT1VOREFSWTp0aGlzLm51bUJvdW5kYXJpZXM+MHx8dGhpcy5pc0luP0wuSU5URVJJT1I6TC5FWFRFUklPUil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRlfX0pLGUoUGUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQZX19KSxQZS5vY3RhbnQ9ZnVuY3Rpb24oKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBpKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7dmFyIG49TWF0aC5hYnModCkscj1NYXRoLmFicyhlKTtyZXR1cm4gdD49MD9lPj0wP24+PXI/MDoxOm4+PXI/Nzo2OmU+PTA/bj49cj8zOjI6bj49cj80OjV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPW8ueC1zLngsdT1vLnktcy55O2lmKDA9PT1hJiYwPT09dSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK3MpO3JldHVybiBQZS5vY3RhbnQoYSx1KX19LGUoYmUucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe30sc2l6ZTpmdW5jdGlvbigpe30sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXt9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7fSxzZXREYXRhOmZ1bmN0aW9uKHQpe30sZ2V0RGF0YTpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYmV9fSksZShPZS5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzfSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wdHNbdF19LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGgtMV0pfSxnZXRTZWdtZW50T2N0YW50OmZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5wdHMubGVuZ3RoLTE/LTE6UGUub2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcobmV3IEd0KHRoaXMucHRzKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2JlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT2V9fSksZShfZS5wcm90b3R5cGUse2dldEJvdW5kczpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX2V9fSksZShNZS5wcm90b3R5cGUse2dldEl0ZW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ib3VuZHN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW19lLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNZX19KSxlKERlLnByb3RvdHlwZSx7cG9sbDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciB0PXRoaXMuaXRlbXMuZ2V0KDEpO3JldHVybiB0aGlzLml0ZW1zLnNldCgxLHRoaXMuaXRlbXMuZ2V0KHRoaXMuX3NpemUpKSx0aGlzLl9zaXplLT0xLHRoaXMucmVvcmRlcigxKSx0fSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NpemV9LHJlb3JkZXI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj10aGlzLml0ZW1zLmdldCh0KTsyKnQ8PXRoaXMuX3NpemUmJihlPTIqdCxlIT09dGhpcy5fc2l6ZSYmdGhpcy5pdGVtcy5nZXQoZSsxKS5jb21wYXJlVG8odGhpcy5pdGVtcy5nZXQoZSkpPDAmJmUrKyx0aGlzLml0ZW1zLmdldChlKS5jb21wYXJlVG8obik8MCk7dD1lKXRoaXMuaXRlbXMuc2V0KHQsdGhpcy5pdGVtcy5nZXQoZSkpO3RoaXMuaXRlbXMuc2V0KHQsbil9LGNsZWFyOmZ1bmN0aW9uKCl7dGhpcy5fc2l6ZT0wLHRoaXMuaXRlbXMuY2xlYXIoKX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5fc2l6ZX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuaXRlbXMuYWRkKG51bGwpLHRoaXMuX3NpemUrPTE7dmFyIGU9dGhpcy5fc2l6ZTtmb3IodGhpcy5pdGVtcy5zZXQoMCx0KTt0LmNvbXBhcmVUbyh0aGlzLml0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTwwO2UvPTIpdGhpcy5pdGVtcy5zZXQoZSx0aGlzLml0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTt0aGlzLml0ZW1zLnNldChlLHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEZX19KSxlKEFlLnByb3RvdHlwZSx7dmlzaXRJdGVtOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQWV9fSksZShGZS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUpe30scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7fSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZlfX0pLGUoR2UucHJvdG90eXBlLHtnZXRMZXZlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxldmVsfSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hpbGRCb3VuZGFibGVzLnNpemUoKX0sZ2V0Q2hpbGRCb3VuZGFibGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hpbGRCb3VuZGFibGVzfSxhZGRDaGlsZEJvdW5kYWJsZTpmdW5jdGlvbih0KXtmLmlzVHJ1ZShudWxsPT09dGhpcy5ib3VuZHMpLHRoaXMuY2hpbGRCb3VuZGFibGVzLmFkZCh0KX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkQm91bmRhYmxlcy5pc0VtcHR5KCl9LGdldEJvdW5kczpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5ib3VuZHMmJih0aGlzLmJvdW5kcz10aGlzLmNvbXB1dGVCb3VuZHMoKSksdGhpcy5ib3VuZHN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW19lLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHZX19KSxHZS5zZXJpYWxWZXJzaW9uVUlEPTB4NWExZTU1ZWM0MTM2OTgwMDt2YXIgaG89e3JldmVyc2VPcmRlcjpmdW5jdGlvbigpe3JldHVybntjb21wYXJlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuY29tcGFyZVRvKHQpfX19LG1pbjpmdW5jdGlvbih0KXtyZXR1cm4gaG8uc29ydCh0KSx0LmdldCgwKX0sc29ydDpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9BcnJheSgpO2U/dXQuc29ydChuLGUpOnV0LnNvcnQobik7Zm9yKHZhciBpPXQuaXRlcmF0b3IoKSxyPTAscz1uLmxlbmd0aDtzPnI7cisrKWkubmV4dCgpLGkuc2V0KG5bcl0pfSxzaW5nbGV0b25MaXN0OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBJO3JldHVybiBlLmFkZCh0KSxlfX07ZShxZS5wcm90b3R5cGUse2V4cGFuZFRvUXVldWU6ZnVuY3Rpb24odCxlKXt2YXIgbj1xZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTEpLHI9cWUuaXNDb21wb3NpdGUodGhpcy5ib3VuZGFibGUyKTtpZihuJiZyKXJldHVybiBxZS5hcmVhKHRoaXMuYm91bmRhYmxlMSk+cWUuYXJlYSh0aGlzLmJvdW5kYWJsZTIpPyh0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTEsdGhpcy5ib3VuZGFibGUyLHQsZSksbnVsbCk6KHRoaXMuZXhwYW5kKHRoaXMuYm91bmRhYmxlMix0aGlzLmJvdW5kYWJsZTEsdCxlKSxudWxsKTtpZihuKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTEsdGhpcy5ib3VuZGFibGUyLHQsZSksbnVsbDtpZihyKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTIsdGhpcy5ib3VuZGFibGUxLHQsZSksbnVsbDt0aHJvdyBuZXcgaShcIm5laXRoZXIgYm91bmRhYmxlIGlzIGNvbXBvc2l0ZVwiKX0saXNMZWF2ZXM6ZnVuY3Rpb24oKXtyZXR1cm4hKHFlLmlzQ29tcG9zaXRlKHRoaXMuYm91bmRhYmxlMSl8fHFlLmlzQ29tcG9zaXRlKHRoaXMuYm91bmRhYmxlMikpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5fZGlzdGFuY2U8ZS5fZGlzdGFuY2U/LTE6dGhpcy5fZGlzdGFuY2U+ZS5fZGlzdGFuY2U/MTowfSxleHBhbmQ6ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkscz1yLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKSxhPW5ldyBxZShvLGUsdGhpcy5pdGVtRGlzdGFuY2UpO2EuZ2V0RGlzdGFuY2UoKTxpJiZuLmFkZChhKX19LGdldEJvdW5kYWJsZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQ/dGhpcy5ib3VuZGFibGUxOnRoaXMuYm91bmRhYmxlMn0sZ2V0RGlzdGFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2V9LGRpc3RhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNMZWF2ZXMoKT90aGlzLml0ZW1EaXN0YW5jZS5kaXN0YW5jZSh0aGlzLmJvdW5kYWJsZTEsdGhpcy5ib3VuZGFibGUyKTp0aGlzLmJvdW5kYWJsZTEuZ2V0Qm91bmRzKCkuZGlzdGFuY2UodGhpcy5ib3VuZGFibGUyLmdldEJvdW5kcygpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHFlfX0pLHFlLmFyZWE9ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpfSxxZS5pc0NvbXBvc2l0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEdlfSxlKEJlLnByb3RvdHlwZSx7Z2V0Tm9kZUNhcGFjaXR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZUNhcGFjaXR5fSxsYXN0Tm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXQodC5zaXplKCktMSl9LHNpemU6ZnVuY3Rpb24gdCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5zaXplKHRoaXMucm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLHQ9MCxuPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kgaW5zdGFuY2VvZiBHZT90Kz10aGlzLnNpemUoaSk6aSBpbnN0YW5jZW9mIE1lJiYodCs9MSl9cmV0dXJuIHR9fSxyZW1vdmVJdGVtOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW51bGwsaT10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyIGluc3RhbmNlb2YgTWUmJnIuZ2V0SXRlbSgpPT09ZSYmKG49cil9cmV0dXJuIG51bGwhPT1uPyh0LmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShuKSwhMCk6ITF9LGl0ZW1zVHJlZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLmJ1aWxkKCk7dmFyIHQ9dGhpcy5pdGVtc1RyZWUodGhpcy5yb290KTtyZXR1cm4gbnVsbD09PXQ/bmV3IEk6dH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPW5ldyBJLGk9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYociBpbnN0YW5jZW9mIEdlKXt2YXIgcz10aGlzLml0ZW1zVHJlZShyKTtudWxsIT09cyYmbi5hZGQocyl9ZWxzZSByIGluc3RhbmNlb2YgTWU/bi5hZGQoci5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbi5zaXplKCk8PTA/bnVsbDpufX0saW5zZXJ0OmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUoIXRoaXMuYnVpbHQsXCJDYW5ub3QgaW5zZXJ0IGl0ZW1zIGludG8gYW4gU1RSIHBhY2tlZCBSLXRyZWUgYWZ0ZXIgaXQgaGFzIGJlZW4gYnVpbHQuXCIpLHRoaXMuaXRlbUJvdW5kYWJsZXMuYWRkKG5ldyBNZSh0LGUpKX0sYm91bmRhYmxlc0F0TGV2ZWw6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEk7cmV0dXJuIHRoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCx0aGlzLnJvb3QsZSksZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO2lmKGYuaXNUcnVlKG4+LTIpLGkuZ2V0TGV2ZWwoKT09PW4pcmV0dXJuIHIuYWRkKGkpLG51bGw7Zm9yKHZhciBzPWkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpO28gaW5zdGFuY2VvZiBHZT90aGlzLmJvdW5kYWJsZXNBdExldmVsKG4sbyxyKTooZi5pc1RydWUobyBpbnN0YW5jZW9mIE1lKSwtMT09PW4mJnIuYWRkKG8pKX1yZXR1cm4gbnVsbH19LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmJ1aWxkKCk7dmFyIGU9bmV3IEk7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2U6KHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLnJvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnkodCx0aGlzLnJvb3QsZSksZSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtpZih0aGlzLmJ1aWxkKCksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMucm9vdC5nZXRCb3VuZHMoKSxuKSYmdGhpcy5xdWVyeShuLHRoaXMucm9vdCxpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLEFlKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2UpZm9yKHZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCksdT0wO3U8YS5zaXplKCk7dSsrKXt2YXIgbD1hLmdldCh1KTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMobC5nZXRCb3VuZHMoKSxyKSYmKGwgaW5zdGFuY2VvZiBHZT90aGlzLnF1ZXJ5KHIsbCxvKTpsIGluc3RhbmNlb2YgTWU/by52aXNpdEl0ZW0obC5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2UpZm9yKHZhciBoPWFyZ3VtZW50c1swXSxjPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxhPWMuZ2V0Q2hpbGRCb3VuZGFibGVzKCksdT0wO3U8YS5zaXplKCk7dSsrKXt2YXIgbD1hLmdldCh1KTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMobC5nZXRCb3VuZHMoKSxoKSYmKGwgaW5zdGFuY2VvZiBHZT90aGlzLnF1ZXJ5KGgsbCxnKTpsIGluc3RhbmNlb2YgTWU/Zy5hZGQobC5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fSxidWlsZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1aWx0P251bGw6KHRoaXMucm9vdD10aGlzLml0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKT90aGlzLmNyZWF0ZU5vZGUoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHModGhpcy5pdGVtQm91bmRhYmxlcywtMSksdGhpcy5pdGVtQm91bmRhYmxlcz1udWxsLHZvaWQodGhpcy5idWlsdD0hMCkpfSxnZXRSb290OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLnJvb3R9LHJlbW92ZTpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5yb290LmdldEJvdW5kcygpLHQpP3RoaXMucmVtb3ZlKHQsdGhpcy5yb290LGUpOiExfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl0scz10aGlzLnJlbW92ZUl0ZW0oaSxyKTtpZihzKXJldHVybiEwO2Zvcih2YXIgbz1udWxsLGE9aS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCk7aWYodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHUuZ2V0Qm91bmRzKCksbikmJnUgaW5zdGFuY2VvZiBHZSYmKHM9dGhpcy5yZW1vdmUobix1LHIpKSl7bz11O2JyZWFrfX1yZXR1cm4gbnVsbCE9PW8mJm8uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXNFbXB0eSgpJiZpLmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShvKSxzfX0sY3JlYXRlSGlnaGVyTGV2ZWxzOmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUoIXQuaXNFbXB0eSgpKTt2YXIgbj10aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKzEpO3JldHVybiAxPT09bi5zaXplKCk/bi5nZXQoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHMobixlKzEpfSxkZXB0aDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5kZXB0aCh0aGlzLnJvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTAsbj10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpIGluc3RhbmNlb2YgR2Upe3ZhciByPXRoaXMuZGVwdGgoaSk7cj5lJiYoZT1yKX19cmV0dXJuIGUrMX19LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO3ZhciBuPW5ldyBJO24uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSk7dmFyIGk9bmV3IEkodCk7aG8uc29ydChpLHRoaXMuZ2V0Q29tcGFyYXRvcigpKTtmb3IodmFyIHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7dGhpcy5sYXN0Tm9kZShuKS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5zaXplKCk9PT10aGlzLmdldE5vZGVDYXBhY2l0eSgpJiZuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpLHRoaXMubGFzdE5vZGUobikuYWRkQ2hpbGRCb3VuZGFibGUocyl9cmV0dXJuIG59LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWlsdD90aGlzLnJvb3QuaXNFbXB0eSgpOnRoaXMuaXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQmV9fSksQmUuY29tcGFyZURvdWJsZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lPzE6ZT50Py0xOjB9LEJlLkludGVyc2VjdHNPcD16ZSxCZS5zZXJpYWxWZXJzaW9uVUlEPS0weDM1ZWY2NGM4MmQ0YzU0MDAsQmUuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwLGUoVmUucHJvdG90eXBlLHtkaXN0YW5jZTpmdW5jdGlvbih0LGUpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVmV9fSksaChrZSxCZSksZShrZS5wcm90b3R5cGUse2NyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSh0Lmxlbmd0aD4wKTtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5sZW5ndGg7aSsrKW4uYWRkQWxsKHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHRbaV0sZSkpO3JldHVybiBufSxjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgWWUodCl9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/QmUucHJvdG90eXBlLnNpemUuY2FsbCh0aGlzKTpCZS5wcm90b3R5cGUuc2l6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGluc2VydDpmdW5jdGlvbigpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBCZS5wcm90b3R5cGUuaW5zZXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuaXNOdWxsKCk/bnVsbDp2b2lkIEJlLnByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLHQsZSl9LGdldEludGVyc2VjdHNPcDpmdW5jdGlvbigpe3JldHVybiBrZS5pbnRlcnNlY3RzT3B9LHZlcnRpY2FsU2xpY2VzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL2UpKSxpPW5ldyBBcnJheShlKS5maWxsKG51bGwpLHI9dC5pdGVyYXRvcigpLHM9MDtlPnM7cysrKXtpW3NdPW5ldyBJO2Zvcih2YXIgbz0wO3IuaGFzTmV4dCgpJiZuPm87KXt2YXIgYT1yLm5leHQoKTtpW3NdLmFkZChhKSxvKyt9fXJldHVybiBpfSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIEJlLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLGUsbil9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihSKGFyZ3VtZW50c1syXSxBZSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEdlKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07QmUucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcyxpLHIscyl9ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2Upe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXTtCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLG8sYSx1KX19LGdldENvbXBhcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4ga2UueUNvbXBhcmF0b3J9LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZTpmdW5jdGlvbih0LGUpe3JldHVybiBCZS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlcy5jYWxsKHRoaXMsdCxlKX0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gQmUucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gQmUucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGRlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP0JlLnByb3RvdHlwZS5kZXB0aC5jYWxsKHRoaXMpOkJlLnByb3RvdHlwZS5kZXB0aC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO3ZhciBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL3RoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkpKSxpPW5ldyBJKHQpO2hvLnNvcnQoaSxrZS54Q29tcGFyYXRvcik7dmFyIHI9dGhpcy52ZXJ0aWNhbFNsaWNlcyhpLE1hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGguc3FydChuKSkpKTtyZXR1cm4gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKHIsZSl9LG5lYXJlc3ROZWlnaGJvdXI6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sVmUpKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgcWUodGhpcy5nZXRSb290KCksdGhpcy5nZXRSb290KCksdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFlKXt2YXIgbj1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihuLHIuUE9TSVRJVkVfSU5GSU5JVFkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGtlJiZSKGFyZ3VtZW50c1sxXSxWZSkpe3ZhciBpPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxlPW5ldyBxZSh0aGlzLmdldFJvb3QoKSxpLmdldFJvb3QoKSxzKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcWUmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWEsbD1udWxsLGg9bmV3IERlO2ZvcihoLmFkZChvKTshaC5pc0VtcHR5KCkmJnU+MDspe3ZhciBjPWgucG9sbCgpLGY9Yy5nZXREaXN0YW5jZSgpO2lmKGY+PXUpYnJlYWs7Yy5pc0xlYXZlcygpPyh1PWYsbD1jKTpjLmV4cGFuZFRvUXVldWUoaCx1KX1yZXR1cm5bbC5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLGwuZ2V0Qm91bmRhYmxlKDEpLmdldEl0ZW0oKV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBnPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXSx2PW5ldyBNZShnLGQpLGU9bmV3IHFlKHRoaXMuZ2V0Um9vdCgpLHYscCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKVswXX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0ZlLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrZX19KSxrZS5jZW50cmVYPWZ1bmN0aW9uKHQpe3JldHVybiBrZS5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpfSxrZS5hdmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4odCtlKS8yfSxrZS5jZW50cmVZPWZ1bmN0aW9uKHQpe3JldHVybiBrZS5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpfSxoKFllLEdlKSxlKFllLnByb3RvdHlwZSx7Y29tcHV0ZUJvdW5kczpmdW5jdGlvbigpe2Zvcih2YXIgdD1udWxsLGU9dGhpcy5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bnVsbD09PXQ/dD1uZXcgQyhuLmdldEJvdW5kcygpKTp0LmV4cGFuZFRvSW5jbHVkZShuLmdldEJvdW5kcygpKX1yZXR1cm4gdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWWV9fSksa2UuU1RSdHJlZU5vZGU9WWUsa2Uuc2VyaWFsVmVyc2lvblVJRD0weDM5OTIwZjdkNWYyNjFlMCxrZS54Q29tcGFyYXRvcj17aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gQmUuY29tcGFyZURvdWJsZXMoa2UuY2VudHJlWCh0LmdldEJvdW5kcygpKSxrZS5jZW50cmVYKGUuZ2V0Qm91bmRzKCkpKX19LGtlLnlDb21wYXJhdG9yPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sY29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiBCZS5jb21wYXJlRG91YmxlcyhrZS5jZW50cmVZKHQuZ2V0Qm91bmRzKCkpLGtlLmNlbnRyZVkoZS5nZXRCb3VuZHMoKSkpfX0sa2UuaW50ZXJzZWN0c09wPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltJbnRlcnNlY3RzT3BdfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0cyhlKX19LGtlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMCxlKFVlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVWV9fSksVWUucmVsYXRpdmVTaWduPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU+dD8tMTp0PmU/MTowfSxVZS5jb21wYXJlPWZ1bmN0aW9uKHQsZSxuKXtpZihlLmVxdWFsczJEKG4pKXJldHVybiAwO3ZhciBpPVVlLnJlbGF0aXZlU2lnbihlLngsbi54KSxyPVVlLnJlbGF0aXZlU2lnbihlLnksbi55KTtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiBVZS5jb21wYXJlVmFsdWUoaSxyKTtjYXNlIDE6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZShyLGkpO2Nhc2UgMjpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKHIsLWkpO2Nhc2UgMzpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1pLHIpO2Nhc2UgNDpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1pLC1yKTtjYXNlIDU6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZSgtciwtaSk7Y2FzZSA2OnJldHVybiBVZS5jb21wYXJlVmFsdWUoLXIsaSk7Y2FzZSA3OnJldHVybiBVZS5jb21wYXJlVmFsdWUoaSwtcil9cmV0dXJuIGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJpbnZhbGlkIG9jdGFudCB2YWx1ZVwiKSwwfSxVZS5jb21wYXJlVmFsdWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD50Py0xOnQ+MD8xOjA+ZT8tMTplPjA/MTowfSxlKFhlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkfSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDxlLnNlZ21lbnRJbmRleD8tMTp0aGlzLnNlZ21lbnRJbmRleD5lLnNlZ21lbnRJbmRleD8xOnRoaXMuY29vcmQuZXF1YWxzMkQoZS5jb29yZCk/MDpVZS5jb21wYXJlKHRoaXMuc2VnbWVudE9jdGFudCx0aGlzLmNvb3JkLGUuY29vcmQpfSxpc0VuZFBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiAwIT09dGhpcy5zZWdtZW50SW5kZXh8fHRoaXMuX2lzSW50ZXJpb3I/dGhpcy5zZWdtZW50SW5kZXg9PT10OiEwfSxpc0ludGVyaW9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW50ZXJpb3J9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYZX19KSxlKEhlLnByb3RvdHlwZSx7Z2V0U3BsaXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBOO3RoaXMuYWRkRW5kcG9pbnRzKCk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKSxuPWUubmV4dCgpO2UuaGFzTmV4dCgpOyl7dmFyIGk9ZS5uZXh0KCk7dGhpcy5hZGRFZGdlQ29vcmRpbmF0ZXMobixpLHQpLG49aX1yZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfSxhZGRDb2xsYXBzZWROb2RlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3RoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpLHRoaXMuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpO2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKS5pbnRWYWx1ZSgpO3RoaXMuYWRkKHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKG4pLG4pfX0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxmaW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2Uuc2l6ZSgpLTI7ZSsrKXt2YXIgbj10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlKSxpPSh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlKzEpLHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUrMikpO24uZXF1YWxzMkQoaSkmJnQuYWRkKG5ldyBiKGUrMSkpfX0sYWRkRWRnZUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyLHI9dGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLHM9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHIpO3N8fGktLTtuLmFkZChuZXcgZyh0LmNvb3JkKSwhMSk7Zm9yKHZhciBvPXQuc2VnbWVudEluZGV4KzE7bzw9ZS5zZWdtZW50SW5kZXg7bysrKW4uYWRkKHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKG8pKTtzJiZuLmFkZChuZXcgZyhlLmNvb3JkKSl9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSxhZGRTcGxpdEVkZ2VzOmZ1bmN0aW9uKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCksdGhpcy5hZGRDb2xsYXBzZWROb2RlcygpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCksbj1lLm5leHQoKTtlLmhhc05leHQoKTspe3ZhciBpPWUubmV4dCgpLHI9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixpKTt0LmFkZChyKSxuPWl9fSxmaW5kQ29sbGFwc2VJbmRleDpmdW5jdGlvbih0LGUsbil7aWYoIXQuY29vcmQuZXF1YWxzMkQoZS5jb29yZCkpcmV0dXJuITE7dmFyIGk9ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXg7cmV0dXJuIGUuaXNJbnRlcmlvcigpfHxpLS0sMT09PWk/KG5bMF09dC5zZWdtZW50SW5kZXgrMSwhMCk6ITF9LGZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLml0ZXJhdG9yKCksaT1uLm5leHQoKTtuLmhhc05leHQoKTspe3ZhciByPW4ubmV4dCgpLHM9dGhpcy5maW5kQ29sbGFwc2VJbmRleChpLHIsZSk7cyYmdC5hZGQobmV3IGIoZVswXSkpLGk9cn19LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlfSxhZGRFbmRwb2ludHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVkZ2Uuc2l6ZSgpLTE7dGhpcy5hZGQodGhpcy5lZGdlLmdldENvb3JkaW5hdGUoMCksMCksdGhpcy5hZGQodGhpcy5lZGdlLmdldENvb3JkaW5hdGUodCksdCl9LGNyZWF0ZVNwbGl0RWRnZTpmdW5jdGlvbih0LGUpe3ZhciBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzIsaT10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlLnNlZ21lbnRJbmRleCkscj1lLmlzSW50ZXJpb3IoKXx8IWUuY29vcmQuZXF1YWxzMkQoaSk7cnx8bi0tO3ZhciBzPW5ldyBBcnJheShuKS5maWxsKG51bGwpLG89MDtzW28rK109bmV3IGcodC5jb29yZCk7Zm9yKHZhciBhPXQuc2VnbWVudEluZGV4KzE7YTw9ZS5zZWdtZW50SW5kZXg7YSsrKXNbbysrXT10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShhKTtyZXR1cm4gciYmKHNbb109bmV3IGcoZS5jb29yZCkpLG5ldyBLZShzLHRoaXMuZWRnZS5nZXREYXRhKCkpfSxhZGQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgWGUodGhpcy5lZGdlLHQsZSx0aGlzLmVkZ2UuZ2V0U2VnbWVudE9jdGFudChlKSksaT10aGlzLm5vZGVNYXAuZ2V0KG4pO3JldHVybiBudWxsIT09aT8oZi5pc1RydWUoaS5jb29yZC5lcXVhbHMyRCh0KSxcIkZvdW5kIGVxdWFsIG5vZGVzIHdpdGggZGlmZmVyZW50IGNvb3JkaW5hdGVzXCIpLGkpOih0aGlzLm5vZGVNYXAucHV0KG4sbiksbil9LGNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlcygpLG49dC5nZXQoMCksaT1uLmdldENvb3JkaW5hdGUoMCk7aWYoIWkuZXF1YWxzMkQoZVswXSkpdGhyb3cgbmV3IGwoXCJiYWQgc3BsaXQgZWRnZSBzdGFydCBwb2ludCBhdCBcIitpKTt2YXIgcj10LmdldCh0LnNpemUoKS0xKSxzPXIuZ2V0Q29vcmRpbmF0ZXMoKSxvPXNbcy5sZW5ndGgtMV07aWYoIW8uZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkpdGhyb3cgbmV3IGwoXCJiYWQgc3BsaXQgZWRnZSBlbmQgcG9pbnQgYXQgXCIrbyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhlfX0pLGUoV2UucHJvdG90eXBlLHtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmN1cnJOb2RlPyh0aGlzLmN1cnJOb2RlPXRoaXMubmV4dE5vZGUsdGhpcy5jdXJyU2VnSW5kZXg9dGhpcy5jdXJyTm9kZS5zZWdtZW50SW5kZXgsdGhpcy5yZWFkTmV4dE5vZGUoKSx0aGlzLmN1cnJOb2RlKTpudWxsPT09dGhpcy5uZXh0Tm9kZT9udWxsOnRoaXMubmV4dE5vZGUuc2VnbWVudEluZGV4PT09dGhpcy5jdXJyTm9kZS5zZWdtZW50SW5kZXg/KHRoaXMuY3Vyck5vZGU9dGhpcy5uZXh0Tm9kZSx0aGlzLmN1cnJTZWdJbmRleD10aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleCx0aGlzLnJlYWROZXh0Tm9kZSgpLHRoaXMuY3Vyck5vZGUpOih0aGlzLm5leHROb2RlLnNlZ21lbnRJbmRleD50aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleCxudWxsKX0scmVtb3ZlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfSxoYXNOZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLm5leHROb2RlfSxyZWFkTmV4dE5vZGU6ZnVuY3Rpb24oKXt0aGlzLm5vZGVJdC5oYXNOZXh0KCk/dGhpcy5uZXh0Tm9kZT10aGlzLm5vZGVJdC5uZXh0KCk6dGhpcy5uZXh0Tm9kZT1udWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltwXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV2V9fSksZShqZS5wcm90b3R5cGUse2FkZEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYmVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqZX19KSxlKEtlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHN9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RofSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnB0c1t0XX0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aC0xXSl9LGdldFNlZ21lbnRPY3RhbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLnB0cy5sZW5ndGgtMT8tMTp0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sc2FmZU9jdGFudDpmdW5jdGlvbih0LGUpe3JldHVybiB0LmVxdWFsczJEKGUpPzA6UGUub2N0YW50KHQsZSl9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxhZGRJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPShhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdKSxzPW5ldyBnKG4uZ2V0SW50ZXJzZWN0aW9uKHIpKTt0aGlzLmFkZEludGVyc2VjdGlvbihzLGkpfX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLnB0cykpfSxnZXROb2RlTGlzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVMaXN0fSxhZGRJbnRlcnNlY3Rpb25Ob2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSxpPW4rMTtpZihpPHRoaXMucHRzLmxlbmd0aCl7dmFyIHI9dGhpcy5wdHNbaV07dC5lcXVhbHMyRChyKSYmKG49aSl9dmFyIHM9dGhpcy5ub2RlTGlzdC5hZGQodCxuKTtyZXR1cm4gc30sYWRkSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LmdldEludGVyc2VjdGlvbk51bSgpO2krKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bamVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLZX19KSxLZS5nZXROb2RlZFN1YnN0cmluZ3M9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEk7cmV0dXJuIEtlLmdldE5vZGVkU3Vic3RyaW5ncyh0LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW4uaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO3MuZ2V0Tm9kZUxpc3QoKS5hZGRTcGxpdEVkZ2VzKGkpfX0sZShaZS5wcm90b3R5cGUse292ZXJsYXA6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dC5nZXRMaW5lU2VnbWVudChlLHRoaXMub3ZlcmxhcFNlZzEpLG4uZ2V0TGluZVNlZ21lbnQoaSx0aGlzLm92ZXJsYXBTZWcyKSx0aGlzLm92ZXJsYXAodGhpcy5vdmVybGFwU2VnMSx0aGlzLm92ZXJsYXBTZWcyKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFplfX0pLGUoUWUucHJvdG90eXBlLHtnZXRMaW5lU2VnbWVudDpmdW5jdGlvbih0LGUpe2UucDA9dGhpcy5wdHNbdF0sZS5wMT10aGlzLnB0c1t0KzFdfSxjb21wdXRlU2VsZWN0OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXRoaXMucHRzW2VdLHM9dGhpcy5wdHNbbl07aWYoaS50ZW1wRW52MS5pbml0KHIscyksbi1lPT09MSlyZXR1cm4gaS5zZWxlY3QodGhpcyxlKSxudWxsO2lmKCF0LmludGVyc2VjdHMoaS50ZW1wRW52MSkpcmV0dXJuIG51bGw7dmFyIG89TWF0aC50cnVuYygoZStuKS8yKTtcbm8+ZSYmdGhpcy5jb21wdXRlU2VsZWN0KHQsZSxvLGkpLG4+byYmdGhpcy5jb21wdXRlU2VsZWN0KHQsbyxuLGkpfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5lbmQtdGhpcy5zdGFydCsxKS5maWxsKG51bGwpLGU9MCxuPXRoaXMuc3RhcnQ7bjw9dGhpcy5lbmQ7bisrKXRbZSsrXT10aGlzLnB0c1tuXTtyZXR1cm4gdH0sY29tcHV0ZU92ZXJsYXBzOmZ1bmN0aW9uKHQsZSl7dGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0aGlzLnN0YXJ0LHRoaXMuZW5kLHQsdC5zdGFydCx0LmVuZCxlKX0sc2V0SWQ6ZnVuY3Rpb24odCl7dGhpcy5pZD10fSxzZWxlY3Q6ZnVuY3Rpb24odCxlKXt0aGlzLmNvbXB1dGVTZWxlY3QodCx0aGlzLnN0YXJ0LHRoaXMuZW5kLGUpfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmVudil7dmFyIHQ9dGhpcy5wdHNbdGhpcy5zdGFydF0sZT10aGlzLnB0c1t0aGlzLmVuZF07dGhpcy5lbnY9bmV3IEModCxlKX1yZXR1cm4gdGhpcy5lbnZ9LGdldEVuZEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kfSxnZXRTdGFydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnR9LGdldENvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZXh0fSxnZXRJZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkfSxjb21wdXRlT3ZlcmxhcHNJbnRlcm5hbDpmdW5jdGlvbih0LGUsbixpLHIscyl7dmFyIG89dGhpcy5wdHNbdF0sYT10aGlzLnB0c1tlXSx1PW4ucHRzW2ldLGw9bi5wdHNbcl07aWYoZS10PT09MSYmci1pPT09MSlyZXR1cm4gcy5vdmVybGFwKHRoaXMsdCxuLGkpLG51bGw7aWYocy50ZW1wRW52MS5pbml0KG8sYSkscy50ZW1wRW52Mi5pbml0KHUsbCksIXMudGVtcEVudjEuaW50ZXJzZWN0cyhzLnRlbXBFbnYyKSlyZXR1cm4gbnVsbDt2YXIgaD1NYXRoLnRydW5jKCh0K2UpLzIpLGM9TWF0aC50cnVuYygoaStyKS8yKTtoPnQmJihjPmkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwodCxoLG4saSxjLHMpLHI+YyYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0LGgsbixjLHIscykpLGU+aCYmKGM+aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbChoLGUsbixpLGMscykscj5jJiZ0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKGgsZSxuLGMscixzKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFFlfX0pLGUoSmUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBKZX19KSxKZS5pc05vcnRoZXJuPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09SmUuTkV8fHQ9PT1KZS5OV30sSmUuaXNPcHBvc2l0ZT1mdW5jdGlvbih0LGUpe2lmKHQ9PT1lKXJldHVybiExO3ZhciBuPSh0LWUrNCklNDtyZXR1cm4gMj09PW59LEplLmNvbW1vbkhhbGZQbGFuZT1mdW5jdGlvbih0LGUpe2lmKHQ9PT1lKXJldHVybiB0O3ZhciBuPSh0LWUrNCklNDtpZigyPT09bilyZXR1cm4tMTt2YXIgaT1lPnQ/dDplLHI9dD5lP3Q6ZTtyZXR1cm4gMD09PWkmJjM9PT1yPzM6aX0sSmUuaXNJbkhhbGZQbGFuZT1mdW5jdGlvbih0LGUpe3JldHVybiBlPT09SmUuU0U/dD09PUplLlNFfHx0PT09SmUuU1c6dD09PWV8fHQ9PT1lKzF9LEplLnF1YWRyYW50PWZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7cmV0dXJuIHQ+PTA/ZT49MD9KZS5ORTpKZS5TRTplPj0wP0plLk5XOkplLlNXfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgbj1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07aWYoci54PT09bi54JiZyLnk9PT1uLnkpdGhyb3cgbmV3IGkoXCJDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK24pO3JldHVybiByLng+PW4ueD9yLnk+PW4ueT9KZS5ORTpKZS5TRTpyLnk+PW4ueT9KZS5OVzpKZS5TV319LEplLk5FPTAsSmUuTlc9MSxKZS5TVz0yLEplLlNFPTMsZSgkZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRlfX0pLCRlLmdldENoYWluU3RhcnRJbmRpY2VzPWZ1bmN0aW9uKHQpe3ZhciBlPTAsbj1uZXcgSTtuLmFkZChuZXcgYihlKSk7ZG97dmFyIGk9JGUuZmluZENoYWluRW5kKHQsZSk7bi5hZGQobmV3IGIoaSkpLGU9aX13aGlsZShlPHQubGVuZ3RoLTEpO3ZhciByPSRlLnRvSW50QXJyYXkobik7cmV0dXJuIHJ9LCRlLmZpbmRDaGFpbkVuZD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lO248dC5sZW5ndGgtMSYmdFtuXS5lcXVhbHMyRCh0W24rMV0pOyluKys7aWYobj49dC5sZW5ndGgtMSlyZXR1cm4gdC5sZW5ndGgtMTtmb3IodmFyIGk9SmUucXVhZHJhbnQodFtuXSx0W24rMV0pLHI9ZSsxO3I8dC5sZW5ndGg7KXtpZighdFtyLTFdLmVxdWFsczJEKHRbcl0pKXt2YXIgcz1KZS5xdWFkcmFudCh0W3ItMV0sdFtyXSk7aWYocyE9PWkpYnJlYWt9cisrfXJldHVybiByLTF9LCRlLmdldENoYWlucz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuICRlLmdldENoYWlucyh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9bmV3IEkscj0kZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyhlKSxzPTA7czxyLmxlbmd0aC0xO3MrKyl7dmFyIG89bmV3IFFlKGUscltzXSxyW3MrMV0sbik7aS5hZGQobyl9cmV0dXJuIGl9fSwkZS50b0ludEFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX0sZSh0bi5wcm90b3R5cGUse2NvbXB1dGVOb2RlczpmdW5jdGlvbih0KXt9LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdG59fSksZShlbi5wcm90b3R5cGUse3NldFNlZ21lbnRJbnRlcnNlY3RvcjpmdW5jdGlvbih0KXt0aGlzLnNlZ0ludD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt0bl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVufX0pLGgobm4sZW4pLGUobm4ucHJvdG90eXBlLHtnZXRNb25vdG9uZUNoYWluczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vbm9DaGFpbnN9LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe3JldHVybiBLZS5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5ub2RlZFNlZ1N0cmluZ3MpfSxnZXRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluZGV4fSxhZGQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSRlLmdldENoYWlucyh0LmdldENvb3JkaW5hdGVzKCksdCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldElkKHRoaXMuaWRDb3VudGVyKyspLHRoaXMuaW5kZXguaW5zZXJ0KGkuZ2V0RW52ZWxvcGUoKSxpKSx0aGlzLm1vbm9DaGFpbnMuYWRkKGkpfX0sY29tcHV0ZU5vZGVzOmZ1bmN0aW9uKHQpe3RoaXMubm9kZWRTZWdTdHJpbmdzPXQ7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3RoaXMuaW50ZXJzZWN0Q2hhaW5zKCl9LGludGVyc2VjdENoYWluczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgcm4odGhpcy5zZWdJbnQpLGU9dGhpcy5tb25vQ2hhaW5zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPXRoaXMuaW5kZXgucXVlcnkobi5nZXRFbnZlbG9wZSgpKSxyPWkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKHMuZ2V0SWQoKT5uLmdldElkKCkmJihuLmNvbXB1dGVPdmVybGFwcyhzLHQpLHRoaXMubk92ZXJsYXBzKyspLHRoaXMuc2VnSW50LmlzRG9uZSgpKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbm59fSksaChybixaZSksZShybi5wcm90b3R5cGUse292ZXJsYXA6ZnVuY3Rpb24oKXtpZig0IT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gWmUucHJvdG90eXBlLm92ZXJsYXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXSxyPXQuZ2V0Q29udGV4dCgpLHM9bi5nZXRDb250ZXh0KCk7dGhpcy5zaS5wcm9jZXNzSW50ZXJzZWN0aW9ucyhyLGUscyxpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcm59fSksbm4uU2VnbWVudE92ZXJsYXBBY3Rpb249cm4saChzbixsKSxlKHNuLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzbn19KSxzbi5tc2dXaXRoQ29vcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9LGUob24ucHJvdG90eXBlLHtwcm9jZXNzSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXt9LGlzRG9uZTpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb259fSksZShhbi5wcm90b3R5cGUse2dldEludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb259LHNldENoZWNrRW5kU2VnbWVudHNPbmx5OmZ1bmN0aW9uKHQpe3RoaXMuaXNDaGVja0VuZFNlZ21lbnRzT25seT10fSxnZXRJbnRlcnNlY3Rpb25TZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludFNlZ21lbnRzfSxjb3VudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyc2VjdGlvbkNvdW50fSxnZXRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uc30sc2V0RmluZEFsbEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCl7dGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz10fSxzZXRLZWVwSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0KXt0aGlzLmtlZXBJbnRlcnNlY3Rpb25zPXR9LHByb2Nlc3NJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKCF0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zJiZ0aGlzLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiBudWxsO2lmKHQ9PT1uJiZlPT09aSlyZXR1cm4gbnVsbDtpZih0aGlzLmlzQ2hlY2tFbmRTZWdtZW50c09ubHkpe3ZhciByPXRoaXMuaXNFbmRTZWdtZW50KHQsZSl8fHRoaXMuaXNFbmRTZWdtZW50KG4saSk7aWYoIXIpcmV0dXJuIG51bGx9dmFyIHM9dC5nZXRDb29yZGluYXRlcygpW2VdLG89dC5nZXRDb29yZGluYXRlcygpW2UrMV0sYT1uLmdldENvb3JkaW5hdGVzKClbaV0sdT1uLmdldENvb3JkaW5hdGVzKClbaSsxXTt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocyxvLGEsdSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLmludFNlZ21lbnRzPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuaW50U2VnbWVudHNbMF09cyx0aGlzLmludFNlZ21lbnRzWzFdPW8sdGhpcy5pbnRTZWdtZW50c1syXT1hLHRoaXMuaW50U2VnbWVudHNbM109dSx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uPXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApLHRoaXMua2VlcEludGVyc2VjdGlvbnMmJnRoaXMuaW50ZXJzZWN0aW9ucy5hZGQodGhpcy5pbnRlcmlvckludGVyc2VjdGlvbiksdGhpcy5pbnRlcnNlY3Rpb25Db3VudCsrKX0saXNFbmRTZWdtZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIDA9PT1lPyEwOmU+PXQuc2l6ZSgpLTJ9LGhhc0ludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5pbnRlcmlvckludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmluZEFsbEludGVyc2VjdGlvbnM/ITE6bnVsbCE9PXRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb259LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29uXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYW59fSksYW4uY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgYW4odCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGV9LGFuLmNyZWF0ZUFueUludGVyc2VjdGlvbkZpbmRlcj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGFuKHQpfSxhbi5jcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBhbih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX0sZSh1bi5wcm90b3R5cGUse2V4ZWN1dGU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuc2VnSW50P251bGw6dm9pZCB0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9LGdldEludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbnQuZ2V0SW50ZXJzZWN0aW9ucygpfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0ZSgpLHRoaXMuX2lzVmFsaWR9LHNldEZpbmRBbGxJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQpe3RoaXMuZmluZEFsbEludGVyc2VjdGlvbnM9dH0sY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXt0aGlzLl9pc1ZhbGlkPSEwLHRoaXMuc2VnSW50PW5ldyBhbih0aGlzLmxpKSx0aGlzLnNlZ0ludC5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zKTt2YXIgdD1uZXcgbm47cmV0dXJuIHQuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuc2VnSW50KSx0LmNvbXB1dGVOb2Rlcyh0aGlzLnNlZ1N0cmluZ3MpLHRoaXMuc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpPyh0aGlzLl9pc1ZhbGlkPSExLG51bGwpOnZvaWQgMH0sY2hlY2tWYWxpZDpmdW5jdGlvbigpe2lmKHRoaXMuZXhlY3V0ZSgpLCF0aGlzLl9pc1ZhbGlkKXRocm93IG5ldyBzbih0aGlzLmdldEVycm9yTWVzc2FnZSgpLHRoaXMuc2VnSW50LmdldEludGVyaW9ySW50ZXJzZWN0aW9uKCkpfSxnZXRFcnJvck1lc3NhZ2U6ZnVuY3Rpb24oKXtpZih0aGlzLl9pc1ZhbGlkKXJldHVyblwibm8gaW50ZXJzZWN0aW9ucyBmb3VuZFwiO3ZhciB0PXRoaXMuc2VnSW50LmdldEludGVyc2VjdGlvblNlZ21lbnRzKCk7cmV0dXJuXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGJldHdlZW4gXCIrc2UudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSkrXCIgYW5kIFwiK3NlLnRvTGluZVN0cmluZyh0WzJdLHRbM10pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB1bn19KSx1bi5jb21wdXRlSW50ZXJzZWN0aW9ucz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgdW4odCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuaXNWYWxpZCgpLGUuZ2V0SW50ZXJzZWN0aW9ucygpfSxlKGxuLnByb3RvdHlwZSx7Y2hlY2tWYWxpZDpmdW5jdGlvbigpe3RoaXMubnYuY2hlY2tWYWxpZCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsbn19KSxsbi50b1NlZ21lbnRTdHJpbmdzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuYWRkKG5ldyBPZShpLmdldENvb3JkaW5hdGVzKCksaSkpfXJldHVybiBlfSxsbi5jaGVja1ZhbGlkPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBsbih0KTtlLmNoZWNrVmFsaWQoKX0sZShobi5wcm90b3R5cGUse21hcDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10aGlzLm1hcE9wLm1hcCh0LmdldEdlb21ldHJ5TihuKSk7aS5pc0VtcHR5KCl8fGUuYWRkKGkpfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KGUpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaG59fSksaG4ubWFwPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGhuKGUpO3JldHVybiBuLm1hcCh0KX0sZShjbi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNufX0pLGNuLm9wcG9zaXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09Y24uTEVGVD9jbi5SSUdIVDp0PT09Y24uUklHSFQ/Y24uTEVGVDp0fSxjbi5PTj0wLGNuLkxFRlQ9MSxjbi5SSUdIVD0yLGUoZm4ucHJvdG90eXBlLHtzZXRBbGxMb2NhdGlvbnM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10fSxpc051bGw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdIT09TC5OT05FKXJldHVybiExO3JldHVybiEwfSxzZXRBbGxMb2NhdGlvbnNJZk51bGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PUwuTk9ORSYmKHRoaXMubG9jYXRpb25bZV09dCl9LGlzTGluZTpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5sb2NhdGlvbi5sZW5ndGh9LG1lcmdlOmZ1bmN0aW9uKHQpe2lmKHQubG9jYXRpb24ubGVuZ3RoPnRoaXMubG9jYXRpb24ubGVuZ3RoKXt2YXIgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtlW2NuLk9OXT10aGlzLmxvY2F0aW9uW2NuLk9OXSxlW2NuLkxFRlRdPUwuTk9ORSxlW2NuLlJJR0hUXT1MLk5PTkUsdGhpcy5sb2NhdGlvbj1lfWZvcih2YXIgbj0wO248dGhpcy5sb2NhdGlvbi5sZW5ndGg7bisrKXRoaXMubG9jYXRpb25bbl09PT1MLk5PTkUmJm48dC5sb2NhdGlvbi5sZW5ndGgmJih0aGlzLmxvY2F0aW9uW25dPXQubG9jYXRpb25bbl0pfSxnZXRMb2NhdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb2NhdGlvbn0sZmxpcDpmdW5jdGlvbigpe2lmKHRoaXMubG9jYXRpb24ubGVuZ3RoPD0xKXJldHVybiBudWxsO3ZhciB0PXRoaXMubG9jYXRpb25bY24uTEVGVF07dGhpcy5sb2NhdGlvbltjbi5MRUZUXT10aGlzLmxvY2F0aW9uW2NuLlJJR0hUXSx0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXT10fSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChMLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltjbi5MRUZUXSkpLHQuYXBwZW5kKEwudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2NuLk9OXSkpLHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKEwudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXSkpLHQudG9TdHJpbmcoKX0sc2V0TG9jYXRpb25zOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLmxvY2F0aW9uW2NuLk9OXT10LHRoaXMubG9jYXRpb25bY24uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXT1ufSxnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8dGhpcy5sb2NhdGlvbi5sZW5ndGg/dGhpcy5sb2NhdGlvblt0XTpMLk5PTkV9LGlzQXJlYTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xfSxpc0FueU51bGw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdPT09TC5OT05FKXJldHVybiEwO3JldHVybiExfSxzZXRMb2NhdGlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRMb2NhdGlvbihjbi5PTix0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5sb2NhdGlvbltlXT1ufX0saW5pdDpmdW5jdGlvbih0KXt0aGlzLmxvY2F0aW9uPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuc2V0QWxsTG9jYXRpb25zKEwuTk9ORSl9LGlzRXF1YWxPblNpZGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5sb2NhdGlvbltlXT09PXQubG9jYXRpb25bZV19LGFsbFBvc2l0aW9uc0VxdWFsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKWlmKHRoaXMubG9jYXRpb25bZV0hPT10KXJldHVybiExO3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmbn19KSxlKGduLnByb3RvdHlwZSx7Z2V0R2VvbWV0cnlDb3VudDpmdW5jdGlvbigpe3ZhciB0PTA7cmV0dXJuIHRoaXMuZWx0WzBdLmlzTnVsbCgpfHx0KyssdGhpcy5lbHRbMV0uaXNOdWxsKCl8fHQrKyx0fSxzZXRBbGxMb2NhdGlvbnM6ZnVuY3Rpb24odCxlKXt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnMoZSl9LGlzTnVsbDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNOdWxsKCl9LHNldEFsbExvY2F0aW9uc0lmTnVsbDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0KSx0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFtlXS5zZXRBbGxMb2NhdGlvbnNJZk51bGwobil9fSxpc0xpbmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTGluZSgpfSxtZXJnZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDsyPmU7ZSsrKW51bGw9PT10aGlzLmVsdFtlXSYmbnVsbCE9PXQuZWx0W2VdP3RoaXMuZWx0W2VdPW5ldyBmbih0LmVsdFtlXSk6dGhpcy5lbHRbZV0ubWVyZ2UodC5lbHRbZV0pfSxmbGlwOmZ1bmN0aW9uKCl7dGhpcy5lbHRbMF0uZmxpcCgpLHRoaXMuZWx0WzFdLmZsaXAoKX0sZ2V0TG9jYXRpb246ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoY24uT04pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuZWx0W2VdLmdldChuKX19LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7cmV0dXJuIG51bGwhPT10aGlzLmVsdFswXSYmKHQuYXBwZW5kKFwiQTpcIiksdC5hcHBlbmQodGhpcy5lbHRbMF0udG9TdHJpbmcoKSkpLG51bGwhPT10aGlzLmVsdFsxXSYmKHQuYXBwZW5kKFwiIEI6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzFdLnRvU3RyaW5nKCkpKSx0LnRvU3RyaW5nKCl9LGlzQXJlYTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmVsdFswXS5pc0FyZWEoKXx8dGhpcy5lbHRbMV0uaXNBcmVhKCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBcmVhKCl9fSxpc0FueU51bGw6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzQW55TnVsbCgpfSxzZXRMb2NhdGlvbjpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oY24uT04sZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuZWx0W25dLnNldExvY2F0aW9uKGkscil9fSxpc0VxdWFsT25TaWRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZWx0WzBdLmlzRXF1YWxPblNpZGUodC5lbHRbMF0sZSkmJnRoaXMuZWx0WzFdLmlzRXF1YWxPblNpZGUodC5lbHRbMV0sZSl9LGFsbFBvc2l0aW9uc0VxdWFsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZWx0W3RdLmFsbFBvc2l0aW9uc0VxdWFsKGUpfSx0b0xpbmU6ZnVuY3Rpb24odCl7dGhpcy5lbHRbdF0uaXNBcmVhKCkmJih0aGlzLmVsdFt0XT1uZXcgZm4odGhpcy5lbHRbdF0ubG9jYXRpb25bMF0pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ259fSksZ24udG9MaW5lTGFiZWw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBnbihMLk5PTkUpLG49MDsyPm47bisrKWUuc2V0TG9jYXRpb24obix0LmdldExvY2F0aW9uKG4pKTtyZXR1cm4gZX0sZShkbi5wcm90b3R5cGUse2NvbXB1dGVSaW5nOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucmluZylyZXR1cm4gbnVsbDtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMucHRzLnNpemUoKSkuZmlsbChudWxsKSxlPTA7ZTx0aGlzLnB0cy5zaXplKCk7ZSsrKXRbZV09dGhpcy5wdHMuZ2V0KGUpO3RoaXMucmluZz10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpLHRoaXMuX2lzSG9sZT1oZS5pc0NDVyh0aGlzLnJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSl9LGlzSXNvbGF0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfSxjb21wdXRlUG9pbnRzOmZ1bmN0aW9uKHQpe3RoaXMuc3RhcnREZT10O3ZhciBlPXQsbj0hMDtkb3tpZihudWxsPT09ZSl0aHJvdyBuZXcgc24oXCJGb3VuZCBudWxsIERpcmVjdGVkRWRnZVwiKTtpZihlLmdldEVkZ2VSaW5nKCk9PT10aGlzKXRocm93IG5ldyBzbihcIkRpcmVjdGVkIEVkZ2UgdmlzaXRlZCB0d2ljZSBkdXJpbmcgcmluZy1idWlsZGluZyBhdCBcIitlLmdldENvb3JkaW5hdGUoKSk7dGhpcy5lZGdlcy5hZGQoZSk7dmFyIGk9ZS5nZXRMYWJlbCgpO2YuaXNUcnVlKGkuaXNBcmVhKCkpLHRoaXMubWVyZ2VMYWJlbChpKSx0aGlzLmFkZFBvaW50cyhlLmdldEVkZ2UoKSxlLmlzRm9yd2FyZCgpLG4pLG49ITEsdGhpcy5zZXRFZGdlUmluZyhlLHRoaXMpLGU9dGhpcy5nZXROZXh0KGUpfXdoaWxlKGUhPT10aGlzLnN0YXJ0RGUpfSxnZXRMaW5lYXJSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmluZ30sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wdHMuZ2V0KHQpfSxjb21wdXRlTWF4Tm9kZURlZ3JlZTpmdW5jdGlvbigpe3RoaXMubWF4Tm9kZURlZ3JlZT0wO3ZhciB0PXRoaXMuc3RhcnREZTtkb3t2YXIgZT10LmdldE5vZGUoKSxuPWUuZ2V0RWRnZXMoKS5nZXRPdXRnb2luZ0RlZ3JlZSh0aGlzKTtuPnRoaXMubWF4Tm9kZURlZ3JlZSYmKHRoaXMubWF4Tm9kZURlZ3JlZT1uKSx0PXRoaXMuZ2V0TmV4dCh0KX13aGlsZSh0IT09dGhpcy5zdGFydERlKTt0aGlzLm1heE5vZGVEZWdyZWUqPTJ9LGFkZFBvaW50czpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRDb29yZGluYXRlcygpO2lmKGUpe3ZhciByPTE7biYmKHI9MCk7Zm9yKHZhciBzPXI7czxpLmxlbmd0aDtzKyspdGhpcy5wdHMuYWRkKGlbc10pfWVsc2V7dmFyIHI9aS5sZW5ndGgtMjtuJiYocj1pLmxlbmd0aC0xKTtmb3IodmFyIHM9cjtzPj0wO3MtLSl0aGlzLnB0cy5hZGQoaVtzXSl9fSxpc0hvbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNIb2xlfSxzZXRJblJlc3VsdDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3RhcnREZTtkbyB0LmdldEVkZ2UoKS5zZXRJblJlc3VsdCghMCksdD10LmdldE5leHQoKTt3aGlsZSh0IT09dGhpcy5zdGFydERlKX0sY29udGFpbnNQb2ludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldExpbmVhclJpbmcoKSxuPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCFuLmNvbnRhaW5zKHQpKXJldHVybiExO2lmKCFoZS5pc1BvaW50SW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKSlyZXR1cm4hMTtmb3IodmFyIGk9dGhpcy5ob2xlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYoci5jb250YWluc1BvaW50KHQpKXJldHVybiExfXJldHVybiEwfSxhZGRIb2xlOmZ1bmN0aW9uKHQpe3RoaXMuaG9sZXMuYWRkKHQpfSxpc1NoZWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnNoZWxsfSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzfSxnZXRNYXhOb2RlRGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4Tm9kZURlZ3JlZTwwJiZ0aGlzLmNvbXB1dGVNYXhOb2RlRGVncmVlKCksdGhpcy5tYXhOb2RlRGVncmVlfSxnZXRTaGVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsfSxtZXJnZUxhYmVsOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodCwwKSx0aGlzLm1lcmdlTGFiZWwodCwxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1lLmdldExvY2F0aW9uKG4sY24uUklHSFQpO2lmKGk9PT1MLk5PTkUpcmV0dXJuIG51bGw7aWYodGhpcy5sYWJlbC5nZXRMb2NhdGlvbihuKT09PUwuTk9ORSlyZXR1cm4gdGhpcy5sYWJlbC5zZXRMb2NhdGlvbihuLGkpLG51bGx9fSxzZXRTaGVsbDpmdW5jdGlvbih0KXt0aGlzLnNoZWxsPXQsbnVsbCE9PXQmJnQuYWRkSG9sZSh0aGlzKX0sdG9Qb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodGhpcy5ob2xlcy5zaXplKCkpLmZpbGwobnVsbCksbj0wO248dGhpcy5ob2xlcy5zaXplKCk7bisrKWVbbl09dGhpcy5ob2xlcy5nZXQobikuZ2V0TGluZWFyUmluZygpO3ZhciBpPXQuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSxlKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZG59fSksaChwbixkbiksZShwbi5wcm90b3R5cGUse3NldEVkZ2VSaW5nOmZ1bmN0aW9uKHQsZSl7dC5zZXRNaW5FZGdlUmluZyhlKX0sZ2V0TmV4dDpmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXROZXh0TWluKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHBufX0pLGgodm4sZG4pLGUodm4ucHJvdG90eXBlLHtidWlsZE1pbmltYWxSaW5nczpmdW5jdGlvbigpe3ZhciB0PW5ldyBJLGU9dGhpcy5zdGFydERlO2Rve2lmKG51bGw9PT1lLmdldE1pbkVkZ2VSaW5nKCkpe3ZhciBuPW5ldyBwbihlLHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTt0LmFkZChuKX1lPWUuZ2V0TmV4dCgpfXdoaWxlKGUhPT10aGlzLnN0YXJ0RGUpO3JldHVybiB0fSxzZXRFZGdlUmluZzpmdW5jdGlvbih0LGUpe3Quc2V0RWRnZVJpbmcoZSl9LGxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5nczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3RhcnREZTtkb3t2YXIgZT10LmdldE5vZGUoKTtlLmdldEVkZ2VzKCkubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHRoaXMpLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuc3RhcnREZSl9LGdldE5leHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0TmV4dCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2bn19KSxlKG1uLnByb3RvdHlwZSx7c2V0VmlzaXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH0sc2V0SW5SZXN1bHQ6ZnVuY3Rpb24odCl7dGhpcy5faXNJblJlc3VsdD10fSxpc0NvdmVyZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkfSxpc0NvdmVyZWRTZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkU2V0fSxzZXRMYWJlbDpmdW5jdGlvbih0KXt0aGlzLmxhYmVsPXR9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LHNldENvdmVyZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNDb3ZlcmVkPXQsdGhpcy5faXNDb3ZlcmVkU2V0PSEwfSx1cGRhdGVJTTpmdW5jdGlvbih0KXtmLmlzVHJ1ZSh0aGlzLmxhYmVsLmdldEdlb21ldHJ5Q291bnQoKT49MixcImZvdW5kIHBhcnRpYWwgbGFiZWxcIiksdGhpcy5jb21wdXRlSU0odCl9LGlzSW5SZXN1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH0saXNWaXNpdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbW59fSksaCh5bixtbiksZSh5bi5wcm90b3R5cGUse2lzSW5jaWRlbnRFZGdlSW5SZXN1bHQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2lmKGUuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSlyZXR1cm4hMH1yZXR1cm4hMX0saXNJc29sYXRlZDpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZH0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwibm9kZSBcIit0aGlzLmNvb3JkK1wiIGxibDogXCIrdGhpcy5sYWJlbCl9LGNvbXB1dGVJTTpmdW5jdGlvbih0KXt9LGNvbXB1dGVNZXJnZWRMb2NhdGlvbjpmdW5jdGlvbih0LGUpe3ZhciBuPUwuTk9ORTtpZihuPXRoaXMubGFiZWwuZ2V0TG9jYXRpb24oZSksIXQuaXNOdWxsKGUpKXt2YXIgaT10LmdldExvY2F0aW9uKGUpO24hPT1MLkJPVU5EQVJZJiYobj1pKX1yZXR1cm4gbn0sc2V0TGFiZWw6ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbW4ucHJvdG90eXBlLnNldExhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMubGFiZWw/dGhpcy5sYWJlbD1uZXcgZ24odCxlKTp0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LG1lcmdlTGFiZWw6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHluKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQubGFiZWwpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnbilmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49MDsyPm47bisrKXt2YXIgaT10aGlzLmNvbXB1dGVNZXJnZWRMb2NhdGlvbihlLG4pLHI9dGhpcy5sYWJlbC5nZXRMb2NhdGlvbihuKTtyPT09TC5OT05FJiZ0aGlzLmxhYmVsLnNldExvY2F0aW9uKG4saSl9fSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5lZGdlcy5pbnNlcnQodCksdC5zZXROb2RlKHRoaXMpfSxzZXRMYWJlbEJvdW5kYXJ5OmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10aGlzLmxhYmVsKXJldHVybiBudWxsO3ZhciBlPUwuTk9ORTtudWxsIT09dGhpcy5sYWJlbCYmKGU9dGhpcy5sYWJlbC5nZXRMb2NhdGlvbih0KSk7dmFyIG49bnVsbDtzd2l0Y2goZSl7Y2FzZSBMLkJPVU5EQVJZOm49TC5JTlRFUklPUjticmVhaztjYXNlIEwuSU5URVJJT1I6bj1MLkJPVU5EQVJZO2JyZWFrO2RlZmF1bHQ6bj1MLkJPVU5EQVJZfXRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geW59fSksZSh4bi5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9LGFkZE5vZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMubm9kZU1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1lJiYoZT10aGlzLm5vZGVGYWN0LmNyZWF0ZU5vZGUodCksdGhpcy5ub2RlTWFwLnB1dCh0LGUpKSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeW4pe3ZhciBuPWFyZ3VtZW50c1swXSxlPXRoaXMubm9kZU1hcC5nZXQobi5nZXRDb29yZGluYXRlKCkpO3JldHVybiBudWxsPT09ZT8odGhpcy5ub2RlTWFwLnB1dChuLmdldENvb3JkaW5hdGUoKSxuKSxuKTooZS5tZXJnZUxhYmVsKG4pLGUpfX0scHJpbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0sdmFsdWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX0sZ2V0Qm91bmRhcnlOb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk9PT1MLkJPVU5EQVJZJiZlLmFkZChpKX1yZXR1cm4gZX0sYWRkOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZSgpLG49dGhpcy5hZGROb2RlKGUpO24uYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4bn19KSxlKEVuLnByb3RvdHlwZSx7Y29tcGFyZURpcmVjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5keD09PXQuZHgmJnRoaXMuZHk9PT10LmR5PzA6dGhpcy5xdWFkcmFudD50LnF1YWRyYW50PzE6dGhpcy5xdWFkcmFudDx0LnF1YWRyYW50Py0xOmhlLmNvbXB1dGVPcmllbnRhdGlvbih0LnAwLHQucDEsdGhpcy5wMSl9LGdldER5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMH0sc2V0Tm9kZTpmdW5jdGlvbih0KXt0aGlzLm5vZGU9dH0scHJpbnQ6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5hdGFuMih0aGlzLmR5LHRoaXMuZHgpLG49dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxpPW4ubGFzdEluZGV4T2YoXCIuXCIpLHI9bi5zdWJzdHJpbmcoaSsxKTt0LnByaW50KFwiICBcIityK1wiOiBcIit0aGlzLnAwK1wiIC0gXCIrdGhpcy5wMStcIiBcIit0aGlzLnF1YWRyYW50K1wiOlwiK2UrXCIgICBcIit0aGlzLmxhYmVsKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX0sZ2V0RGlyZWN0ZWRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDF9LGdldER4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHh9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlfSxnZXRRdWFkcmFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnF1YWRyYW50fSxnZXROb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1NYXRoLmF0YW4yKHRoaXMuZHksdGhpcy5keCksZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIiksaT1lLnN1YnN0cmluZyhuKzEpO3JldHVyblwiICBcIitpK1wiOiBcIit0aGlzLnAwK1wiIC0gXCIrdGhpcy5wMStcIiBcIit0aGlzLnF1YWRyYW50K1wiOlwiK3QrXCIgICBcIit0aGlzLmxhYmVsfSxjb21wdXRlTGFiZWw6ZnVuY3Rpb24odCl7fSxpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5wMD10LHRoaXMucDE9ZSx0aGlzLmR4PWUueC10LngsdGhpcy5keT1lLnktdC55LHRoaXMucXVhZHJhbnQ9SmUucXVhZHJhbnQodGhpcy5keCx0aGlzLmR5KSxmLmlzVHJ1ZSghKDA9PT10aGlzLmR4JiYwPT09dGhpcy5keSksXCJFZGdlRW5kIHdpdGggaWRlbnRpY2FsIGVuZHBvaW50cyBmb3VuZFwiKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVufX0pLGgoSW4sRW4pLGUoSW4ucHJvdG90eXBlLHtnZXROZXh0TWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dE1pbn0sZ2V0RGVwdGg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGVwdGhbdF19LHNldFZpc2l0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNWaXNpdGVkPXR9LGNvbXB1dGVEaXJlY3RlZExhYmVsOmZ1bmN0aW9uKCl7dGhpcy5sYWJlbD1uZXcgZ24odGhpcy5lZGdlLmdldExhYmVsKCkpLHRoaXMuX2lzRm9yd2FyZHx8dGhpcy5sYWJlbC5mbGlwKCl9LGdldE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0fSxzZXREZXB0aDpmdW5jdGlvbih0LGUpe2lmKC05OTkhPT10aGlzLmRlcHRoW3RdJiZ0aGlzLmRlcHRoW3RdIT09ZSl0aHJvdyBuZXcgc24oXCJhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3RoaXMuZGVwdGhbdF09ZX0saXNJbnRlcmlvckFyZWFFZGdlOmZ1bmN0aW9uIHQoKXtmb3IodmFyIHQ9ITAsZT0wOzI+ZTtlKyspdGhpcy5sYWJlbC5pc0FyZWEoZSkmJnRoaXMubGFiZWwuZ2V0TG9jYXRpb24oZSxjbi5MRUZUKT09PUwuSU5URVJJT1ImJnRoaXMubGFiZWwuZ2V0TG9jYXRpb24oZSxjbi5SSUdIVCk9PT1MLklOVEVSSU9SfHwodD0hMSk7cmV0dXJuIHR9LHNldE5leHRNaW46ZnVuY3Rpb24odCl7dGhpcy5uZXh0TWluPXR9LHByaW50OmZ1bmN0aW9uKHQpe0VuLnByb3RvdHlwZS5wcmludC5jYWxsKHRoaXMsdCksdC5wcmludChcIiBcIit0aGlzLmRlcHRoW2NuLkxFRlRdK1wiL1wiK3RoaXMuZGVwdGhbY24uUklHSFRdKSx0LnByaW50KFwiIChcIit0aGlzLmdldERlcHRoRGVsdGEoKStcIilcIiksdGhpcy5faXNJblJlc3VsdCYmdC5wcmludChcIiBpblJlc3VsdFwiKX0sc2V0TWluRWRnZVJpbmc6ZnVuY3Rpb24odCl7dGhpcy5taW5FZGdlUmluZz10fSxpc0xpbmVFZGdlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sYWJlbC5pc0xpbmUoMCl8fHRoaXMubGFiZWwuaXNMaW5lKDEpLGU9IXRoaXMubGFiZWwuaXNBcmVhKDApfHx0aGlzLmxhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDAsTC5FWFRFUklPUiksbj0hdGhpcy5sYWJlbC5pc0FyZWEoMSl8fHRoaXMubGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMSxMLkVYVEVSSU9SKTtyZXR1cm4gdCYmZSYmbn0sc2V0RWRnZVJpbmc6ZnVuY3Rpb24odCl7dGhpcy5lZGdlUmluZz10fSxnZXRNaW5FZGdlUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbkVkZ2VSaW5nfSxnZXREZXB0aERlbHRhOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lZGdlLmdldERlcHRoRGVsdGEoKTtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfHwodD0tdCksdH0sc2V0SW5SZXN1bHQ6ZnVuY3Rpb24odCl7dGhpcy5faXNJblJlc3VsdD10fSxnZXRTeW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW19LGlzRm9yd2FyZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0ZvcndhcmR9LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlfSxwcmludEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5wcmludCh0KSx0LnByaW50KFwiIFwiKSx0aGlzLl9pc0ZvcndhcmQ/dGhpcy5lZGdlLnByaW50KHQpOnRoaXMuZWRnZS5wcmludFJldmVyc2UodCl9LHNldFN5bTpmdW5jdGlvbih0KXt0aGlzLnN5bT10fSxzZXRWaXNpdGVkRWRnZTpmdW5jdGlvbih0KXt0aGlzLnNldFZpc2l0ZWQodCksdGhpcy5zeW0uc2V0VmlzaXRlZCh0KX0sc2V0RWRnZURlcHRoczpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0RWRnZSgpLmdldERlcHRoRGVsdGEoKTt0aGlzLl9pc0ZvcndhcmR8fChuPS1uKTt2YXIgaT0xO3Q9PT1jbi5MRUZUJiYoaT0tMSk7dmFyIHI9Y24ub3Bwb3NpdGUodCkscz1uKmksbz1lK3M7dGhpcy5zZXREZXB0aCh0LGUpLHRoaXMuc2V0RGVwdGgocixvKX0sZ2V0RWRnZVJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlUmluZ30saXNJblJlc3VsdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fSxzZXROZXh0OmZ1bmN0aW9uKHQpe3RoaXMubmV4dD10fSxpc1Zpc2l0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBJbn19KSxJbi5kZXB0aEZhY3Rvcj1mdW5jdGlvbih0LGUpe3JldHVybiB0PT09TC5FWFRFUklPUiYmZT09PUwuSU5URVJJT1I/MTp0PT09TC5JTlRFUklPUiYmZT09PUwuRVhURVJJT1I/LTE6MH0sZShObi5wcm90b3R5cGUse2NyZWF0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB5bih0LG51bGwpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBObn19KSxlKENuLnByb3RvdHlwZSx7cHJpbnRFZGdlczpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJFZGdlczpcIik7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2VzLnNpemUoKTtlKyspe3QucHJpbnRsbihcImVkZ2UgXCIrZStcIjpcIik7dmFyIG49dGhpcy5lZGdlcy5nZXQoZSk7bi5wcmludCh0KSxuLmVpTGlzdC5wcmludCh0KX19LGZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZXMuZmluZCh0KX0sYWRkTm9kZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeW4pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5ub2Rlcy5hZGROb2RlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLm5vZGVzLmFkZE5vZGUoZSl9fSxnZXROb2RlSXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlcy5pdGVyYXRvcigpfSxsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19LGRlYnVnUHJpbnRsbjpmdW5jdGlvbih0KXtBLm91dC5wcmludGxuKHQpfSxpc0JvdW5kYXJ5Tm9kZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubm9kZXMuZmluZChlKTtpZihudWxsPT09bilyZXR1cm4hMTt2YXIgaT1uLmdldExhYmVsKCk7cmV0dXJuIG51bGwhPT1pJiZpLmdldExvY2F0aW9uKHQpPT09TC5CT1VOREFSWX0sbGlua0FsbERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl9fSxtYXRjaEluU2FtZURpcmVjdGlvbjpmdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gdC5lcXVhbHMobik/aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQsZSxpKT09PWhlLkNPTExJTkVBUiYmSmUucXVhZHJhbnQodCxlKT09PUplLnF1YWRyYW50KG4saSk6ITF9LGdldEVkZ2VFbmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZUVuZExpc3R9LGRlYnVnUHJpbnQ6ZnVuY3Rpb24odCl7QS5vdXQucHJpbnQodCl9LGdldEVkZ2VJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzLml0ZXJhdG9yKCl9LGZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0aGlzLmVkZ2VzLnNpemUoKTtuKyspe3ZhciBpPXRoaXMuZWRnZXMuZ2V0KG4pLHI9aS5nZXRDb29yZGluYXRlcygpO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLHJbMF0sclsxXSkpcmV0dXJuIGk7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUscltyLmxlbmd0aC0xXSxyW3IubGVuZ3RoLTJdKSlyZXR1cm4gaX1yZXR1cm4gbnVsbH0saW5zZXJ0RWRnZTpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLmFkZCh0KX0sZmluZEVkZ2VFbmQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYobi5nZXRFZGdlKCk9PT10KXJldHVybiBufXJldHVybiBudWxsfSxhZGRFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5lZGdlcy5hZGQobik7dmFyIGk9bmV3IEluKG4sITApLHI9bmV3IEluKG4sITEpO2kuc2V0U3ltKHIpLHIuc2V0U3ltKGkpLHRoaXMuYWRkKGkpLHRoaXMuYWRkKHIpfX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMubm9kZXMuYWRkKHQpLHRoaXMuZWRnZUVuZExpc3QuYWRkKHQpfSxnZXROb2RlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzLnZhbHVlcygpfSxmaW5kRWRnZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5lZGdlcy5zaXplKCk7bisrKXt2YXIgaT10aGlzLmVkZ2VzLmdldChuKSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0LmVxdWFscyhyWzBdKSYmZS5lcXVhbHMoclsxXSkpcmV0dXJuIGl9cmV0dXJuIG51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENufX0pLENuLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19LGUoU24ucHJvdG90eXBlLHtzb3J0U2hlbGxzQW5kSG9sZXM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmlzSG9sZSgpP24uYWRkKHIpOmUuYWRkKHIpfX0sY29tcHV0ZVBvbHlnb25zOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS50b1BvbHlnb24odGhpcy5nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKHIpfXJldHVybiBlfSxwbGFjZUZyZWVIb2xlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihudWxsPT09aS5nZXRTaGVsbCgpKXt2YXIgcj10aGlzLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoaSx0KTtpZihudWxsPT09cil0aHJvdyBuZXcgc24oXCJ1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbFwiLGkuZ2V0Q29vcmRpbmF0ZSgwKSk7aS5zZXRTaGVsbChyKX19fSxidWlsZE1pbmltYWxFZGdlUmluZ3M6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1uZXcgSSxyPXQuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKHMuZ2V0TWF4Tm9kZURlZ3JlZSgpPjIpe3MubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7dmFyIG89cy5idWlsZE1pbmltYWxSaW5ncygpLGE9dGhpcy5maW5kU2hlbGwobyk7bnVsbCE9PWE/KHRoaXMucGxhY2VQb2x5Z29uSG9sZXMoYSxvKSxlLmFkZChhKSk6bi5hZGRBbGwobyl9ZWxzZSBpLmFkZChzKX1yZXR1cm4gaX0sY29udGFpbnNQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5zaGVsbExpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKG4uY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMH1yZXR1cm4hMX0sYnVpbGRNYXhpbWFsRWRnZVJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuaXNJblJlc3VsdCgpJiZpLmdldExhYmVsKCkuaXNBcmVhKCkmJm51bGw9PT1pLmdldEVkZ2VSaW5nKCkpe3ZhciByPW5ldyB2bihpLHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZChyKSxyLnNldEluUmVzdWx0KCl9fXJldHVybiBlfSxwbGFjZVBvbHlnb25Ib2xlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmlzSG9sZSgpJiZpLnNldFNoZWxsKHQpfX0sZ2V0UG9seWdvbnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvbXB1dGVQb2x5Z29ucyh0aGlzLnNoZWxsTGlzdCk7cmV0dXJuIHR9LGZpbmRFZGdlUmluZ0NvbnRhaW5pbmc6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRMaW5lYXJSaW5nKCksaT1uLmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscz1udWxsLG89bnVsbCxhPWUuaXRlcmF0b3IoKTthLmhhc05leHQoKTspe3ZhciB1PWEubmV4dCgpLGw9dS5nZXRMaW5lYXJSaW5nKCksaD1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtudWxsIT09cyYmKG89cy5nZXRMaW5lYXJSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTt2YXIgYz0hMTtoLmNvbnRhaW5zKGkpJiZoZS5pc1BvaW50SW5SaW5nKHIsbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09c3x8by5jb250YWlucyhoKSkmJihzPXUpfXJldHVybiBzfSxmaW5kU2hlbGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj1udWxsLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc0hvbGUoKXx8KG49cixlKyspfXJldHVybiBmLmlzVHJ1ZSgxPj1lLFwiZm91bmQgdHdvIHNoZWxscyBpbiBNaW5pbWFsRWRnZVJpbmcgbGlzdFwiKSxufSxhZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQuZ2V0RWRnZUVuZHMoKSx0LmdldE5vZGVzKCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtDbi5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyhuKTt2YXIgaT10aGlzLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyhlKSxyPW5ldyBJLHM9dGhpcy5idWlsZE1pbmltYWxFZGdlUmluZ3MoaSx0aGlzLnNoZWxsTGlzdCxyKTt0aGlzLnNvcnRTaGVsbHNBbmRIb2xlcyhzLHRoaXMuc2hlbGxMaXN0LHIpLHRoaXMucGxhY2VGcmVlSG9sZXModGhpcy5zaGVsbExpc3Qscil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTbn19KSxlKHduLnByb3RvdHlwZSx7Y29sbGVjdExpbmVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLm9wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5jb2xsZWN0TGluZUVkZ2Uobix0LHRoaXMubGluZUVkZ2VzTGlzdCksdGhpcy5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2Uobix0LHRoaXMubGluZUVkZ2VzTGlzdCl9fSxsYWJlbElzb2xhdGVkTGluZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLm9wLmdldEFyZ0dlb21ldHJ5KGUpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX0sYnVpbGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmluZENvdmVyZWRMaW5lRWRnZXMoKSx0aGlzLmNvbGxlY3RMaW5lcyh0KSx0aGlzLmJ1aWxkTGluZXModCksdGhpcy5yZXN1bHRMaW5lTGlzdH0sY29sbGVjdExpbmVFZGdlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldExhYmVsKCkscj10LmdldEVkZ2UoKTt0LmlzTGluZUVkZ2UoKSYmKHQuaXNWaXNpdGVkKCl8fCFpaS5pc1Jlc3VsdE9mT3AoaSxlKXx8ci5pc0NvdmVyZWQoKXx8KG4uYWRkKHIpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSl9LGZpbmRDb3ZlcmVkTGluZUVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMub3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkuZmluZENvdmVyZWRMaW5lRWRnZXMoKX1mb3IodmFyIG49dGhpcy5vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRFZGdlKCk7aWYoaS5pc0xpbmVFZGdlKCkmJiFyLmlzQ292ZXJlZFNldCgpKXt2YXIgcz10aGlzLm9wLmlzQ292ZXJlZEJ5QShpLmdldENvb3JkaW5hdGUoKSk7ci5zZXRDb3ZlcmVkKHMpfX19LGxhYmVsSXNvbGF0ZWRMaW5lczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7bi5pc0lzb2xhdGVkKCkmJihpLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKG4sMCk6dGhpcy5sYWJlbElzb2xhdGVkTGluZShuLDEpKX19LGJ1aWxkTGluZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMubGluZUVkZ2VzTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT0obi5nZXRMYWJlbCgpLHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobi5nZXRDb29yZGluYXRlcygpKSk7dGhpcy5yZXN1bHRMaW5lTGlzdC5hZGQoaSksbi5zZXRJblJlc3VsdCghMCl9fSxjb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2U6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0TGFiZWwoKTtyZXR1cm4gdC5pc0xpbmVFZGdlKCk/bnVsbDp0LmlzVmlzaXRlZCgpP251bGw6dC5pc0ludGVyaW9yQXJlYUVkZ2UoKT9udWxsOnQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKT9udWxsOihmLmlzVHJ1ZSghKHQuaXNJblJlc3VsdCgpfHx0LmdldFN5bSgpLmlzSW5SZXN1bHQoKSl8fCF0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpLHZvaWQoaWkuaXNSZXN1bHRPZk9wKGksZSkmJmU9PT1paS5JTlRFUlNFQ1RJT04mJihuLmFkZCh0LmdldEVkZ2UoKSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdufX0pLGUoTG4ucHJvdG90eXBlLHtmaWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRDb29yZGluYXRlKCk7aWYoIXRoaXMub3AuaXNDb3ZlcmVkQnlMQShlKSl7dmFyIG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSk7dGhpcy5yZXN1bHRQb2ludExpc3QuYWRkKG4pfX0sZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKCEobi5pc0luUmVzdWx0KCl8fG4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpfHwwIT09bi5nZXRFZGdlcygpLmdldERlZ3JlZSgpJiZ0IT09aWkuSU5URVJTRUNUSU9OKSl7dmFyIGk9bi5nZXRMYWJlbCgpO2lpLmlzUmVzdWx0T2ZPcChpLHQpJiZ0aGlzLmZpbHRlckNvdmVyZWROb2RlVG9Qb2ludChuKX19fSxidWlsZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpLHRoaXMucmVzdWx0UG9pbnRMaXN0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMbn19KSxlKFJuLnByb3RvdHlwZSx7bG9jYXRlOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUm59fSksZShUbi5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXtyZXR1cm4gVG4ubG9jYXRlKHQsdGhpcy5nZW9tKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bUm5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUbn19KSxUbi5pc1BvaW50SW5SaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/aGUuaXNQb2ludEluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSk6ITF9LFRuLmNvbnRhaW5zUG9pbnRJblBvbHlnb249ZnVuY3Rpb24odCxlKXtpZihlLmlzRW1wdHkoKSlyZXR1cm4hMTt2YXIgbj1lLmdldEV4dGVyaW9yUmluZygpO2lmKCFUbi5pc1BvaW50SW5SaW5nKHQsbikpcmV0dXJuITE7Zm9yKHZhciBpPTA7aTxlLmdldE51bUludGVyaW9yUmluZygpO2krKyl7dmFyIHI9ZS5nZXRJbnRlcmlvclJpbmdOKGkpO2lmKFRuLmlzUG9pbnRJblJpbmcodCxyKSlyZXR1cm4hMX1yZXR1cm4hMH0sVG4uY29udGFpbnNQb2ludD1mdW5jdGlvbih0LGUpe2lmKGUgaW5zdGFuY2VvZiBUdClyZXR1cm4gVG4uY29udGFpbnNQb2ludEluUG9seWdvbih0LGUpO2lmKGUgaW5zdGFuY2VvZiBmdClmb3IodmFyIG49bmV3IFJlKGUpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaSE9PWUmJlRuLmNvbnRhaW5zUG9pbnQodCxpKSlyZXR1cm4hMH1yZXR1cm4hMX0sVG4ubG9jYXRlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP0wuRVhURVJJT1I6VG4uY29udGFpbnNQb2ludCh0LGUpP0wuSU5URVJJT1I6TC5FWFRFUklPUn0sZShQbi5wcm90b3R5cGUse2dldE5leHRDVzpmdW5jdGlvbih0KXt0aGlzLmdldEVkZ2VzKCk7dmFyIGU9dGhpcy5lZGdlTGlzdC5pbmRleE9mKHQpLG49ZS0xO3JldHVybiAwPT09ZSYmKG49dGhpcy5lZGdlTGlzdC5zaXplKCktMSksdGhpcy5lZGdlTGlzdC5nZXQobil9LHByb3BhZ2F0ZVNpZGVMYWJlbHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPUwuTk9ORSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpO3IuaXNBcmVhKHQpJiZyLmdldExvY2F0aW9uKHQsY24uTEVGVCkhPT1MLk5PTkUmJihlPXIuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSl9aWYoZT09PUwuTk9ORSlyZXR1cm4gbnVsbDtmb3IodmFyIHM9ZSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpO2lmKHIuZ2V0TG9jYXRpb24odCxjbi5PTik9PT1MLk5PTkUmJnIuc2V0TG9jYXRpb24odCxjbi5PTixzKSxyLmlzQXJlYSh0KSl7dmFyIG89ci5nZXRMb2NhdGlvbih0LGNuLkxFRlQpLGE9ci5nZXRMb2NhdGlvbih0LGNuLlJJR0hUKTtpZihhIT09TC5OT05FKXtpZihhIT09cyl0aHJvdyBuZXcgc24oXCJzaWRlIGxvY2F0aW9uIGNvbmZsaWN0XCIsaS5nZXRDb29yZGluYXRlKCkpO289PT1MLk5PTkUmJmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlIChhdCBcIitpLmdldENvb3JkaW5hdGUoKStcIilcIikscz1vfWVsc2UgZi5pc1RydWUoci5nZXRMb2NhdGlvbih0LGNuLkxFRlQpPT09TC5OT05FLFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZVwiKSxyLnNldExvY2F0aW9uKHQsY24uUklHSFQscyksci5zZXRMb2NhdGlvbih0LGNuLkxFRlQscyl9fX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dmFyIGU9dC5uZXh0KCk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpfSxwcmludDpmdW5jdGlvbih0KXtBLm91dC5wcmludGxuKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpfX0saXNBcmVhTGFiZWxzQ29uc2lzdGVudDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0LmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KDApfSxjaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0RWRnZXMoKTtpZihlLnNpemUoKTw9MClyZXR1cm4hMDt2YXIgbj1lLnNpemUoKS0xLGk9ZS5nZXQobikuZ2V0TGFiZWwoKSxyPWkuZ2V0TG9jYXRpb24odCxjbi5MRUZUKTtmLmlzVHJ1ZShyIT09TC5OT05FLFwiRm91bmQgdW5sYWJlbGxlZCBhcmVhIGVkZ2VcIik7Zm9yKHZhciBzPXIsbz10aGlzLml0ZXJhdG9yKCk7by5oYXNOZXh0KCk7KXt2YXIgYT1vLm5leHQoKSx1PWEuZ2V0TGFiZWwoKTtcbmYuaXNUcnVlKHUuaXNBcmVhKHQpLFwiRm91bmQgbm9uLWFyZWEgZWRnZVwiKTt2YXIgbD11LmdldExvY2F0aW9uKHQsY24uTEVGVCksaD11LmdldExvY2F0aW9uKHQsY24uUklHSFQpO2lmKGw9PT1oKXJldHVybiExO2lmKGghPT1zKXJldHVybiExO3M9bH1yZXR1cm4hMH0sZmluZEluZGV4OmZ1bmN0aW9uKHQpe3RoaXMuaXRlcmF0b3IoKTtmb3IodmFyIGU9MDtlPHRoaXMuZWRnZUxpc3Quc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5lZGdlTGlzdC5nZXQoZSk7aWYobj09PXQpcmV0dXJuIGV9cmV0dXJuLTF9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoKS5pdGVyYXRvcigpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5lZGdlTGlzdCYmKHRoaXMuZWRnZUxpc3Q9bmV3IEkodGhpcy5lZGdlTWFwLnZhbHVlcygpKSksdGhpcy5lZGdlTGlzdH0sZ2V0TG9jYXRpb246ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLnB0SW5BcmVhTG9jYXRpb25bdF09PT1MLk5PTkUmJih0aGlzLnB0SW5BcmVhTG9jYXRpb25bdF09VG4ubG9jYXRlKGUsblt0XS5nZXRHZW9tZXRyeSgpKSksdGhpcy5wdEluQXJlYUxvY2F0aW9uW3RdfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3QuYXBwZW5kKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpLHQuYXBwZW5kKFwiXFxuXCIpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0LmFwcGVuZChuKSx0LmFwcGVuZChcIlxcblwiKX1yZXR1cm4gdC50b1N0cmluZygpfSxjb21wdXRlRWRnZUVuZExhYmVsczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5jb21wdXRlTGFiZWwodCl9fSxjb21wdXRlTGFiZWxsaW5nOmZ1bmN0aW9uKHQpe3RoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModFswXS5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygwKSx0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMSk7Zm9yKHZhciBlPVshMSwhMV0sbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWZvcih2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKSxzPTA7Mj5zO3MrKylyLmlzTGluZShzKSYmci5nZXRMb2NhdGlvbihzKT09PUwuQk9VTkRBUlkmJihlW3NdPSEwKTtmb3IodmFyIG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOylmb3IodmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCkscz0wOzI+cztzKyspaWYoci5pc0FueU51bGwocykpe3ZhciBvPUwuTk9ORTtpZihlW3NdKW89TC5FWFRFUklPUjtlbHNle3ZhciBhPWkuZ2V0Q29vcmRpbmF0ZSgpO289dGhpcy5nZXRMb2NhdGlvbihzLGEsdCl9ci5zZXRBbGxMb2NhdGlvbnNJZk51bGwocyxvKX19LGdldERlZ3JlZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VNYXAuc2l6ZSgpfSxpbnNlcnRFZGdlRW5kOmZ1bmN0aW9uKHQsZSl7dGhpcy5lZGdlTWFwLnB1dCh0LGUpLHRoaXMuZWRnZUxpc3Q9bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUG59fSksaChibixQbiksZShibi5wcm90b3R5cGUse2xpbmtSZXN1bHREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5nZXRSZXN1bHRBcmVhRWRnZXMoKTtmb3IodmFyIHQ9bnVsbCxlPW51bGwsbj10aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlORyxpPTA7aTx0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCk7aSsrKXt2YXIgcj10aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5nZXQoaSkscz1yLmdldFN5bSgpO2lmKHIuZ2V0TGFiZWwoKS5pc0FyZWEoKSlzd2l0Y2gobnVsbD09PXQmJnIuaXNJblJlc3VsdCgpJiYodD1yKSxuKXtjYXNlIHRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKCFzLmlzSW5SZXN1bHQoKSljb250aW51ZTtlPXMsbj10aGlzLkxJTktJTkdfVE9fT1VUR09JTkc7YnJlYWs7Y2FzZSB0aGlzLkxJTktJTkdfVE9fT1VUR09JTkc6aWYoIXIuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2Uuc2V0TmV4dChyKSxuPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1pZihuPT09dGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HKXtpZihudWxsPT09dCl0aHJvdyBuZXcgc24oXCJubyBvdXRnb2luZyBkaXJFZGdlIGZvdW5kXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO2YuaXNUcnVlKHQuaXNJblJlc3VsdCgpLFwidW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlXCIpLGUuc2V0TmV4dCh0KX19LGluc2VydDpmdW5jdGlvbih0KXt2YXIgZT10O3RoaXMuaW5zZXJ0RWRnZUVuZChlLGUpfSxnZXRSaWdodG1vc3RFZGdlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRFZGdlcygpLGU9dC5zaXplKCk7aWYoMT5lKXJldHVybiBudWxsO3ZhciBuPXQuZ2V0KDApO2lmKDE9PT1lKXJldHVybiBuO3ZhciBpPXQuZ2V0KGUtMSkscj1uLmdldFF1YWRyYW50KCkscz1pLmdldFF1YWRyYW50KCk7aWYoSmUuaXNOb3J0aGVybihyKSYmSmUuaXNOb3J0aGVybihzKSlyZXR1cm4gbjtpZighSmUuaXNOb3J0aGVybihyKSYmIUplLmlzTm9ydGhlcm4ocykpcmV0dXJuIGk7cmV0dXJuIDAhPT1uLmdldER5KCk/bjowIT09aS5nZXREeSgpP2k6KGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCB0d28gaG9yaXpvbnRhbCBlZGdlcyBpbmNpZGVudCBvbiBub2RlXCIpLG51bGwpfSxwcmludDpmdW5jdGlvbih0KXtBLm91dC5wcmludGxuKFwiRGlyZWN0ZWRFZGdlU3RhcjogXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0LnByaW50KFwib3V0IFwiKSxuLnByaW50KHQpLHQucHJpbnRsbigpLHQucHJpbnQoXCJpbiBcIiksbi5nZXRTeW0oKS5wcmludCh0KSx0LnByaW50bG4oKX19LGdldFJlc3VsdEFyZWFFZGdlczpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnJlc3VsdEFyZWFFZGdlTGlzdClyZXR1cm4gdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Q7dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Q9bmV3IEk7Zm9yKHZhciB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpOyhlLmlzSW5SZXN1bHQoKXx8ZS5nZXRTeW0oKS5pc0luUmVzdWx0KCkpJiZ0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5hZGQoZSl9cmV0dXJuIHRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0fSx1cGRhdGVMYWJlbGxpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpO2kuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdC5nZXRMb2NhdGlvbigwKSksaS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0LmdldExvY2F0aW9uKDEpKX19LGxpbmtBbGxEaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5nZXRFZGdlcygpO2Zvcih2YXIgdD1udWxsLGU9bnVsbCxuPXRoaXMuZWRnZUxpc3Quc2l6ZSgpLTE7bj49MDtuLS0pe3ZhciBpPXRoaXMuZWRnZUxpc3QuZ2V0KG4pLHI9aS5nZXRTeW0oKTtudWxsPT09ZSYmKGU9ciksbnVsbCE9PXQmJnIuc2V0TmV4dCh0KSx0PWl9ZS5zZXROZXh0KHQpfSxjb21wdXRlRGVwdGhzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZmluZEluZGV4KHQpLG49KHQuZ2V0TGFiZWwoKSx0LmdldERlcHRoKGNuLkxFRlQpKSxpPXQuZ2V0RGVwdGgoY24uUklHSFQpLHI9dGhpcy5jb21wdXRlRGVwdGhzKGUrMSx0aGlzLmVkZ2VMaXN0LnNpemUoKSxuKSxzPXRoaXMuY29tcHV0ZURlcHRocygwLGUscik7aWYocyE9PWkpdGhyb3cgbmV3IHNuKFwiZGVwdGggbWlzbWF0Y2ggYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl0sbD11LGg9bzthPmg7aCsrKXt2YXIgYz10aGlzLmVkZ2VMaXN0LmdldChoKTtjLmdldExhYmVsKCk7Yy5zZXRFZGdlRGVwdGhzKGNuLlJJR0hULGwpLGw9Yy5nZXREZXB0aChjbi5MRUZUKX1yZXR1cm4gbH19LG1lcmdlU3ltTGFiZWxzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO24ubWVyZ2UoZS5nZXRTeW0oKS5nZXRMYWJlbCgpKX19LGxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPW51bGwsaT10aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlORyxyPXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKS0xO3I+PTA7ci0tKXt2YXIgcz10aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5nZXQociksbz1zLmdldFN5bSgpO3N3aXRjaChudWxsPT09ZSYmcy5nZXRFZGdlUmluZygpPT09dCYmKGU9cyksaSl7Y2FzZSB0aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlORzppZihvLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO249byxpPXRoaXMuTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuTElOS0lOR19UT19PVVRHT0lORzppZihzLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO24uc2V0TmV4dE1pbihzKSxpPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1pPT09dGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HJiYoZi5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIGZvciBmaXJzdCBvdXRnb2luZyBkaXJFZGdlXCIpLGYuaXNUcnVlKGUuZ2V0RWRnZVJpbmcoKT09PXQsXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksbi5zZXROZXh0TWluKGUpKX0sZ2V0T3V0Z29pbmdEZWdyZWU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PTAsZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmlzSW5SZXN1bHQoKSYmdCsrfXJldHVybiB0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGk9YXJndW1lbnRzWzBdLHQ9MCxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZ2V0RWRnZVJpbmcoKT09PWkmJnQrK31yZXR1cm4gdH19LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LGZpbmRDb3ZlcmVkTGluZUVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PUwuTk9ORSxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRTeW0oKTtpZighbi5pc0xpbmVFZGdlKCkpe2lmKG4uaXNJblJlc3VsdCgpKXt0PUwuSU5URVJJT1I7YnJlYWt9aWYoaS5pc0luUmVzdWx0KCkpe3Q9TC5FWFRFUklPUjticmVha319fWlmKHQ9PT1MLk5PTkUpcmV0dXJuIG51bGw7Zm9yKHZhciByPXQsZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0U3ltKCk7bi5pc0xpbmVFZGdlKCk/bi5nZXRFZGdlKCkuc2V0Q292ZXJlZChyPT09TC5JTlRFUklPUik6KG4uaXNJblJlc3VsdCgpJiYocj1MLkVYVEVSSU9SKSxpLmlzSW5SZXN1bHQoKSYmKHI9TC5JTlRFUklPUikpfX0sY29tcHV0ZUxhYmVsbGluZzpmdW5jdGlvbih0KXtQbi5wcm90b3R5cGUuY29tcHV0ZUxhYmVsbGluZy5jYWxsKHRoaXMsdCksdGhpcy5sYWJlbD1uZXcgZ24oTC5OT05FKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldEVkZ2UoKSxyPWkuZ2V0TGFiZWwoKSxzPTA7Mj5zO3MrKyl7dmFyIG89ci5nZXRMb2NhdGlvbihzKTtvIT09TC5JTlRFUklPUiYmbyE9PUwuQk9VTkRBUll8fHRoaXMubGFiZWwuc2V0TG9jYXRpb24ocyxMLklOVEVSSU9SKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJufX0pLGgoT24sTm4pLGUoT24ucHJvdG90eXBlLHtjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgeW4odCxuZXcgYm4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPbn19KSxlKF9uLnByb3RvdHlwZSx7Y29tcHV0ZUludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlKXt0aGlzLm1jZS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuY2hhaW5JbmRleCx0Lm1jZSx0LmNoYWluSW5kZXgsZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9ufX0pLGUoTW4ucHJvdG90eXBlLHtpc0RlbGV0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV2ZW50VHlwZT09PU1uLkRFTEVURX0sc2V0RGVsZXRlRXZlbnRJbmRleDpmdW5jdGlvbih0KXt0aGlzLmRlbGV0ZUV2ZW50SW5kZXg9dH0sZ2V0T2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2JqfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy54VmFsdWU8ZS54VmFsdWU/LTE6dGhpcy54VmFsdWU+ZS54VmFsdWU/MTp0aGlzLmV2ZW50VHlwZTxlLmV2ZW50VHlwZT8tMTp0aGlzLmV2ZW50VHlwZT5lLmV2ZW50VHlwZT8xOjB9LGdldEluc2VydEV2ZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5zZXJ0RXZlbnR9LGlzSW5zZXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXZlbnRUeXBlPT09TW4uSU5TRVJUfSxpc1NhbWVMYWJlbDpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXRoaXMubGFiZWw/ITE6dGhpcy5sYWJlbD09PXQubGFiZWx9LGdldERlbGV0ZUV2ZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxldGVFdmVudEluZGV4fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTW59fSksTW4uSU5TRVJUPTEsTW4uREVMRVRFPTIsZShEbi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERufX0pLGUoQW4ucHJvdG90eXBlLHtpc1RyaXZpYWxJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJjE9PT10aGlzLmxpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihBbi5pc0FkamFjZW50U2VnbWVudHMoZSxpKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe3ZhciByPXQuZ2V0TnVtUG9pbnRzKCktMTtpZigwPT09ZSYmaT09PXJ8fDA9PT1pJiZlPT09cilyZXR1cm4hMH19cmV0dXJuITF9LGdldFByb3BlckludGVyc2VjdGlvblBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9LHNldElzRG9uZUlmUHJvcGVySW50OmZ1bmN0aW9uKHQpe3RoaXMuaXNEb25lV2hlblByb3BlckludD10fSxoYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3BlckludGVyaW9yfSxpc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0Q29vcmRpbmF0ZSgpO2lmKHQuaXNJbnRlcnNlY3Rpb24ocikpcmV0dXJuITB9cmV0dXJuITF9LGhhc1Byb3BlckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3Blcn0saGFzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzRG9uZX0saXNCb3VuZGFyeVBvaW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT1lPyExOnRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzBdKT8hMDohIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzFdKX0sc2V0Qm91bmRhcnlOb2RlczpmdW5jdGlvbih0LGUpe3RoaXMuYmR5Tm9kZXM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5iZHlOb2Rlc1swXT10LHRoaXMuYmR5Tm9kZXNbMV09ZX0sYWRkSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmZT09PWkpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO3ZhciByPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW2ldLGE9bi5nZXRDb29yZGluYXRlcygpW2krMV07dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLnJlY29yZElzb2xhdGVkJiYodC5zZXRJc29sYXRlZCghMSksbi5zZXRJc29sYXRlZCghMSkpLHRoaXMubnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLGkpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLCF0aGlzLmluY2x1ZGVQcm9wZXImJnRoaXMubGkuaXNQcm9wZXIoKXx8KHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksaSwxKSksdGhpcy5saS5pc1Byb3BlcigpJiYodGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD10aGlzLmxpLmdldEludGVyc2VjdGlvbigwKS5jb3B5KCksdGhpcy5oYXNQcm9wZXI9ITAsdGhpcy5pc0RvbmVXaGVuUHJvcGVySW50JiYodGhpcy5faXNEb25lPSEwKSx0aGlzLmlzQm91bmRhcnlQb2ludCh0aGlzLmxpLHRoaXMuYmR5Tm9kZXMpfHwodGhpcy5oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFufX0pLEFuLmlzQWRqYWNlbnRTZWdtZW50cz1mdW5jdGlvbih0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX0saChGbixEbiksZShGbi5wcm90b3R5cGUse3ByZXBhcmVFdmVudHM6ZnVuY3Rpb24oKXtoby5zb3J0KHRoaXMuZXZlbnRzKTtmb3IodmFyIHQ9MDt0PHRoaXMuZXZlbnRzLnNpemUoKTt0Kyspe3ZhciBlPXRoaXMuZXZlbnRzLmdldCh0KTtlLmlzRGVsZXRlKCkmJmUuZ2V0SW5zZXJ0RXZlbnQoKS5zZXREZWxldGVFdmVudEluZGV4KHQpfX0sY29tcHV0ZUludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubk92ZXJsYXBzPTAsdGhpcy5wcmVwYXJlRXZlbnRzKCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmV2ZW50cy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmV2ZW50cy5nZXQoZSk7aWYobi5pc0luc2VydCgpJiZ0aGlzLnByb2Nlc3NPdmVybGFwcyhlLG4uZ2V0RGVsZXRlRXZlbnRJbmRleCgpLG4sdCksdC5pc0RvbmUoKSlicmVha319ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFuJiZSKGFyZ3VtZW50c1swXSx5KSYmUihhcmd1bWVudHNbMV0seSkpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLmFkZEVkZ2VzKGksaSksdGhpcy5hZGRFZGdlcyhyLHIpLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMocyl9ZWxzZSBpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmUihhcmd1bWVudHNbMF0seSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQW4pe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXTt1P3RoaXMuYWRkRWRnZXMobyxudWxsKTp0aGlzLmFkZEVkZ2VzKG8pLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMoYSl9fSxhZGRFZGdlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UoKSxpPW4uZ2V0U3RhcnRJbmRleGVzKCkscj0wO3I8aS5sZW5ndGgtMTtyKyspe3ZhciBzPW5ldyBfbihuLHIpLG89bmV3IE1uKGUsbi5nZXRNaW5YKHIpLHMpO3RoaXMuZXZlbnRzLmFkZChvKSx0aGlzLmV2ZW50cy5hZGQobmV3IE1uKG4uZ2V0TWF4WChyKSxvKSl9fSxwcm9jZXNzT3ZlcmxhcHM6ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByPW4uZ2V0T2JqZWN0KCkscz10O2U+cztzKyspe3ZhciBvPXRoaXMuZXZlbnRzLmdldChzKTtpZihvLmlzSW5zZXJ0KCkpe3ZhciBhPW8uZ2V0T2JqZWN0KCk7bi5pc1NhbWVMYWJlbChvKXx8KHIuY29tcHV0ZUludGVyc2VjdGlvbnMoYSxpKSx0aGlzLm5PdmVybGFwcysrKX19fSxhZGRFZGdlczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmFkZEVkZ2UobixuKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0sZT1pLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmFkZEVkZ2UobixyKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZufX0pLGUoR24ucHJvdG90eXBlLHtnZXRNaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW59LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHRoaXMubWluPmV8fHRoaXMubWF4PHQpfSxnZXRNYXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHNlLnRvTGluZVN0cmluZyhuZXcgZyh0aGlzLm1pbiwwKSxuZXcgZyh0aGlzLm1heCwwKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEdufX0pLGUocW4ucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWUscj0obi5taW4rbi5tYXgpLzIscz0oaS5taW4raS5tYXgpLzI7cmV0dXJuIHM+cj8tMTpyPnM/MTowfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcW59fSksR24uTm9kZUNvbXBhcmF0b3I9cW4saChCbixHbiksZShCbi5wcm90b3R5cGUse3F1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQsZSk/dm9pZCBuLnZpc2l0SXRlbSh0aGlzLml0ZW0pOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJufX0pLGgoem4sR24pLGUoem4ucHJvdG90eXBlLHtidWlsZEV4dGVudDpmdW5jdGlvbih0LGUpe3RoaXMubWluPU1hdGgubWluKHQubWluLGUubWluKSx0aGlzLm1heD1NYXRoLm1heCh0Lm1heCxlLm1heCl9LHF1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQsZSk/KG51bGwhPT10aGlzLm5vZGUxJiZ0aGlzLm5vZGUxLnF1ZXJ5KHQsZSxuKSx2b2lkKG51bGwhPT10aGlzLm5vZGUyJiZ0aGlzLm5vZGUyLnF1ZXJ5KHQsZSxuKSkpOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHpufX0pLGUoVm4ucHJvdG90eXBlLHtidWlsZFRyZWU6ZnVuY3Rpb24oKXtoby5zb3J0KHRoaXMubGVhdmVzLG5ldyBJbnRlcnZhbFJUcmVlTm9kZS5Ob2RlQ29tcGFyYXRvcik7Zm9yKHZhciB0PXRoaXMubGVhdmVzLGU9bnVsbCxuPW5ldyBJOzspe2lmKHRoaXMuYnVpbGRMZXZlbCh0LG4pLDE9PT1uLnNpemUoKSlyZXR1cm4gbi5nZXQoMCk7ZT10LHQ9bixuPWV9fSxpbnNlcnQ6ZnVuY3Rpb24odCxlLG4pe2lmKG51bGwhPT10aGlzLnJvb3QpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkluZGV4IGNhbm5vdCBiZSBhZGRlZCB0byBvbmNlIGl0IGhhcyBiZWVuIHF1ZXJpZWRcIik7dGhpcy5sZWF2ZXMuYWRkKG5ldyBCbih0LGUsbikpfSxxdWVyeTpmdW5jdGlvbih0LGUsbil7dGhpcy5pbml0KCksdGhpcy5yb290LnF1ZXJ5KHQsZSxuKX0sYnVpbGRSb290OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/bnVsbDp2b2lkKHRoaXMucm9vdD10aGlzLmJ1aWxkVHJlZSgpKX0scHJpbnROb2RlOmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4oc2UudG9MaW5lU3RyaW5nKG5ldyBnKHQubWluLHRoaXMubGV2ZWwpLG5ldyBnKHQubWF4LHRoaXMubGV2ZWwpKSl9LGluaXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD9udWxsOnZvaWQgdGhpcy5idWlsZFJvb3QoKX0sYnVpbGRMZXZlbDpmdW5jdGlvbih0LGUpe3RoaXMubGV2ZWwrKyxlLmNsZWFyKCk7Zm9yKHZhciBuPTA7bjx0LnNpemUoKTtuKz0yKXt2YXIgaT10LmdldChuKSxyPW4rMTx0LnNpemUoKT90LmdldChuKTpudWxsO2lmKG51bGw9PT1yKWUuYWRkKGkpO2Vsc2V7dmFyIHM9bmV3IHpuKHQuZ2V0KG4pLHQuZ2V0KG4rMSkpO2UuYWRkKHMpfX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZufX0pLGUoa24ucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7aWYodGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZyYmdCBpbnN0YW5jZW9mIGJ0KXt2YXIgZT10LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0aGlzLmxpbmVzLmFkZChlKSxudWxsfXQgaW5zdGFuY2VvZiBTdCYmdGhpcy5saW5lcy5hZGQodCl9LHNldEZvcmNlVG9MaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3RoaXMuaXNGb3JjZWRUb0xpbmVTdHJpbmc9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtufX0pLGtuLmdldEdlb21ldHJ5PWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShrbi5nZXRMaW5lcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gZS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShrbi5nZXRMaW5lcyhlLG4pKX19LGtuLmdldExpbmVzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4ga24uZ2V0TGluZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLHYpJiZSKGFyZ3VtZW50c1sxXSx2KSl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2tuLmdldExpbmVzKHIsbil9cmV0dXJuIG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9bmV3IEk7cmV0dXJuIHMuYXBwbHkobmV3IGtuKGEsbykpLGF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZSKGFyZ3VtZW50c1sxXSx2KSl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdO3JldHVybiB1IGluc3RhbmNlb2YgU3Q/bC5hZGQodSk6dS5hcHBseShuZXcga24obCkpLGx9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZSKGFyZ3VtZW50c1swXSx2KSYmUihhcmd1bWVudHNbMV0sdikpe2Zvcih2YXIgaD1hcmd1bWVudHNbMF0sYz1hcmd1bWVudHNbMV0sZj1hcmd1bWVudHNbMl0saT1oLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtrbi5nZXRMaW5lcyhyLGMsZil9cmV0dXJuIGN9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmUihhcmd1bWVudHNbMV0sdikpe3ZhciBnPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXTtyZXR1cm4gZy5hcHBseShuZXcga24oZCxwKSksZH19fSxlKFluLnByb3RvdHlwZSx7dmlzaXRJdGVtOmZ1bmN0aW9uKHQpe3RoaXMuaXRlbXMuYWRkKHQpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFlufX0pLGUoVW4ucHJvdG90eXBlLHtsb2NhdGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGxlKHQpLG49bmV3IFhuKGUpO3JldHVybiB0aGlzLmluZGV4LnF1ZXJ5KHQueSx0LnksbiksZS5nZXRMb2NhdGlvbigpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFVufX0pLGUoWG4ucHJvdG90eXBlLHt2aXNpdEl0ZW06ZnVuY3Rpb24odCl7dmFyIGU9dDt0aGlzLmNvdW50ZXIuY291bnRTZWdtZW50KGUuZ2V0Q29vcmRpbmF0ZSgwKSxlLmdldENvb3JkaW5hdGUoMSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhufX0pLGUoSG4ucHJvdG90eXBlLHtpbml0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1rbi5nZXRMaW5lcyh0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRDb29yZGluYXRlcygpO3RoaXMuYWRkTGluZShyKX19LGFkZExpbmU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPW5ldyBjZSh0W2UtMV0sdFtlXSksaT1NYXRoLm1pbihuLnAwLnksbi5wMS55KSxyPU1hdGgubWF4KG4ucDAueSxuLnAxLnkpO3RoaXMuaW5kZXguaW5zZXJ0KGkscixuKX19LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBZbjtyZXR1cm4gdGhpcy5pbmRleC5xdWVyeSh0LGUsbiksbi5nZXRJdGVtcygpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy5pbmRleC5xdWVyeShpLHIscyl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIbn19KSxVbi5TZWdtZW50VmlzaXRvcj1YbixVbi5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeT1IbixlKFduLnByb3RvdHlwZSx7Z2V0U2VnbWVudEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmR9LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KSx0LnByaW50bG4oXCIgZGlzdCA9IFwiK3RoaXMuZGlzdCl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmNvbXBhcmUoZS5zZWdtZW50SW5kZXgsZS5kaXN0KX0saXNFbmRQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYwPT09dGhpcy5kaXN0PyEwOnRoaXMuc2VnbWVudEluZGV4PT09dH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZCtcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4K1wiIGRpc3QgPSBcIit0aGlzLmRpc3R9LGdldERpc3RhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzdH0sY29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDx0Py0xOnRoaXMuc2VnbWVudEluZGV4PnQ/MTp0aGlzLmRpc3Q8ZT8tMTp0aGlzLmRpc3Q+ZT8xOjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXbn19KSxlKGpuLnByb3RvdHlwZSx7cHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0sYWRkU3BsaXRFZGdlczpmdW5jdGlvbih0KXt0aGlzLmFkZEVuZHBvaW50cygpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCksbj1lLm5leHQoKTtlLmhhc05leHQoKTspe3ZhciBpPWUubmV4dCgpLHI9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixpKTt0LmFkZChyKSxuPWl9fSxhZGRFbmRwb2ludHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVkZ2UucHRzLmxlbmd0aC0xO3RoaXMuYWRkKHRoaXMuZWRnZS5wdHNbMF0sMCwwKSx0aGlzLmFkZCh0aGlzLmVkZ2UucHRzW3RdLHQsMCl9LGNyZWF0ZVNwbGl0RWRnZTpmdW5jdGlvbih0LGUpe3ZhciBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzIsaT10aGlzLmVkZ2UucHRzW2Uuc2VnbWVudEluZGV4XSxyPWUuZGlzdD4wfHwhZS5jb29yZC5lcXVhbHMyRChpKTtyfHxuLS07dmFyIHM9bmV3IEFycmF5KG4pLmZpbGwobnVsbCksbz0wO3NbbysrXT1uZXcgZyh0LmNvb3JkKTtmb3IodmFyIGE9dC5zZWdtZW50SW5kZXgrMTthPD1lLnNlZ21lbnRJbmRleDthKyspc1tvKytdPXRoaXMuZWRnZS5wdHNbYV07cmV0dXJuIHImJihzW29dPWUuY29vcmQpLG5ldyBKbihzLG5ldyBnbih0aGlzLmVkZ2UubGFiZWwpKX0sYWRkOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgV24odCxlLG4pLHI9dGhpcy5ub2RlTWFwLmdldChpKTtyZXR1cm4gbnVsbCE9PXI/cjoodGhpcy5ub2RlTWFwLnB1dChpLGkpLGkpfSxpc0ludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYobi5jb29yZC5lcXVhbHModCkpcmV0dXJuITB9cmV0dXJuITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGpufX0pLGUoS24ucHJvdG90eXBlLHtnZXRDaGFpblN0YXJ0SW5kaWNlczpmdW5jdGlvbih0KXt2YXIgZT0wLG49bmV3IEk7bi5hZGQobmV3IGIoZSkpO2Rve3ZhciBpPXRoaXMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQobmV3IGIoaSkpLGU9aX13aGlsZShlPHQubGVuZ3RoLTEpO3ZhciByPUtuLnRvSW50QXJyYXkobik7cmV0dXJuIHJ9LGZpbmRDaGFpbkVuZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1KZS5xdWFkcmFudCh0W2VdLHRbZSsxXSksaT1lKzE7aTx0Lmxlbmd0aDspe3ZhciByPUplLnF1YWRyYW50KHRbaS0xXSx0W2ldKTtpZihyIT09bilicmVhaztpKyt9cmV0dXJuIGktMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS259fSksS24udG9JbnRBcnJheT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPXQuZ2V0KG4pLmludFZhbHVlKCk7cmV0dXJuIGV9LGUoWm4ucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sZ2V0TWF4WDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZT5uP2U6bn0sZ2V0TWluWDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gbj5lP2U6bn0sY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbjpmdW5jdGlvbigpe2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuc3RhcnRJbmRleFt0XSx0aGlzLnN0YXJ0SW5kZXhbdCsxXSxlLGUuc3RhcnRJbmRleFtuXSxlLnN0YXJ0SW5kZXhbbisxXSxpKX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM10sdT1hcmd1bWVudHNbNF0sbD1hcmd1bWVudHNbNV0saD10aGlzLnB0c1tyXSxjPXRoaXMucHRzW3NdLGY9by5wdHNbYV0sZz1vLnB0c1t1XTtpZihzLXI9PT0xJiZ1LWE9PT0xKXJldHVybiBsLmFkZEludGVyc2VjdGlvbnModGhpcy5lLHIsby5lLGEpLG51bGw7aWYodGhpcy5lbnYxLmluaXQoaCxjKSx0aGlzLmVudjIuaW5pdChmLGcpLCF0aGlzLmVudjEuaW50ZXJzZWN0cyh0aGlzLmVudjIpKXJldHVybiBudWxsO3ZhciBkPU1hdGgudHJ1bmMoKHIrcykvMikscD1NYXRoLnRydW5jKChhK3UpLzIpO2Q+ciYmKHA+YSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHIsZCxvLGEscCxsKSx1PnAmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihyLGQsbyxwLHUsbCkpLHM+ZCYmKHA+YSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKGQscyxvLGEscCxsKSx1PnAmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihkLHMsbyxwLHUsbCkpfX0sZ2V0U3RhcnRJbmRleGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnRJbmRleH0sY29tcHV0ZUludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHRoaXMuc3RhcnRJbmRleC5sZW5ndGgtMTtuKyspZm9yKHZhciBpPTA7aTx0LnN0YXJ0SW5kZXgubGVuZ3RoLTE7aSsrKXRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihuLHQsaSxlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWm59fSksZShRbi5wcm90b3R5cGUse2dldERlcHRoOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZGVwdGhbdF1bZV19LHNldERlcHRoOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLmRlcHRoW3RdW2VdPW59LGlzTnVsbDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9MDsyPnQ7dCsrKWZvcih2YXIgZT0wOzM+ZTtlKyspaWYodGhpcy5kZXB0aFt0XVtlXSE9PVFuLk5VTExfVkFMVUUpcmV0dXJuITE7cmV0dXJuITB9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5kZXB0aFtuXVsxXT09PVFuLk5VTExfVkFMVUV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5kZXB0aFtpXVtyXT09PVFuLk5VTExfVkFMVUV9fSxub3JtYWxpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDsyPnQ7dCsrKWlmKCF0aGlzLmlzTnVsbCh0KSl7dmFyIGU9dGhpcy5kZXB0aFt0XVsxXTt0aGlzLmRlcHRoW3RdWzJdPGUmJihlPXRoaXMuZGVwdGhbdF1bMl0pLDA+ZSYmKGU9MCk7Zm9yKHZhciBuPTE7Mz5uO24rKyl7dmFyIGk9MDt0aGlzLmRlcHRoW3RdW25dPmUmJihpPTEpLHRoaXMuZGVwdGhbdF1bbl09aX19fSxnZXREZWx0YTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kZXB0aFt0XVtjbi5SSUdIVF0tdGhpcy5kZXB0aFt0XVtjbi5MRUZUXX0sZ2V0TG9jYXRpb246ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5kZXB0aFt0XVtlXTw9MD9MLkVYVEVSSU9SOkwuSU5URVJJT1J9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJBOiBcIit0aGlzLmRlcHRoWzBdWzFdK1wiLFwiK3RoaXMuZGVwdGhbMF1bMl0rXCIgQjogXCIrdGhpcy5kZXB0aFsxXVsxXStcIixcIit0aGlzLmRlcHRoWzFdWzJdfSxhZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDsyPmU7ZSsrKWZvcih2YXIgbj0xOzM+bjtuKyspe3ZhciBpPXQuZ2V0TG9jYXRpb24oZSxuKTtpIT09TC5FWFRFUklPUiYmaSE9PUwuSU5URVJJT1J8fCh0aGlzLmlzTnVsbChlLG4pP3RoaXMuZGVwdGhbZV1bbl09UW4uZGVwdGhBdExvY2F0aW9uKGkpOnRoaXMuZGVwdGhbZV1bbl0rPVFuLmRlcHRoQXRMb2NhdGlvbihpKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO289PT1MLklOVEVSSU9SJiZ0aGlzLmRlcHRoW3JdW3NdKyt9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBRbn19KSxRbi5kZXB0aEF0TG9jYXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1MLkVYVEVSSU9SPzA6dD09PUwuSU5URVJJT1I/MTpRbi5OVUxMX1ZBTFVFfSxRbi5OVUxMX1ZBTFVFPS0xLGgoSm4sbW4pLGUoSm4ucHJvdG90eXBlLHtnZXREZXB0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlcHRofSxnZXRDb2xsYXBzZWRFZGdlOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7dFswXT10aGlzLnB0c1swXSx0WzFdPXRoaXMucHRzWzFdO3ZhciBlPW5ldyBKbih0LGduLnRvTGluZUxhYmVsKHRoaXMubGFiZWwpKTtyZXR1cm4gZX0saXNJc29sYXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0lzb2xhdGVkfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sc2V0SXNvbGF0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNJc29sYXRlZD10fSxzZXROYW1lOmZ1bmN0aW9uKHQpe3RoaXMubmFtZT10fSxlcXVhbHM6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgSm4pKXJldHVybiExO3ZhciBlPXQ7aWYodGhpcy5wdHMubGVuZ3RoIT09ZS5wdHMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0hMCxpPSEwLHI9dGhpcy5wdHMubGVuZ3RoLHM9MDtzPHRoaXMucHRzLmxlbmd0aDtzKyspaWYodGhpcy5wdHNbc10uZXF1YWxzMkQoZS5wdHNbc10pfHwobj0hMSksdGhpcy5wdHNbc10uZXF1YWxzMkQoZS5wdHNbLS1yXSl8fChpPSExKSwhbiYmIWkpcmV0dXJuITE7cmV0dXJuITB9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5wdHMubGVuZ3RoPjA/dGhpcy5wdHNbMF06bnVsbDtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnB0c1t0XX19LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMubmFtZStcIjogXCIpLHQucHJpbnQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKHZhciBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5wcmludChcIixcIiksdC5wcmludCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3QucHJpbnQoXCIpICBcIit0aGlzLmxhYmVsK1wiIFwiK3RoaXMuZGVwdGhEZWx0YSl9LGNvbXB1dGVJTTpmdW5jdGlvbih0KXtKbi51cGRhdGVJTSh0aGlzLmxhYmVsLHQpfSxpc0NvbGxhcHNlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsLmlzQXJlYSgpPzMhPT10aGlzLnB0cy5sZW5ndGg/ITE6ISF0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbMl0pOiExfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX0sZ2V0TWF4aW11bVNlZ21lbnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGgtMX0sZ2V0RGVwdGhEZWx0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlcHRoRGVsdGF9LGdldE51bVBvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9LHByaW50UmV2ZXJzZTpmdW5jdGlvbih0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLm5hbWUrXCI6IFwiKTtmb3IodmFyIGU9dGhpcy5wdHMubGVuZ3RoLTE7ZT49MDtlLS0pdC5wcmludCh0aGlzLnB0c1tlXStcIiBcIik7dC5wcmludGxuKFwiXCIpfSxnZXRNb25vdG9uZUNoYWluRWRnZTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5tY2UmJih0aGlzLm1jZT1uZXcgWm4odGhpcykpLHRoaXMubWNlfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmVudil7dGhpcy5lbnY9bmV3IEM7Zm9yKHZhciB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMuZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLnB0c1t0XSl9cmV0dXJuIHRoaXMuZW52fSxhZGRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bmV3IGcodC5nZXRJbnRlcnNlY3Rpb24oaSkpLHM9ZSxvPXQuZ2V0RWRnZURpc3RhbmNlKG4saSksYT1zKzE7aWYoYTx0aGlzLnB0cy5sZW5ndGgpe3ZhciB1PXRoaXMucHRzW2FdO3IuZXF1YWxzMkQodSkmJihzPWEsbz0wKX10aGlzLmVpTGlzdC5hZGQocixzLG8pfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3QuYXBwZW5kKFwiZWRnZSBcIit0aGlzLm5hbWUrXCI6IFwiKSx0LmFwcGVuZChcIkxJTkVTVFJJTkcgKFwiKTtmb3IodmFyIGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LmFwcGVuZChcIixcIiksdC5hcHBlbmQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTtyZXR1cm4gdC5hcHBlbmQoXCIpICBcIit0aGlzLmxhYmVsK1wiIFwiK3RoaXMuZGVwdGhEZWx0YSksdC50b1N0cmluZygpfSxpc1BvaW50d2lzZUVxdWFsOmZ1bmN0aW9uKHQpe2lmKHRoaXMucHRzLmxlbmd0aCE9PXQucHRzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspaWYoIXRoaXMucHRzW2VdLmVxdWFsczJEKHQucHRzW2VdKSlyZXR1cm4hMTtyZXR1cm4hMH0sc2V0RGVwdGhEZWx0YTpmdW5jdGlvbih0KXt0aGlzLmRlcHRoRGVsdGE9dH0sZ2V0RWRnZUludGVyc2VjdGlvbkxpc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5laUxpc3R9LGFkZEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtpKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4saSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEpufX0pLEpuLnVwZGF0ZUlNPWZ1bmN0aW9uKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG1uLnByb3RvdHlwZS51cGRhdGVJTS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Uuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGNuLk9OKSx0LmdldExvY2F0aW9uKDEsY24uT04pLDEpLHQuaXNBcmVhKCkmJihlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxjbi5MRUZUKSx0LmdldExvY2F0aW9uKDEsY24uTEVGVCksMiksZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsY24uUklHSFQpLHQuZ2V0TG9jYXRpb24oMSxjbi5SSUdIVCksMikpfSxoKCRuLENuKSxlKCRuLnByb3RvdHlwZSx7aW5zZXJ0Qm91bmRhcnlQb2ludDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubm9kZXMuYWRkTm9kZShlKSxpPW4uZ2V0TGFiZWwoKSxyPTEscz1MLk5PTkU7cz1pLmdldExvY2F0aW9uKHQsY24uT04pLHM9PT1MLkJPVU5EQVJZJiZyKys7dmFyIG89JG4uZGV0ZXJtaW5lQm91bmRhcnkodGhpcy5ib3VuZGFyeU5vZGVSdWxlLHIpO2kuc2V0TG9jYXRpb24odCxvKX0sY29tcHV0ZVNlbGZOb2RlczpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcHV0ZVNlbGZOb2Rlcyh0LGUsITEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl0scz1uZXcgQW4obiwhMCwhMSk7cy5zZXRJc0RvbmVJZlByb3BlckludChyKTt2YXIgbz10aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpLGE9dGhpcy5wYXJlbnRHZW9tIGluc3RhbmNlb2YgYnR8fHRoaXMucGFyZW50R2VvbSBpbnN0YW5jZW9mIFR0fHx0aGlzLnBhcmVudEdlb20gaW5zdGFuY2VvZiBPdCx1PWl8fCFhO3JldHVybiBvLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuZWRnZXMscyx1KSx0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0aGlzLmFyZ0luZGV4KSxzfX0sY29tcHV0ZVNwbGl0RWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZWlMaXN0LmFkZFNwbGl0RWRnZXModCl9fSxjb21wdXRlRWRnZUludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBBbihlLG4sITApO2kuc2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSx0LmdldEJvdW5kYXJ5Tm9kZXMoKSk7dmFyIHI9dGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKTtyZXR1cm4gci5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLmVkZ2VzLHQuZWRnZXMsaSksaX0sZ2V0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRHZW9tfSxnZXRCb3VuZGFyeU5vZGVSdWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm91bmRhcnlOb2RlUnVsZX0saGFzVG9vRmV3UG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50c30sYWRkUG9pbnQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT10LmdldENvb3JkaW5hdGUoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsZSxMLklOVEVSSU9SKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxuLEwuSU5URVJJT1IpfX0sYWRkUG9seWdvbjpmdW5jdGlvbih0KXt0aGlzLmFkZFBvbHlnb25SaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksTC5FWFRFUklPUixMLklOVEVSSU9SKTtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXt2YXIgbj10LmdldEludGVyaW9yUmluZ04oZSk7dGhpcy5hZGRQb2x5Z29uUmluZyhuLEwuSU5URVJJT1IsTC5FWFRFUklPUil9fSxhZGRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMuaW5zZXJ0RWRnZSh0KTt2YXIgZT10LmdldENvb3JkaW5hdGVzKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LGVbMF0sTC5CT1VOREFSWSksdGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LGVbZS5sZW5ndGgtMV0sTC5CT1VOREFSWSl9LGFkZExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLmludmFsaWRQb2ludD1lWzBdLG51bGw7dmFyIG49bmV3IEpuKGUsbmV3IGduKHRoaXMuYXJnSW5kZXgsTC5JTlRFUklPUikpO3RoaXMubGluZUVkZ2VNYXAucHV0KHQsbiksdGhpcy5pbnNlcnRFZGdlKG4pLGYuaXNUcnVlKGUubGVuZ3RoPj0yLFwiZm91bmQgTGluZVN0cmluZyB3aXRoIHNpbmdsZSBwb2ludFwiKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5hcmdJbmRleCxlWzBdKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5hcmdJbmRleCxlW2UubGVuZ3RoLTFdKX0sZ2V0SW52YWxpZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52YWxpZFBvaW50fSxnZXRCb3VuZGFyeVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSxlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKSxuPTAsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtlW24rK109ci5nZXRDb29yZGluYXRlKCkuY29weSgpfXJldHVybiBlfSxnZXRCb3VuZGFyeU5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmJvdW5kYXJ5Tm9kZXMmJih0aGlzLmJvdW5kYXJ5Tm9kZXM9dGhpcy5ub2Rlcy5nZXRCb3VuZGFyeU5vZGVzKHRoaXMuYXJnSW5kZXgpKSx0aGlzLmJvdW5kYXJ5Tm9kZXN9LGFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pc0JvdW5kYXJ5Tm9kZSh0LGUpP251bGw6dm9pZChuPT09TC5CT1VOREFSWSYmdGhpcy51c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlP3RoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpOnRoaXMuaW5zZXJ0UG9pbnQodCxlLG4pKX0sYWRkUG9seWdvblJpbmc6ZnVuY3Rpb24odCxlLG4pe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBpPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihpLmxlbmd0aDw0KXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5pbnZhbGlkUG9pbnQ9aVswXSxudWxsO3ZhciByPWUscz1uO2hlLmlzQ0NXKGkpJiYocj1uLHM9ZSk7dmFyIG89bmV3IEpuKGksbmV3IGduKHRoaXMuYXJnSW5kZXgsTC5CT1VOREFSWSxyLHMpKTt0aGlzLmxpbmVFZGdlTWFwLnB1dCh0LG8pLHRoaXMuaW5zZXJ0RWRnZShvKSx0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsaVswXSxMLkJPVU5EQVJZKX0saW5zZXJ0UG9pbnQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMubm9kZXMuYWRkTm9kZShlKSxyPWkuZ2V0TGFiZWwoKTtudWxsPT09cj9pLmxhYmVsPW5ldyBnbih0LG4pOnIuc2V0TG9jYXRpb24odCxuKX0sY3JlYXRlRWRnZVNldEludGVyc2VjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBGbn0sYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSxyPW4uZWlMaXN0Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTt0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKHQscy5jb29yZCxpKX19LGFkZDpmdW5jdGlvbigpe2lmKDEhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBDbi5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIE90JiYodGhpcy51c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSExKSx0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBndCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgT3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fSxhZGRDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19LGxvY2F0ZTpmdW5jdGlvbih0KXtyZXR1cm4gUih0aGlzLnBhcmVudEdlb20sUnQpJiZ0aGlzLnBhcmVudEdlb20uZ2V0TnVtR2VvbWV0cmllcygpPjUwPyhudWxsPT09dGhpcy5hcmVhUHRMb2NhdG9yJiYodGhpcy5hcmVhUHRMb2NhdG9yPW5ldyBVbih0aGlzLnBhcmVudEdlb20pKSx0aGlzLmFyZWFQdExvY2F0b3IubG9jYXRlKHQpKTp0aGlzLnB0TG9jYXRvci5sb2NhdGUodCx0aGlzLnBhcmVudEdlb20pfSxmaW5kRWRnZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubGluZUVkZ2VNYXAuZ2V0KHQpfXJldHVybiBDbi5wcm90b3R5cGUuZmluZEVkZ2UuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiAkbn19KSwkbi5kZXRlcm1pbmVCb3VuZGFyeT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmlzSW5Cb3VuZGFyeShlKT9MLkJPVU5EQVJZOkwuSU5URVJJT1J9LGUodGkucHJvdG90eXBlLHtnZXRBcmdHZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcmdbdF0uZ2V0R2VvbWV0cnkoKX0sc2V0Q29tcHV0YXRpb25QcmVjaXNpb246ZnVuY3Rpb24odCl7dGhpcy5yZXN1bHRQcmVjaXNpb25Nb2RlbD10LHRoaXMubGkuc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5yZXN1bHRQcmVjaXNpb25Nb2RlbCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRpfX0pLGUoZWkucHJvdG90eXBlLHtjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPWVpLmNvbXBhcmVPcmllbnRlZCh0aGlzLnB0cyx0aGlzLl9vcmllbnRhdGlvbixlLnB0cyxlLl9vcmllbnRhdGlvbik7cmV0dXJuIG59LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlaX19KSxlaS5vcmllbnRhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gMT09PUguaW5jcmVhc2luZ0RpcmVjdGlvbih0KX0sZWkuY29tcGFyZU9yaWVudGVkPWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj1lPzE6LTEscz1pPzE6LTEsbz1lP3QubGVuZ3RoOi0xLGE9aT9uLmxlbmd0aDotMSx1PWU/MDp0Lmxlbmd0aC0xLGw9aT8wOm4ubGVuZ3RoLTE7Oyl7dmFyIGg9dFt1XS5jb21wYXJlVG8obltsXSk7aWYoMCE9PWgpcmV0dXJuIGg7dSs9cixsKz1zO3ZhciBjPXU9PT1vLGY9bD09PWE7aWYoYyYmIWYpcmV0dXJuLTE7aWYoIWMmJmYpcmV0dXJuIDE7aWYoYyYmZilyZXR1cm4gMH19LGUobmkucHJvdG90eXBlLHtwcmludDpmdW5jdGlvbih0KXt0LnByaW50KFwiTVVMVElMSU5FU1RSSU5HICggXCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlcy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmVkZ2VzLmdldChlKTtlPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoXCIoXCIpO2Zvcih2YXIgaT1uLmdldENvb3JkaW5hdGVzKCkscj0wO3I8aS5sZW5ndGg7cisrKXI+MCYmdC5wcmludChcIixcIiksdC5wcmludChpW3JdLngrXCIgXCIraVtyXS55KTt0LnByaW50bG4oXCIpXCIpfXQucHJpbnQoXCIpICBcIil9LGFkZEFsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSl9LGZpbmRFZGdlSW5kZXg6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2VzLnNpemUoKTtlKyspaWYodGhpcy5lZGdlcy5nZXQoZSkuZXF1YWxzKHQpKXJldHVybiBlO3JldHVybi0xfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzLml0ZXJhdG9yKCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LGdldDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lZGdlcy5nZXQodCl9LGZpbmRFcXVhbEVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGVpKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbj10aGlzLm9jYU1hcC5nZXQoZSk7cmV0dXJuIG59LGFkZDpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLmFkZCh0KTt2YXIgZT1uZXcgZWkodC5nZXRDb29yZGluYXRlcygpKTt0aGlzLm9jYU1hcC5wdXQoZSx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbml9fSksaChpaSx0aSksZShpaS5wcm90b3R5cGUse2luc2VydFVuaXF1ZUVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXt2YXIgbj1lLmdldExhYmVsKCksaT10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwoaT1uZXcgZ24odC5nZXRMYWJlbCgpKSxpLmZsaXAoKSk7dmFyIHI9ZS5nZXREZXB0aCgpO3IuaXNOdWxsKCkmJnIuYWRkKG4pLHIuYWRkKGkpLG4ubWVyZ2UoaSl9ZWxzZSB0aGlzLmVkZ2VMaXN0LmFkZCh0KX0sZ2V0R3JhcGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaH0sY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0U3ltKCk7ZS5pc0luUmVzdWx0KCkmJm4uaXNJblJlc3VsdCgpJiYoZS5zZXRJblJlc3VsdCghMSksbi5zZXRJblJlc3VsdCghMSkpfX0saXNDb3ZlcmVkQnlMQTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0NvdmVyZWQodCx0aGlzLnJlc3VsdExpbmVMaXN0KT8hMDohIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5yZXN1bHRQb2x5TGlzdCl9LGNvbXB1dGVHZW9tZXRyeTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uZXcgSTtyZXR1cm4gci5hZGRBbGwodCksci5hZGRBbGwoZSksci5hZGRBbGwobiksci5pc0VtcHR5KCk/aWkuY3JlYXRlRW1wdHlSZXN1bHQoaSx0aGlzLmFyZ1swXS5nZXRHZW9tZXRyeSgpLHRoaXMuYXJnWzFdLmdldEdlb21ldHJ5KCksdGhpcy5nZW9tRmFjdCk6dGhpcy5nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHIpfSxtZXJnZVN5bUxhYmVsczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5tZXJnZVN5bUxhYmVscygpfX0saXNDb3ZlcmVkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9dGhpcy5wdExvY2F0b3IubG9jYXRlKHQsaSk7aWYociE9PUwuRVhURVJJT1IpcmV0dXJuITB9cmV0dXJuITF9LHJlcGxhY2VDb2xsYXBzZWRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgSSxlPXRoaXMuZWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uaXNDb2xsYXBzZWQoKSYmKGUucmVtb3ZlKCksdC5hZGQobi5nZXRDb2xsYXBzZWRFZGdlKCkpKX10aGlzLmVkZ2VMaXN0LmFkZEFsbCh0KX0sdXBkYXRlTm9kZUxhYmVsbGluZzpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRFZGdlcygpLmdldExhYmVsKCk7ZS5nZXRMYWJlbCgpLm1lcmdlKG4pfX0sZ2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcHV0ZU92ZXJsYXkodCksdGhpcy5yZXN1bHRHZW9tfSxpbnNlcnRVbmlxdWVFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKG4pfX0sY29tcHV0ZU92ZXJsYXk6ZnVuY3Rpb24odCl7dGhpcy5jb3B5UG9pbnRzKDApLHRoaXMuY29weVBvaW50cygxKSx0aGlzLmFyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITEpLHRoaXMuYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSksdGhpcy5hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuYXJnWzFdLHRoaXMubGksITApO3ZhciBlPW5ldyBJO3RoaXMuYXJnWzBdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpLHRoaXMuYXJnWzFdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZXMoZSksdGhpcy5jb21wdXRlTGFiZWxzRnJvbURlcHRocygpLHRoaXMucmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCksbG4uY2hlY2tWYWxpZCh0aGlzLmVkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuZ3JhcGguYWRkRWRnZXModGhpcy5lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLmNvbXB1dGVMYWJlbGxpbmcoKSx0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGVzKCksdGhpcy5maW5kUmVzdWx0QXJlYUVkZ2VzKHQpLHRoaXMuY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKTt2YXIgbj1uZXcgU24odGhpcy5nZW9tRmFjdCk7bi5hZGQodGhpcy5ncmFwaCksdGhpcy5yZXN1bHRQb2x5TGlzdD1uLmdldFBvbHlnb25zKCk7dmFyIGk9bmV3IHduKHRoaXMsdGhpcy5nZW9tRmFjdCx0aGlzLnB0TG9jYXRvcik7dGhpcy5yZXN1bHRMaW5lTGlzdD1pLmJ1aWxkKHQpO3ZhciByPW5ldyBMbih0aGlzLHRoaXMuZ2VvbUZhY3QsdGhpcy5wdExvY2F0b3IpO3RoaXMucmVzdWx0UG9pbnRMaXN0PXIuYnVpbGQodCksXG50aGlzLnJlc3VsdEdlb209dGhpcy5jb21wdXRlR2VvbWV0cnkodGhpcy5yZXN1bHRQb2ludExpc3QsdGhpcy5yZXN1bHRMaW5lTGlzdCx0aGlzLnJlc3VsdFBvbHlMaXN0LHQpfSxsYWJlbEluY29tcGxldGVOb2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfSxjb3B5UG9pbnRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmFyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9dGhpcy5ncmFwaC5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKTtpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19LGZpbmRSZXN1bHRBcmVhRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7aS5pc0FyZWEoKSYmIW4uaXNJbnRlcmlvckFyZWFFZGdlKCkmJmlpLmlzUmVzdWx0T2ZPcChpLmdldExvY2F0aW9uKDAsY24uUklHSFQpLGkuZ2V0TG9jYXRpb24oMSxjbi5SSUdIVCksdCkmJm4uc2V0SW5SZXN1bHQoITApfX0sY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5lZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCksaT1lLmdldERlcHRoKCk7aWYoIWkuaXNOdWxsKCkpe2kubm9ybWFsaXplKCk7Zm9yKHZhciByPTA7Mj5yO3IrKyluLmlzTnVsbChyKXx8IW4uaXNBcmVhKCl8fGkuaXNOdWxsKHIpfHwoMD09PWkuZ2V0RGVsdGEocik/bi50b0xpbmUocik6KGYuaXNUcnVlKCFpLmlzTnVsbChyLGNuLkxFRlQpLFwiZGVwdGggb2YgTEVGVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHIsY24uTEVGVCxpLmdldExvY2F0aW9uKHIsY24uTEVGVCkpLGYuaXNUcnVlKCFpLmlzTnVsbChyLGNuLlJJR0hUKSxcImRlcHRoIG9mIFJJR0hUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24ocixjbi5SSUdIVCxpLmdldExvY2F0aW9uKHIsY24uUklHSFQpKSkpfX19LGNvbXB1dGVMYWJlbGxpbmc6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLmFyZyl9dGhpcy5tZXJnZVN5bUxhYmVscygpLHRoaXMudXBkYXRlTm9kZUxhYmVsbGluZygpfSxsYWJlbEluY29tcGxldGVOb2RlczpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKTtuLmlzSXNvbGF0ZWQoKSYmKHQrKyxpLmlzTnVsbCgwKT90aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUobiwwKTp0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUobiwxKSksbi5nZXRFZGdlcygpLnVwZGF0ZUxhYmVsbGluZyhpKX19LGlzQ292ZXJlZEJ5QTpmdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5yZXN1bHRQb2x5TGlzdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGlpfX0pLGlpLm92ZXJsYXlPcD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IGlpKHQsZSkscj1pLmdldFJlc3VsdEdlb21ldHJ5KG4pO3JldHVybiByfSxpaS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLklOVEVSU0VDVElPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7dmFyIG49ZTtyZXR1cm4gaG4ubWFwKHQse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW01hcE9wXX0sbWFwOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyc2VjdGlvbihuKX19KX1yZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuSU5URVJTRUNUSU9OKX0saWkuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBpaS5jcmVhdGVFbXB0eVJlc3VsdChpaS5TWU1ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1yZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuU1lNRElGRkVSRU5DRSl9LGlpLnJlc3VsdERpbWVuc2lvbj1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5nZXREaW1lbnNpb24oKSxyPW4uZ2V0RGltZW5zaW9uKCkscz0tMTtzd2l0Y2godCl7Y2FzZSBpaS5JTlRFUlNFQ1RJT046cz1NYXRoLm1pbihpLHIpO2JyZWFrO2Nhc2UgaWkuVU5JT046cz1NYXRoLm1heChpLHIpO2JyZWFrO2Nhc2UgaWkuRElGRkVSRU5DRTpzPWk7YnJlYWs7Y2FzZSBpaS5TWU1ESUZGRVJFTkNFOnM9TWF0aC5tYXgoaSxyKX1yZXR1cm4gc30saWkuY3JlYXRlRW1wdHlSZXN1bHQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bnVsbDtzd2l0Y2goaWkucmVzdWx0RGltZW5zaW9uKHQsZSxuKSl7Y2FzZS0xOnI9aS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obmV3IEFycmF5KDApLmZpbGwobnVsbCkpO2JyZWFrO2Nhc2UgMDpyPWkuY3JlYXRlUG9pbnQoKTticmVhaztjYXNlIDE6cj1pLmNyZWF0ZUxpbmVTdHJpbmcoKTticmVhaztjYXNlIDI6cj1pLmNyZWF0ZVBvbHlnb24oKX1yZXR1cm4gcn0saWkuZGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmlzRW1wdHkoKT9paS5jcmVhdGVFbXB0eVJlc3VsdChpaS5ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk6ZS5pc0VtcHR5KCk/dC5jb3B5KCk6KHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxzaS5vdmVybGF5T3AodCxlLGlpLkRJRkZFUkVOQ0UpKX0saWkuaXNSZXN1bHRPZk9wPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0TG9jYXRpb24oMCksaT10LmdldExvY2F0aW9uKDEpO3JldHVybiBpaS5pc1Jlc3VsdE9mT3AobixpLGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07c3dpdGNoKHI9PT1MLkJPVU5EQVJZJiYocj1MLklOVEVSSU9SKSxzPT09TC5CT1VOREFSWSYmKHM9TC5JTlRFUklPUiksbyl7Y2FzZSBpaS5JTlRFUlNFQ1RJT046cmV0dXJuIHI9PT1MLklOVEVSSU9SJiZzPT09TC5JTlRFUklPUjtjYXNlIGlpLlVOSU9OOnJldHVybiByPT09TC5JTlRFUklPUnx8cz09PUwuSU5URVJJT1I7Y2FzZSBpaS5ESUZGRVJFTkNFOnJldHVybiByPT09TC5JTlRFUklPUiYmcyE9PUwuSU5URVJJT1I7Y2FzZSBpaS5TWU1ESUZGRVJFTkNFOnJldHVybiByPT09TC5JTlRFUklPUiYmcyE9PUwuSU5URVJJT1J8fHIhPT1MLklOVEVSSU9SJiZzPT09TC5JTlRFUklPUn1yZXR1cm4hMX19LGlpLklOVEVSU0VDVElPTj0xLGlpLlVOSU9OPTIsaWkuRElGRkVSRU5DRT0zLGlpLlNZTURJRkZFUkVOQ0U9NCxlKHJpLnByb3RvdHlwZSx7c2VsZlNuYXA6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEllKHQpLG49ZS5zbmFwVG8odCx0aGlzLnNuYXBUb2xlcmFuY2UpO3JldHVybiBufSxyZW1vdmVDb21tb25CaXRzOmZ1bmN0aW9uKHQpe3RoaXMuY2JyPW5ldyBTZSx0aGlzLmNici5hZGQodFswXSksdGhpcy5jYnIuYWRkKHRbMV0pO3ZhciBlPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiBlWzBdPXRoaXMuY2JyLnJlbW92ZUNvbW1vbkJpdHModFswXS5jb3B5KCkpLGVbMV09dGhpcy5jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzFdLmNvcHkoKSksZX0scHJlcGFyZVJlc3VsdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jYnIuYWRkQ29tbW9uQml0cyh0KSx0fSxnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnNuYXAodGhpcy5nZW9tKSxuPWlpLm92ZXJsYXlPcChlWzBdLGVbMV0sdCk7cmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChuKX0sY2hlY2tWYWxpZDpmdW5jdGlvbih0KXt0LmlzVmFsaWQoKXx8QS5vdXQucHJpbnRsbihcIlNuYXBwZWQgZ2VvbWV0cnkgaXMgaW52YWxpZFwiKX0sY29tcHV0ZVNuYXBUb2xlcmFuY2U6ZnVuY3Rpb24oKXt0aGlzLnNuYXBUb2xlcmFuY2U9SWUuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHRoaXMuZ2VvbVswXSx0aGlzLmdlb21bMV0pfSxzbmFwOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0KSxuPUllLnNuYXAoZVswXSxlWzFdLHRoaXMuc25hcFRvbGVyYW5jZSk7cmV0dXJuIG59LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHJpfX0pLHJpLm92ZXJsYXlPcD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IHJpKHQsZSk7cmV0dXJuIGkuZ2V0UmVzdWx0R2VvbWV0cnkobil9LHJpLnVuaW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJpLm92ZXJsYXlPcCh0LGUsaWkuVU5JT04pfSxyaS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5JTlRFUlNFQ1RJT04pfSxyaS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJpLm92ZXJsYXlPcCh0LGUsaWkuU1lNRElGRkVSRU5DRSl9LHJpLmRpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5ESUZGRVJFTkNFKX0sZShzaS5wcm90b3R5cGUse2dldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPW51bGwsbj0hMSxpPW51bGw7dHJ5e2U9aWkub3ZlcmxheU9wKHRoaXMuZ2VvbVswXSx0aGlzLmdlb21bMV0sdCk7dmFyIHI9ITA7ciYmKG49ITApfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGwpKXRocm93IHQ7aT10fWZpbmFsbHl7fWlmKCFuKXRyeXtlPXJpLm92ZXJsYXlPcCh0aGlzLmdlb21bMF0sdGhpcy5nZW9tWzFdLHQpfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBsP2k6dH1maW5hbGx5e31yZXR1cm4gZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gc2l9fSksc2kub3ZlcmxheU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgc2kodCxlKTtyZXR1cm4gaS5nZXRSZXN1bHRHZW9tZXRyeShuKX0sc2kudW5pb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gc2kub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LHNpLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLklOVEVSU0VDVElPTil9LHNpLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gc2kub3ZlcmxheU9wKHQsZSxpaS5TWU1ESUZGRVJFTkNFKX0sc2kuZGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLkRJRkZFUkVOQ0UpfSxlKG9pLnByb3RvdHlwZSx7YWRkUG9seWdvbjpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgZT1udWxsLG49MCxpPXRoaXMuaG9yaXpvbnRhbEJpc2VjdG9yKHQpO2lmKDA9PT1pLmdldExlbmd0aCgpKW49MCxlPWkuZ2V0Q29vcmRpbmF0ZSgpO2Vsc2V7dmFyIHI9c2kub3ZlcmxheU9wKGksdCxpaS5JTlRFUlNFQ1RJT04pLHM9dGhpcy53aWRlc3RHZW9tZXRyeShyKTtuPXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCksZT1vaS5jZW50cmUocy5nZXRFbnZlbG9wZUludGVybmFsKCkpfShudWxsPT09dGhpcy5pbnRlcmlvclBvaW50fHxuPnRoaXMubWF4V2lkdGgpJiYodGhpcy5pbnRlcmlvclBvaW50PWUsdGhpcy5tYXhXaWR0aD1uKX0sZ2V0SW50ZXJpb3JQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9yUG9pbnR9LHdpZGVzdEdlb21ldHJ5OmZ1bmN0aW9uIHQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZ0KXt2YXIgZT1hcmd1bWVudHNbMF07aWYoZS5pc0VtcHR5KCkpcmV0dXJuIGU7Zm9yKHZhciB0PWUuZ2V0R2VvbWV0cnlOKDApLG49MTtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyllLmdldEdlb21ldHJ5TihuKS5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKT50LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpJiYodD1lLmdldEdlb21ldHJ5TihuKSk7cmV0dXJuIHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgaT1hcmd1bWVudHNbMF07cmV0dXJuIGkgaW5zdGFuY2VvZiBmdD90aGlzLndpZGVzdEdlb21ldHJ5KGkpOml9fSxob3Jpem9udGFsQmlzZWN0b3I6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCksbj1haS5nZXRCaXNlY3RvclkodCk7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgZyhlLmdldE1pblgoKSxuKSxuZXcgZyhlLmdldE1heFgoKSxuKV0pfSxhZGQ6ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdClmb3IodmFyIGU9dCxuPTA7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4obikpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvaX19KSxvaS5jZW50cmU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKG9pLmF2Zyh0LmdldE1pblgoKSx0LmdldE1heFgoKSksb2kuYXZnKHQuZ2V0TWluWSgpLHQuZ2V0TWF4WSgpKSl9LG9pLmF2Zz1mdW5jdGlvbih0LGUpe3JldHVybih0K2UpLzJ9LGUoYWkucHJvdG90eXBlLHt1cGRhdGVJbnRlcnZhbDpmdW5jdGlvbih0KXt0PD10aGlzLmNlbnRyZVk/dD50aGlzLmxvWSYmKHRoaXMubG9ZPXQpOnQ+dGhpcy5jZW50cmVZJiZ0PHRoaXMuaGlZJiYodGhpcy5oaVk9dCl9LGdldEJpc2VjdG9yWTpmdW5jdGlvbigpe3RoaXMucHJvY2Vzcyh0aGlzLnBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCkpO2Zvcih2YXIgdD0wO3Q8dGhpcy5wb2x5LmdldE51bUludGVyaW9yUmluZygpO3QrKyl0aGlzLnByb2Nlc3ModGhpcy5wb2x5LmdldEludGVyaW9yUmluZ04odCkpO3ZhciBlPW9pLmF2Zyh0aGlzLmhpWSx0aGlzLmxvWSk7cmV0dXJuIGV9LHByb2Nlc3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj0wO248ZS5zaXplKCk7bisrKXt2YXIgaT1lLmdldFkobik7dGhpcy51cGRhdGVJbnRlcnZhbChpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFpfX0pLGFpLmdldEJpc2VjdG9yWT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgYWkodCk7cmV0dXJuIGUuZ2V0QmlzZWN0b3JZKCl9LG9pLlNhZmVCaXNlY3RvckZpbmRlcj1haSxlKHVpLnByb3RvdHlwZSx7YWRkRW5kcG9pbnRzOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkRW5kcG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpZm9yKHZhciBlPXQsbj0wO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXRoaXMuYWRkRW5kcG9pbnRzKGUuZ2V0R2VvbWV0cnlOKG4pKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBpPWFyZ3VtZW50c1swXTt0aGlzLmFkZChpWzBdKSx0aGlzLmFkZChpW2kubGVuZ3RoLTFdKX19LGdldEludGVyaW9yUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvclBvaW50fSxhZGRJbnRlcmlvcjpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBTdCl0aGlzLmFkZEludGVyaW9yKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpZm9yKHZhciBlPXQsbj0wO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXRoaXMuYWRkSW50ZXJpb3IoZS5nZXRHZW9tZXRyeU4obikpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSlmb3IodmFyIGk9YXJndW1lbnRzWzBdLG49MTtuPGkubGVuZ3RoLTE7bisrKXRoaXMuYWRkKGlbbl0pfSxhZGQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5kaXN0YW5jZSh0aGlzLmNlbnRyb2lkKTtlPHRoaXMubWluRGlzdGFuY2UmJih0aGlzLmludGVyaW9yUG9pbnQ9bmV3IGcodCksdGhpcy5taW5EaXN0YW5jZT1lKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdWl9fSksZShsaS5wcm90b3R5cGUse2dldEludGVyaW9yUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvclBvaW50fSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgTHQpdGhpcy5hZGQodC5nZXRDb29yZGluYXRlKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgZT10LG49MDtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5TihuKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWkuZGlzdGFuY2UodGhpcy5jZW50cm9pZCk7cjx0aGlzLm1pbkRpc3RhbmNlJiYodGhpcy5pbnRlcmlvclBvaW50PW5ldyBnKGkpLHRoaXMubWluRGlzdGFuY2U9cil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsaX19KSxlKGhpLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaGl9fSksaGkudG9EZWdyZWVzPWZ1bmN0aW9uKHQpe3JldHVybiAxODAqdC9NYXRoLlBJfSxoaS5ub3JtYWxpemU9ZnVuY3Rpb24odCl7Zm9yKDt0Pk1hdGguUEk7KXQtPWhpLlBJX1RJTUVTXzI7Zm9yKDt0PD0tTWF0aC5QSTspdCs9aGkuUElfVElNRVNfMjtyZXR1cm4gdH0saGkuYW5nbGU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmF0YW4yKHQueSx0LngpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1uLngtZS54LHI9bi55LWUueTtyZXR1cm4gTWF0aC5hdGFuMihyLGkpfX0saGkuaXNBY3V0ZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC54LWUueCxyPXQueS1lLnkscz1uLngtZS54LG89bi55LWUueSxhPWkqcytyKm87cmV0dXJuIGE+MH0saGkuaXNPYnR1c2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9bi54LWUueCxvPW4ueS1lLnksYT1pKnMrcipvO3JldHVybiAwPmF9LGhpLmludGVyaW9yQW5nbGU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWhpLmFuZ2xlKGUsdCkscj1oaS5hbmdsZShlLG4pO3JldHVybiBNYXRoLmFicyhyLWkpfSxoaS5ub3JtYWxpemVQb3NpdGl2ZT1mdW5jdGlvbih0KXtpZigwPnQpe2Zvcig7MD50Oyl0Kz1oaS5QSV9USU1FU18yO3Q+PWhpLlBJX1RJTUVTXzImJih0PTApfWVsc2V7Zm9yKDt0Pj1oaS5QSV9USU1FU18yOyl0LT1oaS5QSV9USU1FU18yOzA+dCYmKHQ9MCl9cmV0dXJuIHR9LGhpLmFuZ2xlQmV0d2Vlbj1mdW5jdGlvbih0LGUsbil7dmFyIGk9aGkuYW5nbGUoZSx0KSxyPWhpLmFuZ2xlKGUsbik7cmV0dXJuIGhpLmRpZmYoaSxyKX0saGkuZGlmZj1mdW5jdGlvbih0LGUpe3ZhciBuPW51bGw7cmV0dXJuIG49ZT50P2UtdDp0LWUsbj5NYXRoLlBJJiYobj0yKk1hdGguUEktbiksbn0saGkudG9SYWRpYW5zPWZ1bmN0aW9uKHQpe3JldHVybiB0Kk1hdGguUEkvMTgwfSxoaS5nZXRUdXJuPWZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5zaW4oZS10KTtyZXR1cm4gbj4wP2hpLkNPVU5URVJDTE9DS1dJU0U6MD5uP2hpLkNMT0NLV0lTRTpoaS5OT05FfSxoaS5hbmdsZUJldHdlZW5PcmllbnRlZD1mdW5jdGlvbih0LGUsbil7dmFyIGk9aGkuYW5nbGUoZSx0KSxyPWhpLmFuZ2xlKGUsbikscz1yLWk7cmV0dXJuIHM8PS1NYXRoLlBJP3MraGkuUElfVElNRVNfMjpzPk1hdGguUEk/cy1oaS5QSV9USU1FU18yOnN9LGhpLlBJX1RJTUVTXzI9MipNYXRoLlBJLGhpLlBJX09WRVJfMj1NYXRoLlBJLzIsaGkuUElfT1ZFUl80PU1hdGguUEkvNCxoaS5DT1VOVEVSQ0xPQ0tXSVNFPWhlLkNPVU5URVJDTE9DS1dJU0UsaGkuQ0xPQ0tXSVNFPWhlLkNMT0NLV0lTRSxoaS5OT05FPWhlLkNPTExJTkVBUixlKGNpLnByb3RvdHlwZSx7YXJlYTpmdW5jdGlvbigpe3JldHVybiBjaS5hcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sc2lnbmVkQXJlYTpmdW5jdGlvbigpe3JldHVybiBjaS5zaWduZWRBcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saW50ZXJwb2xhdGVaOmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBpKFwiU3VwcGxpZWQgcG9pbnQgaXMgbnVsbC5cIik7cmV0dXJuIGNpLmludGVycG9sYXRlWih0LHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sbG9uZ2VzdFNpZGVMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gY2kubG9uZ2VzdFNpZGVMZW5ndGgodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxpc0FjdXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmlzQWN1dGUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxjaXJjdW1jZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuY2lyY3VtY2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sYXJlYTNEOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmFyZWEzRCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGNlbnRyb2lkOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmNlbnRyb2lkKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saW5DZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuaW5DZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjaX19KSxjaS5hcmVhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnMoKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMil9LGNpLnNpZ25lZEFyZWE9ZnVuY3Rpb24odCxlLG4pe3JldHVybigobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzJ9LGNpLmRldD1mdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gdCppLWUqbn0sY2kuaW50ZXJwb2xhdGVaPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWUueCxzPWUueSxvPW4ueC1yLGE9aS54LXIsdT1uLnktcyxsPWkueS1zLGg9bypsLWEqdSxjPXQueC1yLGY9dC55LXMsZz0obCpjLWEqZikvaCxkPSgtdSpjK28qZikvaCxwPWUueitnKihuLnotZS56KStkKihpLnotZS56KTtyZXR1cm4gcH0sY2kubG9uZ2VzdFNpZGVMZW5ndGg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZGlzdGFuY2UoZSkscj1lLmRpc3RhbmNlKG4pLHM9bi5kaXN0YW5jZSh0KSxvPWk7cmV0dXJuIHI+byYmKG89cikscz5vJiYobz1zKSxvfSxjaS5pc0FjdXRlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGkuaXNBY3V0ZSh0LGUsbikmJmhpLmlzQWN1dGUoZSxuLHQpPyEhaGkuaXNBY3V0ZShuLHQsZSk6ITF9LGNpLmNpcmN1bWNlbnRyZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bi54LHI9bi55LHM9dC54LWksbz10LnktcixhPWUueC1pLHU9ZS55LXIsbD0yKmNpLmRldChzLG8sYSx1KSxoPWNpLmRldChvLHMqcytvKm8sdSxhKmErdSp1KSxjPWNpLmRldChzLHMqcytvKm8sYSxhKmErdSp1KSxmPWktaC9sLGQ9citjL2w7cmV0dXJuIG5ldyBnKGYsZCl9LGNpLnBlcnBlbmRpY3VsYXJCaXNlY3Rvcj1mdW5jdGlvbih0LGUpe3ZhciBuPWUueC10LngsaT1lLnktdC55LHI9bmV3IEYodC54K24vMix0LnkraS8yLDEpLHM9bmV3IEYodC54LWkrbi8yLHQueStuK2kvMiwxKTtyZXR1cm4gbmV3IEYocixzKX0sY2kuYW5nbGVCaXNlY3Rvcj1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5kaXN0YW5jZSh0KSxyPWUuZGlzdGFuY2Uobikscz1pLyhpK3IpLG89bi54LXQueCxhPW4ueS10LnksdT1uZXcgZyh0LngrcypvLHQueStzKmEpO3JldHVybiB1fSxjaS5hcmVhM0Q9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9ZS56LXQueixvPW4ueC10LngsYT1uLnktdC55LHU9bi56LXQueixsPXIqdS1zKmEsaD1zKm8taSp1LGM9aSphLXIqbyxmPWwqbCtoKmgrYypjLGc9TWF0aC5zcXJ0KGYpLzI7cmV0dXJuIGd9LGNpLmNlbnRyb2lkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT0odC54K2UueCtuLngpLzMscj0odC55K2UueStuLnkpLzM7cmV0dXJuIG5ldyBnKGkscil9LGNpLmluQ2VudHJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShuKSxzPXQuZGlzdGFuY2UoZSksbz1pK3IrcyxhPShpKnQueCtyKmUueCtzKm4ueCkvbyx1PShpKnQueStyKmUueStzKm4ueSkvbztyZXR1cm4gbmV3IGcoYSx1KX0sZShmaS5wcm90b3R5cGUse2dldFJhZGl1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLnJhZGl1c30sZ2V0RGlhbWV0ZXI6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMTpyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5jZW50cmUpfXZhciB0PXRoaXMuZXh0cmVtYWxQdHNbMF0sZT10aGlzLmV4dHJlbWFsUHRzWzFdO3JldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX0sZ2V0RXh0cmVtYWxQb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5leHRyZW1hbFB0c30sY29tcHV0ZUNpcmNsZVBvaW50czpmdW5jdGlvbigpe2lmKHRoaXMuaW5wdXQuaXNFbXB0eSgpKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7aWYoMT09PXRoaXMuaW5wdXQuZ2V0TnVtUG9pbnRzKCkpe3ZhciB0PXRoaXMuaW5wdXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1bbmV3IGcodFswXSldLG51bGx9dmFyIGU9dGhpcy5pbnB1dC5jb252ZXhIdWxsKCksbj1lLmdldENvb3JkaW5hdGVzKCksdD1uO2lmKG5bMF0uZXF1YWxzMkQobltuLmxlbmd0aC0xXSkmJih0PW5ldyBBcnJheShuLmxlbmd0aC0xKS5maWxsKG51bGwpLEguY29weURlZXAobiwwLHQsMCxuLmxlbmd0aC0xKSksdC5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9SC5jb3B5RGVlcCh0KSxudWxsO2Zvcih2YXIgaT1maS5sb3dlc3RQb2ludCh0KSxyPWZpLnBvaW50V2l0TWluQW5nbGVXaXRoWCh0LGkpLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89ZmkucG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudCh0LGkscik7aWYoaGkuaXNPYnR1c2UoaSxvLHIpKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPVtuZXcgZyhpKSxuZXcgZyhyKV0sbnVsbDtpZihoaS5pc09idHVzZShvLGkscikpaT1vO2Vsc2V7aWYoIWhpLmlzT2J0dXNlKG8scixpKSlyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1bbmV3IGcoaSksbmV3IGcociksbmV3IGcobyldLG51bGw7cj1vfX1mLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiTG9naWMgZmFpbHVyZSBpbiBNaW5pbXVtIEJvdW5kaW5nIENpcmNsZSBhbGdvcml0aG0hXCIpfSxjb21wdXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmV4dHJlbWFsUHRzP251bGw6KHRoaXMuY29tcHV0ZUNpcmNsZVBvaW50cygpLHRoaXMuY29tcHV0ZUNlbnRyZSgpLHZvaWQobnVsbCE9PXRoaXMuY2VudHJlJiYodGhpcy5yYWRpdXM9dGhpcy5jZW50cmUuZGlzdGFuY2UodGhpcy5leHRyZW1hbFB0c1swXSkpKSl9LGdldEZhcnRoZXN0UG9pbnRzOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuY2VudHJlKX12YXIgdD10aGlzLmV4dHJlbWFsUHRzWzBdLGU9dGhpcy5leHRyZW1hbFB0c1t0aGlzLmV4dHJlbWFsUHRzLmxlbmd0aC0xXTtyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCxlXSl9LGdldENpcmNsZTpmdW5jdGlvbigpe2lmKHRoaXMuY29tcHV0ZSgpLG51bGw9PT10aGlzLmNlbnRyZSlyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbigpO3ZhciB0PXRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuY2VudHJlKTtyZXR1cm4gMD09PXRoaXMucmFkaXVzP3Q6dC5idWZmZXIodGhpcy5yYWRpdXMpfSxnZXRDZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5jZW50cmV9LGNvbXB1dGVDZW50cmU6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDp0aGlzLmNlbnRyZT1udWxsO2JyZWFrO2Nhc2UgMTp0aGlzLmNlbnRyZT10aGlzLmV4dHJlbWFsUHRzWzBdO2JyZWFrO2Nhc2UgMjp0aGlzLmNlbnRyZT1uZXcgZygodGhpcy5leHRyZW1hbFB0c1swXS54K3RoaXMuZXh0cmVtYWxQdHNbMV0ueCkvMiwodGhpcy5leHRyZW1hbFB0c1swXS55K3RoaXMuZXh0cmVtYWxQdHNbMV0ueSkvMik7YnJlYWs7Y2FzZSAzOnRoaXMuY2VudHJlPWNpLmNpcmN1bWNlbnRyZSh0aGlzLmV4dHJlbWFsUHRzWzBdLHRoaXMuZXh0cmVtYWxQdHNbMV0sdGhpcy5leHRyZW1hbFB0c1syXSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmaX19KSxmaS5wb2ludFdpdE1pbkFuZ2xlV2l0aFg9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ci5NQVhfVkFMVUUsaT1udWxsLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89dFtzXTtpZihvIT09ZSl7dmFyIGE9by54LWUueCx1PW8ueS1lLnk7MD51JiYodT0tdSk7dmFyIGw9TWF0aC5zcXJ0KGEqYSt1KnUpLGg9dS9sO24+aCYmKG49aCxpPW8pfX1yZXR1cm4gaX0sZmkubG93ZXN0UG9pbnQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRbMF0sbj0xO248dC5sZW5ndGg7bisrKXRbbl0ueTxlLnkmJihlPXRbbl0pO3JldHVybiBlfSxmaS5wb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50PWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9ci5NQVhfVkFMVUUscz1udWxsLG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIGE9dFtvXTtpZihhIT09ZSYmYSE9PW4pe3ZhciB1PWhpLmFuZ2xlQmV0d2VlbihlLGEsbik7aT51JiYoaT11LHM9YSl9fXJldHVybiBzfSxlKGdpLnByb3RvdHlwZSx7Z2V0V2lkdGhDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMubWluV2lkdGhQdH0sZ2V0U3VwcG9ydGluZ1NlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMubWluQmFzZVNlZy5wMCx0aGlzLm1pbkJhc2VTZWcucDFdKX0sZ2V0RGlhbWV0ZXI6ZnVuY3Rpb24oKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSxudWxsPT09dGhpcy5taW5XaWR0aFB0KXJldHVybiB0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhudWxsKTt2YXIgdD10aGlzLm1pbkJhc2VTZWcucHJvamVjdCh0aGlzLm1pbldpZHRoUHQpO3JldHVybiB0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCx0aGlzLm1pbldpZHRoUHRdKX0sY29tcHV0ZVdpZHRoQ29udmV4OmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBUdD90aGlzLmNvbnZleEh1bGxQdHM9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpOnRoaXMuY29udmV4SHVsbFB0cz10LmdldENvb3JkaW5hdGVzKCksMD09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMubWluV2lkdGg9MCx0aGlzLm1pbldpZHRoUHQ9bnVsbCx0aGlzLm1pbkJhc2VTZWc9bnVsbCk6MT09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMubWluV2lkdGg9MCx0aGlzLm1pbldpZHRoUHQ9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMD10aGlzLmNvbnZleEh1bGxQdHNbMF0sdGhpcy5taW5CYXNlU2VnLnAxPXRoaXMuY29udmV4SHVsbFB0c1swXSk6Mj09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGh8fDM9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLm1pbldpZHRoPTAsdGhpcy5taW5XaWR0aFB0PXRoaXMuY29udmV4SHVsbFB0c1swXSx0aGlzLm1pbkJhc2VTZWcucDA9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMT10aGlzLmNvbnZleEh1bGxQdHNbMV0pOnRoaXMuY29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0aGlzLmNvbnZleEh1bGxQdHMpfSxjb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyOmZ1bmN0aW9uKHQpe3RoaXMubWluV2lkdGg9ci5NQVhfVkFMVUU7Zm9yKHZhciBlPTEsbj1uZXcgY2UsaT0wO2k8dC5sZW5ndGgtMTtpKyspbi5wMD10W2ldLG4ucDE9dFtpKzFdLGU9dGhpcy5maW5kTWF4UGVycERpc3RhbmNlKHQsbixlKX0sY29tcHV0ZU1pbmltdW1EaWFtZXRlcjpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLm1pbldpZHRoUHQpcmV0dXJuIG51bGw7aWYodGhpcy5pc0NvbnZleCl0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0aGlzLmlucHV0R2VvbSk7ZWxzZXt2YXIgdD1uZXcgbWUodGhpcy5pbnB1dEdlb20pLmdldENvbnZleEh1bGwoKTt0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0KX19LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLm1pbldpZHRofSxmaW5kTWF4UGVycERpc3RhbmNlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtuXSkscj1pLHM9bixvPXM7cj49aTspaT1yLHM9byxvPWdpLm5leHRJbmRleCh0LHMpLHI9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtvXSk7cmV0dXJuIGk8dGhpcy5taW5XaWR0aCYmKHRoaXMubWluUHRJbmRleD1zLHRoaXMubWluV2lkdGg9aSx0aGlzLm1pbldpZHRoUHQ9dFt0aGlzLm1pblB0SW5kZXhdLHRoaXMubWluQmFzZVNlZz1uZXcgY2UoZSkpLHN9LGdldE1pbmltdW1SZWN0YW5nbGU6ZnVuY3Rpb24oKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSwwPT09dGhpcy5taW5XaWR0aClyZXR1cm4gdGhpcy5taW5CYXNlU2VnLnAwLmVxdWFsczJEKHRoaXMubWluQmFzZVNlZy5wMSk/dGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMubWluQmFzZVNlZy5wMCk6dGhpcy5taW5CYXNlU2VnLnRvR2VvbWV0cnkodGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpKTtmb3IodmFyIHQ9dGhpcy5taW5CYXNlU2VnLnAxLngtdGhpcy5taW5CYXNlU2VnLnAwLngsZT10aGlzLm1pbkJhc2VTZWcucDEueS10aGlzLm1pbkJhc2VTZWcucDAueSxuPXIuTUFYX1ZBTFVFLGk9LXIuTUFYX1ZBTFVFLHM9ci5NQVhfVkFMVUUsbz0tci5NQVhfVkFMVUUsYT0wO2E8dGhpcy5jb252ZXhIdWxsUHRzLmxlbmd0aDthKyspe3ZhciB1PWdpLmNvbXB1dGVDKHQsZSx0aGlzLmNvbnZleEh1bGxQdHNbYV0pO3U+aSYmKGk9dSksbj51JiYobj11KTt2YXIgbD1naS5jb21wdXRlQygtZSx0LHRoaXMuY29udmV4SHVsbFB0c1thXSk7bD5vJiYobz1sKSxzPmwmJihzPWwpfXZhciBoPWdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxvKSxjPWdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxzKSxmPWdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LGkpLGc9Z2kuY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQsbiksZD1mLmxpbmVJbnRlcnNlY3Rpb24oaCkscD1nLmxpbmVJbnRlcnNlY3Rpb24oaCksdj1nLmxpbmVJbnRlcnNlY3Rpb24oYyksbT1mLmxpbmVJbnRlcnNlY3Rpb24oYykseT10aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhbZCxwLHYsbSxkXSk7cmV0dXJuIHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKHksbnVsbCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGdpfX0pLGdpLm5leHRJbmRleD1mdW5jdGlvbih0LGUpe3JldHVybiBlKyssZT49dC5sZW5ndGgmJihlPTApLGV9LGdpLmNvbXB1dGVDPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdCpuLnktZSpuLnh9LGdpLmdldE1pbmltdW1EaWFtZXRlcj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGdpKHQpLmdldERpYW1ldGVyKCl9LGdpLmdldE1pbmltdW1SZWN0YW5nbGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnaSh0KS5nZXRNaW5pbXVtUmVjdGFuZ2xlKCl9LGdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bnVsbCxyPW51bGw7cmV0dXJuIE1hdGguYWJzKGUpPk1hdGguYWJzKHQpPyhpPW5ldyBnKDAsbi9lKSxyPW5ldyBnKDEsbi9lLXQvZSkpOihpPW5ldyBnKG4vdCwwKSxyPW5ldyBnKG4vdC1lL3QsMSkpLG5ldyBjZShpLHIpfTt2YXIgY289T2JqZWN0LmZyZWV6ZSh7Q2VudHJvaWQ6Z2UsQ0dBbGdvcml0aG1zOmhlLENvbnZleEh1bGw6bWUsSW50ZXJpb3JQb2ludEFyZWE6b2ksSW50ZXJpb3JQb2ludExpbmU6dWksSW50ZXJpb3JQb2ludFBvaW50OmxpLFJvYnVzdExpbmVJbnRlcnNlY3RvcjphZSxNaW5pbXVtQm91bmRpbmdDaXJjbGU6ZmksTWluaW11bURpYW1ldGVyOmdpfSk7ZShkaS5wcm90b3R5cGUse2dldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwaSh0aGlzLmRpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5pbnB1dEdlb20pfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXtpZigwPj10KXRocm93IG5ldyBpKFwiVG9sZXJhbmNlIG11c3QgYmUgcG9zaXRpdmVcIik7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkaX19KSxkaS5kZW5zaWZ5UG9pbnRzPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bmV3IGNlLHI9bmV3IE4scz0wO3M8dC5sZW5ndGgtMTtzKyspe2kucDA9dFtzXSxpLnAxPXRbcysxXSxyLmFkZChpLnAwLCExKTt2YXIgbz1pLmdldExlbmd0aCgpLGE9TWF0aC50cnVuYyhvL2UpKzE7aWYoYT4xKWZvcih2YXIgdT1vL2EsbD0xO2E+bDtsKyspe3ZhciBoPWwqdS9vLGM9aS5wb2ludEFsb25nKGgpO24ubWFrZVByZWNpc2UoYyksci5hZGQoYywhMSl9fXJldHVybiByLmFkZCh0W3QubGVuZ3RoLTFdLCExKSxyLnRvQ29vcmRpbmF0ZUFycmF5KCl9LGRpLmRlbnNpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZGkodCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfSxoKHBpLHhlKSxlKHBpLnByb3RvdHlwZSx7dHJhbnNmb3JtTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49eGUucHJvdG90eXBlLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LHRyYW5zZm9ybVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIE90P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LHRyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC50b0Nvb3JkaW5hdGVBcnJheSgpLGk9ZGkuZGVuc2lmeVBvaW50cyhuLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UsZS5nZXRQcmVjaXNpb25Nb2RlbCgpKTtyZXR1cm4gZSBpbnN0YW5jZW9mIFN0JiYxPT09aS5sZW5ndGgmJihpPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKSx0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShpKX0sY3JlYXRlVmFsaWRBcmVhOmZ1bmN0aW9uKHQpe3JldHVybiB0LmJ1ZmZlcigwKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcGl9fSksZGkuRGVuc2lmeVRyYW5zZm9ybWVyPXBpO3ZhciBmbz1PYmplY3QuZnJlZXplKHtEZW5zaWZpZXI6ZGl9KTtlKHZpLnByb3RvdHlwZSx7ZmluZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2Rve2lmKG51bGw9PT1lKXJldHVybiBudWxsO2lmKGUuZGVzdCgpLmVxdWFsczJEKHQpKXJldHVybiBlO2U9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gbnVsbH0sZGVzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWd9LG9OZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bS5fbmV4dH0saW5zZXJ0OmZ1bmN0aW9uKHQpe2lmKHRoaXMub05leHQoKT09PXRoaXMpcmV0dXJuIHRoaXMuaW5zZXJ0QWZ0ZXIodCksbnVsbDt2YXIgZT10aGlzLmNvbXBhcmVUbyh0KSxuPXRoaXM7ZG97dmFyIGk9bi5vTmV4dCgpLHI9aS5jb21wYXJlVG8odCk7aWYociE9PWV8fGk9PT10aGlzKXJldHVybiBuLmluc2VydEFmdGVyKHQpLG51bGw7bj1pfXdoaWxlKG4hPT10aGlzKTtmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9LGluc2VydEFmdGVyOmZ1bmN0aW9uKHQpe2YuZXF1YWxzKHRoaXMuX29yaWcsdC5vcmlnKCkpO3ZhciBlPXRoaXMub05leHQoKTt0aGlzLl9zeW0uc2V0TmV4dCh0KSx0LnN5bSgpLnNldE5leHQoZSl9LGRlZ3JlZTpmdW5jdGlvbiB0KCl7dmFyIHQ9MCxlPXRoaXM7ZG8gdCsrLGU9ZS5vTmV4dCgpO3doaWxlKGUhPT10aGlzKTtyZXR1cm4gdH0sZXF1YWxzOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fb3JpZy5lcXVhbHMyRCh0KSYmdGhpcy5fc3ltLl9vcmlnLmVxdWFscyhlKX19LGRlbHRhWTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueS10aGlzLl9vcmlnLnl9LHN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW19LHByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLm5leHQoKS5fc3ltfSxjb21wYXJlQW5ndWxhckRpcmVjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmRlbHRhWCgpLG49dGhpcy5kZWx0YVkoKSxpPXQuZGVsdGFYKCkscj10LmRlbHRhWSgpO2lmKGU9PT1pJiZuPT09cilyZXR1cm4gMDt2YXIgcz1KZS5xdWFkcmFudChlLG4pLG89SmUucXVhZHJhbnQoaSxyKTtyZXR1cm4gcz5vPzE6bz5zPy0xOmhlLmNvbXB1dGVPcmllbnRhdGlvbih0Ll9vcmlnLHQuZGVzdCgpLHRoaXMuZGVzdCgpKX0scHJldk5vZGU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpczsyPT09dC5kZWdyZWUoKTspaWYodD10LnByZXYoKSx0PT09dGhpcylyZXR1cm4gbnVsbDtyZXR1cm4gdH0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10aGlzLmNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKGUpO3JldHVybiBufSxuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25leHR9LHNldFN5bTpmdW5jdGlvbih0KXt0aGlzLl9zeW09dH0sb3JpZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcmlnfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiSEUoXCIrdGhpcy5fb3JpZy54K1wiIFwiK3RoaXMuX29yaWcueStcIiwgXCIrdGhpcy5fc3ltLl9vcmlnLngrXCIgXCIrdGhpcy5fc3ltLl9vcmlnLnkrXCIpXCJ9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5fbmV4dD10fSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuc2V0U3ltKHQpLHQuc2V0U3ltKHRoaXMpLHRoaXMuc2V0TmV4dCh0KSx0LnNldE5leHQodGhpcyl9LGRlbHRhWDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueC10aGlzLl9vcmlnLnh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZpfX0pLHZpLmluaXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsIT09dC5fc3ltfHxudWxsIT09ZS5fc3ltfHxudWxsIT09dC5fbmV4dHx8bnVsbCE9PWUuX25leHQpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkVkZ2VzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXCIpO3JldHVybiB0LmluaXQoZSksdH0sdmkuY3JlYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IHZpKHQpLGk9bmV3IHZpKGUpO3JldHVybiBuLmluaXQoaSksbn0saChtaSx2aSksZShtaS5wcm90b3R5cGUse21hcms6ZnVuY3Rpb24oKXt0aGlzLl9pc01hcmtlZD0hMH0sc2V0TWFyazpmdW5jdGlvbih0KXt0aGlzLl9pc01hcmtlZD10fSxpc01hcmtlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc01hcmtlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbWl9fSksbWkuc2V0TWFya0JvdGg9ZnVuY3Rpb24odCxlKXt0LnNldE1hcmsoZSksdC5zeW0oKS5zZXRNYXJrKGUpfSxtaS5pc01hcmtlZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5pc01hcmtlZCgpfSxtaS5zZXRNYXJrPWZ1bmN0aW9uKHQsZSl7dC5zZXRNYXJrKGUpfSxtaS5tYXJrQm90aD1mdW5jdGlvbih0KXt0Lm1hcmsoKSx0LnN5bSgpLm1hcmsoKX0sbWkubWFyaz1mdW5jdGlvbih0KXt0Lm1hcmsoKX0sZSh5aS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5jcmVhdGUodCxlKTtudWxsIT09bj9uLmluc2VydChpKTp0aGlzLnZlcnRleE1hcC5wdXQodCxpKTt2YXIgcj10aGlzLnZlcnRleE1hcC5nZXQoZSk7cmV0dXJuIG51bGwhPT1yP3IuaW5zZXJ0KGkuc3ltKCkpOnRoaXMudmVydGV4TWFwLnB1dChlLGkuc3ltKCkpLGl9LGNyZWF0ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY3JlYXRlRWRnZSh0KSxpPXRoaXMuY3JlYXRlRWRnZShlKTtyZXR1cm4gdmkuaW5pdChuLGkpLG59LGNyZWF0ZUVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB2aSh0KX0sYWRkRWRnZTpmdW5jdGlvbih0LGUpe2lmKCF5aS5pc1ZhbGlkRWRnZSh0LGUpKXJldHVybiBudWxsO3ZhciBuPXRoaXMudmVydGV4TWFwLmdldCh0KSxpPW51bGw7aWYobnVsbCE9PW4mJihpPW4uZmluZChlKSksbnVsbCE9PWkpcmV0dXJuIGk7dmFyIHI9dGhpcy5pbnNlcnQodCxlLG4pO3JldHVybiByfSxnZXRWZXJ0ZXhFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleE1hcC52YWx1ZXMoKX0sZmluZEVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnZlcnRleE1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1uP251bGw6bi5maW5kKGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5aX19KSx5aS5pc1ZhbGlkRWRnZT1mdW5jdGlvbih0LGUpe3ZhciBuPWUuY29tcGFyZVRvKHQpO3JldHVybiAwIT09bn0saCh4aSxtaSksZSh4aS5wcm90b3R5cGUse3NldFN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5faXNTdGFydD0hMH0saXNTdGFydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1N0YXJ0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4aX19KSxoKEVpLHlpKSxlKEVpLnByb3RvdHlwZSx7Y3JlYXRlRWRnZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHhpKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFaX19KSxlKElpLnByb3RvdHlwZSx7YWRkTGluZTpmdW5jdGlvbih0KXt0aGlzLmxpbmVzLmFkZCh0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LnRvQ29vcmRpbmF0ZUFycmF5KCkpKX0sdXBkYXRlUmluZ1N0YXJ0RWRnZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5pc1N0YXJ0KCl8fCh0PXQuc3ltKCksdC5pc1N0YXJ0KCkpP251bGw9PT10aGlzLnJpbmdTdGFydEVkZ2U/KHRoaXMucmluZ1N0YXJ0RWRnZT10LG51bGwpOnZvaWQodC5vcmlnKCkuY29tcGFyZVRvKHRoaXMucmluZ1N0YXJ0RWRnZS5vcmlnKCkpPDAmJih0aGlzLnJpbmdTdGFydEVkZ2U9dCkpOm51bGx9LGdldFJlc3VsdDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yZXN1bHQmJnRoaXMuY29tcHV0ZVJlc3VsdCgpLHRoaXMucmVzdWx0fSxwcm9jZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPXQucHJldk5vZGUoKTtudWxsPT09ZSYmKGU9dCksdGhpcy5zdGFja0VkZ2VzKGUpLHRoaXMuYnVpbGRMaW5lcygpfSxidWlsZFJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IE4sbj10O2ZvcihlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaT09PXQpYnJlYWs7ZS5hZGQoaS5vcmlnKCkuY29weSgpLCExKSxuPWl9ZS5hZGQobi5kZXN0KCkuY29weSgpLCExKSx0aGlzLmFkZExpbmUoZSl9LGJ1aWxkTGluZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTixuPXQ7Zm9yKHRoaXMucmluZ1N0YXJ0RWRnZT1udWxsLG1pLm1hcmtCb3RoKG4pLGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXt0aGlzLnVwZGF0ZVJpbmdTdGFydEVkZ2Uobik7dmFyIGk9bi5uZXh0KCk7aWYoaT09PXQpcmV0dXJuIHRoaXMuYnVpbGRSaW5nKHRoaXMucmluZ1N0YXJ0RWRnZSksbnVsbDtlLmFkZChpLm9yaWcoKS5jb3B5KCksITEpLG49aSxtaS5tYXJrQm90aChuKX1lLmFkZChuLmRlc3QoKS5jb3B5KCksITEpLHRoaXMuc3RhY2tFZGdlcyhuLnN5bSgpKSx0aGlzLmFkZExpbmUoZSl9LHN0YWNrRWRnZXM6ZnVuY3Rpb24odCl7dmFyIGU9dDtkbyBtaS5pc01hcmtlZChlKXx8dGhpcy5ub2RlRWRnZVN0YWNrLmFkZChlKSxlPWUub05leHQoKTt3aGlsZShlIT09dCl9LGNvbXB1dGVSZXN1bHQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXRWZXJ0ZXhFZGdlcygpLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bWkuaXNNYXJrZWQobil8fHRoaXMucHJvY2VzcyhuKX10aGlzLnJlc3VsdD10aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLmxpbmVzKX0sYnVpbGRMaW5lczpmdW5jdGlvbigpe2Zvcig7IXRoaXMubm9kZUVkZ2VTdGFjay5lbXB0eSgpOyl7dmFyIHQ9dGhpcy5ub2RlRWRnZVN0YWNrLnBvcCgpO21pLmlzTWFya2VkKHQpfHx0aGlzLmJ1aWxkTGluZSh0KX19LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3QuYXBwbHkoe2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLmFkZCh0KX19KX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmFkZChpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciByPWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5mYWN0b3J5JiYodGhpcy5mYWN0b3J5PXIuZ2V0RmFjdG9yeSgpKTtmb3IodmFyIHM9ci5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxvPSExLG49MTtuPHMuc2l6ZSgpO24rKyl7dmFyIGE9dGhpcy5ncmFwaC5hZGRFZGdlKHMuZ2V0Q29vcmRpbmF0ZShuLTEpLHMuZ2V0Q29vcmRpbmF0ZShuKSk7bnVsbCE9PWEmJihvfHwoYS5zZXRTdGFydCgpLG89ITApKX19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBJaX19KSxJaS5kaXNzb2x2ZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgSWk7cmV0dXJuIGUuYWRkKHQpLGUuZ2V0UmVzdWx0KCl9O3ZhciBnbz1PYmplY3QuZnJlZXplKHtMaW5lRGlzc29sdmVyOklpfSk7ZShOaS5wcm90b3R5cGUse2hhc0NoaWxkcmVuOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7ND50O3QrKylpZihudWxsIT09dGhpcy5zdWJub2RlW3RdKXJldHVybiEwO3JldHVybiExfSxpc1BydW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuISh0aGlzLmhhc0NoaWxkcmVuKCl8fHRoaXMuaGFzSXRlbXMoKSl9LGFkZEFsbEl0ZW1zOmZ1bmN0aW9uKHQpe3QuYWRkQWxsKHRoaXMuaXRlbXMpO2Zvcih2YXIgZT0wOzQ+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmdGhpcy5zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fSxnZXROb2RlQ291bnQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ND5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrMX0sc2l6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDs0PmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0Kz10aGlzLnN1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCt0aGlzLml0ZW1zLnNpemUoKX0sYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmc6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO2UuYWRkQWxsKHRoaXMuaXRlbXMpO2Zvcih2YXIgbj0wOzQ+bjtuKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtuXSYmdGhpcy5zdWJub2RlW25dLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl9LHZpc2l0SXRlbXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5pdGVtcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLnZpc2l0SXRlbShuLm5leHQoKSl9LGhhc0l0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXRlbXMuaXNFbXB0eSgpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2Zvcih2YXIgbj0hMSxpPTA7ND5pO2krKylpZihudWxsIT09dGhpcy5zdWJub2RlW2ldJiYobj10aGlzLnN1Ym5vZGVbaV0ucmVtb3ZlKHQsZSkpKXt0aGlzLnN1Ym5vZGVbaV0uaXNQcnVuYWJsZSgpJiYodGhpcy5zdWJub2RlW2ldPW51bGwpO2JyZWFrfXJldHVybiBuP246bj10aGlzLml0ZW1zLnJlbW92ZShlKX0sdmlzaXQ6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO3RoaXMudmlzaXRJdGVtcyh0LGUpO2Zvcih2YXIgbj0wOzQ+bjtuKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtuXSYmdGhpcy5zdWJub2RlW25dLnZpc2l0KHQsZSl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGRlcHRoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzQ+ZTtlKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtlXSl7dmFyIG49dGhpcy5zdWJub2RlW2VdLmRlcHRoKCk7bj50JiYodD1uKX1yZXR1cm4gdCsxfSxpc0VtcHR5OmZ1bmN0aW9uIHQoKXt2YXIgdD0hMDt0aGlzLml0ZW1zLmlzRW1wdHkoKXx8KHQ9ITEpO2Zvcih2YXIgZT0wOzQ+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHRoaXMuc3Vibm9kZVtlXS5pc0VtcHR5KCl8fCh0PSExKSk7cmV0dXJuIHR9LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5pfX0pLE5pLmdldFN1Ym5vZGVJbmRleD1mdW5jdGlvbih0LGUsbil7dmFyIGk9LTE7cmV0dXJuIHQuZ2V0TWluWCgpPj1lJiYodC5nZXRNaW5ZKCk+PW4mJihpPTMpLHQuZ2V0TWF4WSgpPD1uJiYoaT0xKSksdC5nZXRNYXhYKCk8PWUmJih0LmdldE1pblkoKT49biYmKGk9MiksdC5nZXRNYXhZKCk8PW4mJihpPTApKSxpfSxDaS5leHBvbmVudD1mdW5jdGlvbih0KXtyZXR1cm4gU2koNjQsdCktMTAyM30sQ2kucG93ZXJPZjI9ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucG93KDIsdCl9LGUod2kucHJvdG90eXBlLHtnZXRMZXZlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxldmVsfSxjb21wdXRlS2V5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtmb3IodGhpcy5sZXZlbD13aS5jb21wdXRlUXVhZExldmVsKHQpLHRoaXMuZW52PW5ldyBDLHRoaXMuY29tcHV0ZUtleSh0aGlzLmxldmVsLHQpOyF0aGlzLmVudi5jb250YWlucyh0KTspdGhpcy5sZXZlbCs9MSx0aGlzLmNvbXB1dGVLZXkodGhpcy5sZXZlbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1DaS5wb3dlck9mMihlKTt0aGlzLnB0Lng9TWF0aC5mbG9vcihuLmdldE1pblgoKS9pKSppLHRoaXMucHQueT1NYXRoLmZsb29yKG4uZ2V0TWluWSgpL2kpKmksdGhpcy5lbnYuaW5pdCh0aGlzLnB0LngsdGhpcy5wdC54K2ksdGhpcy5wdC55LHRoaXMucHQueStpKX19LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW52fSxnZXRDZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGcoKHRoaXMuZW52LmdldE1pblgoKSt0aGlzLmVudi5nZXRNYXhYKCkpLzIsKHRoaXMuZW52LmdldE1pblkoKSt0aGlzLmVudi5nZXRNYXhZKCkpLzIpfSxnZXRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3aX19KSx3aS5jb21wdXRlUXVhZExldmVsPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCksaT1lPm4/ZTpuLHI9Q2kuZXhwb25lbnQoaSkrMTtyZXR1cm4gcn0saChMaSxOaSksZShMaS5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7dmFyIGU9TmkuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmV4LHRoaXMuY2VudHJleSk7aWYoLTE9PT1lKXJldHVybiB0aGlzO2lmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXTtyZXR1cm4gbi5maW5kKHQpfXJldHVybiB0aGlzfSxpc1NlYXJjaE1hdGNoOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVudi5pbnRlcnNlY3RzKHQpfSxnZXRTdWJub2RlOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dGhpcy5zdWJub2RlW3RdJiYodGhpcy5zdWJub2RlW3RdPXRoaXMuY3JlYXRlU3Vibm9kZSh0KSksdGhpcy5zdWJub2RlW3RdfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVudn0sZ2V0Tm9kZTpmdW5jdGlvbih0KXt2YXIgZT1OaS5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZXgsdGhpcy5jZW50cmV5KTtpZigtMSE9PWUpe3ZhciBuPXRoaXMuZ2V0U3Vibm9kZShlKTtyZXR1cm4gbi5nZXROb2RlKHQpfXJldHVybiB0aGlzfSxjcmVhdGVTdWJub2RlOmZ1bmN0aW9uKHQpe3ZhciBlPTAsbj0wLGk9MCxyPTA7c3dpdGNoKHQpe2Nhc2UgMDplPXRoaXMuZW52LmdldE1pblgoKSxuPXRoaXMuY2VudHJleCxpPXRoaXMuZW52LmdldE1pblkoKSxyPXRoaXMuY2VudHJleTticmVhaztjYXNlIDE6ZT10aGlzLmNlbnRyZXgsbj10aGlzLmVudi5nZXRNYXhYKCksaT10aGlzLmVudi5nZXRNaW5ZKCkscj10aGlzLmNlbnRyZXk7YnJlYWs7Y2FzZSAyOmU9dGhpcy5lbnYuZ2V0TWluWCgpLG49dGhpcy5jZW50cmV4LGk9dGhpcy5jZW50cmV5LHI9dGhpcy5lbnYuZ2V0TWF4WSgpO2JyZWFrO2Nhc2UgMzplPXRoaXMuY2VudHJleCxuPXRoaXMuZW52LmdldE1heFgoKSxpPXRoaXMuY2VudHJleSxyPXRoaXMuZW52LmdldE1heFkoKX12YXIgcz1uZXcgQyhlLG4saSxyKSxvPW5ldyBMaShzLHRoaXMubGV2ZWwtMSk7cmV0dXJuIG99LGluc2VydE5vZGU6ZnVuY3Rpb24odCl7Zi5pc1RydWUobnVsbD09PXRoaXMuZW52fHx0aGlzLmVudi5jb250YWlucyh0LmVudikpO3ZhciBlPU5pLmdldFN1Ym5vZGVJbmRleCh0LmVudix0aGlzLmNlbnRyZXgsdGhpcy5jZW50cmV5KTtpZih0LmxldmVsPT09dGhpcy5sZXZlbC0xKXRoaXMuc3Vibm9kZVtlXT10O2Vsc2V7dmFyIG49dGhpcy5jcmVhdGVTdWJub2RlKGUpO24uaW5zZXJ0Tm9kZSh0KSx0aGlzLnN1Ym5vZGVbZV09bn19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExpfX0pLExpLmNyZWF0ZU5vZGU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHdpKHQpLG49bmV3IExpKGUuZ2V0RW52ZWxvcGUoKSxlLmdldExldmVsKCkpO3JldHVybiBufSxMaS5jcmVhdGVFeHBhbmRlZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBDKGUpO251bGwhPT10JiZuLmV4cGFuZFRvSW5jbHVkZSh0LmVudik7dmFyIGk9TGkuY3JlYXRlTm9kZShuKTtyZXR1cm4gbnVsbCE9PXQmJmkuaW5zZXJ0Tm9kZSh0KSxpfSxlKFJpLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUml9fSksUmkuaXNaZXJvV2lkdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLXQ7aWYoMD09PW4pcmV0dXJuITA7dmFyIGk9TWF0aC5tYXgoTWF0aC5hYnModCksTWF0aC5hYnMoZSkpLHI9bi9pLHM9Q2kuZXhwb25lbnQocik7cmV0dXJuIHM8PVJpLk1JTl9CSU5BUllfRVhQT05FTlR9LFJpLk1JTl9CSU5BUllfRVhQT05FTlQ9LTUwLGgoVGksTmkpLGUoVGkucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1OaS5nZXRTdWJub2RlSW5kZXgodCxUaS5vcmlnaW4ueCxUaS5vcmlnaW4ueSk7aWYoLTE9PT1uKXJldHVybiB0aGlzLmFkZChlKSxudWxsO3ZhciBpPXRoaXMuc3Vibm9kZVtuXTtpZihudWxsPT09aXx8IWkuZ2V0RW52ZWxvcGUoKS5jb250YWlucyh0KSl7dmFyIHI9TGkuY3JlYXRlRXhwYW5kZWQoaSx0KTt0aGlzLnN1Ym5vZGVbbl09cn10aGlzLmluc2VydENvbnRhaW5lZCh0aGlzLnN1Ym5vZGVbbl0sdCxlKX0saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4hMH0saW5zZXJ0Q29udGFpbmVkOmZ1bmN0aW9uKHQsZSxuKXtmLmlzVHJ1ZSh0LmdldEVudmVsb3BlKCkuY29udGFpbnMoZSkpO3ZhciBpPVJpLmlzWmVyb1dpZHRoKGUuZ2V0TWluWCgpLGUuZ2V0TWF4WCgpKSxyPVJpLmlzWmVyb1dpZHRoKGUuZ2V0TWluWSgpLGUuZ2V0TWF4WSgpKSxzPW51bGw7cz1pfHxyP3QuZmluZChlKTp0LmdldE5vZGUoZSkscy5hZGQobil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRpfX0pLFRpLm9yaWdpbj1uZXcgZygwLDApLGUoUGkucHJvdG90eXBlLHtzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290LnNpemUoKTowfSxpbnNlcnQ6ZnVuY3Rpb24odCxlKXt0aGlzLmNvbGxlY3RTdGF0cyh0KTt2YXIgbj1QaS5lbnN1cmVFeHRlbnQodCx0aGlzLm1pbkV4dGVudCk7dGhpcy5yb290Lmluc2VydChuLGUpfSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgWW47cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlLmdldEl0ZW1zKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLnJvb3QudmlzaXQobixpKX19LHF1ZXJ5QWxsOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEk7cmV0dXJuIHRoaXMucm9vdC5hZGRBbGxJdGVtcyh0KSxcbnR9LHJlbW92ZTpmdW5jdGlvbih0LGUpe3ZhciBuPVBpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTtyZXR1cm4gdGhpcy5yb290LnJlbW92ZShuLGUpfSxjb2xsZWN0U3RhdHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpO2U8dGhpcy5taW5FeHRlbnQmJmU+MCYmKHRoaXMubWluRXh0ZW50PWUpO3ZhciBuPXQuZ2V0SGVpZ2h0KCk7bjx0aGlzLm1pbkV4dGVudCYmbj4wJiYodGhpcy5taW5FeHRlbnQ9bil9LGRlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290LmRlcHRoKCk6MH0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yb290fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltGZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUGl9fSksUGkuZW5zdXJlRXh0ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRNaW5YKCksaT10LmdldE1heFgoKSxyPXQuZ2V0TWluWSgpLHM9dC5nZXRNYXhZKCk7cmV0dXJuIG4hPT1pJiZyIT09cz90OihuPT09aSYmKG4tPWUvMixpPW4rZS8yKSxyPT09cyYmKHItPWUvMixzPXIrZS8yKSxuZXcgQyhuLGkscixzKSl9LFBpLnNlcmlhbFZlcnNpb25VSUQ9LTB4Njc4YjYwYzk2N2EyNTQwMDt2YXIgcG89T2JqZWN0LmZyZWV6ZSh7UXVhZHRyZWU6UGl9KSx2bz1PYmplY3QuZnJlZXplKHtTVFJ0cmVlOmtlfSksbW89T2JqZWN0LmZyZWV6ZSh7cXVhZHRyZWU6cG8sc3RydHJlZTp2b30pLHlvPVtcIlBvaW50XCIsXCJNdWx0aVBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJNdWx0aUxpbmVTdHJpbmdcIixcIlBvbHlnb25cIixcIk11bHRpUG9seWdvblwiXTtlKGJpLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT12b2lkIDA7ZT1cInN0cmluZ1wiPT10eXBlb2YgdD9KU09OLnBhcnNlKHQpOnQ7dmFyIG49ZS50eXBlO2lmKCF4b1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrZS50eXBlKTtyZXR1cm4tMSE9PXlvLmluZGV4T2Yobik/eG9bbl0uYXBwbHkodGhpcyxbZS5jb29yZGluYXRlc10pOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT1uP3hvW25dLmFwcGx5KHRoaXMsW2UuZ2VvbWV0cmllc10pOnhvW25dLmFwcGx5KHRoaXMsW2VdKX0sd3JpdGU6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRHZW9tZXRyeVR5cGUoKTtpZighRW9bZV0pdGhyb3cgbmV3IEVycm9yKFwiR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gRW9bZV0uYXBwbHkodGhpcyxbdF0pfX0pO3ZhciB4bz17RmVhdHVyZTpmdW5jdGlvbih0KXt2YXIgZT17fTtmb3IodmFyIG4gaW4gdCllW25dPXRbbl07aWYodC5nZW9tZXRyeSl7dmFyIGk9dC5nZW9tZXRyeS50eXBlO2lmKCF4b1tpXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrdC50eXBlKTtlLmdlb21ldHJ5PXRoaXMucmVhZCh0Lmdlb21ldHJ5KX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PXhvLmJib3guYXBwbHkodGhpcyxbdC5iYm94XSkpLGV9LEZlYXR1cmVDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXt9O2lmKHQuZmVhdHVyZXMpe2UuZmVhdHVyZXM9W107Zm9yKHZhciBuPTA7bjx0LmZlYXR1cmVzLmxlbmd0aDsrK24pZS5mZWF0dXJlcy5wdXNoKHRoaXMucmVhZCh0LmZlYXR1cmVzW25dKSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD10aGlzLnBhcnNlLmJib3guYXBwbHkodGhpcyxbdC5iYm94XSkpLGV9LGNvb3JkaW5hdGVzOmZ1bmN0aW9uIHQoZSl7Zm9yKHZhciB0PVtdLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIGk9ZVtuXTt0LnB1c2gobmV3IGcoaVswXSxpWzFdKSl9cmV0dXJuIHR9LGJib3g6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoW25ldyBnKHRbMF0sdFsxXSksbmV3IGcodFsyXSx0WzFdKSxuZXcgZyh0WzJdLHRbM10pLG5ldyBnKHRbMF0sdFszXSksbmV3IGcodFswXSx0WzFdKV0pfSxQb2ludDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZyh0WzBdLHRbMV0pO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKWUucHVzaCh4by5Qb2ludC5hcHBseSh0aGlzLFt0W25dXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXhvLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsW3RdKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlKX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKHhvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbdFtuXV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT14by5jb29yZGluYXRlcy5hcHBseSh0aGlzLFt0WzBdXSksbj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGUpLGk9W10scj0xO3I8dC5sZW5ndGg7KytyKXt2YXIgcz10W3JdLG89eG8uY29vcmRpbmF0ZXMuYXBwbHkodGhpcyxbc10pLGE9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhvKTtpLnB1c2goYSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixpKX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBpPXRbbl07ZS5wdXNoKHhvLlBvbHlnb24uYXBwbHkodGhpcyxbaV0pKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIGk9dFtuXTtlLnB1c2godGhpcy5yZWFkKGkpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0sRW89e2Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuW3QueCx0LnldfSxQb2ludDpmdW5jdGlvbih0KXt2YXIgZT1Fby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3QuZ2V0Q29vcmRpbmF0ZSgpXSk7cmV0dXJue3R5cGU6XCJQb2ludFwiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoOysrbil7dmFyIGk9dC5nZW9tZXRyaWVzW25dLHI9RW8uUG9pbnQuYXBwbHkodGhpcyxbaV0pO2UucHVzaChyLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9pbnRcIixjb29yZGluYXRlczplfX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj10LmdldENvb3JkaW5hdGVzKCksaT0wO2k8bi5sZW5ndGg7KytpKXt2YXIgcj1uW2ldO2UucHVzaChFby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3JdKSl9cmV0dXJue3R5cGU6XCJMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPUVvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbaV0pO2UucHVzaChyLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxQb2x5Z29uOmZ1bmN0aW9uKHQpe3ZhciBlPVtdLG49RW8uTGluZVN0cmluZy5hcHBseSh0aGlzLFt0LnNoZWxsXSk7ZS5wdXNoKG4uY29vcmRpbmF0ZXMpO2Zvcih2YXIgaT0wO2k8dC5ob2xlcy5sZW5ndGg7KytpKXt2YXIgcj10LmhvbGVzW2ldLHM9RW8uTGluZVN0cmluZy5hcHBseSh0aGlzLFtyXSk7ZS5wdXNoKHMuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7KytuKXt2YXIgaT10Lmdlb21ldHJpZXNbbl0scj1Fby5Qb2x5Z29uLmFwcGx5KHRoaXMsW2ldKTtlLnB1c2goci5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvbHlnb25cIixjb29yZGluYXRlczplfX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoOysrbil7dmFyIGk9dC5nZW9tZXRyaWVzW25dLHI9aS5nZXRHZW9tZXRyeVR5cGUoKTtlLnB1c2goRW9bcl0uYXBwbHkodGhpcyxbaV0pKX1yZXR1cm57dHlwZTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLGdlb21ldHJpZXM6ZX19fTtlKE9pLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnBhcnNlci5yZWFkKHQpO3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsLmdldFR5cGUoKT09PWVlLkZJWEVEJiZ0aGlzLnJlZHVjZVByZWNpc2lvbihlKSxlfSxyZWR1Y2VQcmVjaXNpb246ZnVuY3Rpb24odCl7dmFyIGUsbjtpZih0LmNvb3JkaW5hdGUpdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0LmNvb3JkaW5hdGUpO2Vsc2UgaWYodC5wb2ludHMpZm9yKGU9MCxuPXQucG9pbnRzLmxlbmd0aDtuPmU7ZSsrKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5wb2ludHNbZV0pO2Vsc2UgaWYodC5nZW9tZXRyaWVzKWZvcihlPTAsbj10Lmdlb21ldHJpZXMubGVuZ3RoO24+ZTtlKyspdGhpcy5yZWR1Y2VQcmVjaXNpb24odC5nZW9tZXRyaWVzW2VdKX19KSxlKF9pLnByb3RvdHlwZSx7d3JpdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfX0pLGUoTWkucHJvdG90eXBlLHtyZWFkOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucGFyc2VyLnJlYWQodCk7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWwuZ2V0VHlwZSgpPT09ZWUuRklYRUQmJnRoaXMucmVkdWNlUHJlY2lzaW9uKGUpLGV9LHJlZHVjZVByZWNpc2lvbjpmdW5jdGlvbih0KXtpZih0LmNvb3JkaW5hdGUpdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0LmNvb3JkaW5hdGUpO2Vsc2UgaWYodC5wb2ludHMpZm9yKHZhciBlPTAsbj10LnBvaW50cy5jb29yZGluYXRlcy5sZW5ndGg7bj5lO2UrKyl0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHQucG9pbnRzLmNvb3JkaW5hdGVzW2VdKTtlbHNlIGlmKHQuZ2VvbWV0cmllcylmb3IodmFyIGk9MCxyPXQuZ2VvbWV0cmllcy5sZW5ndGg7cj5pO2krKyl0aGlzLnJlZHVjZVByZWNpc2lvbih0Lmdlb21ldHJpZXNbaV0pfX0pLGUoQWkucHJvdG90eXBlLHtyZWFkOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygb2wuZ2VvbS5Qb2ludD90aGlzLmNvbnZlcnRGcm9tUG9pbnQodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5MaW5lYXJSaW5nP3RoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLlBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTXVsdGlQb2ludD90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2ludCh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5NdWx0aUxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5NdWx0aVBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9seWdvbih0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24/dGhpcy5jb252ZXJ0RnJvbUNvbGxlY3Rpb24odCk6dm9pZCAwfSxjb252ZXJ0RnJvbVBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQobmV3IGcoZVswXSxlWzFdKSl9LGNvbnZlcnRGcm9tTGluZVN0cmluZzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyh0WzBdLHRbMV0pfSkpfSxjb252ZXJ0RnJvbUxpbmVhclJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodFswXSx0WzFdKX0pKX0sY29udmVydEZyb21Qb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldExpbmVhclJpbmdzKCksbj1udWxsLGk9W10scj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgcz10aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyhlW3JdKTswPT09cj9uPXM6aS5wdXNoKHMpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4saSl9LGNvbnZlcnRGcm9tTXVsdGlQb2ludDpmdW5jdGlvbih0KXt2YXIgZT10LmdldFBvaW50cygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX0sY29udmVydEZyb21NdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRMaW5lU3RyaW5ncygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCl9LHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9LGNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0UG9seWdvbnMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfSxjb252ZXJ0RnJvbUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRHZW9tZXRyaWVzKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlYWQodCl9LHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9LHdyaXRlOmZ1bmN0aW9uKHQpe3JldHVyblwiUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2ludCh0LmdldENvb3JkaW5hdGUoKSk6XCJMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZVN0cmluZyh0KTpcIkxpbmVhclJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lYXJSaW5nKHQpOlwiUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvbHlnb24odCk6XCJNdWx0aVBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2ludCh0KTpcIk11bHRpTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpTGluZVN0cmluZyh0KTpcIk11bHRpUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9seWdvbih0KTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0NvbGxlY3Rpb24odCk6dm9pZCAwfSxjb252ZXJ0VG9Qb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IG9sLmdlb20uUG9pbnQoW3QueCx0LnldKX0sY29udmVydFRvTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50cy5jb29yZGluYXRlcy5tYXAoRGkpO3JldHVybiBuZXcgb2wuZ2VvbS5MaW5lU3RyaW5nKGUpfSxjb252ZXJ0VG9MaW5lYXJSaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXQucG9pbnRzLmNvb3JkaW5hdGVzLm1hcChEaSk7cmV0dXJuIG5ldyBvbC5nZW9tLkxpbmVhclJpbmcoZSl9LGNvbnZlcnRUb1BvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVt0LnNoZWxsLnBvaW50cy5jb29yZGluYXRlcy5tYXAoRGkpXSxuPTA7bjx0LmhvbGVzLmxlbmd0aDtuKyspZS5wdXNoKHQuaG9sZXNbbl0ucG9pbnRzLmNvb3JkaW5hdGVzLm1hcChEaSkpO3JldHVybiBuZXcgb2wuZ2VvbS5Qb2x5Z29uKGUpfSxjb252ZXJ0VG9NdWx0aVBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgb2wuZ2VvbS5NdWx0aVBvaW50KHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoRGkpKX0sY29udmVydFRvTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQuZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyBvbC5nZW9tLk11bHRpTGluZVN0cmluZyhlKX0sY29udmVydFRvTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQuZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyBvbC5nZW9tLk11bHRpUG9seWdvbihlKX0sY29udmVydFRvQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDtuKyspe3ZhciBpPXQuZ2VvbWV0cmllc1tuXTtlLnB1c2godGhpcy53cml0ZShpKSl9cmV0dXJuIG5ldyBvbC5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbihlKX19KTt2YXIgSW89T2JqZWN0LmZyZWV6ZSh7R2VvSlNPTlJlYWRlcjpPaSxHZW9KU09OV3JpdGVyOl9pLE9MM1BhcnNlcjpBaSxXS1RSZWFkZXI6TWksV0tUV3JpdGVyOnNlfSk7ZShGaS5wcm90b3R5cGUse3Jlc2NhbGU6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5yZXNjYWxlKG4uZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgaT1hcmd1bWVudHNbMF0scj1udWxsLHM9bnVsbDsyPT09aS5sZW5ndGgmJihyPW5ldyBnKGlbMF0pLHM9bmV3IGcoaVsxXSkpO2Zvcih2YXIgZT0wO2U8aS5sZW5ndGg7ZSsrKWlbZV0ueD1pW2VdLngvdGhpcy5zY2FsZUZhY3Rvcit0aGlzLm9mZnNldFgsaVtlXS55PWlbZV0ueS90aGlzLnNjYWxlRmFjdG9yK3RoaXMub2Zmc2V0WTsyPT09aS5sZW5ndGgmJmlbMF0uZXF1YWxzMkQoaVsxXSkmJkEub3V0LnByaW50bG4oaSl9fSxzY2FsZTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmFkZChuZXcgS2UodGhpcy5zY2FsZShpLmdldENvb3JkaW5hdGVzKCkpLGkuZ2V0RGF0YSgpKSl9cmV0dXJuIGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciByPWFyZ3VtZW50c1swXSxzPW5ldyBBcnJheShyLmxlbmd0aCkuZmlsbChudWxsKSxuPTA7bjxyLmxlbmd0aDtuKyspc1tuXT1uZXcgZyhNYXRoLnJvdW5kKChyW25dLngtdGhpcy5vZmZzZXRYKSp0aGlzLnNjYWxlRmFjdG9yKSxNYXRoLnJvdW5kKChyW25dLnktdGhpcy5vZmZzZXRZKSp0aGlzLnNjYWxlRmFjdG9yKSxyW25dLnopO3ZhciBvPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHMocyk7cmV0dXJuIG99fSxpc0ludGVnZXJQcmVjaXNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMuc2NhbGVGYWN0b3J9LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe3ZhciB0PXRoaXMubm9kZXIuZ2V0Tm9kZWRTdWJzdHJpbmdzKCk7cmV0dXJuIHRoaXMuaXNTY2FsZWQmJnRoaXMucmVzY2FsZSh0KSx0fSxjb21wdXRlTm9kZXM6ZnVuY3Rpb24odCl7dmFyIGU9dDt0aGlzLmlzU2NhbGVkJiYoZT10aGlzLnNjYWxlKHQpKSx0aGlzLm5vZGVyLmNvbXB1dGVOb2RlcyhlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdG5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGaX19KTt2YXIgTm89T2JqZWN0LmZyZWV6ZSh7TUNJbmRleE5vZGVyOm5uLFNjYWxlZE5vZGVyOkZpLFNlZ21lbnRTdHJpbmc6YmV9KTtlKEdpLnByb3RvdHlwZSx7aXNTaW1wbGVNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO2Zvcih2YXIgZT1uZXcgYXQsbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10LmdldEdlb21ldHJ5TihuKSxyPWkuZ2V0Q29vcmRpbmF0ZSgpO2lmKGUuY29udGFpbnMocikpcmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249ciwhMTtlLmFkZChyKX1yZXR1cm4hMH0saXNTaW1wbGVQb2x5Z29uYWw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWtuLmdldExpbmVzKHQpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoIXRoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeShpKSlyZXR1cm4hMX1yZXR1cm4hMH0saGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBydCxuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPShpLmdldE1heGltdW1TZWdtZW50SW5kZXgoKSxpLmlzQ2xvc2VkKCkpLHM9aS5nZXRDb29yZGluYXRlKDApO3RoaXMuYWRkRW5kcG9pbnQoZSxzLHIpO3ZhciBvPWkuZ2V0Q29vcmRpbmF0ZShpLmdldE51bVBvaW50cygpLTEpO3RoaXMuYWRkRW5kcG9pbnQoZSxvLHIpfWZvcih2YXIgbj1lLnZhbHVlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgYT1uLm5leHQoKTtpZihhLmlzQ2xvc2VkJiYyIT09YS5kZWdyZWUpcmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249YS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9LGdldE5vblNpbXBsZUxvY2F0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb259LGlzU2ltcGxlTGluZWFyR2VvbWV0cnk6ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7dmFyIGU9bmV3ICRuKDAsdCksbj1uZXcgYWUsaT1lLmNvbXB1dGVTZWxmTm9kZXMobiwhMCk7cmV0dXJuIGkuaGFzSW50ZXJzZWN0aW9uKCk/aS5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5ub25TaW1wbGVMb2NhdGlvbj1pLmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOnRoaXMuaGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSk/ITE6IXRoaXMuaXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yfHwhdGhpcy5oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbihlKTohMH0saGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpLHI9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZighcy5pc0VuZFBvaW50KGkpKXJldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPXMuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfSxhZGRFbmRwb2ludDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXQoZSk7bnVsbD09PWkmJihpPW5ldyBxaShlKSx0LnB1dChlLGkpKSxpLmFkZEVuZHBvaW50KG4pfSxjb21wdXRlU2ltcGxlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPW51bGwsdC5pc0VtcHR5KCk/ITA6dCBpbnN0YW5jZW9mIFN0P3RoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KTp0IGluc3RhbmNlb2YgZ3Q/dGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpOnQgaW5zdGFuY2VvZiBQdD90aGlzLmlzU2ltcGxlTXVsdGlQb2ludCh0KTpSKHQsUnQpP3RoaXMuaXNTaW1wbGVQb2x5Z29uYWwodCk6dCBpbnN0YW5jZW9mIGZ0P3RoaXMuaXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCk6ITB9LGlzU2ltcGxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249bnVsbCx0aGlzLmNvbXB1dGVTaW1wbGUodGhpcy5pbnB1dEdlb20pfSxpc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuY29tcHV0ZVNpbXBsZShuKSlyZXR1cm4hMX1yZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR2l9fSksZShxaS5wcm90b3R5cGUse2FkZEVuZHBvaW50OmZ1bmN0aW9uKHQpe3RoaXMuZGVncmVlKyssdGhpcy5pc0Nsb3NlZHw9dH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxaX19KSxHaS5FbmRwb2ludEluZm89cWksZShCaS5wcm90b3R5cGUse2dldEVuZENhcFN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kQ2FwU3R5bGV9LGlzU2luZ2xlU2lkZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNTaW5nbGVTaWRlZH0sc2V0UXVhZHJhbnRTZWdtZW50czpmdW5jdGlvbih0KXt0aGlzLnF1YWRyYW50U2VnbWVudHM9dCwwPT09dGhpcy5xdWFkcmFudFNlZ21lbnRzJiYodGhpcy5qb2luU3R5bGU9QmkuSk9JTl9CRVZFTCksdGhpcy5xdWFkcmFudFNlZ21lbnRzPDAmJih0aGlzLmpvaW5TdHlsZT1CaS5KT0lOX01JVFJFLHRoaXMubWl0cmVMaW1pdD1NYXRoLmFicyh0aGlzLnF1YWRyYW50U2VnbWVudHMpKSwwPj10JiYodGhpcy5xdWFkcmFudFNlZ21lbnRzPTEpLHRoaXMuam9pblN0eWxlIT09QmkuSk9JTl9ST1VORCYmKHRoaXMucXVhZHJhbnRTZWdtZW50cz1CaS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTKX0sZ2V0Sm9pblN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pblN0eWxlfSxzZXRKb2luU3R5bGU6ZnVuY3Rpb24odCl7dGhpcy5qb2luU3R5bGU9dH0sc2V0U2ltcGxpZnlGYWN0b3I6ZnVuY3Rpb24odCl7dGhpcy5zaW1wbGlmeUZhY3Rvcj0wPnQ/MDp0fSxnZXRTaW1wbGlmeUZhY3RvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpbXBsaWZ5RmFjdG9yfSxnZXRRdWFkcmFudFNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucXVhZHJhbnRTZWdtZW50c30sc2V0RW5kQ2FwU3R5bGU6ZnVuY3Rpb24odCl7dGhpcy5lbmRDYXBTdHlsZT10fSxnZXRNaXRyZUxpbWl0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWl0cmVMaW1pdH0sc2V0TWl0cmVMaW1pdDpmdW5jdGlvbih0KXt0aGlzLm1pdHJlTGltaXQ9dH0sc2V0U2luZ2xlU2lkZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNTaW5nbGVTaWRlZD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCaX19KSxCaS5idWZmZXJEaXN0YW5jZUVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguUEkvMi90O3JldHVybiAxLU1hdGguY29zKGUvMil9LEJpLkNBUF9ST1VORD0xLEJpLkNBUF9GTEFUPTIsQmkuQ0FQX1NRVUFSRT0zLEJpLkpPSU5fUk9VTkQ9MSxCaS5KT0lOX01JVFJFPTIsQmkuSk9JTl9CRVZFTD0zLEJpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM9OCxCaS5ERUZBVUxUX01JVFJFX0xJTUlUPTUsQmkuREVGQVVMVF9TSU1QTElGWV9GQUNUT1I9LjAxLGUoemkucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWluQ29vcmR9LGdldFJpZ2h0bW9zdFNpZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKTtyZXR1cm4gMD5uJiYobj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlLTEpKSwwPm4mJih0aGlzLm1pbkNvb3JkPW51bGwsdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCkpLG59LGZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2YuaXNUcnVlKHRoaXMubWluSW5kZXg+MCYmdGhpcy5taW5JbmRleDx0Lmxlbmd0aCxcInJpZ2h0bW9zdCBwb2ludCBleHBlY3RlZCB0byBiZSBpbnRlcmlvciB2ZXJ0ZXggb2YgZWRnZVwiKTt2YXIgZT10W3RoaXMubWluSW5kZXgtMV0sbj10W3RoaXMubWluSW5kZXgrMV0saT1oZS5jb21wdXRlT3JpZW50YXRpb24odGhpcy5taW5Db29yZCxuLGUpLHI9ITE7ZS55PHRoaXMubWluQ29vcmQueSYmbi55PHRoaXMubWluQ29vcmQueSYmaT09PWhlLkNPVU5URVJDTE9DS1dJU0U/cj0hMDplLnk+dGhpcy5taW5Db29yZC55JiZuLnk+dGhpcy5taW5Db29yZC55JiZpPT09aGUuQ0xPQ0tXSVNFJiYocj0hMCksciYmKHRoaXMubWluSW5kZXg9dGhpcy5taW5JbmRleC0xKX0sZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0RWRnZSgpLGk9bi5nZXRDb29yZGluYXRlcygpO2lmKDA+ZXx8ZSsxPj1pLmxlbmd0aClyZXR1cm4tMTtpZihpW2VdLnk9PT1pW2UrMV0ueSlyZXR1cm4tMTt2YXIgcj1jbi5MRUZUO3JldHVybiBpW2VdLnk8aVtlKzFdLnkmJihyPWNuLlJJR0hUKSxyfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3JpZW50ZWREZX0sY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLG49MDtuPGUubGVuZ3RoLTE7bisrKShudWxsPT09dGhpcy5taW5Db29yZHx8ZVtuXS54PnRoaXMubWluQ29vcmQueCkmJih0aGlzLm1pbkRlPXQsdGhpcy5taW5JbmRleD1uLHRoaXMubWluQ29vcmQ9ZVtuXSl9LGZpbmRSaWdodG1vc3RFZGdlQXROb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5taW5EZS5nZXROb2RlKCksZT10LmdldEVkZ2VzKCk7dGhpcy5taW5EZT1lLmdldFJpZ2h0bW9zdEVkZ2UoKSx0aGlzLm1pbkRlLmlzRm9yd2FyZCgpfHwodGhpcy5taW5EZT10aGlzLm1pbkRlLmdldFN5bSgpLHRoaXMubWluSW5kZXg9dGhpcy5taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSl9LGZpbmRFZGdlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmlzRm9yd2FyZCgpJiZ0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZShuKX1mLmlzVHJ1ZSgwIT09dGhpcy5taW5JbmRleHx8dGhpcy5taW5Db29yZC5lcXVhbHModGhpcy5taW5EZS5nZXRDb29yZGluYXRlKCkpLFwiaW5jb25zaXN0ZW5jeSBpbiByaWdodG1vc3QgcHJvY2Vzc2luZ1wiKSwwPT09dGhpcy5taW5JbmRleD90aGlzLmZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCk6dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCksdGhpcy5vcmllbnRlZERlPXRoaXMubWluRGU7dmFyIGk9dGhpcy5nZXRSaWdodG1vc3RTaWRlKHRoaXMubWluRGUsdGhpcy5taW5JbmRleCk7aT09PWNuLkxFRlQmJih0aGlzLm9yaWVudGVkRGU9dGhpcy5taW5EZS5nZXRTeW0oKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHppfX0pLFZpLnByb3RvdHlwZS5hZGRMYXN0PWZ1bmN0aW9uKHQpe3RoaXMuYXJyYXlfLnB1c2godCl9LFZpLnByb3RvdHlwZS5yZW1vdmVGaXJzdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5zaGlmdCgpfSxWaS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxlKGtpLnByb3RvdHlwZSx7Y2xlYXJWaXNpdGVkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5zZXRWaXNpdGVkKCExKX19LGdldFJpZ2h0bW9zdENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodE1vc3RDb29yZH0sY29tcHV0ZU5vZGVEZXB0aDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5pc1Zpc2l0ZWQoKXx8aS5nZXRTeW0oKS5pc1Zpc2l0ZWQoKSl7ZT1pO2JyZWFrfX1pZihudWxsPT09ZSl0aHJvdyBuZXcgc24oXCJ1bmFibGUgdG8gZmluZCBlZGdlIHRvIGNvbXB1dGUgZGVwdGhzIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKTt0LmdldEVkZ2VzKCkuY29tcHV0ZURlcHRocyhlKTtmb3IodmFyIG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldFZpc2l0ZWQoITApLHRoaXMuY29weVN5bURlcHRocyhpKX19LGNvbXB1dGVEZXB0aDpmdW5jdGlvbih0KXt0aGlzLmNsZWFyVmlzaXRlZEVkZ2VzKCk7dmFyIGU9dGhpcy5maW5kZXIuZ2V0RWRnZSgpO2UuZ2V0Tm9kZSgpLGUuZ2V0TGFiZWwoKTtlLnNldEVkZ2VEZXB0aHMoY24uUklHSFQsdCksdGhpcy5jb3B5U3ltRGVwdGhzKGUpLHRoaXMuY29tcHV0ZURlcHRocyhlKX0sY3JlYXRlOmZ1bmN0aW9uKHQpe3RoaXMuYWRkUmVhY2hhYmxlKHQpLHRoaXMuZmluZGVyLmZpbmRFZGdlKHRoaXMuZGlyRWRnZUxpc3QpLHRoaXMucmlnaHRNb3N0Q29vcmQ9dGhpcy5maW5kZXIuZ2V0Q29vcmRpbmF0ZSgpfSxmaW5kUmVzdWx0RWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXREZXB0aChjbi5SSUdIVCk+PTEmJmUuZ2V0RGVwdGgoY24uTEVGVCk8PTAmJiFlLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZlLnNldEluUmVzdWx0KCEwKX19LGNvbXB1dGVEZXB0aHM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEosbj1uZXcgVmksaT10LmdldE5vZGUoKTtmb3Iobi5hZGRMYXN0KGkpLGUuYWRkKGkpLHQuc2V0VmlzaXRlZCghMCk7IW4uaXNFbXB0eSgpOyl7dmFyIHI9bi5yZW1vdmVGaXJzdCgpO2UuYWRkKHIpLHRoaXMuY29tcHV0ZU5vZGVEZXB0aChyKTtmb3IodmFyIHM9ci5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKSxhPW8uZ2V0U3ltKCk7aWYoIWEuaXNWaXNpdGVkKCkpe3ZhciB1PWEuZ2V0Tm9kZSgpO2UuY29udGFpbnModSl8fChuLmFkZExhc3QodSksZS5hZGQodSkpfX19fSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5yaWdodE1vc3RDb29yZC54PGUucmlnaHRNb3N0Q29vcmQueD8tMTp0aGlzLnJpZ2h0TW9zdENvb3JkLng+ZS5yaWdodE1vc3RDb29yZC54PzE6MH0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5lbnYpe2Zvcih2YXIgdD1uZXcgQyxlPXRoaXMuZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKSxyPTA7cjxpLmxlbmd0aC0xO3IrKyl0LmV4cGFuZFRvSW5jbHVkZShpW3JdKTt0aGlzLmVudj10fXJldHVybiB0aGlzLmVudn0sYWRkUmVhY2hhYmxlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBwZTtmb3IoZS5hZGQodCk7IWUuZW1wdHkoKTspe3ZhciBuPWUucG9wKCk7dGhpcy5hZGQobixlKX19LGNvcHlTeW1EZXB0aHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRTeW0oKTtlLnNldERlcHRoKGNuLkxFRlQsdC5nZXREZXB0aChjbi5SSUdIVCkpLGUuc2V0RGVwdGgoY24uUklHSFQsdC5nZXREZXB0aChjbi5MRUZUKSl9LGFkZDpmdW5jdGlvbih0LGUpe3Quc2V0VmlzaXRlZCghMCksdGhpcy5ub2Rlcy5hZGQodCk7Zm9yKHZhciBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5kaXJFZGdlTGlzdC5hZGQoaSk7dmFyIHI9aS5nZXRTeW0oKSxzPXIuZ2V0Tm9kZSgpO3MuaXNWaXNpdGVkKCl8fGUucHVzaChzKX19LGdldE5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXN9LGdldERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXJFZGdlTGlzdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtpfX0pLGUoWWkucHJvdG90eXBlLHtpc0RlbGV0YWJsZTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLmlucHV0TGluZVt0XSxzPXRoaXMuaW5wdXRMaW5lW2VdLG89dGhpcy5pbnB1dExpbmVbbl07cmV0dXJuIHRoaXMuaXNDb25jYXZlKHIscyxvKSYmdGhpcy5pc1NoYWxsb3cocixzLG8saSk/dGhpcy5pc1NoYWxsb3dTYW1wbGVkKHIscyx0LG4saSk6ITF9LGRlbGV0ZVNoYWxsb3dDb25jYXZpdGllczpmdW5jdGlvbigpe2Zvcih2YXIgdD0xLGU9KHRoaXMuaW5wdXRMaW5lLmxlbmd0aC0xLHRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCkpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKSxpPSExO248dGhpcy5pbnB1dExpbmUubGVuZ3RoOyl7dmFyIHI9ITE7dGhpcy5pc0RlbGV0YWJsZSh0LGUsbix0aGlzLmRpc3RhbmNlVG9sKSYmKHRoaXMuaXNEZWxldGVkW2VdPVlpLkRFTEVURSxyPSEwLGk9ITApLHQ9cj9uOmUsZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKX1yZXR1cm4gaX0saXNTaGFsbG93Q29uY2F2aXR5OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWhlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsbikscz1yPT09dGhpcy5hbmdsZU9yaWVudGF0aW9uO2lmKCFzKXJldHVybiExO3ZhciBvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsdCxuKTtyZXR1cm4gaT5vfSxpc1NoYWxsb3dTYW1wbGVkOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9TWF0aC50cnVuYygoaS1uKS9ZaS5OVU1fUFRTX1RPX0NIRUNLKTswPj1zJiYocz0xKTtmb3IodmFyIG89bjtpPm87bys9cylpZighdGhpcy5pc1NoYWxsb3codCxlLHRoaXMuaW5wdXRMaW5lW29dLHIpKXJldHVybiExO3JldHVybiEwfSxpc0NvbmNhdmU6ZnVuY3Rpb24gdChlLG4saSl7dmFyIHI9aGUuY29tcHV0ZU9yaWVudGF0aW9uKGUsbixpKSx0PXI9PT10aGlzLmFuZ2xlT3JpZW50YXRpb247cmV0dXJuIHR9LHNpbXBsaWZ5OmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2VUb2w9TWF0aC5hYnModCksMD50JiYodGhpcy5hbmdsZU9yaWVudGF0aW9uPWhlLkNMT0NLV0lTRSksdGhpcy5pc0RlbGV0ZWQ9bmV3IEFycmF5KHRoaXMuaW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTt2YXIgZT0hMTtkbyBlPXRoaXMuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCk7d2hpbGUoZSk7cmV0dXJuIHRoaXMuY29sbGFwc2VMaW5lKCl9LGZpbmROZXh0Tm9uRGVsZXRlZEluZGV4OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10KzE7ZTx0aGlzLmlucHV0TGluZS5sZW5ndGgmJnRoaXMuaXNEZWxldGVkW2VdPT09WWkuREVMRVRFOyllKys7cmV0dXJuIGV9LGlzU2hhbGxvdzpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1oZS5kaXN0YW5jZVBvaW50TGluZShlLHQsbik7cmV0dXJuIGk+cn0sY29sbGFwc2VMaW5lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBOLGU9MDtlPHRoaXMuaW5wdXRMaW5lLmxlbmd0aDtlKyspdGhpcy5pc0RlbGV0ZWRbZV0hPT1ZaS5ERUxFVEUmJnQuYWRkKHRoaXMuaW5wdXRMaW5lW2VdKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZaX19KSxZaS5zaW1wbGlmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBZaSh0KTtyZXR1cm4gbi5zaW1wbGlmeShlKX0sWWkuSU5JVD0wLFlpLkRFTEVURT0xLFlpLktFRVA9MSxZaS5OVU1fUFRTX1RPX0NIRUNLPTEwLGUoVWkucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHRMaXN0LnRvQXJyYXkoVWkuQ09PUkRJTkFURV9BUlJBWV9UWVBFKTtyZXR1cm4gdH0sc2V0UHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy5wcmVjaXNpb25Nb2RlbD10fSxhZGRQdDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZyh0KTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShlKSx0aGlzLmlzUmVkdW5kYW50KGUpP251bGw6dm9pZCB0aGlzLnB0TGlzdC5hZGQoZSl9LHJldmVyc2U6ZnVuY3Rpb24oKXt9LGFkZFB0czpmdW5jdGlvbih0LGUpe2lmKGUpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpcy5hZGRQdCh0W25dKTtlbHNlIGZvcih2YXIgbj10Lmxlbmd0aC0xO24+PTA7bi0tKXRoaXMuYWRkUHQodFtuXSl9LGlzUmVkdW5kYW50OmZ1bmN0aW9uKHQpe2lmKHRoaXMucHRMaXN0LnNpemUoKTwxKXJldHVybiExO3ZhciBlPXRoaXMucHRMaXN0LmdldCh0aGlzLnB0TGlzdC5zaXplKCktMSksbj10LmRpc3RhbmNlKGUpO3JldHVybiBuPHRoaXMubWluaW1pbVZlcnRleERpc3RhbmNlfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBpZSxlPXQuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBlLnRvU3RyaW5nKCl9LGNsb3NlUmluZzpmdW5jdGlvbigpe2lmKHRoaXMucHRMaXN0LnNpemUoKTwxKXJldHVybiBudWxsO3ZhciB0PW5ldyBnKHRoaXMucHRMaXN0LmdldCgwKSksZT10aGlzLnB0TGlzdC5nZXQodGhpcy5wdExpc3Quc2l6ZSgpLTEpLG49bnVsbDtyZXR1cm4gdGhpcy5wdExpc3Quc2l6ZSgpPj0yJiYobj10aGlzLnB0TGlzdC5nZXQodGhpcy5wdExpc3Quc2l6ZSgpLTIpKSx0LmVxdWFscyhlKT9udWxsOnZvaWQgdGhpcy5wdExpc3QuYWRkKHQpfSxzZXRNaW5pbXVtVmVydGV4RGlzdGFuY2U6ZnVuY3Rpb24odCl7dGhpcy5taW5pbWltVmVydGV4RGlzdGFuY2U9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVWl9fSksVWkuQ09PUkRJTkFURV9BUlJBWV9UWVBFPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLGUoWGkucHJvdG90eXBlLHthZGROZXh0U2VnbWVudDpmdW5jdGlvbih0LGUpe2lmKHRoaXMuczA9dGhpcy5zMSx0aGlzLnMxPXRoaXMuczIsdGhpcy5zMj10LHRoaXMuc2VnMC5zZXRDb29yZGluYXRlcyh0aGlzLnMwLHRoaXMuczEpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5zZWcwLHRoaXMuc2lkZSx0aGlzLmRpc3RhbmNlLHRoaXMub2Zmc2V0MCksdGhpcy5zZWcxLnNldENvb3JkaW5hdGVzKHRoaXMuczEsdGhpcy5zMiksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLnNlZzEsdGhpcy5zaWRlLHRoaXMuZGlzdGFuY2UsdGhpcy5vZmZzZXQxKSx0aGlzLnMxLmVxdWFscyh0aGlzLnMyKSlyZXR1cm4gbnVsbDt2YXIgbj1oZS5jb21wdXRlT3JpZW50YXRpb24odGhpcy5zMCx0aGlzLnMxLHRoaXMuczIpLGk9bj09PWhlLkNMT0NLV0lTRSYmdGhpcy5zaWRlPT09Y24uTEVGVHx8bj09PWhlLkNPVU5URVJDTE9DS1dJU0UmJnRoaXMuc2lkZT09PWNuLlJJR0hUOzA9PT1uP3RoaXMuYWRkQ29sbGluZWFyKGUpOmk/dGhpcy5hZGRPdXRzaWRlVHVybihuLGUpOnRoaXMuYWRkSW5zaWRlVHVybihuLGUpfSxhZGRMaW5lRW5kQ2FwOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNlKHQsZSksaT1uZXcgY2U7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLGNuLkxFRlQsdGhpcy5kaXN0YW5jZSxpKTt2YXIgcj1uZXcgY2U7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLGNuLlJJR0hULHRoaXMuZGlzdGFuY2Uscik7dmFyIHM9ZS54LXQueCxvPWUueS10LnksYT1NYXRoLmF0YW4yKG8scyk7c3dpdGNoKHRoaXMuYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UgQmkuQ0FQX1JPVU5EOnRoaXMuc2VnTGlzdC5hZGRQdChpLnAxKSx0aGlzLmFkZEZpbGxldEFyYyhlLGErTWF0aC5QSS8yLGEtTWF0aC5QSS8yLGhlLkNMT0NLV0lTRSx0aGlzLmRpc3RhbmNlKSx0aGlzLnNlZ0xpc3QuYWRkUHQoci5wMSk7YnJlYWs7Y2FzZSBCaS5DQVBfRkxBVDp0aGlzLnNlZ0xpc3QuYWRkUHQoaS5wMSksdGhpcy5zZWdMaXN0LmFkZFB0KHIucDEpO2JyZWFrO2Nhc2UgQmkuQ0FQX1NRVUFSRTp2YXIgdT1uZXcgZzt1Lng9TWF0aC5hYnModGhpcy5kaXN0YW5jZSkqTWF0aC5jb3MoYSksdS55PU1hdGguYWJzKHRoaXMuZGlzdGFuY2UpKk1hdGguc2luKGEpO3ZhciBsPW5ldyBnKGkucDEueCt1LngsaS5wMS55K3UueSksaD1uZXcgZyhyLnAxLngrdS54LHIucDEueSt1LnkpO3RoaXMuc2VnTGlzdC5hZGRQdChsKSx0aGlzLnNlZ0xpc3QuYWRkUHQoaCl9fSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc2VnTGlzdC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0fSxhZGRNaXRyZUpvaW46ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9ITAscz1udWxsO3RyeXtzPUYuaW50ZXJzZWN0aW9uKGUucDAsZS5wMSxuLnAwLG4ucDEpO3ZhciBvPTA+PWk/MTpzLmRpc3RhbmNlKHQpL01hdGguYWJzKGkpO28+dGhpcy5idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpJiYocj0hMSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgdykpdGhyb3cgdDtzPW5ldyBnKDAsMCkscj0hMX1maW5hbGx5e31yP3RoaXMuc2VnTGlzdC5hZGRQdChzKTp0aGlzLmFkZExpbWl0ZWRNaXRyZUpvaW4oZSxuLGksdGhpcy5idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKX0sYWRkRmlsbGV0Q29ybmVyOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9ZS54LXQueCxvPWUueS10LnksYT1NYXRoLmF0YW4yKG8scyksdT1uLngtdC54LGw9bi55LXQueSxoPU1hdGguYXRhbjIobCx1KTtpPT09aGUuQ0xPQ0tXSVNFP2g+PWEmJihhKz0yKk1hdGguUEkpOmE+PWgmJihhLT0yKk1hdGguUEkpLHRoaXMuc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZEZpbGxldEFyYyh0LGEsaCxpLHIpLHRoaXMuc2VnTGlzdC5hZGRQdChuKX0sYWRkT3V0c2lkZVR1cm46ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMub2Zmc2V0MS5wMCk8dGhpcy5kaXN0YW5jZSpYaS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj8odGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSksbnVsbCk6dm9pZCh0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUJpLkpPSU5fTUlUUkU/dGhpcy5hZGRNaXRyZUpvaW4odGhpcy5zMSx0aGlzLm9mZnNldDAsdGhpcy5vZmZzZXQxLHRoaXMuZGlzdGFuY2UpOnRoaXMuYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09QmkuSk9JTl9CRVZFTD90aGlzLmFkZEJldmVsSm9pbih0aGlzLm9mZnNldDAsdGhpcy5vZmZzZXQxKTooZSYmdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSksdGhpcy5hZGRGaWxsZXRDb3JuZXIodGhpcy5zMSx0aGlzLm9mZnNldDAucDEsdGhpcy5vZmZzZXQxLnAwLHQsdGhpcy5kaXN0YW5jZSksdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCkpKX0sY3JlYXRlU3F1YXJlOmZ1bmN0aW9uKHQpe3RoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngrdGhpcy5kaXN0YW5jZSx0LnkrdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngrdGhpcy5kaXN0YW5jZSx0LnktdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngtdGhpcy5kaXN0YW5jZSx0LnktdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngtdGhpcy5kaXN0YW5jZSx0LnkrdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5jbG9zZVJpbmcoKX0sYWRkU2VnbWVudHM6ZnVuY3Rpb24odCxlKXt0aGlzLnNlZ0xpc3QuYWRkUHRzKHQsZSl9LGFkZEZpcnN0U2VnbWVudDpmdW5jdGlvbigpe3RoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApfSxhZGRMYXN0U2VnbWVudDpmdW5jdGlvbigpe3RoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDEpfSxpbml0U2lkZVNlZ21lbnRzOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLnMxPXQsdGhpcy5zMj1lLHRoaXMuc2lkZT1uLHRoaXMuc2VnMS5zZXRDb29yZGluYXRlcyh0LGUpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5zZWcxLG4sdGhpcy5kaXN0YW5jZSx0aGlzLm9mZnNldDEpfSxhZGRMaW1pdGVkTWl0cmVKb2luOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXRoaXMuc2VnMC5wMSxzPWhpLmFuZ2xlKHIsdGhpcy5zZWcwLnAwKSxvPShoaS5hbmdsZShyLHRoaXMuc2VnMS5wMSksaGkuYW5nbGVCZXR3ZWVuT3JpZW50ZWQodGhpcy5zZWcwLnAwLHIsdGhpcy5zZWcxLnAxKSksYT1vLzIsdT1oaS5ub3JtYWxpemUocythKSxsPWhpLm5vcm1hbGl6ZSh1K01hdGguUEkpLGg9aSpuLGM9aCpNYXRoLmFicyhNYXRoLnNpbihhKSksZj1uLWMsZD1yLngraCpNYXRoLmNvcyhsKSxwPXIueStoKk1hdGguc2luKGwpLHY9bmV3IGcoZCxwKSxtPW5ldyBjZShyLHYpLHk9bS5wb2ludEFsb25nT2Zmc2V0KDEsZikseD1tLnBvaW50QWxvbmdPZmZzZXQoMSwtZik7dGhpcy5zaWRlPT09Y24uTEVGVD8odGhpcy5zZWdMaXN0LmFkZFB0KHkpLHRoaXMuc2VnTGlzdC5hZGRQdCh4KSk6KHRoaXMuc2VnTGlzdC5hZGRQdCh4KSx0aGlzLnNlZ0xpc3QuYWRkUHQoeSkpfSxjb21wdXRlT2Zmc2V0U2VnbWVudDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1lPT09Y24uTEVGVD8xOi0xLHM9dC5wMS54LXQucDAueCxvPXQucDEueS10LnAwLnksYT1NYXRoLnNxcnQocypzK28qbyksdT1yKm4qcy9hLGw9cipuKm8vYTtpLnAwLng9dC5wMC54LWwsaS5wMC55PXQucDAueSt1LGkucDEueD10LnAxLngtbCxpLnAxLnk9dC5wMS55K3V9LGFkZEZpbGxldEFyYzpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPWk9PT1oZS5DTE9DS1dJU0U/LTE6MSxvPU1hdGguYWJzKGUtbiksYT1NYXRoLnRydW5jKG8vdGhpcy5maWxsZXRBbmdsZVF1YW50dW0rLjUpO2lmKDE+YSlyZXR1cm4gbnVsbDt2YXIgdT1udWxsLGw9bnVsbDt1PTAsbD1vL2E7Zm9yKHZhciBoPXUsYz1uZXcgZztvPmg7KXt2YXIgZj1lK3MqaDtjLng9dC54K3IqTWF0aC5jb3MoZiksYy55PXQueStyKk1hdGguc2luKGYpLHRoaXMuc2VnTGlzdC5hZGRQdChjKSxoKz1sfX0sYWRkSW5zaWRlVHVybjpmdW5jdGlvbih0LGUpe2lmKHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLm9mZnNldDAucDAsdGhpcy5vZmZzZXQwLnAxLHRoaXMub2Zmc2V0MS5wMCx0aGlzLm9mZnNldDEucDEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkpdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtlbHNlIGlmKHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMCx0aGlzLm9mZnNldDAucDEuZGlzdGFuY2UodGhpcy5vZmZzZXQxLnAwKTx0aGlzLmRpc3RhbmNlKlhpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQwLnAxKTtlbHNle2lmKHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj4wKXt2YXIgbj1uZXcgZygodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MC5wMS54K3RoaXMuczEueCkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MC5wMS55K3RoaXMuczEueSkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5zZWdMaXN0LmFkZFB0KG4pO3ZhciBpPW5ldyBnKCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQxLnAwLngrdGhpcy5zMS54KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQxLnAwLnkrdGhpcy5zMS55KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLnNlZ0xpc3QuYWRkUHQoaSl9ZWxzZSB0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5zMSk7dGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCl9fSxjcmVhdGVDaXJjbGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodC54K3RoaXMuZGlzdGFuY2UsdC55KTt0aGlzLnNlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGRGaWxsZXRBcmModCwwLDIqTWF0aC5QSSwtMSx0aGlzLmRpc3RhbmNlKSx0aGlzLnNlZ0xpc3QuY2xvc2VSaW5nKCl9LGFkZEJldmVsSm9pbjpmdW5jdGlvbih0LGUpe3RoaXMuc2VnTGlzdC5hZGRQdCh0LnAxKSx0aGlzLnNlZ0xpc3QuYWRkUHQoZS5wMCl9LGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZT10LHRoaXMubWF4Q3VydmVTZWdtZW50RXJyb3I9dCooMS1NYXRoLmNvcyh0aGlzLmZpbGxldEFuZ2xlUXVhbnR1bS8yKSksdGhpcy5zZWdMaXN0PW5ldyBVaSx0aGlzLnNlZ0xpc3Quc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5wcmVjaXNpb25Nb2RlbCksdGhpcy5zZWdMaXN0LnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KlhpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil9LGFkZENvbGxpbmVhcjpmdW5jdGlvbih0KXt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5zMCx0aGlzLnMxLHRoaXMuczEsdGhpcy5zMik7dmFyIGU9dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTtlPj0yJiYodGhpcy5idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1CaS5KT0lOX0JFVkVMfHx0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUJpLkpPSU5fTUlUUkU/KHQmJnRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApKTp0aGlzLmFkZEZpbGxldENvcm5lcih0aGlzLnMxLHRoaXMub2Zmc2V0MC5wMSx0aGlzLm9mZnNldDEucDAsaGUuQ0xPQ0tXSVNFLHRoaXMuZGlzdGFuY2UpKX0sY2xvc2VSaW5nOmZ1bmN0aW9uKCl7dGhpcy5zZWdMaXN0LmNsb3NlUmluZygpfSxoYXNOYXJyb3dDb25jYXZlQW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYaX19KSxYaS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj0uMDAxLFhpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0uMDAxLFhpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0xZS02LFhpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SPTgwLGUoSGkucHJvdG90eXBlLHtnZXRPZmZzZXRDdXJ2ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMuZGlzdGFuY2U9ZSwwPT09ZSlyZXR1cm4gbnVsbDt2YXIgbj0wPmUsaT1NYXRoLmFicyhlKSxyPXRoaXMuZ2V0U2VnR2VuKGkpO3QubGVuZ3RoPD0xP3RoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxyKTp0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZSh0LG4scik7dmFyIHM9ci5nZXRDb29yZGluYXRlcygpO3JldHVybiBuJiZILnJldmVyc2Uocyksc30sY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5kaXN0YW5jZSk7aWYoZSl7bi5hZGRTZWdtZW50cyh0LCEwKTt2YXIgcj1ZaS5zaW1wbGlmeSh0LC1pKSxzPXIubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKHJbc10scltzLTFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPXMtMjtvPj0wO28tLSluLmFkZE5leHRTZWdtZW50KHJbb10sITApfWVsc2V7bi5hZGRTZWdtZW50cyh0LCExKTt2YXIgYT1ZaS5zaW1wbGlmeSh0LGkpLHU9YS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoYVswXSxhWzFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPTI7dT49bztvKyspbi5hZGROZXh0U2VnbWVudChhW29dLCEwKX1uLmFkZExhc3RTZWdtZW50KCksbi5jbG9zZVJpbmcoKX0sY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKTtlPT09Y24uUklHSFQmJihpPS1pKTt2YXIgcj1ZaS5zaW1wbGlmeSh0LGkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzLTFdLHJbMF0sZSk7Zm9yKHZhciBvPTE7cz49bztvKyspe3ZhciBhPTEhPT1vO24uYWRkTmV4dFNlZ21lbnQocltvXSxhKX1uLmNsb3NlUmluZygpfSxjb21wdXRlTGluZUJ1ZmZlckN1cnZlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKSxpPVlpLnNpbXBsaWZ5KHQsbikscj1pLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhpWzBdLGlbMV0sY24uTEVGVCk7Zm9yKHZhciBzPTI7cj49cztzKyspZS5hZGROZXh0U2VnbWVudChpW3NdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKGlbci0xXSxpW3JdKTt2YXIgbz1ZaS5zaW1wbGlmeSh0LC1uKSxhPW8ubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKG9bYV0sb1thLTFdLGNuLkxFRlQpO2Zvcih2YXIgcz1hLTI7cz49MDtzLS0pZS5hZGROZXh0U2VnbWVudChvW3NdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKG9bMV0sb1swXSksZS5jbG9zZVJpbmcoKX0sY29tcHV0ZVBvaW50Q3VydmU6ZnVuY3Rpb24odCxlKXtzd2l0Y2godGhpcy5idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBCaS5DQVBfUk9VTkQ6ZS5jcmVhdGVDaXJjbGUodCk7YnJlYWs7Y2FzZSBCaS5DQVBfU1FVQVJFOmUuY3JlYXRlU3F1YXJlKHQpfX0sZ2V0TGluZUN1cnZlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5kaXN0YW5jZT1lLDA+ZSYmIXRoaXMuYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDtpZigwPT09ZSlyZXR1cm4gbnVsbDt2YXIgbj1NYXRoLmFicyhlKSxpPXRoaXMuZ2V0U2VnR2VuKG4pO2lmKHQubGVuZ3RoPD0xKXRoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxpKTtlbHNlIGlmKHRoaXMuYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSl7dmFyIHI9MD5lO3RoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxyLGkpfWVsc2UgdGhpcy5jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQsaSk7dmFyIHM9aS5nZXRDb29yZGluYXRlcygpO3JldHVybiBzfSxnZXRCdWZmZXJQYXJhbWV0ZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmUGFyYW1zfSxzaW1wbGlmeVRvbGVyYW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gdCp0aGlzLmJ1ZlBhcmFtcy5nZXRTaW1wbGlmeUZhY3RvcigpfSxnZXRSaW5nQ3VydmU6ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuZGlzdGFuY2U9bix0Lmxlbmd0aDw9MilyZXR1cm4gdGhpcy5nZXRMaW5lQ3VydmUodCxuKTtpZigwPT09bilyZXR1cm4gSGkuY29weUNvb3JkaW5hdGVzKHQpO3ZhciBpPXRoaXMuZ2V0U2VnR2VuKG4pO3JldHVybiB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLGkpLGkuZ2V0Q29vcmRpbmF0ZXMoKX0sY29tcHV0ZU9mZnNldEN1cnZlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuZGlzdGFuY2UpO2lmKGUpe3ZhciByPVlpLnNpbXBsaWZ5KHQsLWkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzXSxyW3MtMV0sY24uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IodmFyIG89cy0yO28+PTA7by0tKW4uYWRkTmV4dFNlZ21lbnQocltvXSwhMCl9ZWxzZXt2YXIgYT1ZaS5zaW1wbGlmeSh0LGkpLHU9YS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoYVswXSxhWzFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPTI7dT49bztvKyspbi5hZGROZXh0U2VnbWVudChhW29dLCEwKX1uLmFkZExhc3RTZWdtZW50KCl9LGdldFNlZ0dlbjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFhpKHRoaXMucHJlY2lzaW9uTW9kZWwsdGhpcy5idWZQYXJhbXMsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhpfX0pLEhpLmNvcHlDb29yZGluYXRlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfSxlKFdpLnByb3RvdHlwZSx7ZmluZFN0YWJiZWRTZWdtZW50czpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEksbj10aGlzLnN1YmdyYXBocy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldEVudmVsb3BlKCk7dC55PHIuZ2V0TWluWSgpfHx0Lnk+ci5nZXRNYXhZKCl8fHRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LGkuZ2V0RGlyZWN0ZWRFZGdlcygpLGUpfXJldHVybiBlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSW4pZm9yKHZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPWFyZ3VtZW50c1syXSx1PW8uZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCksbj0wO248dS5sZW5ndGgtMTtuKyspe3RoaXMuc2VnLnAwPXVbbl0sdGhpcy5zZWcucDE9dVtuKzFdLHRoaXMuc2VnLnAwLnk+dGhpcy5zZWcucDEueSYmdGhpcy5zZWcucmV2ZXJzZSgpO3ZhciBsPU1hdGgubWF4KHRoaXMuc2VnLnAwLngsdGhpcy5zZWcucDEueCk7aWYoIShsPHMueHx8dGhpcy5zZWcuaXNIb3Jpem9udGFsKCl8fHMueTx0aGlzLnNlZy5wMC55fHxzLnk+dGhpcy5zZWcucDEueXx8aGUuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMuc2VnLnAwLHRoaXMuc2VnLnAxLHMpPT09aGUuUklHSFQpKXt2YXIgaD1vLmdldERlcHRoKGNuLkxFRlQpO3RoaXMuc2VnLnAwLmVxdWFscyh1W25dKXx8KGg9by5nZXREZXB0aChjbi5SSUdIVCkpO3ZhciBjPW5ldyBqaSh0aGlzLnNlZyxoKTthLmFkZChjKX19ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZSKGFyZ3VtZW50c1sxXSx5KSlmb3IodmFyIGY9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdLG49ZC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIHY9bi5uZXh0KCk7di5pc0ZvcndhcmQoKSYmdGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKGYsdixwKX19LGdldERlcHRoOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0KTtpZigwPT09ZS5zaXplKCkpcmV0dXJuIDA7dmFyIG49aG8ubWluKGUpO3JldHVybiBuLmxlZnREZXB0aH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV2l9fSksZShqaS5wcm90b3R5cGUse2NvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O2lmKHRoaXMudXB3YXJkU2VnLm1pblgoKT49ZS51cHdhcmRTZWcubWF4WCgpKXJldHVybiAxO2lmKHRoaXMudXB3YXJkU2VnLm1heFgoKTw9ZS51cHdhcmRTZWcubWluWCgpKXJldHVybi0xO3ZhciBuPXRoaXMudXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgoZS51cHdhcmRTZWcpO3JldHVybiAwIT09bj9uOihuPS0xKmUudXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy51cHdhcmRTZWcpLDAhPT1uP246dGhpcy51cHdhcmRTZWcuY29tcGFyZVRvKGUudXB3YXJkU2VnKSl9LGNvbXBhcmVYOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dC5wMS5jb21wYXJlVG8oZS5wMSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXB3YXJkU2VnLnRvU3RyaW5nKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqaX19KSxXaS5EZXB0aFNlZ21lbnQ9amksZShLaS5wcm90b3R5cGUse2FkZFBvaW50OmZ1bmN0aW9uKHQpe2lmKHRoaXMuZGlzdGFuY2U8PTApcmV0dXJuIG51bGw7XG52YXIgZT10LmdldENvb3JkaW5hdGVzKCksbj10aGlzLmN1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLmRpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sTC5FWFRFUklPUixMLklOVEVSSU9SKX0sYWRkUG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmRpc3RhbmNlLG49Y24uTEVGVDt0aGlzLmRpc3RhbmNlPDAmJihlPS10aGlzLmRpc3RhbmNlLG49Y24uUklHSFQpO3ZhciBpPXQuZ2V0RXh0ZXJpb3JSaW5nKCkscj1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKGkuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYodGhpcy5kaXN0YW5jZTwwJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShpLHRoaXMuZGlzdGFuY2UpKXJldHVybiBudWxsO2lmKHRoaXMuZGlzdGFuY2U8PTAmJnIubGVuZ3RoPDMpcmV0dXJuIG51bGw7dGhpcy5hZGRQb2x5Z29uUmluZyhyLGUsbixMLkVYVEVSSU9SLEwuSU5URVJJT1IpO2Zvcih2YXIgcz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe3ZhciBvPXQuZ2V0SW50ZXJpb3JSaW5nTihzKSxhPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHMoby5nZXRDb29yZGluYXRlcygpKTt0aGlzLmRpc3RhbmNlPjAmJnRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KG8sLXRoaXMuZGlzdGFuY2UpfHx0aGlzLmFkZFBvbHlnb25SaW5nKGEsZSxjbi5vcHBvc2l0ZShuKSxMLklOVEVSSU9SLEwuRVhURVJJT1IpfX0saXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHk6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgY2kodFswXSx0WzFdLHRbMl0pLGk9bi5pbkNlbnRyZSgpLHI9aGUuZGlzdGFuY2VQb2ludExpbmUoaSxuLnAwLG4ucDEpO3JldHVybiByPE1hdGguYWJzKGUpfSxhZGRMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZGlzdGFuY2U8PTAmJiF0aGlzLmN1cnZlQnVpbGRlci5nZXRCdWZmZXJQYXJhbWV0ZXJzKCkuaXNTaW5nbGVTaWRlZCgpKXJldHVybiBudWxsO3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKSxuPXRoaXMuY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUobixMLkVYVEVSSU9SLEwuSU5URVJJT1IpfSxhZGRDdXJ2ZTpmdW5jdGlvbih0LGUsbil7aWYobnVsbD09PXR8fHQubGVuZ3RoPDIpcmV0dXJuIG51bGw7dmFyIGk9bmV3IEtlKHQsbmV3IGduKDAsTC5CT1VOREFSWSxlLG4pKTt0aGlzLmN1cnZlTGlzdC5hZGQoaSl9LGdldEN1cnZlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFkZCh0aGlzLmlucHV0R2VvbSksdGhpcy5jdXJ2ZUxpc3R9LGFkZFBvbHlnb25SaW5nOmZ1bmN0aW9uKHQsZSxuLGkscil7aWYoMD09PWUmJnQubGVuZ3RoPGJ0Lk1JTklNVU1fVkFMSURfU0laRSlyZXR1cm4gbnVsbDt2YXIgcz1pLG89cjt0Lmxlbmd0aD49YnQuTUlOSU1VTV9WQUxJRF9TSVpFJiZoZS5pc0NDVyh0KSYmKHM9cixvPWksbj1jbi5vcHBvc2l0ZShuKSk7dmFyIGE9dGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0UmluZ0N1cnZlKHQsbixlKTt0aGlzLmFkZEN1cnZlKGEscyxvKX0sYWRkOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEx0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGd0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBPdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBmdCkpdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19LGlzRXJvZGVkQ29tcGxldGVseTpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihuLmxlbmd0aDw0KXJldHVybiAwPmU7aWYoND09PW4ubGVuZ3RoKXJldHVybiB0aGlzLmlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KG4sZSk7dmFyIGk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkscj1NYXRoLm1pbihpLmdldEhlaWdodCgpLGkuZ2V0V2lkdGgoKSk7cmV0dXJuIDA+ZSYmMipNYXRoLmFicyhlKT5yfSxhZGRDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtpfX0pLGUoWmkucHJvdG90eXBlLHtpc1RyaXZpYWxJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJjE9PT10aGlzLmxpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihaaS5pc0FkamFjZW50U2VnbWVudHMoZSxpKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe3ZhciByPXQuc2l6ZSgpLTE7aWYoMD09PWUmJmk9PT1yfHwwPT09aSYmZT09PXIpcmV0dXJuITB9fXJldHVybiExfSxnZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50fSxoYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3BlckludGVyaW9yfSxnZXRMaW5lSW50ZXJzZWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saX0saGFzUHJvcGVySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzUHJvcGVyfSxwcm9jZXNzSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmZT09PWkpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO3ZhciByPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW2ldLGE9bi5nZXRDb29yZGluYXRlcygpW2krMV07dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyc2VjdGlvbnMrKyx0aGlzLmxpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zKyssdGhpcy5oYXNJbnRlcmlvcj0hMCksdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4saSl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsdC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5saSxpLDEpLHRoaXMubGkuaXNQcm9wZXIoKSYmKHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucysrLHRoaXMuaGFzUHJvcGVyPSEwLHRoaXMuaGFzUHJvcGVySW50ZXJpb3I9ITApKSl9LGhhc0ludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiExfSxoYXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc0ludGVyaW9yfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFppfX0pLFppLmlzQWRqYWNlbnRTZWdtZW50cz1mdW5jdGlvbih0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX0sZShRaS5wcm90b3R5cGUse3NldFdvcmtpbmdQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbih0KXt0aGlzLndvcmtpbmdQcmVjaXNpb25Nb2RlbD10fSxpbnNlcnRVbmlxdWVFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7dmFyIG49ZS5nZXRMYWJlbCgpLGk9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KGk9bmV3IGduKHQuZ2V0TGFiZWwoKSksaS5mbGlwKCkpLG4ubWVyZ2UoaSk7dmFyIHI9UWkuZGVwdGhEZWx0YShpKSxzPWUuZ2V0RGVwdGhEZWx0YSgpLG89cytyO2Uuc2V0RGVwdGhEZWx0YShvKX1lbHNlIHRoaXMuZWRnZUxpc3QuYWRkKHQpLHQuc2V0RGVwdGhEZWx0YShRaS5kZXB0aERlbHRhKHQuZ2V0TGFiZWwoKSkpfSxidWlsZFN1YmdyYXBoczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpLHM9ci5nZXRSaWdodG1vc3RDb29yZGluYXRlKCksbz1uZXcgV2kobiksYT1vLmdldERlcHRoKHMpO3IuY29tcHV0ZURlcHRoKGEpLHIuZmluZFJlc3VsdEVkZ2VzKCksbi5hZGQociksZS5hZGQoci5nZXREaXJlY3RlZEVkZ2VzKCksci5nZXROb2RlcygpKX19LGNyZWF0ZVN1YmdyYXBoczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10LmdldE5vZGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKCFpLmlzVmlzaXRlZCgpKXt2YXIgcj1uZXcga2k7ci5jcmVhdGUoaSksZS5hZGQocil9fXJldHVybiBoby5zb3J0KGUsaG8ucmV2ZXJzZU9yZGVyKCkpLGV9LGNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdlb21GYWN0LmNyZWF0ZVBvbHlnb24oKTtyZXR1cm4gdH0sZ2V0Tm9kZXI6ZnVuY3Rpb24odCl7aWYobnVsbCE9PXRoaXMud29ya2luZ05vZGVyKXJldHVybiB0aGlzLndvcmtpbmdOb2Rlcjt2YXIgZT1uZXcgbm4sbj1uZXcgYWU7cmV0dXJuIG4uc2V0UHJlY2lzaW9uTW9kZWwodCksZS5zZXRTZWdtZW50SW50ZXJzZWN0b3IobmV3IFppKG4pKSxlfSxidWZmZXI6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLndvcmtpbmdQcmVjaXNpb25Nb2RlbDtudWxsPT09biYmKG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLmdlb21GYWN0PXQuZ2V0RmFjdG9yeSgpO3ZhciBpPW5ldyBIaShuLHRoaXMuYnVmUGFyYW1zKSxyPW5ldyBLaSh0LGUsaSkscz1yLmdldEN1cnZlcygpO2lmKHMuc2l6ZSgpPD0wKXJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKTt0aGlzLmNvbXB1dGVOb2RlZEVkZ2VzKHMsbiksdGhpcy5ncmFwaD1uZXcgQ24obmV3IE9uKSx0aGlzLmdyYXBoLmFkZEVkZ2VzKHRoaXMuZWRnZUxpc3QuZ2V0RWRnZXMoKSk7dmFyIG89dGhpcy5jcmVhdGVTdWJncmFwaHModGhpcy5ncmFwaCksYT1uZXcgU24odGhpcy5nZW9tRmFjdCk7dGhpcy5idWlsZFN1YmdyYXBocyhvLGEpO3ZhciB1PWEuZ2V0UG9seWdvbnMoKTtpZih1LnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dmFyIGw9dGhpcy5nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHUpO3JldHVybiBsfSxjb21wdXRlTm9kZWRFZGdlczpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0Tm9kZXIoZSk7bi5jb21wdXRlTm9kZXModCk7Zm9yKHZhciBpPW4uZ2V0Tm9kZWRTdWJzdHJpbmdzKCkscj1pLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZigyIT09by5sZW5ndGh8fCFvWzBdLmVxdWFsczJEKG9bMV0pKXt2YXIgYT1zLmdldERhdGEoKSx1PW5ldyBKbihzLmdldENvb3JkaW5hdGVzKCksbmV3IGduKGEpKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2UodSl9fX0sc2V0Tm9kZXI6ZnVuY3Rpb24odCl7dGhpcy53b3JraW5nTm9kZXI9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUWl9fSksUWkuZGVwdGhEZWx0YT1mdW5jdGlvbih0KXt2YXIgZT10LmdldExvY2F0aW9uKDAsY24uTEVGVCksbj10LmdldExvY2F0aW9uKDAsY24uUklHSFQpO3JldHVybiBlPT09TC5JTlRFUklPUiYmbj09PUwuRVhURVJJT1I/MTplPT09TC5FWFRFUklPUiYmbj09PUwuSU5URVJJT1I/LTE6MH0sUWkuY29udmVydFNlZ1N0cmluZ3M9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBpZSxuPW5ldyBJO3QuaGFzTmV4dCgpOyl7dmFyIGk9dC5uZXh0KCkscj1lLmNyZWF0ZUxpbmVTdHJpbmcoaS5nZXRDb29yZGluYXRlcygpKTtuLmFkZChyKX1yZXR1cm4gZS5idWlsZEdlb21ldHJ5KG4pfSxlKEppLnByb3RvdHlwZSx7Y2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9dGhpcy5zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKG5bMF0sdGhpcy5zZWdTdHJpbmdzKSx0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKG5bbi5sZW5ndGgtMV0sdGhpcy5zZWdTdHJpbmdzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0sdD1yLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWZvcih2YXIgZT10Lm5leHQoKSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPTE7czxuLmxlbmd0aC0xO3MrKylpZihuW3NdLmVxdWFscyhpKSl0aHJvdyBuZXcgbChcImZvdW5kIGVuZHB0L2ludGVyaW9yIHB0IGludGVyc2VjdGlvbiBhdCBpbmRleCBcIitzK1wiIDpwdCBcIitpKX0sY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9dGhpcy5zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWZvcih2YXIgZT10Lm5leHQoKSxuPXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhlLGkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPXIuZ2V0Q29vcmRpbmF0ZXMoKSxhPXMuZ2V0Q29vcmRpbmF0ZXMoKSx1PTA7dTxvLmxlbmd0aC0xO3UrKylmb3IodmFyIGg9MDtoPGEubGVuZ3RoLTE7aCsrKXRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMocix1LHMsaCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGM9YXJndW1lbnRzWzBdLGY9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLGQ9YXJndW1lbnRzWzNdO2lmKGM9PT1nJiZmPT09ZClyZXR1cm4gbnVsbDt2YXIgcD1jLmdldENvb3JkaW5hdGVzKClbZl0sdj1jLmdldENvb3JkaW5hdGVzKClbZisxXSxtPWcuZ2V0Q29vcmRpbmF0ZXMoKVtkXSx5PWcuZ2V0Q29vcmRpbmF0ZXMoKVtkKzFdO2lmKHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihwLHYsbSx5KSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5saS5pc1Byb3BlcigpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMubGkscCx2KXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLmxpLG0seSkpKXRocm93IG5ldyBsKFwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBhdCBcIitwK1wiLVwiK3YrXCIgYW5kIFwiK20rXCItXCIreSl9fSxjaGVja1ZhbGlkOmZ1bmN0aW9uKCl7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrQ29sbGFwc2VzKCl9LGNoZWNrQ29sbGFwc2VzOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7dGhpcy5jaGVja0NvbGxhcHNlcyhlKX1lbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgbj1hcmd1bWVudHNbMF0saT1uLmdldENvb3JkaW5hdGVzKCksdD0wO3Q8aS5sZW5ndGgtMjt0KyspdGhpcy5jaGVja0NvbGxhcHNlKGlbdF0saVt0KzFdLGlbdCsyXSl9LGhhc0ludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9MDtpPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7aSsrKXt2YXIgcj10LmdldEludGVyc2VjdGlvbihpKTtpZighci5lcXVhbHMoZSkmJiFyLmVxdWFscyhuKSlyZXR1cm4hMH1yZXR1cm4hMX0sY2hlY2tDb2xsYXBzZTpmdW5jdGlvbih0LGUsbil7aWYodC5lcXVhbHMobikpdGhyb3cgbmV3IGwoXCJmb3VuZCBub24tbm9kZWQgY29sbGFwc2UgYXQgXCIrSmkuZmFjdC5jcmVhdGVMaW5lU3RyaW5nKFt0LGUsbl0pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSml9fSksSmkuZmFjdD1uZXcgaWUsZSgkaS5wcm90b3R5cGUse2ludGVyc2VjdHNTY2FsZWQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1NYXRoLm1pbih0LngsZS54KSxpPU1hdGgubWF4KHQueCxlLngpLHI9TWF0aC5taW4odC55LGUueSkscz1NYXRoLm1heCh0LnksZS55KSxvPXRoaXMubWF4eDxufHx0aGlzLm1pbng+aXx8dGhpcy5tYXh5PHJ8fHRoaXMubWlueT5zO2lmKG8pcmV0dXJuITE7dmFyIGE9dGhpcy5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHQsZSk7cmV0dXJuIGYuaXNUcnVlKCEobyYmYSksXCJGb3VuZCBiYWQgZW52ZWxvcGUgdGVzdFwiKSxhfSxpbml0Q29ybmVyczpmdW5jdGlvbih0KXt2YXIgZT0uNTt0aGlzLm1pbng9dC54LWUsdGhpcy5tYXh4PXQueCtlLHRoaXMubWlueT10LnktZSx0aGlzLm1heHk9dC55K2UsdGhpcy5jb3JuZXJbMF09bmV3IGcodGhpcy5tYXh4LHRoaXMubWF4eSksdGhpcy5jb3JuZXJbMV09bmV3IGcodGhpcy5taW54LHRoaXMubWF4eSksdGhpcy5jb3JuZXJbMl09bmV3IGcodGhpcy5taW54LHRoaXMubWlueSksdGhpcy5jb3JuZXJbM109bmV3IGcodGhpcy5tYXh4LHRoaXMubWlueSl9LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PXRoaXMuc2NhbGVGYWN0b3I/dGhpcy5pbnRlcnNlY3RzU2NhbGVkKHQsZSk6KHRoaXMuY29weVNjYWxlZCh0LHRoaXMucDBTY2FsZWQpLHRoaXMuY29weVNjYWxlZChlLHRoaXMucDFTY2FsZWQpLHRoaXMuaW50ZXJzZWN0c1NjYWxlZCh0aGlzLnAwU2NhbGVkLHRoaXMucDFTY2FsZWQpKX0sc2NhbGU6ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucm91bmQodCp0aGlzLnNjYWxlRmFjdG9yKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWdpbmFsUHR9LGNvcHlTY2FsZWQ6ZnVuY3Rpb24odCxlKXtlLng9dGhpcy5zY2FsZSh0LngpLGUueT10aGlzLnNjYWxlKHQueSl9LGdldFNhZmVFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLnNhZmVFbnYpe3ZhciB0PSRpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1IvdGhpcy5zY2FsZUZhY3Rvcjt0aGlzLnNhZmVFbnY9bmV3IEModGhpcy5vcmlnaW5hbFB0LngtdCx0aGlzLm9yaWdpbmFsUHQueCt0LHRoaXMub3JpZ2luYWxQdC55LXQsdGhpcy5vcmlnaW5hbFB0LnkrdCl9cmV0dXJuIHRoaXMuc2FmZUVudn0saW50ZXJzZWN0c1BpeGVsQ2xvc3VyZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzBdLHRoaXMuY29ybmVyWzFdKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpPyEwOih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzFdLHRoaXMuY29ybmVyWzJdKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpPyEwOih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzJdLHRoaXMuY29ybmVyWzNdKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpPyEwOih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzNdLHRoaXMuY29ybmVyWzBdKSwhIXRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkpKSl9LGludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj0hMSxpPSExO3JldHVybiB0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzBdLHRoaXMuY29ybmVyWzFdKSx0aGlzLmxpLmlzUHJvcGVyKCk/ITA6KHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbMV0sdGhpcy5jb3JuZXJbMl0pLHRoaXMubGkuaXNQcm9wZXIoKT8hMDoodGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKG49ITApLHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbMl0sdGhpcy5jb3JuZXJbM10pLHRoaXMubGkuaXNQcm9wZXIoKT8hMDoodGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKGk9ITApLHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbM10sdGhpcy5jb3JuZXJbMF0pLHRoaXMubGkuaXNQcm9wZXIoKT8hMDpuJiZpPyEwOnQuZXF1YWxzKHRoaXMucHQpPyEwOiEhZS5lcXVhbHModGhpcy5wdCkpKSl9LGFkZFNuYXBwZWROb2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRDb29yZGluYXRlKGUpLGk9dC5nZXRDb29yZGluYXRlKGUrMSk7cmV0dXJuIHRoaXMuaW50ZXJzZWN0cyhuLGkpPyh0LmFkZEludGVyc2VjdGlvbih0aGlzLmdldENvb3JkaW5hdGUoKSxlKSwhMCk6ITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRpfX0pLCRpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1I9Ljc1LGUodHIucHJvdG90eXBlLHtzZWxlY3Q6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0LmdldExpbmVTZWdtZW50KGUsdGhpcy5zZWxlY3RlZFNlZ21lbnQpLHRoaXMuc2VsZWN0KHRoaXMuc2VsZWN0ZWRTZWdtZW50KX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRyfX0pLGUoZXIucHJvdG90eXBlLHtzbmFwOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zbmFwKHQsbnVsbCwtMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWFyZ3VtZW50c1syXSxyPWUuZ2V0U2FmZUVudmVsb3BlKCkscz1uZXcgbnIoZSxuLGkpO3JldHVybiB0aGlzLmluZGV4LnF1ZXJ5KHIse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sdmlzaXRJdGVtOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7ZS5zZWxlY3QocixzKX19KSxzLmlzTm9kZUFkZGVkKCl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlcn19KSxoKG5yLHRyKSxlKG5yLnByb3RvdHlwZSx7aXNOb2RlQWRkZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNOb2RlQWRkZWR9LHNlbGVjdDpmdW5jdGlvbigpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0ci5wcm90b3R5cGUuc2VsZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldENvbnRleHQoKTtyZXR1cm4gbnVsbCE9PXRoaXMucGFyZW50RWRnZSYmbj09PXRoaXMucGFyZW50RWRnZSYmZT09PXRoaXMuaG90UGl4ZWxWZXJ0ZXhJbmRleD9udWxsOnZvaWQodGhpcy5faXNOb2RlQWRkZWQ9dGhpcy5ob3RQaXhlbC5hZGRTbmFwcGVkTm9kZShuLGUpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbnJ9fSksZXIuSG90UGl4ZWxTbmFwQWN0aW9uPW5yLGUoaXIucHJvdG90eXBlLHtwcm9jZXNzSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmZT09PWkpcmV0dXJuIG51bGw7dmFyIHI9dC5nZXRDb29yZGluYXRlcygpW2VdLHM9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbaV0sYT1uLmdldENvb3JkaW5hdGVzKClbaSsxXTtpZih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocixzLG8sYSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkpe2Zvcih2YXIgdT0wO3U8dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTt1KyspdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbnMuYWRkKHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKHUpKTt0LmFkZEludGVyc2VjdGlvbnModGhpcy5saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGksMSl9fSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGlyfX0pLGUocnIucHJvdG90eXBlLHtjaGVja0NvcnJlY3RuZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPUtlLmdldE5vZGVkU3Vic3RyaW5ncyh0KSxuPW5ldyBKaShlKTt0cnl7bi5jaGVja1ZhbGlkKCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgUykpdGhyb3cgdDt0LnByaW50U3RhY2tUcmFjZSgpfWZpbmFsbHl7fX0sZ2V0Tm9kZWRTdWJzdHJpbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIEtlLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLm5vZGVkU2VnU3RyaW5ncyl9LHNuYXBSb3VuZDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvblNuYXBzKG4pLHRoaXMuY29tcHV0ZVZlcnRleFNuYXBzKHQpfSxmaW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGlyKGUpO3JldHVybiB0aGlzLm5vZGVyLnNldFNlZ21lbnRJbnRlcnNlY3RvcihuKSx0aGlzLm5vZGVyLmNvbXB1dGVOb2Rlcyh0KSxuLmdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpfSxjb21wdXRlVmVydGV4U25hcHM6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5jb21wdXRlVmVydGV4U25hcHMobil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEtlKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1pLmdldENvb3JkaW5hdGVzKCkscz0wO3M8ci5sZW5ndGg7cysrKXt2YXIgbz1uZXcgJGkocltzXSx0aGlzLnNjYWxlRmFjdG9yLHRoaXMubGkpLGE9dGhpcy5wb2ludFNuYXBwZXIuc25hcChvLGkscyk7YSYmaS5hZGRJbnRlcnNlY3Rpb24ocltzXSxzKX19LGNvbXB1dGVOb2RlczpmdW5jdGlvbih0KXt0aGlzLm5vZGVkU2VnU3RyaW5ncz10LHRoaXMubm9kZXI9bmV3IG5uLHRoaXMucG9pbnRTbmFwcGVyPW5ldyBlcih0aGlzLm5vZGVyLmdldEluZGV4KCkpLHRoaXMuc25hcFJvdW5kKHQsdGhpcy5saSl9LGNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uZXcgJGkobix0aGlzLnNjYWxlRmFjdG9yLHRoaXMubGkpO3RoaXMucG9pbnRTbmFwcGVyLnNuYXAoaSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt0bl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHJyfX0pLGUoc3IucHJvdG90eXBlLHtidWZmZXJGaXhlZFByZWNpc2lvbjpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRmkobmV3IHJyKG5ldyBlZSgxKSksdC5nZXRTY2FsZSgpKSxuPW5ldyBRaSh0aGlzLmJ1ZlBhcmFtcyk7bi5zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCksbi5zZXROb2RlcihlKSx0aGlzLnJlc3VsdEdlb21ldHJ5PW4uYnVmZmVyKHRoaXMuYXJnR2VvbSx0aGlzLmRpc3RhbmNlKX0sYnVmZmVyUmVkdWNlZFByZWNpc2lvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9c3IuTUFYX1BSRUNJU0lPTl9ESUdJVFM7dD49MDt0LS0pe3RyeXt0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24odCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2Ygc24pKXRocm93IHQ7dGhpcy5zYXZlRXhjZXB0aW9uPXR9ZmluYWxseXt9aWYobnVsbCE9PXRoaXMucmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGx9dGhyb3cgdGhpcy5zYXZlRXhjZXB0aW9ufWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1zci5wcmVjaXNpb25TY2FsZUZhY3Rvcih0aGlzLmFyZ0dlb20sdGhpcy5kaXN0YW5jZSxlKSxpPW5ldyBlZShuKTt0aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKGkpfX0sY29tcHV0ZUdlb21ldHJ5OmZ1bmN0aW9uKCl7aWYodGhpcy5idWZmZXJPcmlnaW5hbFByZWNpc2lvbigpLG51bGwhPT10aGlzLnJlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsO3ZhciB0PXRoaXMuYXJnR2VvbS5nZXRGYWN0b3J5KCkuZ2V0UHJlY2lzaW9uTW9kZWwoKTt0LmdldFR5cGUoKT09PWVlLkZJWEVEP3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24odCk6dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCl9LHNldFF1YWRyYW50U2VnbWVudHM6ZnVuY3Rpb24odCl7dGhpcy5idWZQYXJhbXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX0sYnVmZmVyT3JpZ2luYWxQcmVjaXNpb246ZnVuY3Rpb24oKXt0cnl7dmFyIHQ9bmV3IFFpKHRoaXMuYnVmUGFyYW1zKTt0aGlzLnJlc3VsdEdlb21ldHJ5PXQuYnVmZmVyKHRoaXMuYXJnR2VvbSx0aGlzLmRpc3RhbmNlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBsKSl0aHJvdyB0O3RoaXMuc2F2ZUV4Y2VwdGlvbj10fWZpbmFsbHl7fX0sZ2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGlzdGFuY2U9dCx0aGlzLmNvbXB1dGVHZW9tZXRyeSgpLHRoaXMucmVzdWx0R2VvbWV0cnl9LHNldEVuZENhcFN0eWxlOmZ1bmN0aW9uKHQpe3RoaXMuYnVmUGFyYW1zLnNldEVuZENhcFN0eWxlKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzcn19KSxzci5idWZmZXJPcD1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgc3IodCksaT1uLmdldFJlc3VsdEdlb21ldHJ5KGUpO3JldHVybiBpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9bmV3IHNyKHIpO2Euc2V0UXVhZHJhbnRTZWdtZW50cyhvKTt2YXIgaT1hLmdldFJlc3VsdEdlb21ldHJ5KHMpO3JldHVybiBpfWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQmkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdLGg9YXJndW1lbnRzWzJdLGE9bmV3IHNyKHUsaCksaT1hLmdldFJlc3VsdEdlb21ldHJ5KGwpO3JldHVybiBpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYz1hcmd1bWVudHNbMF0sZj1hcmd1bWVudHNbMV0sZz1hcmd1bWVudHNbMl0sZD1hcmd1bWVudHNbM10sYT1uZXcgc3IoYyk7YS5zZXRRdWFkcmFudFNlZ21lbnRzKGcpLGEuc2V0RW5kQ2FwU3R5bGUoZCk7dmFyIGk9YS5nZXRSZXN1bHRHZW9tZXRyeShmKTtyZXR1cm4gaX19LHNyLnByZWNpc2lvblNjYWxlRmFjdG9yPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPVQubWF4KE1hdGguYWJzKGkuZ2V0TWF4WCgpKSxNYXRoLmFicyhpLmdldE1heFkoKSksTWF0aC5hYnMoaS5nZXRNaW5YKCkpLE1hdGguYWJzKGkuZ2V0TWluWSgpKSkscz1lPjA/ZTowLG89cisyKnMsYT1NYXRoLnRydW5jKE1hdGgubG9nKG8pL01hdGgubG9nKDEwKSsxKSx1PW4tYSxsPU1hdGgucG93KDEwLHUpO3JldHVybiBsfSxzci5DQVBfUk9VTkQ9QmkuQ0FQX1JPVU5ELHNyLkNBUF9CVVRUPUJpLkNBUF9GTEFULHNyLkNBUF9GTEFUPUJpLkNBUF9GTEFULHNyLkNBUF9TUVVBUkU9QmkuQ0FQX1NRVUFSRSxzci5NQVhfUFJFQ0lTSU9OX0RJR0lUUz0xMjt2YXIgQ289T2JqZWN0LmZyZWV6ZSh7QnVmZmVyT3A6c3IsQnVmZmVyUGFyYW1ldGVyczpCaX0pO2Uob3IucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLmNvbXBzLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvcn19KSxvci5nZXRQb2x5Z29ucz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG9yLmdldFBvbHlnb25zKHQsbmV3IEkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIGUgaW5zdGFuY2VvZiBUdD9uLmFkZChlKTplIGluc3RhbmNlb2YgZnQmJmUuYXBwbHkobmV3IG9yKG4pKSxufX0sZShhci5wcm90b3R5cGUse2lzSW5zaWRlQXJlYTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ0luZGV4PT09YXIuSU5TSURFX0FSRUF9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0sZ2V0R2VvbWV0cnlDb21wb25lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wb25lbnR9LGdldFNlZ21lbnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ0luZGV4fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhcn19KSxhci5JTlNJREVfQVJFQT0tMSxlKHVyLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBMdCYmdGhpcy5wdHMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltodF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVyfX0pLHVyLmdldFBvaW50cz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQgaW5zdGFuY2VvZiBMdD9oby5zaW5nbGV0b25MaXN0KHQpOnVyLmdldFBvaW50cyh0LG5ldyBJKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBlIGluc3RhbmNlb2YgTHQ/bi5hZGQoZSk6ZSBpbnN0YW5jZW9mIGZ0JiZlLmFwcGx5KG5ldyB1cihuKSksbn19LGUobHIucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7KHQgaW5zdGFuY2VvZiBMdHx8dCBpbnN0YW5jZW9mIFN0fHx0IGluc3RhbmNlb2YgVHQpJiZ0aGlzLmxvY2F0aW9ucy5hZGQobmV3IGFyKHQsMCx0LmdldENvb3JkaW5hdGUoKSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltodF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGxyfX0pLGxyLmdldExvY2F0aW9ucz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgSTtyZXR1cm4gdC5hcHBseShuZXcgbHIoZSkpLGV9LGUoaHIucHJvdG90eXBlLHtjb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDAsdCksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9MS1lLHI9b3IuZ2V0UG9seWdvbnModGhpcy5nZW9tW2VdKTtpZihyLnNpemUoKT4wKXt2YXIgcz1sci5nZXRMb2NhdGlvbnModGhpcy5nZW9tW2ldKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKHMscixuKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiB0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25baV09blswXSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bZV09blsxXSxudWxsfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJlIoYXJndW1lbnRzWzBdLHkpJiZSKGFyZ3VtZW50c1sxXSx5KSl7Zm9yKHZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXSxsPTA7bDxvLnNpemUoKTtsKyspZm9yKHZhciBoPW8uZ2V0KGwpLGM9MDtjPGEuc2l6ZSgpO2MrKylpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKGgsYS5nZXQoYyksdSksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgYXImJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVHQpe3ZhciBmPWFyZ3VtZW50c1swXSxnPWFyZ3VtZW50c1sxXSxkPWFyZ3VtZW50c1syXSxwPWYuZ2V0Q29vcmRpbmF0ZSgpO2lmKEwuRVhURVJJT1IhPT10aGlzLnB0TG9jYXRvci5sb2NhdGUocCxnKSlyZXR1cm4gdGhpcy5taW5EaXN0YW5jZT0wLGRbMF09ZixkWzFdPW5ldyBhcihnLHApLG51bGx9fSxjb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50czpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LnNpemUoKTtpKyspZm9yKHZhciByPXQuZ2V0KGkpLHM9MDtzPGUuc2l6ZSgpO3MrKyl7dmFyIG89ZS5nZXQocyk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UocixvLG4pLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fSxjb21wdXRlRmFjZXREaXN0YW5jZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGU9a24uZ2V0TGluZXModGhpcy5nZW9tWzBdKSxuPWtuLmdldExpbmVzKHRoaXMuZ2VvbVsxXSksaT11ci5nZXRQb2ludHModGhpcy5nZW9tWzBdKSxyPXVyLmdldFBvaW50cyh0aGlzLmdlb21bMV0pO3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzKGUsbix0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKGUscix0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKG4saSx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITApLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyhpLHIsdCksdm9pZCB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpKSkpfSxuZWFyZXN0TG9jYXRpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9ufSx1cGRhdGVNaW5EaXN0YW5jZTpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dFswXT9udWxsOnZvaWQoZT8odGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMV0sdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMF0pOih0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMF09dFswXSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMV09dFsxXSkpfSxuZWFyZXN0UG9pbnRzOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKTt2YXIgdD1bdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMV0uZ2V0Q29vcmRpbmF0ZSgpXTtyZXR1cm4gdH0sY29tcHV0ZU1pbkRpc3RhbmNlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKG51bGwhPT10aGlzLm1pbkRpc3RhbmNlTG9jYXRpb24pcmV0dXJuIG51bGw7aWYodGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUZhY2V0RGlzdGFuY2UoKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgTHQpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtmb3IodmFyIGk9dC5nZXRDb29yZGluYXRlcygpLHI9ZS5nZXRDb29yZGluYXRlKCkscz0wO3M8aS5sZW5ndGgtMTtzKyspe3ZhciBvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKHIsaVtzXSxpW3MrMV0pO2lmKG88dGhpcy5taW5EaXN0YW5jZSl7dGhpcy5taW5EaXN0YW5jZT1vO3ZhciBhPW5ldyBjZShpW3NdLGlbcysxXSksdT1hLmNsb3Nlc3RQb2ludChyKTtuWzBdPW5ldyBhcih0LHMsdSksblsxXT1uZXcgYXIoZSwwLHIpfWlmKHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBTdCl7dmFyIGw9YXJndW1lbnRzWzBdLGg9YXJndW1lbnRzWzFdLGM9YXJndW1lbnRzWzJdO2lmKGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGguZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLm1pbkRpc3RhbmNlKXJldHVybiBudWxsO2Zvcih2YXIgaT1sLmdldENvb3JkaW5hdGVzKCksZj1oLmdldENvb3JkaW5hdGVzKCkscz0wO3M8aS5sZW5ndGgtMTtzKyspZm9yKHZhciBnPTA7ZzxmLmxlbmd0aC0xO2crKyl7dmFyIG89aGUuZGlzdGFuY2VMaW5lTGluZShpW3NdLGlbcysxXSxmW2ddLGZbZysxXSk7aWYobzx0aGlzLm1pbkRpc3RhbmNlKXt0aGlzLm1pbkRpc3RhbmNlPW87dmFyIGQ9bmV3IGNlKGlbc10saVtzKzFdKSxwPW5ldyBjZShmW2ddLGZbZysxXSksdj1kLmNsb3Nlc3RQb2ludHMocCk7Y1swXT1uZXcgYXIobCxzLHZbMF0pLGNbMV09bmV3IGFyKGgsZyx2WzFdKX1pZih0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19LGNvbXB1dGVNaW5EaXN0YW5jZVBvaW50czpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LnNpemUoKTtpKyspZm9yKHZhciByPXQuZ2V0KGkpLHM9MDtzPGUuc2l6ZSgpO3MrKyl7dmFyIG89ZS5nZXQocyksYT1yLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZShvLmdldENvb3JkaW5hdGUoKSk7aWYoYTx0aGlzLm1pbkRpc3RhbmNlJiYodGhpcy5taW5EaXN0YW5jZT1hLG5bMF09bmV3IGFyKHIsMCxyLmdldENvb3JkaW5hdGUoKSksblsxXT1uZXcgYXIobywwLG8uZ2V0Q29vcmRpbmF0ZSgpKSksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19LGRpc3RhbmNlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZ2VvbVswXXx8bnVsbD09PXRoaXMuZ2VvbVsxXSl0aHJvdyBuZXcgaShcIm51bGwgZ2VvbWV0cmllcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gdGhpcy5nZW9tWzBdLmlzRW1wdHkoKXx8dGhpcy5nZW9tWzFdLmlzRW1wdHkoKT8wOih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMubWluRGlzdGFuY2UpfSxjb21wdXRlTWluRGlzdGFuY2VMaW5lczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LnNpemUoKTtpKyspZm9yKHZhciByPXQuZ2V0KGkpLHM9MDtzPGUuc2l6ZSgpO3MrKyl7dmFyIG89ZS5nZXQocyk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UocixvLG4pLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBocn19KSxoci5kaXN0YW5jZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBocih0LGUpO3JldHVybiBuLmRpc3RhbmNlKCl9LGhyLmlzV2l0aGluRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBocih0LGUsbik7cmV0dXJuIGkuZGlzdGFuY2UoKTw9bn0saHIubmVhcmVzdFBvaW50cz1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBocih0LGUpO3JldHVybiBuLm5lYXJlc3RQb2ludHMoKX07dmFyIFNvPU9iamVjdC5mcmVlemUoe0Rpc3RhbmNlT3A6aHJ9KTtlKGNyLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5jb29yZGluYXRlcyl7Zm9yKHZhciB0PTAsZT0wLG49bmV3IE4saT10aGlzLmRpcmVjdGVkRWRnZXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuZ2V0RWRnZURpcmVjdGlvbigpP3QrKzplKyssbi5hZGQoci5nZXRFZGdlKCkuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksITEsci5nZXRFZGdlRGlyZWN0aW9uKCkpfXRoaXMuY29vcmRpbmF0ZXM9bi50b0Nvb3JkaW5hdGVBcnJheSgpLGU+dCYmSC5yZXZlcnNlKHRoaXMuY29vcmRpbmF0ZXMpfXJldHVybiB0aGlzLmNvb3JkaW5hdGVzfSx0b0xpbmVTdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuZGlyZWN0ZWRFZGdlcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNyfX0pLGUoZnIucHJvdG90eXBlLHtzZXRWaXNpdGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzVmlzaXRlZD10fSxpc01hcmtlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc01hcmtlZH0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LHNldE1hcmtlZDpmdW5jdGlvbih0KXt0aGlzLl9pc01hcmtlZD10fSxnZXRDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0saXNWaXNpdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH0sc2V0Q29udGV4dDpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZnJ9fSksZnIuZ2V0Q29tcG9uZW50V2l0aFZpc2l0ZWRTdGF0ZT1mdW5jdGlvbih0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt2YXIgbj10Lm5leHQoKTtpZihuLmlzVmlzaXRlZCgpPT09ZSlyZXR1cm4gbn1yZXR1cm4gbnVsbH0sZnIuc2V0VmlzaXRlZD1mdW5jdGlvbih0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt2YXIgbj10Lm5leHQoKTtuLnNldFZpc2l0ZWQoZSl9fSxmci5zZXRNYXJrZWQ9ZnVuY3Rpb24odCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dmFyIG49dC5uZXh0KCk7bi5zZXRNYXJrZWQoZSl9fSxoKGdyLGZyKSxlKGdyLnByb3RvdHlwZSx7aXNSZW1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnBhcmVudEVkZ2V9LGNvbXBhcmVEaXJlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucXVhZHJhbnQ+dC5xdWFkcmFudD8xOnRoaXMucXVhZHJhbnQ8dC5xdWFkcmFudD8tMTpoZS5jb21wdXRlT3JpZW50YXRpb24odC5wMCx0LnAxLHRoaXMucDEpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZnJvbS5nZXRDb29yZGluYXRlKCl9LHByaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksbj1lLmxhc3RJbmRleE9mKFwiLlwiKSxpPWUuc3Vic3RyaW5nKG4rMSk7dC5wcmludChcIiAgXCIraStcIjogXCIrdGhpcy5wMCtcIiAtIFwiK3RoaXMucDErXCIgXCIrdGhpcy5xdWFkcmFudCtcIjpcIit0aGlzLmFuZ2xlKX0sZ2V0RGlyZWN0aW9uUHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMX0sZ2V0QW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbmdsZX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX0sZ2V0RnJvbU5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mcm9tfSxnZXRTeW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW19LHNldEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5wYXJlbnRFZGdlPXR9LHJlbW92ZTpmdW5jdGlvbigpe3RoaXMuc3ltPW51bGwsdGhpcy5wYXJlbnRFZGdlPW51bGx9LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRFZGdlfSxnZXRRdWFkcmFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnF1YWRyYW50fSxzZXRTeW06ZnVuY3Rpb24odCl7dGhpcy5zeW09dH0sZ2V0VG9Ob2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG99LGdldEVkZ2VEaXJlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlRGlyZWN0aW9ufSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ3J9fSksZ3IudG9FZGdlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuYWRkKG4ubmV4dCgpLnBhcmVudEVkZ2UpO3JldHVybiBlfSxoKGRyLGdyKSxlKGRyLnByb3RvdHlwZSx7Z2V0TmV4dDpmdW5jdGlvbigpe3JldHVybiAyIT09dGhpcy5nZXRUb05vZGUoKS5nZXREZWdyZWUoKT9udWxsOnRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKT09PXRoaXMuZ2V0U3ltKCk/dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpOihmLmlzVHJ1ZSh0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk9PT10aGlzLmdldFN5bSgpKSx0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkcn19KSxoKHByLGZyKSxlKHByLnByb3RvdHlwZSx7aXNSZW1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmRpckVkZ2V9LHNldERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24odCxlKXt0aGlzLmRpckVkZ2U9W3QsZV0sdC5zZXRFZGdlKHRoaXMpLGUuc2V0RWRnZSh0aGlzKSx0LnNldFN5bShlKSxlLnNldFN5bSh0KSx0LmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZSh0KSxlLmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZShlKX0sZ2V0RGlyRWRnZTpmdW5jdGlvbigpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRpckVkZ2VbdF19aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcil7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PWU/dGhpcy5kaXJFZGdlWzBdOnRoaXMuZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09ZT90aGlzLmRpckVkZ2VbMV06bnVsbH19LHJlbW92ZTpmdW5jdGlvbigpe3RoaXMuZGlyRWRnZT1udWxsfSxnZXRPcHBvc2l0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLmRpckVkZ2VbMF0uZ2V0VG9Ob2RlKCk6dGhpcy5kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuZGlyRWRnZVsxXS5nZXRUb05vZGUoKTpudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBwcn19KSxlKHZyLnByb3RvdHlwZSx7Z2V0TmV4dEVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlKzEpKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dmFyIGU9dC5uZXh0KCk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMub3V0RWRnZXMuaXRlcmF0b3IoKX0sc29ydEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5zb3J0ZWR8fChoby5zb3J0KHRoaXMub3V0RWRnZXMpLHRoaXMuc29ydGVkPSEwKX0scmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMub3V0RWRnZXMucmVtb3ZlKHQpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMub3V0RWRnZXN9LGdldE5leHRDV0VkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlLTEpKX0sZ2V0SW5kZXg6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHByKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IodmFyIGU9MDtlPHRoaXMub3V0RWRnZXMuc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5vdXRFZGdlcy5nZXQoZSk7aWYobi5nZXRFZGdlKCk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ3Ipe3ZhciBpPWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2Zvcih2YXIgZT0wO2U8dGhpcy5vdXRFZGdlcy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLm91dEVkZ2VzLmdldChlKTtpZihuPT09aSlyZXR1cm4gZX1yZXR1cm4tMX1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciByPWFyZ3VtZW50c1swXSxzPXIldGhpcy5vdXRFZGdlcy5zaXplKCk7cmV0dXJuIDA+cyYmKHMrPXRoaXMub3V0RWRnZXMuc2l6ZSgpKSxzfX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMub3V0RWRnZXMuYWRkKHQpLHRoaXMuc29ydGVkPSExfSxnZXREZWdyZWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vdXRFZGdlcy5zaXplKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZyfX0pLGgobXIsZnIpLGUobXIucHJvdG90eXBlLHtpc1JlbW92ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMucHR9LGFkZE91dEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5kZVN0YXIuYWRkKHQpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGdldE91dEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVTdGFyfSxyZW1vdmU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnB0PW51bGw7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZGVTdGFyLnJlbW92ZSh0KX19LGdldEluZGV4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRlU3Rhci5nZXRJbmRleCh0KX0sZ2V0RGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVTdGFyLmdldERlZ3JlZSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtcn19KSxtci5nZXRFZGdlc0JldHdlZW49ZnVuY3Rpb24odCxlKXt2YXIgbj1nci50b0VkZ2VzKHQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKSxpPW5ldyBKKG4pLHI9Z3IudG9FZGdlcyhlLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSk7cmV0dXJuIGkucmV0YWluQWxsKHIpLGl9LGgoeXIscHIpLGUoeXIucHJvdG90eXBlLHtnZXRMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geXJ9fSksZSh4ci5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSxyZW1vdmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5yZW1vdmUodCl9LHZhbHVlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9LGFkZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4cn19KSxlKEVyLnByb3RvdHlwZSx7ZmluZE5vZGVzT2ZEZWdyZWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuZ2V0RGVncmVlKCk9PT10JiZlLmFkZChpKX1yZXR1cm4gZX0sZGlyRWRnZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlyRWRnZXMuaXRlcmF0b3IoKX0sZWRnZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXMuaXRlcmF0b3IoKX0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBwcil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDEpKSx0aGlzLmVkZ2VzLnJlbW92ZSh0KSx0LnJlbW92ZSgpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBncil7dmFyIGU9YXJndW1lbnRzWzBdLG49ZS5nZXRTeW0oKTtudWxsIT09biYmbi5zZXRTeW0obnVsbCksZS5nZXRGcm9tTm9kZSgpLnJlbW92ZShlKSxlLnJlbW92ZSgpLHRoaXMuZGlyRWRnZXMucmVtb3ZlKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcil7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLHM9ci5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksbj1vLmdldFN5bSgpO251bGwhPT1uJiZ0aGlzLnJlbW92ZShuKSx0aGlzLmRpckVkZ2VzLnJlbW92ZShvKTt2YXIgYT1vLmdldEVkZ2UoKTtudWxsIT09YSYmdGhpcy5lZGdlcy5yZW1vdmUoYSl9dGhpcy5ub2RlTWFwLnJlbW92ZShpLmdldENvb3JkaW5hdGUoKSksaS5yZW1vdmUoKX19LGZpbmROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZmluZCh0KX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sbm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC5pdGVyYXRvcigpfSxjb250YWluczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcHIpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lZGdlcy5jb250YWlucyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGdyKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZGlyRWRnZXMuY29udGFpbnMoZSl9fSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1yKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlTWFwLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcHIpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmVkZ2VzLmFkZChlKSx0aGlzLmFkZChlLmdldERpckVkZ2UoMCkpLHRoaXMuYWRkKGUuZ2V0RGlyRWRnZSgxKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGdyKXt2YXIgbj1hcmd1bWVudHNbMF07dGhpcy5kaXJFZGdlcy5hZGQobil9fSxnZXROb2RlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVyfX0pLGgoSXIsRXIpLGUoSXIucHJvdG90eXBlLHthZGRFZGdlOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDt2YXIgbj1lWzBdLGk9ZVtlLmxlbmd0aC0xXSxyPXRoaXMuZ2V0Tm9kZShuKSxzPXRoaXMuZ2V0Tm9kZShpKSxvPW5ldyBkcihyLHMsZVsxXSwhMCksYT1uZXcgZHIocyxyLGVbZS5sZW5ndGgtMl0sITEpLHU9bmV3IHlyKHQpO3Uuc2V0RGlyZWN0ZWRFZGdlcyhvLGEpLHRoaXMuYWRkKHUpfSxnZXROb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgbXIodCksdGhpcy5hZGQoZSkpLGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElyfX0pLGUoTnIucHJvdG90eXBlLHtidWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuaXNNYXJrZWQoKXx8KGYuaXNUcnVlKDI9PT1lLmdldERlZ3JlZSgpKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fSxidWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7MiE9PWUuZ2V0RGVncmVlKCkmJih0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fSxidWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXM6ZnVuY3Rpb24oKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKX0sZ2V0TWVyZ2VkTGluZVN0cmluZ3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZXJnZSgpLHRoaXMubWVyZ2VkTGluZVN0cmluZ3N9LGJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZ2V0RWRnZSgpLmlzTWFya2VkKCl8fHRoaXMuZWRnZVN0cmluZ3MuYWRkKHRoaXMuYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKG4pKX19LG1lcmdlOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMubWVyZ2VkTGluZVN0cmluZ3MpcmV0dXJuIG51bGw7ZnIuc2V0TWFya2VkKHRoaXMuZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpLGZyLnNldE1hcmtlZCh0aGlzLmdyYXBoLmVkZ2VJdGVyYXRvcigpLCExKSx0aGlzLmVkZ2VTdHJpbmdzPW5ldyBJLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCksdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wcygpLHRoaXMubWVyZ2VkTGluZVN0cmluZ3M9bmV3IEk7Zm9yKHZhciB0PXRoaXMuZWRnZVN0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO3RoaXMubWVyZ2VkTGluZVN0cmluZ3MuYWRkKGUudG9MaW5lU3RyaW5nKCkpfX0sYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjcih0aGlzLmZhY3RvcnkpLG49dDtkbyBlLmFkZChuKSxuLmdldEVkZ2UoKS5zZXRNYXJrZWQoITApLG49bi5nZXROZXh0KCk7d2hpbGUobnVsbCE9PW4mJm4hPT10KTtyZXR1cm4gZX0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07dC5hcHBseSh7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgU3QmJnRoaXMuYWRkKHQpfX0pfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlZExpbmVTdHJpbmdzPW51bGw7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe1xudmFyIGk9bi5uZXh0KCk7dGhpcy5hZGQoaSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIHI9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLmZhY3RvcnkmJih0aGlzLmZhY3Rvcnk9ci5nZXRGYWN0b3J5KCkpLHRoaXMuZ3JhcGguYWRkRWRnZShyKX19LGJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzOmZ1bmN0aW9uKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlcygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOcn19KTt2YXIgd289T2JqZWN0LmZyZWV6ZSh7TGluZU1lcmdlcjpOcn0pLExvPU9iamVjdC5mcmVlemUoe092ZXJsYXlPcDppaX0pO2goQ3IsZ3IpLGUoQ3IucHJvdG90eXBlLHtnZXROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dH0saXNJblJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuZWRnZVJpbmd9LHNldFJpbmc6ZnVuY3Rpb24odCl7dGhpcy5lZGdlUmluZz10fSxzZXRMYWJlbDpmdW5jdGlvbih0KXt0aGlzLmxhYmVsPXR9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5uZXh0PXR9LGdldFJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlUmluZ30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ3J9fSksaChTcixwciksZShTci5wcm90b3R5cGUse2dldExpbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTcn19KSxlKHdyLnByb3RvdHlwZSx7aXNJbmNsdWRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLnJpbmdQdHMpe2Zvcih2YXIgdD1uZXcgTixlPXRoaXMuZGVMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0RWRnZSgpO3dyLmFkZEVkZ2UoaS5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuLmdldEVkZ2VEaXJlY3Rpb24oKSx0KX10aGlzLnJpbmdQdHM9dC50b0Nvb3JkaW5hdGVBcnJheSgpfXJldHVybiB0aGlzLnJpbmdQdHN9LGlzSW5jbHVkZWRTZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZFNldH0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5yaW5nUHRzLmxlbmd0aDw9Mz8hMToodGhpcy5nZXRSaW5nKCksdGhpcy5yaW5nLmlzVmFsaWQoKSl9LGJ1aWxkOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7ZG8gdGhpcy5hZGQoZSksZS5zZXRSaW5nKHRoaXMpLGU9ZS5nZXROZXh0KCksZi5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZi5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIik7d2hpbGUoZSE9PXQpfSxpc091dGVySG9sZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0hvbGU/IXRoaXMuaGFzU2hlbGwoKTohMX0sZ2V0UG9seWdvbjpmdW5jdGlvbigpe3ZhciB0PW51bGw7aWYobnVsbCE9PXRoaXMuaG9sZXMpe3Q9bmV3IEFycmF5KHRoaXMuaG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5zaXplKCk7ZSsrKXRbZV09dGhpcy5ob2xlcy5nZXQoZSl9dmFyIG49dGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24odGhpcy5yaW5nLHQpO3JldHVybiBufSxpc0hvbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNIb2xlfSxpc1Byb2Nlc3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1Byb2Nlc3NlZH0sYWRkSG9sZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe3ZhciB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5ob2xlcyYmKHRoaXMuaG9sZXM9bmV3IEkpLHRoaXMuaG9sZXMuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB3cil7dmFyIGU9YXJndW1lbnRzWzBdO2Uuc2V0U2hlbGwodGhpcyk7dmFyIG49ZS5nZXRSaW5nKCk7bnVsbD09PXRoaXMuaG9sZXMmJih0aGlzLmhvbGVzPW5ldyBJKSx0aGlzLmhvbGVzLmFkZChuKX19LHNldEluY2x1ZGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzSW5jbHVkZWQ9dCx0aGlzLl9pc0luY2x1ZGVkU2V0PSEwfSxnZXRPdXRlckhvbGU6ZnVuY3Rpb24oKXtpZih0aGlzLmlzSG9sZSgpKXJldHVybiBudWxsO2Zvcih2YXIgdD0wO3Q8dGhpcy5kZUxpc3Quc2l6ZSgpO3QrKyl7dmFyIGU9dGhpcy5kZUxpc3QuZ2V0KHQpLG49ZS5nZXRTeW0oKS5nZXRSaW5nKCk7aWYobi5pc091dGVySG9sZSgpKXJldHVybiBufXJldHVybiBudWxsfSxjb21wdXRlSG9sZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0UmluZygpO3RoaXMuX2lzSG9sZT1oZS5pc0NDVyh0LmdldENvb3JkaW5hdGVzKCkpfSxoYXNTaGVsbDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5zaGVsbH0saXNPdXRlclNoZWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmdldE91dGVySG9sZSgpfSxnZXRMaW5lU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLnJpbmdQdHMpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcobmV3IEd0KHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSkpfSxnZXRTaGVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzSG9sZSgpP3RoaXMuc2hlbGw6dGhpc30sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuZGVMaXN0LmFkZCh0KX0sZ2V0UmluZzpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnJpbmcpcmV0dXJuIHRoaXMucmluZzt0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5yaW5nUHRzLmxlbmd0aDwzJiZBLm91dC5wcmludGxuKHRoaXMucmluZ1B0cyk7dHJ5e3RoaXMucmluZz10aGlzLmZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0aGlzLnJpbmdQdHMpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFMpKXRocm93IHQ7QS5vdXQucHJpbnRsbih0aGlzLnJpbmdQdHMpfWZpbmFsbHl7fXJldHVybiB0aGlzLnJpbmd9LHVwZGF0ZUluY2x1ZGVkOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IodmFyIHQ9MDt0PHRoaXMuZGVMaXN0LnNpemUoKTt0Kyspe3ZhciBlPXRoaXMuZGVMaXN0LmdldCh0KSxuPWUuZ2V0U3ltKCkuZ2V0UmluZygpLmdldFNoZWxsKCk7aWYobnVsbCE9PW4mJm4uaXNJbmNsdWRlZFNldCgpKXJldHVybiB0aGlzLnNldEluY2x1ZGVkKCFuLmlzSW5jbHVkZWQoKSksbnVsbH19LHNldFNoZWxsOmZ1bmN0aW9uKHQpe3RoaXMuc2hlbGw9dH0sc2V0UHJvY2Vzc2VkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzUHJvY2Vzc2VkPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdyfX0pLHdyLmZpbmREaXJFZGdlc0luUmluZz1mdW5jdGlvbih0KXt2YXIgZT10LG49bmV3IEk7ZG8gbi5hZGQoZSksZT1lLmdldE5leHQoKSxmLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxmLmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKTt3aGlsZShlIT09dCk7cmV0dXJuIG59LHdyLmFkZEVkZ2U9ZnVuY3Rpb24odCxlLG4pe2lmKGUpZm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspbi5hZGQodFtpXSwhMSk7ZWxzZSBmb3IodmFyIGk9dC5sZW5ndGgtMTtpPj0wO2ktLSluLmFkZCh0W2ldLCExKX0sd3IuZmluZEVkZ2VSaW5nQ29udGFpbmluZz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldFJpbmcoKSxpPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHI9bi5nZXRDb29yZGluYXRlTigwKSxzPW51bGwsbz1udWxsLGE9ZS5pdGVyYXRvcigpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCksbD11LmdldFJpbmcoKSxoPWwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCFoLmVxdWFscyhpKSYmaC5jb250YWlucyhpKSl7cj1ILnB0Tm90SW5MaXN0KG4uZ2V0Q29vcmRpbmF0ZXMoKSxsLmdldENvb3JkaW5hdGVzKCkpO3ZhciBjPSExO2hlLmlzUG9pbnRJblJpbmcocixsLmdldENvb3JkaW5hdGVzKCkpJiYoYz0hMCksYyYmKG51bGw9PT1zfHxvLmNvbnRhaW5zKGgpKSYmKHM9dSxvPXMuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9fXJldHVybiBzfSxlKExyLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO3JldHVybiBuLmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpLmNvbXBhcmVUbyhpLmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExyfX0pLHdyLkVudmVsb3BlQ29tcGFyYXRvcj1McixoKFJyLEVyKSxlKFJyLnByb3RvdHlwZSx7ZmluZEVkZ2VSaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB3cih0aGlzLmZhY3RvcnkpO3JldHVybiBlLmJ1aWxkKHQpLGV9LGNvbXB1dGVEZXB0aFBhcml0eTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcig7Oyl7dmFyIHQ9bnVsbDtpZihudWxsPT09dClyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVEZXB0aFBhcml0eSh0KX1lbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF19fSxjb21wdXRlTmV4dENXRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO1JyLmNvbXB1dGVOZXh0Q1dFZGdlcyhlKX19LGFkZEVkZ2U6ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIGU9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIG51bGw7dmFyIG49ZVswXSxpPWVbZS5sZW5ndGgtMV0scj10aGlzLmdldE5vZGUobikscz10aGlzLmdldE5vZGUoaSksbz1uZXcgQ3IocixzLGVbMV0sITApLGE9bmV3IENyKHMscixlW2UubGVuZ3RoLTJdLCExKSx1PW5ldyBTcih0KTt1LnNldERpcmVjdGVkRWRnZXMobyxhKSx0aGlzLmFkZCh1KX0sZGVsZXRlQ3V0RWRnZXM6ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLFJyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuZGlyRWRnZXMpO2Zvcih2YXIgdD1uZXcgSSxlPXRoaXMuZGlyRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKCFuLmlzTWFya2VkKCkpe3ZhciBpPW4uZ2V0U3ltKCk7aWYobi5nZXRMYWJlbCgpPT09aS5nZXRMYWJlbCgpKXtuLnNldE1hcmtlZCghMCksaS5zZXRNYXJrZWQoITApO3ZhciByPW4uZ2V0RWRnZSgpO3QuYWRkKHIuZ2V0TGluZSgpKX19fXJldHVybiB0fSxnZXRFZGdlUmluZ3M6ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLFJyLmxhYmVsKHRoaXMuZGlyRWRnZXMsLTEpO3ZhciB0PVJyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuZGlyRWRnZXMpO3RoaXMuY29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCk7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5kaXJFZGdlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoIWkuaXNNYXJrZWQoKSYmIWkuaXNJblJpbmcoKSl7dmFyIHI9dGhpcy5maW5kRWRnZVJpbmcoaSk7ZS5hZGQocil9fXJldHVybiBlfSxnZXROb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgbXIodCksdGhpcy5hZGQoZSkpLGV9LGNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKSxyPVJyLmZpbmRJbnRlcnNlY3Rpb25Ob2RlcyhuLGkpO2lmKG51bGwhPT1yKWZvcih2YXIgcz1yLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKTtSci5jb21wdXRlTmV4dENDV0VkZ2VzKG8saSl9fX0sZGVsZXRlRGFuZ2xlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmZpbmROb2Rlc09mRGVncmVlKDEpLGU9bmV3IEosbj1uZXcgcGUsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KW4ucHVzaChpLm5leHQoKSk7Zm9yKDshbi5pc0VtcHR5KCk7KXt2YXIgcj1uLnBvcCgpO1JyLmRlbGV0ZUFsbEVkZ2VzKHIpO2Zvcih2YXIgcz1yLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxpPXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciBvPWkubmV4dCgpO28uc2V0TWFya2VkKCEwKTt2YXIgYT1vLmdldFN5bSgpO251bGwhPT1hJiZhLnNldE1hcmtlZCghMCk7dmFyIHU9by5nZXRFZGdlKCk7ZS5hZGQodS5nZXRMaW5lKCkpO3ZhciBsPW8uZ2V0VG9Ob2RlKCk7MT09PVJyLmdldERlZ3JlZU5vbkRlbGV0ZWQobCkmJm4ucHVzaChsKX19cmV0dXJuIGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJyfX0pLFJyLmZpbmRMYWJlbGVkRWRnZVJpbmdzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPTEsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtpZighKHIuaXNNYXJrZWQoKXx8ci5nZXRMYWJlbCgpPj0wKSl7ZS5hZGQocik7dmFyIHM9d3IuZmluZERpckVkZ2VzSW5SaW5nKHIpO1JyLmxhYmVsKHMsbiksbisrfX1yZXR1cm4gZX0sUnIuZ2V0RGVncmVlTm9uRGVsZXRlZD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCksbj0wLGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc01hcmtlZCgpfHxuKyt9cmV0dXJuIG59LFJyLmRlbGV0ZUFsbEVkZ2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuc2V0TWFya2VkKCEwKTt2YXIgcj1pLmdldFN5bSgpO251bGwhPT1yJiZyLnNldE1hcmtlZCghMCl9fSxSci5sYWJlbD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldExhYmVsKGUpfX0sUnIuY29tcHV0ZU5leHRDV0VkZ2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCksbj1udWxsLGk9bnVsbCxyPWUuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYoIXMuaXNNYXJrZWQoKSl7aWYobnVsbD09PW4mJihuPXMpLG51bGwhPT1pKXt2YXIgbz1pLmdldFN5bSgpO28uc2V0TmV4dChzKX1pPXN9fWlmKG51bGwhPT1pKXt2YXIgbz1pLmdldFN5bSgpO28uc2V0TmV4dChuKX19LFJyLmNvbXB1dGVOZXh0Q0NXRWRnZXM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRPdXRFZGdlcygpLGk9bnVsbCxyPW51bGwscz1uLmdldEVkZ2VzKCksbz1zLnNpemUoKS0xO28+PTA7by0tKXt2YXIgYT1zLmdldChvKSx1PWEuZ2V0U3ltKCksbD1udWxsO2EuZ2V0TGFiZWwoKT09PWUmJihsPWEpO3ZhciBoPW51bGw7dS5nZXRMYWJlbCgpPT09ZSYmKGg9dSksbnVsbD09PWwmJm51bGw9PT1ofHwobnVsbCE9PWgmJihyPWgpLG51bGwhPT1sJiYobnVsbCE9PXImJihyLnNldE5leHQobCkscj1udWxsKSxudWxsPT09aSYmKGk9bCkpKX1udWxsIT09ciYmKGYuaXNUcnVlKG51bGwhPT1pKSxyLnNldE5leHQoaSkpfSxSci5nZXREZWdyZWU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCksaT0wLHI9bi5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7cy5nZXRMYWJlbCgpPT09ZSYmaSsrfXJldHVybiBpfSxSci5maW5kSW50ZXJzZWN0aW9uTm9kZXM9ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9bnVsbDtkb3t2YXIgcj1uLmdldEZyb21Ob2RlKCk7UnIuZ2V0RGVncmVlKHIsZSk+MSYmKG51bGw9PT1pJiYoaT1uZXcgSSksaS5hZGQocikpLG49bi5nZXROZXh0KCksZi5pc1RydWUobnVsbCE9PW4sXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZi5pc1RydWUobj09PXR8fCFuLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUobiE9PXQpO3JldHVybiBpfSxlKFRyLnByb3RvdHlwZSx7Z2V0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuZ2VvbUZhY3RvcnkmJih0aGlzLmdlb21GYWN0b3J5PW5ldyBpZSksdGhpcy5wb2x5Z29uaXplKCksdGhpcy5leHRyYWN0T25seVBvbHlnb25hbD90aGlzLmdlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5wb2x5TGlzdCk6dGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KHRoaXMucG9seUxpc3QpKX0sZ2V0SW52YWxpZFJpbmdMaW5lczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLmludmFsaWRSaW5nTGluZXN9LGZpbmRWYWxpZFJpbmdzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc1ZhbGlkKCk/ZS5hZGQocik6bi5hZGQoci5nZXRMaW5lU3RyaW5nKCkpfX0scG9seWdvbml6ZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnBvbHlMaXN0KXJldHVybiBudWxsO2lmKHRoaXMucG9seUxpc3Q9bmV3IEksbnVsbD09PXRoaXMuZ3JhcGgpcmV0dXJuIG51bGw7dGhpcy5kYW5nbGVzPXRoaXMuZ3JhcGguZGVsZXRlRGFuZ2xlcygpLHRoaXMuY3V0RWRnZXM9dGhpcy5ncmFwaC5kZWxldGVDdXRFZGdlcygpO3ZhciB0PXRoaXMuZ3JhcGguZ2V0RWRnZVJpbmdzKCksZT1uZXcgSTt0aGlzLmludmFsaWRSaW5nTGluZXM9bmV3IEksdGhpcy5pc0NoZWNraW5nUmluZ3NWYWxpZD90aGlzLmZpbmRWYWxpZFJpbmdzKHQsZSx0aGlzLmludmFsaWRSaW5nTGluZXMpOmU9dCx0aGlzLmZpbmRTaGVsbHNBbmRIb2xlcyhlKSxUci5hc3NpZ25Ib2xlc1RvU2hlbGxzKHRoaXMuaG9sZUxpc3QsdGhpcy5zaGVsbExpc3QpLGhvLnNvcnQodGhpcy5zaGVsbExpc3QsbmV3IHdyLkVudmVsb3BlQ29tcGFyYXRvcik7dmFyIG49ITA7dGhpcy5leHRyYWN0T25seVBvbHlnb25hbCYmKFRyLmZpbmREaXNqb2ludFNoZWxscyh0aGlzLnNoZWxsTGlzdCksbj0hMSksdGhpcy5wb2x5TGlzdD1Uci5leHRyYWN0UG9seWdvbnModGhpcy5zaGVsbExpc3Qsbil9LGdldERhbmdsZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5kYW5nbGVzfSxnZXRDdXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLmN1dEVkZ2VzfSxnZXRQb2x5Z29uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLnBvbHlMaXN0fSxhZGQ6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5hZGQobil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0KXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5nZW9tRmFjdG9yeT1pLmdldEZhY3RvcnkoKSxudWxsPT09dGhpcy5ncmFwaCYmKHRoaXMuZ3JhcGg9bmV3IFJyKHRoaXMuZ2VvbUZhY3RvcnkpKSx0aGlzLmdyYXBoLmFkZEVkZ2UoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciByPWFyZ3VtZW50c1swXTtyLmFwcGx5KHRoaXMubGluZVN0cmluZ0FkZGVyKX19LHNldENoZWNrUmluZ3NWYWxpZDpmdW5jdGlvbih0KXt0aGlzLmlzQ2hlY2tpbmdSaW5nc1ZhbGlkPXR9LGZpbmRTaGVsbHNBbmRIb2xlczpmdW5jdGlvbih0KXt0aGlzLmhvbGVMaXN0PW5ldyBJLHRoaXMuc2hlbGxMaXN0PW5ldyBJO2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmNvbXB1dGVIb2xlKCksbi5pc0hvbGUoKT90aGlzLmhvbGVMaXN0LmFkZChuKTp0aGlzLnNoZWxsTGlzdC5hZGQobil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUcn19KSxUci5maW5kT3V0ZXJTaGVsbHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRPdXRlckhvbGUoKTtudWxsPT09aXx8aS5pc1Byb2Nlc3NlZCgpfHwobi5zZXRJbmNsdWRlZCghMCksaS5zZXRQcm9jZXNzZWQoITApKX19LFRyLmV4dHJhY3RQb2x5Z29ucz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpOyhlfHxyLmlzSW5jbHVkZWQoKSkmJm4uYWRkKHIuZ2V0UG9seWdvbigpKX1yZXR1cm4gbn0sVHIuYXNzaWduSG9sZXNUb1NoZWxscz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtUci5hc3NpZ25Ib2xlVG9TaGVsbChpLGUpfX0sVHIuYXNzaWduSG9sZVRvU2hlbGw9ZnVuY3Rpb24odCxlKXt2YXIgbj13ci5maW5kRWRnZVJpbmdDb250YWluaW5nKHQsZSk7bnVsbCE9PW4mJm4uYWRkSG9sZSh0KX0sVHIuZmluZERpc2pvaW50U2hlbGxzPWZ1bmN0aW9uKHQpe1RyLmZpbmRPdXRlclNoZWxscyh0KTt2YXIgZT1udWxsO2Rve2U9ITE7Zm9yKHZhciBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuaXNJbmNsdWRlZFNldCgpfHwoaS51cGRhdGVJbmNsdWRlZCgpLGkuaXNJbmNsdWRlZFNldCgpfHwoZT0hMCkpfX13aGlsZShlKX0sZShQci5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgU3QmJnRoaXMucC5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQcn19KSxUci5MaW5lU3RyaW5nQWRkZXI9UHI7dmFyIFJvPU9iamVjdC5mcmVlemUoe1BvbHlnb25pemVyOlRyfSk7ZShici5wcm90b3R5cGUse2NyZWF0ZUVkZ2VFbmRGb3JOZXh0OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW4uc2VnbWVudEluZGV4KzE7aWYocj49dC5nZXROdW1Qb2ludHMoKSYmbnVsbD09PWkpcmV0dXJuIG51bGw7dmFyIHM9dC5nZXRDb29yZGluYXRlKHIpO251bGwhPT1pJiZpLnNlZ21lbnRJbmRleD09PW4uc2VnbWVudEluZGV4JiYocz1pLmNvb3JkKTt2YXIgbz1uZXcgRW4odCxuLmNvb3JkLHMsbmV3IGduKHQuZ2V0TGFiZWwoKSkpO2UuYWRkKG8pfSxjcmVhdGVFZGdlRW5kRm9yUHJldjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uLnNlZ21lbnRJbmRleDtpZigwPT09bi5kaXN0KXtpZigwPT09cilyZXR1cm4gbnVsbDtyLS19dmFyIHM9dC5nZXRDb29yZGluYXRlKHIpO251bGwhPT1pJiZpLnNlZ21lbnRJbmRleD49ciYmKHM9aS5jb29yZCk7dmFyIG89bmV3IGduKHQuZ2V0TGFiZWwoKSk7by5mbGlwKCk7dmFyIGE9bmV3IEVuKHQsbi5jb29yZCxzLG8pO2UuYWRkKGEpfSxjb21wdXRlRWRnZUVuZHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBJLG49dDtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuY29tcHV0ZUVkZ2VFbmRzKGksZSl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPXIuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtvLmFkZEVuZHBvaW50cygpO3ZhciBhPW8uaXRlcmF0b3IoKSx1PW51bGwsbD1udWxsO2lmKCFhLmhhc05leHQoKSlyZXR1cm4gbnVsbDt2YXIgaD1hLm5leHQoKTtkbyB1PWwsbD1oLGg9bnVsbCxhLmhhc05leHQoKSYmKGg9YS5uZXh0KCkpLG51bGwhPT1sJiYodGhpcy5jcmVhdGVFZGdlRW5kRm9yUHJldihyLHMsbCx1KSx0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JOZXh0KHIscyxsLGgpKTt3aGlsZShudWxsIT09bCl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBicn19KSxoKE9yLEVuKSxlKE9yLnByb3RvdHlwZSx7aW5zZXJ0OmZ1bmN0aW9uKHQpe3RoaXMuZWRnZUVuZHMuYWRkKHQpfSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJFZGdlRW5kQnVuZGxlLS0+IExhYmVsOiBcIit0aGlzLmxhYmVsKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KSx0LnByaW50bG4oKX19LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZUVuZHMuaXRlcmF0b3IoKX0sZ2V0RWRnZUVuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlRW5kc30sY29tcHV0ZUxhYmVsT246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxpPSExLHI9dGhpcy5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7bz09PUwuQk9VTkRBUlkmJm4rKyxvPT09TC5JTlRFUklPUiYmKGk9ITApfXZhciBvPUwuTk9ORTtpJiYobz1MLklOVEVSSU9SKSxuPjAmJihvPSRuLmRldGVybWluZUJvdW5kYXJ5KGUsbikpLHRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxvKX0sY29tcHV0ZUxhYmVsU2lkZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmdldExhYmVsKCkuaXNBcmVhKCkpe3ZhciByPWkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LGUpO2lmKHI9PT1MLklOVEVSSU9SKXJldHVybiB0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSxMLklOVEVSSU9SKSxudWxsO3I9PT1MLkVYVEVSSU9SJiZ0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSxMLkVYVEVSSU9SKX19fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxjb21wdXRlTGFiZWxTaWRlczpmdW5jdGlvbih0KXt0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxjbi5MRUZUKSx0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxjbi5SSUdIVCl9LHVwZGF0ZUlNOmZ1bmN0aW9uKHQpe0puLnVwZGF0ZUlNKHRoaXMubGFiZWwsdCl9LGNvbXB1dGVMYWJlbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9ITEsbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmdldExhYmVsKCkuaXNBcmVhKCkmJihlPSEwKX1lP3RoaXMubGFiZWw9bmV3IGduKEwuTk9ORSxMLk5PTkUsTC5OT05FKTp0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpO2Zvcih2YXIgcj0wOzI+cjtyKyspdGhpcy5jb21wdXRlTGFiZWxPbihyLHQpLGUmJnRoaXMuY29tcHV0ZUxhYmVsU2lkZXMocil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9yfX0pLGgoX3IsUG4pLGUoX3IucHJvdG90eXBlLHt1cGRhdGVJTTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi51cGRhdGVJTSh0KX19LGluc2VydDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VNYXAuZ2V0KHQpO251bGw9PT1lPyhlPW5ldyBPcih0KSx0aGlzLmluc2VydEVkZ2VFbmQodCxlKSk6ZS5pbnNlcnQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9yfX0pLGgoTXIseW4pLGUoTXIucHJvdG90eXBlLHt1cGRhdGVJTUZyb21FZGdlczpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLnVwZGF0ZUlNKHQpfSxjb21wdXRlSU06ZnVuY3Rpb24odCl7dC5zZXRBdExlYXN0SWZWYWxpZCh0aGlzLmxhYmVsLmdldExvY2F0aW9uKDApLHRoaXMubGFiZWwuZ2V0TG9jYXRpb24oMSksMCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE1yfX0pLGgoRHIsTm4pLGUoRHIucHJvdG90eXBlLHtjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTXIodCxuZXcgX3IpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEcn19KSxlKEFyLnByb3RvdHlwZSx7aW5zZXJ0RWRnZUVuZHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMubm9kZXMuYWRkKG4pfX0sY29tcHV0ZVByb3BlckludGVyc2VjdGlvbklNOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5hcmdbMF0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxpPXRoaXMuYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCkscj10Lmhhc1Byb3BlckludGVyc2VjdGlvbigpLHM9dC5oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpOzI9PT1uJiYyPT09aT9yJiZlLnNldEF0TGVhc3QoXCIyMTIxMDEyMTJcIik6Mj09PW4mJjE9PT1pPyhyJiZlLnNldEF0TGVhc3QoXCJGRkYwRkZGRjJcIikscyYmZS5zZXRBdExlYXN0KFwiMUZGRkZGMUZGXCIpKToxPT09biYmMj09PWk/KHImJmUuc2V0QXRMZWFzdChcIkYwRkZGRkZGMlwiKSxzJiZlLnNldEF0TGVhc3QoXCIxRjFGRkZGRkZcIikpOjE9PT1uJiYxPT09aSYmcyYmZS5zZXRBdExlYXN0KFwiMEZGRkZGRkZGXCIpfSxsYWJlbElzb2xhdGVkRWRnZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmlzSXNvbGF0ZWQoKSYmKHRoaXMubGFiZWxJc29sYXRlZEVkZ2UoaSxlLHRoaXMuYXJnW2VdLmdldEdlb21ldHJ5KCkpLHRoaXMuaXNvbGF0ZWRFZGdlcy5hZGQoaSkpfX0sbGFiZWxJc29sYXRlZEVkZ2U6ZnVuY3Rpb24odCxlLG4pe2lmKG4uZ2V0RGltZW5zaW9uKCk+MCl7dmFyIGk9dGhpcy5wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLG4pO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxpKX1lbHNlIHQuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxMLkVYVEVSSU9SKX0sY29tcHV0ZUlNOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGZlO2lmKHQuc2V0KEwuRVhURVJJT1IsTC5FWFRFUklPUiwyKSwhdGhpcy5hcmdbMF0uZ2V0R2VvbWV0cnkoKS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0aGlzLmFyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuIHRoaXMuY29tcHV0ZURpc2pvaW50SU0odCksdDt0aGlzLmFyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITEpLHRoaXMuYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSk7dmFyIGU9dGhpcy5hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuYXJnWzFdLHRoaXMubGksITEpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDApLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDEpLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDEpLHRoaXMubGFiZWxJc29sYXRlZE5vZGVzKCksdGhpcy5jb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU0oZSx0KTt2YXIgbj1uZXcgYnIsaT1uLmNvbXB1dGVFZGdlRW5kcyh0aGlzLmFyZ1swXS5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhpKTt2YXIgcj1uLmNvbXB1dGVFZGdlRW5kcyh0aGlzLmFyZ1sxXS5nZXRFZGdlSXRlcmF0b3IoKSk7cmV0dXJuIHRoaXMuaW5zZXJ0RWRnZUVuZHMociksdGhpcy5sYWJlbE5vZGVFZGdlcygpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDAsMSksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMSwwKSx0aGlzLnVwZGF0ZUlNKHQpLHR9LGxhYmVsTm9kZUVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuYXJnKX19LGNvcHlOb2Rlc0FuZExhYmVsczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5hcmdbdF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPXRoaXMubm9kZXMuYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSk7aS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fSxsYWJlbEludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmFyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpLHI9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXRoaXMubm9kZXMuZmluZChzLmNvb3JkKTtvLmdldExhYmVsKCkuaXNOdWxsKHQpJiYoaT09PUwuQk9VTkRBUlk/by5zZXRMYWJlbEJvdW5kYXJ5KHQpOm8uc2V0TGFiZWwodCxMLklOVEVSSU9SKSl9fSxsYWJlbElzb2xhdGVkTm9kZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmFyZ1tlXS5nZXRHZW9tZXRyeSgpKTt0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsbil9LGNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSxyPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz10aGlzLm5vZGVzLmFkZE5vZGUocy5jb29yZCk7aT09PUwuQk9VTkRBUlk/by5zZXRMYWJlbEJvdW5kYXJ5KHQpOm8uZ2V0TGFiZWwoKS5pc051bGwodCkmJm8uc2V0TGFiZWwodCxMLklOVEVSSU9SKX19LGxhYmVsSXNvbGF0ZWROb2RlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKTtmLmlzVHJ1ZShuLmdldEdlb21ldHJ5Q291bnQoKT4wLFwibm9kZSB3aXRoIGVtcHR5IGxhYmVsIGZvdW5kXCIpLGUuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDApOnRoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwxKSl9fSx1cGRhdGVJTTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pc29sYXRlZEVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnVwZGF0ZUlNKHQpfWZvcih2YXIgaT10aGlzLm5vZGVzLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLnVwZGF0ZUlNKHQpLHIudXBkYXRlSU1Gcm9tRWRnZXModCl9fSxjb21wdXRlRGlzam9pbnRJTTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmFyZ1swXS5nZXRHZW9tZXRyeSgpO2UuaXNFbXB0eSgpfHwodC5zZXQoTC5JTlRFUklPUixMLkVYVEVSSU9SLGUuZ2V0RGltZW5zaW9uKCkpLHQuc2V0KEwuQk9VTkRBUlksTC5FWFRFUklPUixlLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKTt2YXIgbj10aGlzLmFyZ1sxXS5nZXRHZW9tZXRyeSgpO24uaXNFbXB0eSgpfHwodC5zZXQoTC5FWFRFUklPUixMLklOVEVSSU9SLG4uZ2V0RGltZW5zaW9uKCkpLHQuc2V0KEwuRVhURVJJT1IsTC5CT1VOREFSWSxuLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQXJ9fSksZShGci5wcm90b3R5cGUse2lzQ29udGFpbmVkSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgVHQpcmV0dXJuITE7aWYodCBpbnN0YW5jZW9mIEx0KXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQgaW5zdGFuY2VvZiBTdClyZXR1cm4gdGhpcy5pc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5KHQpO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTtpZighdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkobikpcmV0dXJuITF9cmV0dXJuITB9LGlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQsZSl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodC54PT09ZS54KXtpZih0Lng9PT10aGlzLnJlY3RFbnYuZ2V0TWluWCgpfHx0Lng9PT10aGlzLnJlY3RFbnYuZ2V0TWF4WCgpKXJldHVybiEwfWVsc2UgaWYodC55PT09ZS55JiYodC55PT09dGhpcy5yZWN0RW52LmdldE1pblkoKXx8dC55PT09dGhpcy5yZWN0RW52LmdldE1heFkoKSkpcmV0dXJuITA7cmV0dXJuITF9LGlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj1uZXcgZyxpPW5ldyBnLHI9MDtyPGUuc2l6ZSgpLTE7cisrKWlmKGUuZ2V0Q29vcmRpbmF0ZShyLG4pLGUuZ2V0Q29vcmRpbmF0ZShyKzEsaSksIXRoaXMuaXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnkobixpKSlyZXR1cm4hMTtyZXR1cm4hMH0saXNQb2ludENvbnRhaW5lZEluQm91bmRhcnk6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodC5nZXRDb29yZGluYXRlKCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBlLng9PT10aGlzLnJlY3RFbnYuZ2V0TWluWCgpfHxlLng9PT10aGlzLnJlY3RFbnYuZ2V0TWF4WCgpfHxlLnk9PT10aGlzLnJlY3RFbnYuZ2V0TWluWSgpfHxlLnk9PT10aGlzLnJlY3RFbnYuZ2V0TWF4WSgpfX0sY29udGFpbnM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVjdEVudi5jb250YWlucyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk/IXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KHQpOiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGcn19KSxGci5jb250YWlucz1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBGcih0KTtyZXR1cm4gbi5jb250YWlucyhlKX0sZShHci5wcm90b3R5cGUse2ludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgQyh0LGUpO2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhuKSlyZXR1cm4hMTtpZih0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyh0KSlyZXR1cm4hMDtpZih0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4hMDtpZih0LmNvbXBhcmVUbyhlKT4wKXt2YXIgaT10O3Q9ZSxlPWl9dmFyIHI9ITE7cmV0dXJuIGUueT50LnkmJihyPSEwKSxyP3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5kaWFnRG93bjAsdGhpcy5kaWFnRG93bjEpOnRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5kaWFnVXAwLHRoaXMuZGlhZ1VwMSksISF0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHcn19KSxlKHFyLnByb3RvdHlwZSx7YXBwbHlUbzpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpJiYhdGhpcy5faXNEb25lO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7aWYobiBpbnN0YW5jZW9mIGZ0KXRoaXMuYXBwbHlUbyhuKTtlbHNlIGlmKHRoaXMudmlzaXQobiksdGhpcy5pc0RvbmUoKSlyZXR1cm4gdGhpcy5faXNEb25lPSEwLG51bGx9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxcn19KSxlKEJyLnByb3RvdHlwZSx7aW50ZXJzZWN0czpmdW5jdGlvbih0KXtpZighdGhpcy5yZWN0RW52LmludGVyc2VjdHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiExO3ZhciBlPW5ldyB6cih0aGlzLnJlY3RFbnYpO2lmKGUuYXBwbHlUbyh0KSxlLmludGVyc2VjdHMoKSlyZXR1cm4hMDt2YXIgbj1uZXcgVnIodGhpcy5yZWN0YW5nbGUpO2lmKG4uYXBwbHlUbyh0KSxuLmNvbnRhaW5zUG9pbnQoKSlyZXR1cm4hMDt2YXIgaT1uZXcga3IodGhpcy5yZWN0YW5nbGUpO3JldHVybiBpLmFwcGx5VG8odCksISFpLmludGVyc2VjdHMoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQnJ9fSksQnIuaW50ZXJzZWN0cz1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBCcih0KTtyZXR1cm4gbi5pbnRlcnNlY3RzKGUpfSxoKHpyLHFyKSxlKHpyLnByb3RvdHlwZSx7aXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdHM9PT0hMH0sdmlzaXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIHRoaXMucmVjdEVudi5pbnRlcnNlY3RzKGUpP3RoaXMucmVjdEVudi5jb250YWlucyhlKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTplLmdldE1pblgoKT49dGhpcy5yZWN0RW52LmdldE1pblgoKSYmZS5nZXRNYXhYKCk8PXRoaXMucmVjdEVudi5nZXRNYXhYKCk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6ZS5nZXRNaW5ZKCk+PXRoaXMucmVjdEVudi5nZXRNaW5ZKCkmJmUuZ2V0TWF4WSgpPD10aGlzLnJlY3RFbnYuZ2V0TWF4WSgpPyh0aGlzLl9pbnRlcnNlY3RzPSEwLG51bGwpOnZvaWQgMDpudWxsfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdHN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHpyfX0pLGgoVnIscXIpLGUoVnIucHJvdG90eXBlLHtpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludD09PSEwfSx2aXNpdDpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBUdCkpcmV0dXJuIG51bGw7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMucmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO2Zvcih2YXIgbj1uZXcgZyxpPTA7ND5pO2krKylpZih0aGlzLnJlY3RTZXEuZ2V0Q29vcmRpbmF0ZShpLG4pLGUuY29udGFpbnMobikmJlRuLmNvbnRhaW5zUG9pbnRJblBvbHlnb24obix0KSlyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludD0hMCxudWxsfSxjb250YWluc1BvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZyfX0pLGgoa3IscXIpLGUoa3IucHJvdG90eXBlLHtpbnRlcnNlY3RzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9ufSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb249PT0hMH0sdmlzaXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMucmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO3ZhciBuPWtuLmdldExpbmVzKHQpO3RoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3Mobil9LGNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZih0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzKG4pLHRoaXMuaGFzSW50ZXJzZWN0aW9uKXJldHVybiBudWxsfX0sY2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj0xO248ZS5zaXplKCk7bisrKWlmKGUuZ2V0Q29vcmRpbmF0ZShuLTEsdGhpcy5wMCksZS5nZXRDb29yZGluYXRlKG4sdGhpcy5wMSksdGhpcy5yZWN0SW50ZXJzZWN0b3IuaW50ZXJzZWN0cyh0aGlzLnAwLHRoaXMucDEpKXJldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbj0hMCxudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrcn19KSxoKFlyLHRpKSxlKFlyLnByb3RvdHlwZSx7Z2V0SW50ZXJzZWN0aW9uTWF0cml4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbGF0ZS5jb21wdXRlSU0oKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWXJ9fSksWXIuY292ZXJzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvdmVycyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/dC5pc1JlY3RhbmdsZSgpPyEwOllyLnJlbGF0ZSh0LGUpLmlzQ292ZXJzKCk6ITF9LFlyLmludGVyc2VjdHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/dC5pc1JlY3RhbmdsZSgpP0JyLmludGVyc2VjdHModCxlKTplLmlzUmVjdGFuZ2xlKCk/QnIuaW50ZXJzZWN0cyhlLHQpOllyLnJlbGF0ZSh0LGUpLmlzSW50ZXJzZWN0cygpOiExfSxZci50b3VjaGVzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP1lyLnJlbGF0ZSh0LGUpLmlzVG91Y2hlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpOiExfSxZci53aXRoaW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5jb250YWlucyh0KX0sWXIuY292ZXJlZEJ5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFlyLmNvdmVycyhlLHQpfSxZci5yZWxhdGU9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFlyKHQsZSksaT1uLmdldEludGVyc2VjdGlvbk1hdHJpeCgpO3JldHVybiBpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQil7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3JldHVybiBZci5yZWxhdGVXaXRoQ2hlY2socixzKS5tYXRjaGVzKG8pfWlmKFIoYXJndW1lbnRzWzJdLFYpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQil7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdLGw9YXJndW1lbnRzWzJdLG49bmV3IFlyKGEsdSxsKSxpPW4uZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCk7cmV0dXJuIGl9fX0sWXIub3ZlcmxhcHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/WXIucmVsYXRlKHQsZSkuaXNPdmVybGFwcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpOiExfSxZci5kaXNqb2ludD1mdW5jdGlvbih0LGUpe3JldHVybiF0LmludGVyc2VjdHMoZSl9LFlyLnJlbGF0ZVdpdGhDaGVjaz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksWXIucmVsYXRlKHQsZSl9LFlyLmNyb3NzZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/WXIucmVsYXRlKHQsZSkuaXNDcm9zc2VzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSk6ITF9LFlyLmNvbnRhaW5zPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvbnRhaW5zKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT90LmlzUmVjdGFuZ2xlKCk/RnIuY29udGFpbnModCxlKTpZci5yZWxhdGUodCxlKS5pc0NvbnRhaW5zKCk6ITF9O3ZhciBUbz1PYmplY3QuZnJlZXplKHtSZWxhdGVPcDpZcn0pO2UoVXIucHJvdG90eXBlLHtleHRyYWN0RWxlbWVudHM6ZnVuY3Rpb24odCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtmb3IodmFyIG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dC5nZXRHZW9tZXRyeU4obik7dGhpcy5za2lwRW1wdHkmJmkuaXNFbXB0eSgpfHxlLmFkZChpKX19LGNvbWJpbmU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEksZT10aGlzLmlucHV0R2VvbXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuZXh0cmFjdEVsZW1lbnRzKG4sdCl9cmV0dXJuIDA9PT10LnNpemUoKT9udWxsIT09dGhpcy5nZW9tRmFjdG9yeT90aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKTpudWxsOnRoaXMuZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVXJ9fSksVXIuY29tYmluZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgVXIodCk7cmV0dXJuIGUuY29tYmluZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1uZXcgVXIoVXIuY3JlYXRlTGlzdChuLGkpKTtyZXR1cm4gZS5jb21iaW5lKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxlPW5ldyBVcihVci5jcmVhdGVMaXN0KHIscyxvKSk7cmV0dXJuIGUuY29tYmluZSgpfX0sVXIuZXh0cmFjdEZhY3Rvcnk9ZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNFbXB0eSgpP251bGw6dC5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCl9LFVyLmNyZWF0ZUxpc3Q9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEk7cmV0dXJuIG4uYWRkKHQpLG4uYWRkKGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxuPW5ldyBJO3JldHVybiBuLmFkZChpKSxuLmFkZChyKSxuLmFkZChzKSxufX0sZShYci5wcm90b3R5cGUse3VuaW9uOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBUZSxlPW5ldyBhdCxuPTA7bjx0aGlzLnBvaW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10aGlzLnBvaW50R2VvbS5nZXRHZW9tZXRyeU4obikscj1pLmdldENvb3JkaW5hdGUoKSxzPXQubG9jYXRlKHIsdGhpcy5vdGhlckdlb20pO3M9PT1MLkVYVEVSSU9SJiZlLmFkZChyKX1pZigwPT09ZS5zaXplKCkpcmV0dXJuIHRoaXMub3RoZXJHZW9tO3ZhciBvPW51bGwsYT1ILnRvQ29vcmRpbmF0ZUFycmF5KGUpO3JldHVybiBvPTE9PT1hLmxlbmd0aD90aGlzLmdlb21GYWN0LmNyZWF0ZVBvaW50KGFbMF0pOnRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoYSksVXIuY29tYmluZShvLHRoaXMub3RoZXJHZW9tKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWHJ9fSksWHIudW5pb249ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgWHIodCxlKTtyZXR1cm4gbi51bmlvbigpfSxlKEhyLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpey0xIT09dGhpcy5zb3J0SW5kZXgmJnQuZ2V0U29ydEluZGV4KCkhPT10aGlzLnNvcnRJbmRleHx8dGhpcy5jb21wcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2h0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSHJ9fSksSHIuZXh0cmFjdD1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIEhyLmV4dHJhY3QodCxlLG5ldyBJKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3JldHVybiBuLmdldFNvcnRJbmRleCgpPT09aT9yLmFkZChuKTpuIGluc3RhbmNlb2YgZnQmJm4uYXBwbHkobmV3IEhyKGkscikpLHJ9fSxlKFdyLnByb3RvdHlwZSx7cmVkdWNlVG9HZW9tZXRyaWVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9bnVsbDtSKGkseSk/cj10aGlzLnVuaW9uVHJlZShpKTppIGluc3RhbmNlb2YgQiYmKHI9aSksZS5hZGQocil9cmV0dXJuIGV9LGV4dHJhY3RCeUVudmVsb3BlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bmV3IEkscj0wO3I8ZS5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXt2YXIgcz1lLmdldEdlb21ldHJ5TihyKTtzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP2kuYWRkKHMpOm4uYWRkKHMpfXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkoaSl9LHVuaW9uT3B0aW1pemVkOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRFbnZlbG9wZUludGVybmFsKCksaT1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighbi5pbnRlcnNlY3RzKGkpKXt2YXIgcj1Vci5jb21iaW5lKHQsZSk7cmV0dXJuIHJ9aWYodC5nZXROdW1HZW9tZXRyaWVzKCk8PTEmJmUuZ2V0TnVtR2VvbWV0cmllcygpPD0xKXJldHVybiB0aGlzLnVuaW9uQWN0dWFsKHQsZSk7dmFyIHM9bi5pbnRlcnNlY3Rpb24oaSk7cmV0dXJuIHRoaXMudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uKHQsZSxzKX0sdW5pb246ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5pbnB1dFBvbHlzKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJ1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlXCIpO2lmKHRoaXMuaW5wdXRQb2x5cy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZW9tRmFjdG9yeT10aGlzLmlucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO2Zvcih2YXIgdD1uZXcga2UoV3IuU1RSVFJFRV9OT0RFX0NBUEFDSVRZKSxlPXRoaXMuaW5wdXRQb2x5cy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dC5pbnNlcnQobi5nZXRFbnZlbG9wZUludGVybmFsKCksbil9dGhpcy5pbnB1dFBvbHlzPW51bGw7dmFyIGk9dC5pdGVtc1RyZWUoKSxyPXRoaXMudW5pb25UcmVlKGkpO3JldHVybiByfSxiaW5hcnlVbmlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24odCwwLHQuc2l6ZSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9YXJndW1lbnRzWzJdO2lmKDE+PWktbil7dmFyIHI9V3IuZ2V0R2VvbWV0cnkoZSxuKTtyZXR1cm4gdGhpcy51bmlvblNhZmUocixudWxsKX1pZihpLW49PT0yKXJldHVybiB0aGlzLnVuaW9uU2FmZShXci5nZXRHZW9tZXRyeShlLG4pLFdyLmdldEdlb21ldHJ5KGUsbisxKSk7dmFyIHM9TWF0aC50cnVuYygoaStuKS8yKSxyPXRoaXMuYmluYXJ5VW5pb24oZSxuLHMpLG89dGhpcy5iaW5hcnlVbmlvbihlLHMsaSk7cmV0dXJuIHRoaXMudW5pb25TYWZlKHIsbyl9fSxyZXBlYXRlZFVuaW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZT1udWxsPT09ZT9pLmNvcHkoKTplLnVuaW9uKGkpfXJldHVybiBlfSx1bmlvblNhZmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PXQ/ZS5jb3B5KCk6bnVsbD09PWU/dC5jb3B5KCk6dGhpcy51bmlvbk9wdGltaXplZCh0LGUpfSx1bmlvbkFjdHVhbDpmdW5jdGlvbih0LGUpe3JldHVybiBXci5yZXN0cmljdFRvUG9seWdvbnModC51bmlvbihlKSl9LHVuaW9uVHJlZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlZHVjZVRvR2VvbWV0cmllcyh0KSxuPXRoaXMuYmluYXJ5VW5pb24oZSk7cmV0dXJuIG59LHVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEkscj10aGlzLmV4dHJhY3RCeUVudmVsb3BlKG4sdCxpKSxzPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUobixlLGkpLG89dGhpcy51bmlvbkFjdHVhbChyLHMpO2kuYWRkKG8pO3ZhciBhPVVyLmNvbWJpbmUoaSk7cmV0dXJuIGF9LGJ1ZmZlclVuaW9uOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0KDApLmdldEZhY3RvcnkoKSxuPWUuYnVpbGRHZW9tZXRyeSh0KSxpPW4uYnVmZmVyKDApO3JldHVybiBpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sZT1yLmdldEZhY3RvcnkoKSxuPWUuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFtyLHNdKSxpPW4uYnVmZmVyKDApO3JldHVybiBpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV3J9fSksV3IucmVzdHJpY3RUb1BvbHlnb25zPWZ1bmN0aW9uKHQpe2lmKFIodCxSdCkpcmV0dXJuIHQ7dmFyIGU9b3IuZ2V0UG9seWdvbnModCk7cmV0dXJuIDE9PT1lLnNpemUoKT9lLmdldCgwKTp0LmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oaWUudG9Qb2x5Z29uQXJyYXkoZSkpfSxXci5nZXRHZW9tZXRyeT1mdW5jdGlvbih0LGUpe3JldHVybiBlPj10LnNpemUoKT9udWxsOnQuZ2V0KGUpfSxXci51bmlvbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgV3IodCk7cmV0dXJuIGUudW5pb24oKX0sV3IuU1RSVFJFRV9OT0RFX0NBUEFDSVRZPTQsZShqci5wcm90b3R5cGUse3VuaW9uTm9PcHQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2ludCgpO3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlVOSU9OKX0sdW5pb25XaXRoTnVsbDpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09ZT90Om51bGw9PT10P2U6dC51bmlvbihlKX0sZXh0cmFjdDpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3Qobil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBpPWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5nZW9tRmFjdCYmKHRoaXMuZ2VvbUZhY3Q9aS5nZXRGYWN0b3J5KCkpLEhyLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9QT0xZR09OLHRoaXMucG9seWdvbnMpLEhyLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9MSU5FU1RSSU5HLHRoaXMubGluZXMpLEhyLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9QT0lOVCx0aGlzLnBvaW50cyl9fSx1bmlvbjpmdW5jdGlvbiB0KCl7aWYobnVsbD09PXRoaXMuZ2VvbUZhY3QpcmV0dXJuIG51bGw7dmFyIGU9bnVsbDtpZih0aGlzLnBvaW50cy5zaXplKCk+MCl7dmFyIG49dGhpcy5nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHRoaXMucG9pbnRzKTtlPXRoaXMudW5pb25Ob09wdChuKX12YXIgaT1udWxsO2lmKHRoaXMubGluZXMuc2l6ZSgpPjApe3ZhciByPXRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLmxpbmVzKTtpPXRoaXMudW5pb25Ob09wdChyKX12YXIgcz1udWxsO3RoaXMucG9seWdvbnMuc2l6ZSgpPjAmJihzPVdyLnVuaW9uKHRoaXMucG9seWdvbnMpKTt2YXIgbz10aGlzLnVuaW9uV2l0aE51bGwoaSxzKSx0PW51bGw7cmV0dXJuIHQ9bnVsbD09PWU/bzpudWxsPT09bz9lOlhyLnVuaW9uKGUsbyksbnVsbD09PXQ/dGhpcy5nZW9tRmFjdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTp0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqcn19KSxqci51bmlvbj1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IGpyKHQpO3JldHVybiBlLnVuaW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgbj1hcmd1bWVudHNbMF0sZT1uZXcganIobik7cmV0dXJuIGUudW5pb24oKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLGU9bmV3IGpyKGkscik7cmV0dXJuIGUudW5pb24oKX19O3ZhciBQbz1PYmplY3QuZnJlZXplKHtVbmFyeVVuaW9uT3A6anJ9KTtlKEtyLnByb3RvdHlwZSx7dmlzaXRJbnRlcmlvclJpbmc6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldENvb3JkaW5hdGVzKCksaT1uWzBdLHI9S3IuZmluZERpZmZlcmVudFBvaW50KG4saSkscz1lLmZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKGksciksbz1lLmZpbmRFZGdlRW5kKHMpLGE9bnVsbDtvLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SP2E9bzpvLmdldFN5bSgpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SJiYoYT1vLmdldFN5bSgpKSxmLmlzVHJ1ZShudWxsIT09YSxcInVuYWJsZSB0byBmaW5kIGRpckVkZ2Ugd2l0aCBJbnRlcmlvciBvbiBSSFNcIiksdGhpcy52aXNpdExpbmtlZERpcmVjdGVkRWRnZXMoYSl9LHZpc2l0U2hlbGxJbnRlcmlvcnM6ZnVuY3Rpb24odCxlKXtpZih0IGluc3RhbmNlb2YgVHQpe3ZhciBuPXQ7dGhpcy52aXNpdEludGVyaW9yUmluZyhuLmdldEV4dGVyaW9yUmluZygpLGUpfWlmKHQgaW5zdGFuY2VvZiBPdClmb3IodmFyIGk9dCxyPTA7cjxpLmdldE51bUdlb21ldHJpZXMoKTtyKyspe3ZhciBuPWkuZ2V0R2VvbWV0cnlOKHIpO3RoaXMudmlzaXRJbnRlcmlvclJpbmcobi5nZXRFeHRlcmlvclJpbmcoKSxlKX19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNjb25uZWN0ZWRSaW5nY29vcmR9LHNldEludGVyaW9yRWRnZXNJblJlc3VsdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SJiZuLnNldEluUmVzdWx0KCEwKX19LHZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlczpmdW5jdGlvbih0KXt2YXIgZT10LG49dDtkbyBmLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgRGlyZWN0ZWQgRWRnZVwiKSxuLnNldFZpc2l0ZWQoITApLG49bi5nZXROZXh0KCk7d2hpbGUobiE9PWUpfSxidWlsZEVkZ2VSaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmlzSW5SZXN1bHQoKSYmbnVsbD09PWkuZ2V0RWRnZVJpbmcoKSl7dmFyIHI9bmV3IHZuKGksdGhpcy5nZW9tZXRyeUZhY3RvcnkpO3IubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7dmFyIHM9ci5idWlsZE1pbmltYWxSaW5ncygpO2UuYWRkQWxsKHMpfX1yZXR1cm4gZX0saGFzVW52aXNpdGVkU2hlbGxFZGdlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5zaXplKCk7ZSsrKXt2YXIgbj10LmdldChlKTtpZighbi5pc0hvbGUoKSl7dmFyIGk9bi5nZXRFZGdlcygpLHI9aS5nZXQoMCk7aWYoci5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsY24uUklHSFQpPT09TC5JTlRFUklPUilmb3IodmFyIHM9MDtzPGkuc2l6ZSgpO3MrKylpZihyPWkuZ2V0KHMpLFxuIXIuaXNWaXNpdGVkKCkpcmV0dXJuIHRoaXMuZGlzY29ubmVjdGVkUmluZ2Nvb3JkPXIuZ2V0Q29vcmRpbmF0ZSgpLCEwfX1yZXR1cm4hMX0saXNJbnRlcmlvcnNDb25uZWN0ZWQ6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTt0aGlzLmdlb21HcmFwaC5jb21wdXRlU3BsaXRFZGdlcyh0KTt2YXIgZT1uZXcgQ24obmV3IE9uKTtlLmFkZEVkZ2VzKHQpLHRoaXMuc2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0KGUpLGUubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKTt2YXIgbj10aGlzLmJ1aWxkRWRnZVJpbmdzKGUuZ2V0RWRnZUVuZHMoKSk7cmV0dXJuIHRoaXMudmlzaXRTaGVsbEludGVyaW9ycyh0aGlzLmdlb21HcmFwaC5nZXRHZW9tZXRyeSgpLGUpLCF0aGlzLmhhc1VudmlzaXRlZFNoZWxsRWRnZShuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS3J9fSksS3IuZmluZERpZmZlcmVudFBvaW50PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGUpKXJldHVybiB0W25dO3JldHVybiBudWxsfSxlKFpyLnByb3RvdHlwZSx7aGFzQ2hpbGRyZW46ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDsyPnQ7dCsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbdF0pcmV0dXJuITA7cmV0dXJuITF9LGlzUHJ1bmFibGU6ZnVuY3Rpb24oKXtyZXR1cm4hKHRoaXMuaGFzQ2hpbGRyZW4oKXx8dGhpcy5oYXNJdGVtcygpKX0sYWRkQWxsSXRlbXM6ZnVuY3Rpb24odCl7dC5hZGRBbGwodGhpcy5pdGVtcyk7Zm9yKHZhciBlPTA7Mj5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiZ0aGlzLnN1Ym5vZGVbZV0uYWRkQWxsSXRlbXModCk7cmV0dXJuIHR9LHNpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7Mj5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrdGhpcy5pdGVtcy5zaXplKCl9LGFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT10fHx0aGlzLmlzU2VhcmNoTWF0Y2godCk/KGUuYWRkQWxsKHRoaXMuaXRlbXMpLG51bGwhPT10aGlzLnN1Ym5vZGVbMF0mJnRoaXMuc3Vibm9kZVswXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpLHZvaWQobnVsbCE9PXRoaXMuc3Vibm9kZVsxXSYmdGhpcy5zdWJub2RlWzFdLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSkpKTpudWxsfSxoYXNJdGVtczpmdW5jdGlvbigpe3JldHVybiF0aGlzLml0ZW1zLmlzRW1wdHkoKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4hMTtmb3IodmFyIG49ITEsaT0wOzI+aTtpKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtpXSYmKG49dGhpcy5zdWJub2RlW2ldLnJlbW92ZSh0LGUpKSl7dGhpcy5zdWJub2RlW2ldLmlzUHJ1bmFibGUoKSYmKHRoaXMuc3Vibm9kZVtpXT1udWxsKTticmVha31yZXR1cm4gbj9uOm49dGhpcy5pdGVtcy5yZW1vdmUoZSl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGRlcHRoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzI+ZTtlKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtlXSl7dmFyIG49dGhpcy5zdWJub2RlW2VdLmRlcHRoKCk7bj50JiYodD1uKX1yZXR1cm4gdCsxfSxub2RlU2l6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDsyPmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0Kz10aGlzLnN1Ym5vZGVbZV0ubm9kZVNpemUoKSk7cmV0dXJuIHQrMX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuaXRlbXMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBacn19KSxaci5nZXRTdWJub2RlSW5kZXg9ZnVuY3Rpb24odCxlKXt2YXIgbj0tMTtyZXR1cm4gdC5taW4+PWUmJihuPTEpLHQubWF4PD1lJiYobj0wKSxufSxlKFFyLnByb3RvdHlwZSx7ZXhwYW5kVG9JbmNsdWRlOmZ1bmN0aW9uKHQpe3QubWF4PnRoaXMubWF4JiYodGhpcy5tYXg9dC5tYXgpLHQubWluPHRoaXMubWluJiYodGhpcy5taW49dC5taW4pfSxnZXRXaWR0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heC10aGlzLm1pbn0sb3ZlcmxhcHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLm92ZXJsYXBzKHQubWluLHQubWF4KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiEodGhpcy5taW4+bnx8dGhpcy5tYXg8ZSl9fSxnZXRNaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW59LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJbXCIrdGhpcy5taW4rXCIsIFwiK3RoaXMubWF4K1wiXVwifSxjb250YWluczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFFyKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY29udGFpbnModC5taW4sdC5tYXgpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gZT49dGhpcy5taW4mJmU8PXRoaXMubWF4fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIG4+PXRoaXMubWluJiZpPD10aGlzLm1heH19LGluaXQ6ZnVuY3Rpb24odCxlKXt0aGlzLm1pbj10LHRoaXMubWF4PWUsdD5lJiYodGhpcy5taW49ZSx0aGlzLm1heD10KX0sZ2V0TWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBRcn19KSxlKEpyLnByb3RvdHlwZSx7Z2V0SW50ZXJ2YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnZhbH0sZ2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sY29tcHV0ZUtleTpmdW5jdGlvbih0KXtmb3IodGhpcy5sZXZlbD1Kci5jb21wdXRlTGV2ZWwodCksdGhpcy5pbnRlcnZhbD1uZXcgUXIsdGhpcy5jb21wdXRlSW50ZXJ2YWwodGhpcy5sZXZlbCx0KTshdGhpcy5pbnRlcnZhbC5jb250YWlucyh0KTspdGhpcy5sZXZlbCs9MSx0aGlzLmNvbXB1dGVJbnRlcnZhbCh0aGlzLmxldmVsLHQpfSxjb21wdXRlSW50ZXJ2YWw6ZnVuY3Rpb24odCxlKXt2YXIgbj1DaS5wb3dlck9mMih0KTt0aGlzLnB0PU1hdGguZmxvb3IoZS5nZXRNaW4oKS9uKSpuLHRoaXMuaW50ZXJ2YWwuaW5pdCh0aGlzLnB0LHRoaXMucHQrbil9LGdldFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEpyfX0pLEpyLmNvbXB1dGVMZXZlbD1mdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCksbj1DaS5leHBvbmVudChlKSsxO3JldHVybiBufSxoKCRyLFpyKSxlKCRyLnByb3RvdHlwZSx7Z2V0SW50ZXJ2YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnZhbH0sZmluZDpmdW5jdGlvbih0KXt2YXIgZT1aci5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZSk7aWYoLTE9PT1lKXJldHVybiB0aGlzO2lmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXTtyZXR1cm4gbi5maW5kKHQpfXJldHVybiB0aGlzfSxpbnNlcnQ6ZnVuY3Rpb24odCl7Zi5pc1RydWUobnVsbD09PXRoaXMuaW50ZXJ2YWx8fHRoaXMuaW50ZXJ2YWwuY29udGFpbnModC5pbnRlcnZhbCkpO3ZhciBlPVpyLmdldFN1Ym5vZGVJbmRleCh0LmludGVydmFsLHRoaXMuY2VudHJlKTtpZih0LmxldmVsPT09dGhpcy5sZXZlbC0xKXRoaXMuc3Vibm9kZVtlXT10O2Vsc2V7dmFyIG49dGhpcy5jcmVhdGVTdWJub2RlKGUpO24uaW5zZXJ0KHQpLHRoaXMuc3Vibm9kZVtlXT1ufX0saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gdC5vdmVybGFwcyh0aGlzLmludGVydmFsKX0sZ2V0U3Vibm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXRoaXMuc3Vibm9kZVt0XSYmKHRoaXMuc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuc3Vibm9kZVt0XX0sZ2V0Tm9kZTpmdW5jdGlvbih0KXt2YXIgZT1aci5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZSk7aWYoLTEhPT1lKXt2YXIgbj10aGlzLmdldFN1Ym5vZGUoZSk7cmV0dXJuIG4uZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc30sY3JlYXRlU3Vibm9kZTpmdW5jdGlvbih0KXt2YXIgZT0wLG49MDtzd2l0Y2godCl7Y2FzZSAwOmU9dGhpcy5pbnRlcnZhbC5nZXRNaW4oKSxuPXRoaXMuY2VudHJlO2JyZWFrO2Nhc2UgMTplPXRoaXMuY2VudHJlLG49dGhpcy5pbnRlcnZhbC5nZXRNYXgoKX12YXIgaT1uZXcgUXIoZSxuKSxyPW5ldyAkcihpLHRoaXMubGV2ZWwtMSk7cmV0dXJuIHJ9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRyfX0pLCRyLmNyZWF0ZU5vZGU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEpyKHQpLG49bmV3ICRyKGUuZ2V0SW50ZXJ2YWwoKSxlLmdldExldmVsKCkpO3JldHVybiBufSwkci5jcmVhdGVFeHBhbmRlZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBRcihlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5pbnRlcnZhbCk7dmFyIGk9JHIuY3JlYXRlTm9kZShuKTtyZXR1cm4gbnVsbCE9PXQmJmkuaW5zZXJ0KHQpLGl9LGgodHMsWnIpLGUodHMucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1aci5nZXRTdWJub2RlSW5kZXgodCx0cy5vcmlnaW4pO2lmKC0xPT09bilyZXR1cm4gdGhpcy5hZGQoZSksbnVsbDt2YXIgaT10aGlzLnN1Ym5vZGVbbl07aWYobnVsbD09PWl8fCFpLmdldEludGVydmFsKCkuY29udGFpbnModCkpe3ZhciByPSRyLmNyZWF0ZUV4cGFuZGVkKGksdCk7dGhpcy5zdWJub2RlW25dPXJ9dGhpcy5pbnNlcnRDb250YWluZWQodGhpcy5zdWJub2RlW25dLHQsZSl9LGlzU2VhcmNoTWF0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuITB9LGluc2VydENvbnRhaW5lZDpmdW5jdGlvbih0LGUsbil7Zi5pc1RydWUodC5nZXRJbnRlcnZhbCgpLmNvbnRhaW5zKGUpKTt2YXIgaT1SaS5pc1plcm9XaWR0aChlLmdldE1pbigpLGUuZ2V0TWF4KCkpLHI9bnVsbDtyPWk/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxyLmFkZChuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdHN9fSksdHMub3JpZ2luPTAsZShlcy5wcm90b3R5cGUse3NpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3Quc2l6ZSgpOjB9LGluc2VydDpmdW5jdGlvbih0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO3ZhciBuPWVzLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTt0aGlzLnJvb3QuaW5zZXJ0KG4sZSl9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5xdWVyeShuZXcgUXIodCx0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBRcil7dmFyIGU9YXJndW1lbnRzWzBdLG49bmV3IEk7cmV0dXJuIHRoaXMucXVlcnkoZSxuKSxufX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07dGhpcy5yb290LmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKGkscil9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3JldHVybiB0aGlzLnJvb3QuYWRkQWxsSXRlbXModCksdC5pdGVyYXRvcigpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXt2YXIgbj1lcy5lbnN1cmVFeHRlbnQodCx0aGlzLm1pbkV4dGVudCk7cmV0dXJuIHRoaXMucm9vdC5yZW1vdmUobixlKX0sY29sbGVjdFN0YXRzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0V2lkdGgoKTtlPHRoaXMubWluRXh0ZW50JiZlPjAmJih0aGlzLm1pbkV4dGVudD1lKX0sZGVwdGg6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3QuZGVwdGgoKTowfSxub2RlU2l6ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5ub2RlU2l6ZSgpOjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVzfX0pLGVzLmVuc3VyZUV4dGVudD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0TWluKCksaT10LmdldE1heCgpO3JldHVybiBuIT09aT90OihuPT09aSYmKG4tPWUvMixpPW4rZS8yKSxuZXcgUXIobixpKSl9LGUobnMucHJvdG90eXBlLHtpc0luc2lkZTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5zfX0pLGUoaXMucHJvdG90eXBlLHt0ZXN0TGluZVNlZ21lbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1udWxsLGk9bnVsbCxyPW51bGwscz1udWxsLG89bnVsbCxhPWUucDAsdT1lLnAxO2k9YS54LXQueCxyPWEueS10Lnkscz11LngtdC54LG89dS55LXQueSwocj4wJiYwPj1vfHxvPjAmJjA+PXIpJiYobj11ZS5zaWduT2ZEZXQyeDIoaSxyLHMsbykvKG8tciksbj4wJiZ0aGlzLmNyb3NzaW5ncysrKX0sYnVpbGRJbmRleDpmdW5jdGlvbigpe3RoaXMudHJlZT1uZXcgZXM7Zm9yKHZhciB0PUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModGhpcy5yaW5nLmdldENvb3JkaW5hdGVzKCkpLGU9JGUuZ2V0Q2hhaW5zKHQpLG49MDtuPGUuc2l6ZSgpO24rKyl7dmFyIGk9ZS5nZXQobikscj1pLmdldEVudmVsb3BlKCk7dGhpcy5pbnRlcnZhbC5taW49ci5nZXRNaW5ZKCksdGhpcy5pbnRlcnZhbC5tYXg9ci5nZXRNYXhZKCksdGhpcy50cmVlLmluc2VydCh0aGlzLmludGVydmFsLGkpfX0sdGVzdE1vbm90b25lQ2hhaW46ZnVuY3Rpb24odCxlLG4pe24uc2VsZWN0KHQsZSl9LGlzSW5zaWRlOmZ1bmN0aW9uKHQpe3RoaXMuY3Jvc3NpbmdzPTA7dmFyIGU9bmV3IEMoci5ORUdBVElWRV9JTkZJTklUWSxyLlBPU0lUSVZFX0lORklOSVRZLHQueSx0LnkpO3RoaXMuaW50ZXJ2YWwubWluPXQueSx0aGlzLmludGVydmFsLm1heD10Lnk7Zm9yKHZhciBuPXRoaXMudHJlZS5xdWVyeSh0aGlzLmludGVydmFsKSxpPW5ldyBycyh0aGlzLHQpLHM9bi5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCk7dGhpcy50ZXN0TW9ub3RvbmVDaGFpbihlLGksbyl9cmV0dXJuIHRoaXMuY3Jvc3NpbmdzJTI9PT0xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltuc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGlzfX0pLGgocnMsdHIpLGUocnMucHJvdG90eXBlLHtzZWxlY3Q6ZnVuY3Rpb24oKXtpZigxIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdHIucHJvdG90eXBlLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubWNwLnRlc3RMaW5lU2VnbWVudCh0aGlzLnAsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHJzfX0pLGlzLk1DU2VsZWN0ZXI9cnMsZShzcy5wcm90b3R5cGUse2luc2VydEVkZ2VFbmRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLm5vZGVzLmFkZChuKX19LGdldE5vZGVJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzLml0ZXJhdG9yKCl9LGNvcHlOb2Rlc0FuZExhYmVsczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldE5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj10aGlzLm5vZGVzLmFkZE5vZGUoaS5nZXRDb29yZGluYXRlKCkpO3Iuc2V0TGFiZWwoZSxpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSkpfX0sYnVpbGQ6ZnVuY3Rpb24odCl7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCwwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscyh0LDApO3ZhciBlPW5ldyBicixuPWUuY29tcHV0ZUVkZ2VFbmRzKHQuZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMobil9LGNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOylmb3IodmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSkscz1pLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpLGE9dGhpcy5ub2Rlcy5hZGROb2RlKG8uY29vcmQpO3I9PT1MLkJPVU5EQVJZP2Euc2V0TGFiZWxCb3VuZGFyeShlKTphLmdldExhYmVsKCkuaXNOdWxsKGUpJiZhLnNldExhYmVsKGUsTC5JTlRFUklPUil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzc319KSxlKG9zLnByb3RvdHlwZSx7aXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7aWYoIWUuZ2V0RWRnZXMoKS5pc0FyZWFMYWJlbHNDb25zaXN0ZW50KHRoaXMuZ2VvbUdyYXBoKSlyZXR1cm4gdGhpcy5pbnZhbGlkUG9pbnQ9ZS5nZXRDb29yZGluYXRlKCkuY29weSgpLCExfXJldHVybiEwfSxnZXRJbnZhbGlkUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZhbGlkUG9pbnR9LGhhc0R1cGxpY2F0ZVJpbmdzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOylmb3IodmFyIGU9dC5uZXh0KCksbj1lLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuZ2V0RWRnZUVuZHMoKS5zaXplKCk+MSlyZXR1cm4gdGhpcy5pbnZhbGlkUG9pbnQ9aS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZSgwKSwhMH1yZXR1cm4hMX0saXNOb2RlQ29uc2lzdGVudEFyZWE6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdlb21HcmFwaC5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITAsITApO3JldHVybiB0Lmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLmludmFsaWRQb2ludD10LmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOih0aGlzLm5vZGVHcmFwaC5idWlsZCh0aGlzLmdlb21HcmFwaCksdGhpcy5pc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9zfX0pLGUoYXMucHJvdG90eXBlLHtidWlsZEluZGV4OmZ1bmN0aW9uKCl7dGhpcy5pbmRleD1uZXcga2U7Zm9yKHZhciB0PTA7dDx0aGlzLnJpbmdzLnNpemUoKTt0Kyspe3ZhciBlPXRoaXMucmluZ3MuZ2V0KHQpLG49ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7dGhpcy5pbmRleC5pbnNlcnQobixlKX19LGdldE5lc3RlZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmVzdGVkUHR9LGlzTm9uTmVzdGVkOmZ1bmN0aW9uKCl7dGhpcy5idWlsZEluZGV4KCk7Zm9yKHZhciB0PTA7dDx0aGlzLnJpbmdzLnNpemUoKTt0KyspZm9yKHZhciBlPXRoaXMucmluZ3MuZ2V0KHQpLG49ZS5nZXRDb29yZGluYXRlcygpLGk9dGhpcy5pbmRleC5xdWVyeShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkscj0wO3I8aS5zaXplKCk7cisrKXt2YXIgcz1pLmdldChyKSxvPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlIT09cyYmZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhzLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpe3ZhciBhPWxzLmZpbmRQdE5vdE5vZGUobixzLHRoaXMuZ3JhcGgpO2lmKG51bGwhPT1hKXt2YXIgdT1oZS5pc1BvaW50SW5SaW5nKGEsbyk7aWYodSlyZXR1cm4gdGhpcy5uZXN0ZWRQdD1hLCExfX19cmV0dXJuITB9LGFkZDpmdW5jdGlvbih0KXt0aGlzLnJpbmdzLmFkZCh0KSx0aGlzLnRvdGFsRW52LmV4cGFuZFRvSW5jbHVkZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFzfX0pLGUodXMucHJvdG90eXBlLHtnZXRFcnJvclR5cGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcnJvclR5cGV9LGdldE1lc3NhZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdXMuZXJyTXNnW3RoaXMuZXJyb3JUeXBlXX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PVwiXCI7cmV0dXJuIG51bGwhPT10aGlzLnB0JiYodD1cIiBhdCBvciBuZWFyIHBvaW50IFwiK3RoaXMucHQpLHRoaXMuZ2V0TWVzc2FnZSgpK3R9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVzfX0pLHVzLkVSUk9SPTAsdXMuUkVQRUFURURfUE9JTlQ9MSx1cy5IT0xFX09VVFNJREVfU0hFTEw9Mix1cy5ORVNURURfSE9MRVM9Myx1cy5ESVNDT05ORUNURURfSU5URVJJT1I9NCx1cy5TRUxGX0lOVEVSU0VDVElPTj01LHVzLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT049Nix1cy5ORVNURURfU0hFTExTPTcsdXMuRFVQTElDQVRFX1JJTkdTPTgsdXMuVE9PX0ZFV19QT0lOVFM9OSx1cy5JTlZBTElEX0NPT1JESU5BVEU9MTAsdXMuUklOR19OT1RfQ0xPU0VEPTExLHVzLmVyck1zZz1bXCJUb3BvbG9neSBWYWxpZGF0aW9uIEVycm9yXCIsXCJSZXBlYXRlZCBQb2ludFwiLFwiSG9sZSBsaWVzIG91dHNpZGUgc2hlbGxcIixcIkhvbGVzIGFyZSBuZXN0ZWRcIixcIkludGVyaW9yIGlzIGRpc2Nvbm5lY3RlZFwiLFwiU2VsZi1pbnRlcnNlY3Rpb25cIixcIlJpbmcgU2VsZi1pbnRlcnNlY3Rpb25cIixcIk5lc3RlZCBzaGVsbHNcIixcIkR1cGxpY2F0ZSBSaW5nc1wiLFwiVG9vIGZldyBkaXN0aW5jdCBwb2ludHMgaW4gZ2VvbWV0cnkgY29tcG9uZW50XCIsXCJJbnZhbGlkIENvb3JkaW5hdGVcIixcIlJpbmcgaXMgbm90IGNsb3NlZFwiXSxlKGxzLnByb3RvdHlwZSx7Y2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHQubGVuZ3RoO2UrKylpZighbHMuaXNWYWxpZCh0W2VdKSlyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgdXModXMuSU5WQUxJRF9DT09SRElOQVRFLHRbZV0pLG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhuLmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2Zvcih2YXIgZT0wO2U8bi5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhuLmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9fSxjaGVja0hvbGVzTm90TmVzdGVkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBhcyhlKSxpPTA7aTx0LmdldE51bUludGVyaW9yUmluZygpO2krKyl7dmFyIHI9dC5nZXRJbnRlcmlvclJpbmdOKGkpO24uYWRkKHIpfXZhciBzPW4uaXNOb25OZXN0ZWQoKTtzfHwodGhpcy52YWxpZEVycj1uZXcgdXModXMuTkVTVEVEX0hPTEVTLG4uZ2V0TmVzdGVkUG9pbnQoKSkpfSxjaGVja0NvbnNpc3RlbnRBcmVhOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBvcyh0KSxuPWUuaXNOb2RlQ29uc2lzdGVudEFyZWEoKTtyZXR1cm4gbj92b2lkKGUuaGFzRHVwbGljYXRlUmluZ3MoKSYmKHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLkRVUExJQ0FURV9SSU5HUyxlLmdldEludmFsaWRQb2ludCgpKSkpOih0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5TRUxGX0lOVEVSU0VDVElPTixlLmdldEludmFsaWRQb2ludCgpKSxudWxsKX0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5wYXJlbnRHZW9tZXRyeSksbnVsbD09PXRoaXMudmFsaWRFcnJ9LGNoZWNrU2hlbGxJbnNpZGVIb2xlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldENvb3JkaW5hdGVzKCkscj1lLmdldENvb3JkaW5hdGVzKCkscz1scy5maW5kUHROb3ROb2RlKGksZSxuKTtpZihudWxsIT09cyl7dmFyIG89aGUuaXNQb2ludEluUmluZyhzLHIpO2lmKCFvKXJldHVybiBzfXZhciBhPWxzLmZpbmRQdE5vdE5vZGUocix0LG4pO2lmKG51bGwhPT1hKXt2YXIgdT1oZS5pc1BvaW50SW5SaW5nKGEsaSk7cmV0dXJuIHU/YTpudWxsfXJldHVybiBmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwicG9pbnRzIGluIHNoZWxsIGFuZCBob2xlIGFwcGVhciB0byBiZSBlcXVhbFwiKSxudWxsfSxjaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1Jpbmcobi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH19LGNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBLcih0KTtlLmlzSW50ZXJpb3JzQ29ubmVjdGVkKCl8fCh0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5ESVNDT05ORUNURURfSU5URVJJT1IsZS5nZXRDb29yZGluYXRlKCkpKX0sY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgYXQsbj0hMCxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2lmKG4pbj0hMTtlbHNle2lmKGUuY29udGFpbnMoci5jb29yZCkpcmV0dXJuIHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT04sci5jb29yZCksbnVsbDtlLmFkZChyLmNvb3JkKX19fSxjaGVja0hvbGVzSW5TaGVsbDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldEV4dGVyaW9yUmluZygpLGk9bmV3IGlzKG4pLHI9MDtyPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cisrKXt2YXIgcz10LmdldEludGVyaW9yUmluZ04ociksbz1scy5maW5kUHROb3ROb2RlKHMuZ2V0Q29vcmRpbmF0ZXMoKSxuLGUpO2lmKG51bGw9PT1vKXJldHVybiBudWxsO3ZhciBhPSFpLmlzSW5zaWRlKG8pO2lmKGEpcmV0dXJuIHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLkhPTEVfT1VUU0lERV9TSEVMTCxvKSxudWxsfX0sY2hlY2tUb29GZXdQb2ludHM6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaGFzVG9vRmV3UG9pbnRzKCk/KHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLlRPT19GRVdfUE9JTlRTLHQuZ2V0SW52YWxpZFBvaW50KCkpLG51bGwpOnZvaWQgMH0sZ2V0VmFsaWRhdGlvbkVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLnBhcmVudEdlb21ldHJ5KSx0aGlzLnZhbGlkRXJyfSxjaGVja1ZhbGlkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMdCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUHQpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKGUuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhuLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKG4pLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3ZhciBpPW5ldyAkbigwLG4pO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIHI9bmV3IGFlO2kuY29tcHV0ZVNlbGZOb2RlcyhyLCEwLCEwKSx0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0KXt2YXIgcz1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhzLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3ZhciBpPW5ldyAkbigwLHMpO3RoaXMuY2hlY2tUb29GZXdQb2ludHMoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXt2YXIgbz1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhvKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3MobyksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIGk9bmV3ICRuKDAsbyk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYoIXRoaXMuaXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhpKSxudWxsIT09dGhpcy52YWxpZEVycikpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChvLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tIb2xlc05vdE5lc3RlZChvLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE90KXtmb3IodmFyIGE9YXJndW1lbnRzWzBdLHU9MDt1PGEuZ2V0TnVtR2VvbWV0cmllcygpO3UrKyl7dmFyIGw9YS5nZXRHZW9tZXRyeU4odSk7aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhsKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3MobCksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9dmFyIGk9bmV3ICRuKDAsYSk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYoIXRoaXMuaXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhpKSxudWxsIT09dGhpcy52YWxpZEVycikpcmV0dXJuIG51bGw7Zm9yKHZhciB1PTA7dTxhLmdldE51bUdlb21ldHJpZXMoKTt1Kyspe3ZhciBsPWEuZ2V0R2VvbWV0cnlOKHUpO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwobCxpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH1mb3IodmFyIHU9MDt1PGEuZ2V0TnVtR2VvbWV0cmllcygpO3UrKyl7dmFyIGw9YS5nZXRHZW9tZXRyeU4odSk7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKGwsaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9aWYodGhpcy5jaGVja1NoZWxsc05vdE5lc3RlZChhLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZ0KWZvcih2YXIgaD1hcmd1bWVudHNbMF0sdT0wO3U8aC5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgYz1oLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrVmFsaWQoYyksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBmPWFyZ3VtZW50c1swXTtpZih0aGlzLnZhbGlkRXJyPW51bGwsZi5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYoZiBpbnN0YW5jZW9mIEx0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBQdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgYnQpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIFN0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBUdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgT3QpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2V7aWYoIShmIGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbihmLmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmNoZWNrVmFsaWQoZil9fX0sc2V0U2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ6ZnVuY3Rpb24odCl7dGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPXR9LGNoZWNrU2hlbGxOb3ROZXN0ZWQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKSxyPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz1yLmdldENvb3JkaW5hdGVzKCksbz1scy5maW5kUHROb3ROb2RlKGkscixuKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDt2YXIgYT1oZS5pc1BvaW50SW5SaW5nKG8scyk7aWYoIWEpcmV0dXJuIG51bGw7aWYoZS5nZXROdW1JbnRlcmlvclJpbmcoKTw9MClyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgdXModXMuTkVTVEVEX1NIRUxMUyxvKSxudWxsO2Zvcih2YXIgdT1udWxsLGw9MDtsPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bCsrKXt2YXIgaD1lLmdldEludGVyaW9yUmluZ04obCk7aWYodT10aGlzLmNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsaCxuKSxudWxsPT09dSlyZXR1cm4gbnVsbH10aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5ORVNURURfU0hFTExTLHUpfSxjaGVja0Nsb3NlZFJpbmdzOmZ1bmN0aW9uKHQpe2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRJbnRlcmlvclJpbmdOKGUpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH0sY2hlY2tDbG9zZWRSaW5nOmZ1bmN0aW9uKHQpe2lmKCF0LmlzQ2xvc2VkKCkpe3ZhciBlPW51bGw7dC5nZXROdW1Qb2ludHMoKT49MSYmKGU9dC5nZXRDb29yZGluYXRlTigwKSksdGhpcy52YWxpZEVycj1uZXcgdXModXMuUklOR19OT1RfQ0xPU0VELGUpfX0sY2hlY2tTaGVsbHNOb3ROZXN0ZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKylmb3IodmFyIGk9dC5nZXRHZW9tZXRyeU4obikscj1pLmdldEV4dGVyaW9yUmluZygpLHM9MDtzPHQuZ2V0TnVtR2VvbWV0cmllcygpO3MrKylpZihuIT09cyl7dmFyIG89dC5nZXRHZW9tZXRyeU4ocyk7aWYodGhpcy5jaGVja1NoZWxsTm90TmVzdGVkKHIsbyxlKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGxzfX0pLGxzLmZpbmRQdE5vdE5vZGU9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1uLmZpbmRFZGdlKGUpLHI9aS5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89dFtzXTtpZighci5pc0ludGVyc2VjdGlvbihvKSlyZXR1cm4gb31yZXR1cm4gbnVsbH0sbHMuaXNWYWxpZD1mdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IGxzKHQpO3JldHVybiBlLmlzVmFsaWQoKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTihuLngpPyExOnIuaXNJbmZpbml0ZShuLngpPyExOnIuaXNOYU4obi55KT8hMTohci5pc0luZmluaXRlKG4ueSl9fTt2YXIgYm89T2JqZWN0LmZyZWV6ZSh7SXNWYWxpZE9wOmxzfSksT289T2JqZWN0LmZyZWV6ZSh7Qm91bmRhcnlPcDpkdCxJc1NpbXBsZU9wOkdpLGJ1ZmZlcjpDbyxkaXN0YW5jZTpTbyxsaW5lbWVyZ2U6d28sb3ZlcmxheTpMbyxwb2x5Z29uaXplOlJvLHJlbGF0ZTpUbyx1bmlvbjpQbyx2YWxpZDpib30pO2goaHMsX3QuQ29vcmRpbmF0ZU9wZXJhdGlvbiksZShocy5wcm90b3R5cGUse2VkaXRDb29yZGluYXRlczpmdW5jdGlvbih0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLGk9MDtpPHQubGVuZ3RoO2krKyl7dmFyIHI9bmV3IGcodFtpXSk7dGhpcy50YXJnZXRQTS5tYWtlUHJlY2lzZShyKSxuW2ldPXJ9dmFyIHM9bmV3IE4obiwhMSksbz1zLnRvQ29vcmRpbmF0ZUFycmF5KCksYT0wO2UgaW5zdGFuY2VvZiBTdCYmKGE9MiksZSBpbnN0YW5jZW9mIGJ0JiYoYT00KTt2YXIgdT1uO3JldHVybiB0aGlzLnJlbW92ZUNvbGxhcHNlZCYmKHU9bnVsbCksby5sZW5ndGg8YT91Om99LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGhzfX0pLGUoY3MucHJvdG90eXBlLHtmaXhQb2x5Z29uYWxUb3BvbG9neTpmdW5jdGlvbih0KXt2YXIgZT10O3RoaXMuY2hhbmdlUHJlY2lzaW9uTW9kZWx8fChlPXRoaXMuY2hhbmdlUE0odCx0aGlzLnRhcmdldFBNKSk7dmFyIG49ZS5idWZmZXIoMCksaT1uO3JldHVybiB0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsfHwoaT10LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeShuKSksaX0scmVkdWNlUG9pbnR3aXNlOmZ1bmN0aW9uKHQpe3ZhciBlPW51bGw7aWYodGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbCl7dmFyIG49dGhpcy5jcmVhdGVGYWN0b3J5KHQuZ2V0RmFjdG9yeSgpLHRoaXMudGFyZ2V0UE0pO2U9bmV3IF90KG4pfWVsc2UgZT1uZXcgX3Q7dmFyIGk9dGhpcy5yZW1vdmVDb2xsYXBzZWQ7dC5nZXREaW1lbnNpb24oKT49MiYmKGk9ITApO3ZhciByPWUuZWRpdCh0LG5ldyBocyh0aGlzLnRhcmdldFBNLGkpKTtyZXR1cm4gcn0sY2hhbmdlUE06ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmNyZWF0ZUVkaXRvcih0LmdldEZhY3RvcnkoKSxlKTtyZXR1cm4gbi5lZGl0KHQsbmV3IF90Lk5vT3BHZW9tZXRyeU9wZXJhdGlvbil9LHNldFJlbW92ZUNvbGxhcHNlZENvbXBvbmVudHM6ZnVuY3Rpb24odCl7dGhpcy5yZW1vdmVDb2xsYXBzZWQ9dH0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBpZShlLHQuZ2V0U1JJRCgpLHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKTtyZXR1cm4gbn0sc2V0Q2hhbmdlUHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbD10fSxyZWR1Y2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZWR1Y2VQb2ludHdpc2UodCk7cmV0dXJuIHRoaXMuaXNQb2ludHdpc2U/ZTpSKGUsUnQpP2UuaXNWYWxpZCgpP2U6dGhpcy5maXhQb2x5Z29uYWxUb3BvbG9neShlKTplfSxzZXRQb2ludHdpc2U6ZnVuY3Rpb24odCl7dGhpcy5pc1BvaW50d2lzZT10fSxjcmVhdGVFZGl0b3I6ZnVuY3Rpb24odCxlKXtpZih0LmdldFByZWNpc2lvbk1vZGVsKCk9PT1lKXJldHVybiBuZXcgX3Q7dmFyIG49dGhpcy5jcmVhdGVGYWN0b3J5KHQsZSksaT1uZXcgX3Qobik7cmV0dXJuIGl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNzfX0pLGNzLnJlZHVjZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBjcyhlKTtyZXR1cm4gbi5yZWR1Y2UodCl9LGNzLnJlZHVjZVBvaW50d2lzZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBjcyhlKTtyZXR1cm4gbi5zZXRQb2ludHdpc2UoITApLG4ucmVkdWNlKHQpfTt2YXIgX289T2JqZWN0LmZyZWV6ZSh7R2VvbWV0cnlQcmVjaXNpb25SZWR1Y2VyOmNzfSk7ZShmcy5wcm90b3R5cGUse3NpbXBsaWZ5U2VjdGlvbjpmdW5jdGlvbih0LGUpe2lmKHQrMT09PWUpcmV0dXJuIG51bGw7dGhpcy5zZWcucDA9dGhpcy5wdHNbdF0sdGhpcy5zZWcucDE9dGhpcy5wdHNbZV07Zm9yKHZhciBuPS0xLGk9dCxyPXQrMTtlPnI7cisrKXt2YXIgcz10aGlzLnNlZy5kaXN0YW5jZSh0aGlzLnB0c1tyXSk7cz5uJiYobj1zLGk9cil9aWYobjw9dGhpcy5kaXN0YW5jZVRvbGVyYW5jZSlmb3IodmFyIHI9dCsxO2U+cjtyKyspdGhpcy51c2VQdFtyXT0hMTtlbHNlIHRoaXMuc2ltcGxpZnlTZWN0aW9uKHQsaSksdGhpcy5zaW1wbGlmeVNlY3Rpb24oaSxlKX0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxzaW1wbGlmeTpmdW5jdGlvbigpe3RoaXMudXNlUHQ9bmV3IEFycmF5KHRoaXMucHRzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IodmFyIHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspdGhpcy51c2VQdFt0XT0hMDt0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMucHRzLmxlbmd0aC0xKTtmb3IodmFyIGU9bmV3IE4sdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLnVzZVB0W3RdJiZlLmFkZChuZXcgZyh0aGlzLnB0c1t0XSkpO3JldHVybiBlLnRvQ29vcmRpbmF0ZUFycmF5KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZzfX0pLGZzLnNpbXBsaWZ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGZzKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uc2ltcGxpZnkoKX0sZShncy5wcm90b3R5cGUse3NldEVuc3VyZVZhbGlkOmZ1bmN0aW9uKHQpe3RoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLmlucHV0R2VvbS5jb3B5KCk6bmV3IGRzKHRoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5LHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLmlucHV0R2VvbSl9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe2lmKDA+dCl0aHJvdyBuZXcgaShcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGdzfX0pLGdzLnNpbXBsaWZ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGdzKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX0saChkcyx4ZSksZShkcy5wcm90b3R5cGUse3RyYW5zZm9ybVBvbHlnb246ZnVuY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIE90P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LGNyZWF0ZVZhbGlkQXJlYTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k/dC5idWZmZXIoMCk6dH0sdHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCksaT1udWxsO3JldHVybiBpPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpmcy5zaW1wbGlmeShuLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpLHRoaXMuZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGkpfSx0cmFuc2Zvcm1NdWx0aVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sdHJhbnNmb3JtTGluZWFyUmluZzpmdW5jdGlvbih0LGUpe3ZhciBuPWUgaW5zdGFuY2VvZiBUdCxpPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1MaW5lYXJSaW5nLmNhbGwodGhpcyx0LGUpO3JldHVybiFufHxpIGluc3RhbmNlb2YgYnQ/aTpudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkc319KSxncy5EUFRyYW5zZm9ybWVyPWRzLGgocHMsY2UpLGUocHMucHJvdG90eXBlLHtnZXRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluZGV4fSxnZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHBzfX0pLGUodnMucHJvdG90eXBlLHthZGRUb1Jlc3VsdDpmdW5jdGlvbih0KXt0aGlzLnJlc3VsdFNlZ3MuYWRkKHQpfSxhc0xpbmVTdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHZzLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLnJlc3VsdFNlZ3MpKX0sZ2V0UmVzdWx0U2l6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucmVzdWx0U2Vncy5zaXplKCk7cmV0dXJuIDA9PT10PzA6dCsxfSxnZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lfSxnZXRTZWdtZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNlZ3NbdF19LGdldFBhcmVudENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpfSxnZXRNaW5pbXVtU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbmltdW1TaXplfSxhc0xpbmVhclJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHZzLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLnJlc3VsdFNlZ3MpKX0sZ2V0U2VnbWVudHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdzfSxpbml0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCk7dGhpcy5zZWdzPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGgtMTtlKyspe3ZhciBuPW5ldyBwcyh0W2VdLHRbZSsxXSx0aGlzLnBhcmVudExpbmUsZSk7dGhpcy5zZWdzW2VdPW59fSxnZXRSZXN1bHRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB2cy5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5yZXN1bHRTZWdzKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdnN9fSksdnMuZXh0cmFjdENvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkrMSkuZmlsbChudWxsKSxuPW51bGwsaT0wO2k8dC5zaXplKCk7aSsrKW49dC5nZXQoaSksZVtpXT1uLnAwO3JldHVybiBlW2UubGVuZ3RoLTFdPW4ucDEsZX0sZShtcy5wcm90b3R5cGUse3JlbW92ZTpmdW5jdGlvbih0KXt0aGlzLmluZGV4LnJlbW92ZShuZXcgQyh0LnAwLHQucDEpLHQpfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHZzKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10LmdldFNlZ21lbnRzKCksbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1lW25dO3RoaXMuYWRkKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIHI9YXJndW1lbnRzWzBdO3RoaXMuaW5kZXguaW5zZXJ0KG5ldyBDKHIucDAsci5wMSkscil9fSxxdWVyeTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgQyh0LnAwLHQucDEpLG49bmV3IHlzKHQpO3RoaXMuaW5kZXgucXVlcnkoZSxuKTt2YXIgaT1uLmdldEl0ZW1zKCk7cmV0dXJuIGl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1zfX0pLGUoeXMucHJvdG90eXBlLHt2aXNpdEl0ZW06ZnVuY3Rpb24odCl7dmFyIGU9dDtDLmludGVyc2VjdHMoZS5wMCxlLnAxLHRoaXMucXVlcnlTZWcucDAsdGhpcy5xdWVyeVNlZy5wMSkmJnRoaXMuaXRlbXMuYWRkKHQpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHlzfX0pLGUoeHMucHJvdG90eXBlLHtmbGF0dGVuOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5saW5lUHRzW3RdLGk9dGhpcy5saW5lUHRzW2VdLHI9bmV3IGNlKG4saSk7cmV0dXJuIHRoaXMucmVtb3ZlKHRoaXMubGluZSx0LGUpLHRoaXMub3V0cHV0SW5kZXguYWRkKHIpLHJ9LGhhc0JhZEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuaGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKG4pPyEwOiEhdGhpcy5oYXNCYWRJbnB1dEludGVyc2VjdGlvbih0LGUsbil9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0sc2ltcGxpZnlTZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtuKz0xO3ZhciBpPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHQrMT09PWUpe3ZhciByPXRoaXMubGluZS5nZXRTZWdtZW50KHQpO3JldHVybiB0aGlzLmxpbmUuYWRkVG9SZXN1bHQociksbnVsbH12YXIgcz0hMDtpZih0aGlzLmxpbmUuZ2V0UmVzdWx0U2l6ZSgpPHRoaXMubGluZS5nZXRNaW5pbXVtU2l6ZSgpKXt2YXIgbz1uKzE7bzx0aGlzLmxpbmUuZ2V0TWluaW11bVNpemUoKSYmKHM9ITEpfXZhciBhPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLHU9dGhpcy5maW5kRnVydGhlc3RQb2ludCh0aGlzLmxpbmVQdHMsdCxlLGEpO2FbMF0+dGhpcy5kaXN0YW5jZVRvbGVyYW5jZSYmKHM9ITEpO3ZhciBsPW5ldyBjZTtpZihsLnAwPXRoaXMubGluZVB0c1t0XSxsLnAxPXRoaXMubGluZVB0c1tlXSxpWzBdPXQsaVsxXT1lLHRoaXMuaGFzQmFkSW50ZXJzZWN0aW9uKHRoaXMubGluZSxpLGwpJiYocz0hMSkscyl7dmFyIHI9dGhpcy5mbGF0dGVuKHQsZSk7cmV0dXJuIHRoaXMubGluZS5hZGRUb1Jlc3VsdChyKSxudWxsfXRoaXMuc2ltcGxpZnlTZWN0aW9uKHQsdSxuKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbih1LGUsbil9LGhhc0JhZE91dHB1dEludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5vdXRwdXRJbmRleC5xdWVyeSh0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oaSx0KSlyZXR1cm4hMH1yZXR1cm4hMX0sZmluZEZ1cnRoZXN0UG9pbnQ6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bmV3IGNlO3IucDA9dFtlXSxyLnAxPXRbbl07Zm9yKHZhciBzPS0xLG89ZSxhPWUrMTtuPmE7YSsrKXt2YXIgdT10W2FdLGw9ci5kaXN0YW5jZSh1KTtsPnMmJihzPWwsbz1hKX1yZXR1cm4gaVswXT1zLG99LHNpbXBsaWZ5OmZ1bmN0aW9uKHQpe3RoaXMubGluZT10LHRoaXMubGluZVB0cz10LmdldFBhcmVudENvb3JkaW5hdGVzKCksdGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLmxpbmVQdHMubGVuZ3RoLTEsMCl9LHJlbW92ZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPWU7bj5pO2krKyl7dmFyIHI9dC5nZXRTZWdtZW50KGkpO3RoaXMuaW5wdXRJbmRleC5yZW1vdmUocil9fSxoYXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odC5wMCx0LnAxLGUucDAsZS5wMSksdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl9LGhhc0JhZElucHV0SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9dGhpcy5pbnB1dEluZGV4LnF1ZXJ5KG4pLHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihzLG4pKXtpZih4cy5pc0luTGluZVNlY3Rpb24odCxlLHMpKWNvbnRpbnVlO3JldHVybiEwfX1yZXR1cm4hMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geHN9fSkseHMuaXNJbkxpbmVTZWN0aW9uPWZ1bmN0aW9uKHQsZSxuKXtpZihuLmdldFBhcmVudCgpIT09dC5nZXRQYXJlbnQoKSlyZXR1cm4hMTt2YXIgaT1uLmdldEluZGV4KCk7cmV0dXJuIGk+PWVbMF0mJmk8ZVsxXX0sZShFcy5wcm90b3R5cGUse3NldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0sc2ltcGxpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5pbnB1dEluZGV4LmFkZChlLm5leHQoKSk7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPW5ldyB4cyh0aGlzLmlucHV0SW5kZXgsdGhpcy5vdXRwdXRJbmRleCk7bi5zZXREaXN0YW5jZVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlVG9sZXJhbmNlKSxuLnNpbXBsaWZ5KGUubmV4dCgpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVzfX0pLGUoSXMucHJvdG90eXBlLHtnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbigpe2lmKHRoaXMuaW5wdXRHZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5pbnB1dEdlb20uY29weSgpO3RoaXMubGluZXN0cmluZ01hcD1uZXcgdGUsdGhpcy5pbnB1dEdlb20uYXBwbHkobmV3IENzKHRoaXMpKSx0aGlzLmxpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KHRoaXMubGluZXN0cmluZ01hcC52YWx1ZXMoKSk7dmFyIHQ9bmV3IE5zKHRoaXMubGluZXN0cmluZ01hcCkudHJhbnNmb3JtKHRoaXMuaW5wdXRHZW9tKTtyZXR1cm4gdH0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7aWYoMD50KXRocm93IG5ldyBpKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMubGluZVNpbXBsaWZpZXIuc2V0RGlzdGFuY2VUb2xlcmFuY2UodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElzfX0pLElzLnNpbXBsaWZ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IElzKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX0saChOcyx4ZSksZShOcy5wcm90b3R5cGUse3RyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7aWYoMD09PXQuc2l6ZSgpKXJldHVybiBudWxsO2lmKGUgaW5zdGFuY2VvZiBTdCl7dmFyIG49dGhpcy5saW5lc3RyaW5nTWFwLmdldChlKTtyZXR1cm4gdGhpcy5jcmVhdGVDb29yZGluYXRlU2VxdWVuY2Uobi5nZXRSZXN1bHRDb29yZGluYXRlcygpKX1yZXR1cm4geGUucHJvdG90eXBlLnRyYW5zZm9ybUNvb3JkaW5hdGVzLmNhbGwodGhpcyx0LGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOc319KSxlKENzLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBTdCl7dmFyIGU9dDtpZihlLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgbj1lLmlzQ2xvc2VkKCk/NDoyLGk9bmV3IHZzKGUsbik7dGhpcy50cHMubGluZXN0cmluZ01hcC5wdXQoZSxpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDc319KSxJcy5MaW5lU3RyaW5nVHJhbnNmb3JtZXI9TnMsSXMuTGluZVN0cmluZ01hcEJ1aWxkZXJGaWx0ZXI9Q3M7dmFyIE1vPU9iamVjdC5mcmVlemUoe0RvdWdsYXNQZXVja2VyU2ltcGxpZmllcjpncyxUb3BvbG9neVByZXNlcnZpbmdTaW1wbGlmaWVyOklzfSk7ZShTcy5wcm90b3R5cGUse3NwbGl0QXQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5taW5pbXVtTGVuL3RoaXMuc2VnTGVuO2lmKHQuZGlzdGFuY2UodGhpcy5zZWcucDApPHRoaXMubWluaW11bUxlbilyZXR1cm4gdGhpcy5zcGxpdFB0PXRoaXMuc2VnLnBvaW50QWxvbmcoZSksbnVsbDtpZih0LmRpc3RhbmNlKHRoaXMuc2VnLnAxKTx0aGlzLm1pbmltdW1MZW4pcmV0dXJuIHRoaXMuc3BsaXRQdD1Tcy5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLnNlZyxlKSxudWxsO3RoaXMuc3BsaXRQdD10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPXRoaXMuZ2V0Q29uc3RyYWluZWRMZW5ndGgobikscz1yL3RoaXMuc2VnTGVuO2kuZXF1YWxzMkQodGhpcy5zZWcucDApP3RoaXMuc3BsaXRQdD10aGlzLnNlZy5wb2ludEFsb25nKHMpOnRoaXMuc3BsaXRQdD1Tcy5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLnNlZyxzKX19LHNldE1pbmltdW1MZW5ndGg6ZnVuY3Rpb24odCl7dGhpcy5taW5pbXVtTGVuPXR9LGdldENvbnN0cmFpbmVkTGVuZ3RoOmZ1bmN0aW9uKHQpe3JldHVybiB0PHRoaXMubWluaW11bUxlbj90aGlzLm1pbmltdW1MZW46dH0sZ2V0U3BsaXRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNwbGl0UHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFNzfX0pLFNzLnBvaW50QWxvbmdSZXZlcnNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGc7cmV0dXJuIG4ueD10LnAxLngtZSoodC5wMS54LXQucDAueCksbi55PXQucDEueS1lKih0LnAxLnktdC5wMC55KSxufSxlKHdzLnByb3RvdHlwZSx7ZmluZFNwbGl0UG9pbnQ6ZnVuY3Rpb24odCxlKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdzfX0pLGUoTHMucHJvdG90eXBlLHtmaW5kU3BsaXRQb2ludDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0TGluZVNlZ21lbnQoKSxpPW4uZ2V0TGVuZ3RoKCkscj1pLzIscz1uZXcgU3Mobiksbz1Mcy5wcm9qZWN0ZWRTcGxpdFBvaW50KHQsZSksYT0yKm8uZGlzdGFuY2UoZSkqLjgsdT1hO3JldHVybiB1PnImJih1PXIpLHMuc2V0TWluaW11bUxlbmd0aCh1KSxzLnNwbGl0QXQobykscy5nZXRTcGxpdFBvaW50KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3dzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTHN9fSksTHMucHJvamVjdGVkU3BsaXRQb2ludD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0TGluZVNlZ21lbnQoKSxpPW4ucHJvamVjdChlKTtyZXR1cm4gaX0sZShScy5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJzfX0pLFJzLnRyaUFyZWE9ZnVuY3Rpb24odCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKGUueS10LnkpKihuLngtdC54KX0sUnMuaXNJbkNpcmNsZURETm9ybWFsaXplZD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1fLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3QoaS54KSxzPV8udmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChpLnkpLG89Xy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KGkueCksYT1fLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QoaS55KSx1PV8udmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdChpLngpLGw9Xy52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KGkueSksaD1yLm11bHRpcGx5KGEpLnNlbGZTdWJ0cmFjdChvLm11bHRpcGx5KHMpKSxjPW8ubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KHUubXVsdGlwbHkoYSkpLGY9dS5tdWx0aXBseShzKS5zZWxmU3VidHJhY3Qoci5tdWx0aXBseShsKSksZz1yLm11bHRpcGx5KHIpLnNlbGZBZGQocy5tdWx0aXBseShzKSksZD1vLm11bHRpcGx5KG8pLnNlbGZBZGQoYS5tdWx0aXBseShhKSkscD11Lm11bHRpcGx5KHUpLnNlbGZBZGQobC5tdWx0aXBseShsKSksdj1nLnNlbGZNdWx0aXBseShjKS5zZWxmQWRkKGQuc2VsZk11bHRpcGx5KGYpKS5zZWxmQWRkKHAuc2VsZk11bHRpcGx5KGgpKSxtPXYuZG91YmxlVmFsdWUoKT4wO3JldHVybiBtfSxScy5jaGVja1JvYnVzdEluQ2lyY2xlPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPVJzLmlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4saSkscz1Scy5pc0luQ2lyY2xlRERTbG93KHQsZSxuLGkpLG89UnMuaXNJbkNpcmNsZUNDKHQsZSxuLGkpLGE9Y2kuY2lyY3VtY2VudHJlKHQsZSxuKTtBLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMoaS5kaXN0YW5jZShhKS10LmRpc3RhbmNlKGEpKS90LmRpc3RhbmNlKGEpKSxyPT09cyYmcj09PW98fChBLm91dC5wcmludGxuKFwiaW5DaXJjbGUgcm9idXN0bmVzcyBmYWlsdXJlIChkb3VibGUgcmVzdWx0ID0gXCIrcitcIiwgREQgcmVzdWx0ID0gXCIrcytcIiwgQ0MgcmVzdWx0ID0gXCIrbytcIilcIiksQS5vdXQucHJpbnRsbihzZS50b0xpbmVTdHJpbmcobmV3IEd0KFt0LGUsbixpXSkpKSxBLm91dC5wcmludGxuKFwiQ2lyY3VtY2VudHJlID0gXCIrc2UudG9Qb2ludChhKStcIiByYWRpdXMgPSBcIit0LmRpc3RhbmNlKGEpKSxBLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMoaS5kaXN0YW5jZShhKS90LmRpc3RhbmNlKGEpLTEpKSxBLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBiID0gXCIrTWF0aC5hYnMoaS5kaXN0YW5jZShhKS9lLmRpc3RhbmNlKGEpLTEpKSxBLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBjID0gXCIrTWF0aC5hYnMoaS5kaXN0YW5jZShhKS9uLmRpc3RhbmNlKGEpLTEpKSxBLm91dC5wcmludGxuKCkpfSxScy5pc0luQ2lyY2xlRERGYXN0PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8uc3FyKHQueCkuc2VsZkFkZChfLnNxcih0LnkpKS5zZWxmTXVsdGlwbHkoUnMudHJpQXJlYURERmFzdChlLG4saSkpLHM9Xy5zcXIoZS54KS5zZWxmQWRkKF8uc3FyKGUueSkpLnNlbGZNdWx0aXBseShScy50cmlBcmVhRERGYXN0KHQsbixpKSksbz1fLnNxcihuLngpLnNlbGZBZGQoXy5zcXIobi55KSkuc2VsZk11bHRpcGx5KFJzLnRyaUFyZWFEREZhc3QodCxlLGkpKSxhPV8uc3FyKGkueCkuc2VsZkFkZChfLnNxcihpLnkpKS5zZWxmTXVsdGlwbHkoUnMudHJpQXJlYURERmFzdCh0LGUsbikpLHU9ci5zZWxmU3VidHJhY3Qocykuc2VsZkFkZChvKS5zZWxmU3VidHJhY3QoYSksbD11LmRvdWJsZVZhbHVlKCk+MDtyZXR1cm4gbH0sUnMuaXNJbkNpcmNsZUNDPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWNpLmNpcmN1bWNlbnRyZSh0LGUsbikscz10LmRpc3RhbmNlKHIpLG89aS5kaXN0YW5jZShyKS1zO3JldHVybiAwPj1vfSxScy5pc0luQ2lyY2xlTm9ybWFsaXplZD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj10LngtaS54LHM9dC55LWkueSxvPWUueC1pLngsYT1lLnktaS55LHU9bi54LWkueCxsPW4ueS1pLnksaD1yKmEtbypzLGM9bypsLXUqYSxmPXUqcy1yKmwsZz1yKnIrcypzLGQ9bypvK2EqYSxwPXUqdStsKmwsdj1nKmMrZCpmK3AqaDtyZXR1cm4gdj4wfSxScy5pc0luQ2lyY2xlRERTbG93PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8udmFsdWVPZihpLngpLHM9Xy52YWx1ZU9mKGkueSksbz1fLnZhbHVlT2YodC54KSxhPV8udmFsdWVPZih0LnkpLHU9Xy52YWx1ZU9mKGUueCksbD1fLnZhbHVlT2YoZS55KSxoPV8udmFsdWVPZihuLngpLGM9Xy52YWx1ZU9mKG4ueSksZj1vLm11bHRpcGx5KG8pLmFkZChhLm11bHRpcGx5KGEpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KHUsbCxoLGMscixzKSksZz11Lm11bHRpcGx5KHUpLmFkZChsLm11bHRpcGx5KGwpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSxoLGMscixzKSksZD1oLm11bHRpcGx5KGgpLmFkZChjLm11bHRpcGx5KGMpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSx1LGwscixzKSkscD1yLm11bHRpcGx5KHIpLmFkZChzLm11bHRpcGx5KHMpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSx1LGwsaCxjKSksdj1mLnN1YnRyYWN0KGcpLmFkZChkKS5zdWJ0cmFjdChwKSxtPXYuZG91YmxlVmFsdWUoKT4wO1xucmV0dXJuIG19LFJzLmlzSW5DaXJjbGVOb25Sb2J1c3Q9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9KHQueCp0LngrdC55KnQueSkqUnMudHJpQXJlYShlLG4saSktKGUueCplLngrZS55KmUueSkqUnMudHJpQXJlYSh0LG4saSkrKG4ueCpuLngrbi55Km4ueSkqUnMudHJpQXJlYSh0LGUsaSktKGkueCppLngraS55KmkueSkqUnMudHJpQXJlYSh0LGUsbik+MDtyZXR1cm4gcn0sUnMuaXNJbkNpcmNsZVJvYnVzdD1mdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gUnMuaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4saSl9LFJzLnRyaUFyZWFERFNsb3c9ZnVuY3Rpb24odCxlLG4saSxyLHMpe3JldHVybiBuLnN1YnRyYWN0KHQpLm11bHRpcGx5KHMuc3VidHJhY3QoZSkpLnN1YnRyYWN0KGkuc3VidHJhY3QoZSkubXVsdGlwbHkoci5zdWJ0cmFjdCh0KSkpfSxScy50cmlBcmVhRERGYXN0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1fLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KHQueSkpLHI9Xy52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkuc2VsZk11bHRpcGx5KF8udmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdCh0LngpKTtyZXR1cm4gaS5zZWxmU3VidHJhY3Qocil9LGUoVHMucHJvdG90eXBlLHtjaXJjbGVDZW50ZXI6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgVHModGhpcy5nZXRYKCksdGhpcy5nZXRZKCkpLGk9dGhpcy5iaXNlY3RvcihuLHQpLHI9dGhpcy5iaXNlY3Rvcih0LGUpLHM9bmV3IEYoaSxyKSxvPW51bGw7dHJ5e289bmV3IFRzKHMuZ2V0WCgpLHMuZ2V0WSgpKX1jYXRjaChpKXtpZighKGkgaW5zdGFuY2VvZiB3KSl0aHJvdyBpO0EuZXJyLnByaW50bG4oXCJhOiBcIituK1wiICBiOiBcIit0K1wiICBjOiBcIitlKSxBLmVyci5wcmludGxuKGkpfWZpbmFsbHl7fXJldHVybiBvfSxkb3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucC54KnQuZ2V0WCgpK3RoaXMucC55KnQuZ2V0WSgpfSxtYWduOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLnAueCp0aGlzLnAueCt0aGlzLnAueSp0aGlzLnAueSl9LGdldFo6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnp9LGJpc2VjdG9yOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5nZXRYKCktdC5nZXRYKCksaT1lLmdldFkoKS10LmdldFkoKSxyPW5ldyBGKHQuZ2V0WCgpK24vMix0LmdldFkoKStpLzIsMSkscz1uZXcgRih0LmdldFgoKS1pK24vMix0LmdldFkoKStuK2kvMiwxKTtyZXR1cm4gbmV3IEYocixzKX0sZXF1YWxzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5wLng9PT10LmdldFgoKSYmdGhpcy5wLnk9PT10LmdldFkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLnAuZGlzdGFuY2UoZS5nZXRDb29yZGluYXRlKCkpPG59fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucH0saXNJbkNpcmNsZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIFJzLmlzSW5DaXJjbGVSb2J1c3QodC5wLGUucCxuLnAsdGhpcy5wKX0saW50ZXJwb2xhdGVaVmFsdWU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0WCgpLHI9dC5nZXRZKCkscz1lLmdldFgoKS1pLG89bi5nZXRYKCktaSxhPWUuZ2V0WSgpLXIsdT1uLmdldFkoKS1yLGw9cyp1LW8qYSxoPXRoaXMuZ2V0WCgpLWksYz10aGlzLmdldFkoKS1yLGY9KHUqaC1vKmMpL2wsZz0oLWEqaCtzKmMpL2wsZD10LmdldFooKStmKihlLmdldFooKS10LmdldFooKSkrZyoobi5nZXRaKCktdC5nZXRaKCkpO3JldHVybiBkfSxtaWRQb2ludDpmdW5jdGlvbih0KXt2YXIgZT0odGhpcy5wLngrdC5nZXRYKCkpLzIsbj0odGhpcy5wLnkrdC5nZXRZKCkpLzIsaT0odGhpcy5wLnordC5nZXRaKCkpLzI7cmV0dXJuIG5ldyBUcyhlLG4saSl9LHJpZ2h0T2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNDQ1codC5kZXN0KCksdC5vcmlnKCkpfSxpc0NDVzpmdW5jdGlvbih0LGUpe3JldHVybih0LnAueC10aGlzLnAueCkqKGUucC55LXRoaXMucC55KS0odC5wLnktdGhpcy5wLnkpKihlLnAueC10aGlzLnAueCk+MH0sZ2V0WDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAueH0sY3Jvc3NQcm9kdWN0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnAueCp0LmdldFkoKS10aGlzLnAueSp0LmdldFgoKX0sc2V0WjpmdW5jdGlvbih0KXt0aGlzLnAuej10fSx0aW1lczpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFRzKHQqdGhpcy5wLngsdCp0aGlzLnAueSl9LGNyb3NzOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUcyh0aGlzLnAueSwtdGhpcy5wLngpfSxsZWZ0T2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNDQ1codC5vcmlnKCksdC5kZXN0KCkpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiUE9JTlQgKFwiK3RoaXMucC54K1wiIFwiK3RoaXMucC55K1wiKVwifSxzdWI6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBUcyh0aGlzLnAueC10LmdldFgoKSx0aGlzLnAueS10LmdldFkoKSl9LGdldFk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnl9LGNsYXNzaWZ5OmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxpPWUuc3ViKHQpLHI9bi5zdWIodCkscz1pLmNyb3NzUHJvZHVjdChyKTtyZXR1cm4gcz4wP1RzLkxFRlQ6MD5zP1RzLlJJR0hUOmkuZ2V0WCgpKnIuZ2V0WCgpPDB8fGkuZ2V0WSgpKnIuZ2V0WSgpPDA/VHMuQkVISU5EOmkubWFnbigpPHIubWFnbigpP1RzLkJFWU9ORDp0LmVxdWFscyhuKT9Ucy5PUklHSU46ZS5lcXVhbHMobik/VHMuREVTVElOQVRJT046VHMuQkVUV0VFTn0sc3VtOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVHModGhpcy5wLngrdC5nZXRYKCksdGhpcy5wLnkrdC5nZXRZKCkpfSxkaXN0YW5jZTpmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZS5nZXRYKCktdC5nZXRYKCksMikrTWF0aC5wb3coZS5nZXRZKCktdC5nZXRZKCksMikpfSxjaXJjdW1SYWRpdXNSYXRpbzpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY2lyY2xlQ2VudGVyKHQsZSksaT10aGlzLmRpc3RhbmNlKG4sdCkscj10aGlzLmRpc3RhbmNlKHRoaXMsdCkscz10aGlzLmRpc3RhbmNlKHQsZSk7cmV0dXJuIHI+cyYmKHI9cykscz10aGlzLmRpc3RhbmNlKGUsdGhpcykscj5zJiYocj1zKSxpL3J9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRzfX0pLFRzLmludGVycG9sYXRlWj1mdW5jdGlvbigpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1lLmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShlKSxzPW4uei1lLnosbz1lLnorcyooci9pKTtyZXR1cm4gb31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdLGw9YXJndW1lbnRzWzJdLGg9YXJndW1lbnRzWzNdLGM9dS54LGY9dS55LGc9bC54LWMsZD1oLngtYyxwPWwueS1mLHY9aC55LWYsbT1nKnYtZCpwLHk9YS54LWMseD1hLnktZixFPSh2KnktZCp4KS9tLEk9KC1wKnkrZyp4KS9tLE49dS56K0UqKGwuei11LnopK0kqKGguei11LnopO3JldHVybiBOfX0sVHMuTEVGVD0wLFRzLlJJR0hUPTEsVHMuQkVZT05EPTIsVHMuQkVISU5EPTMsVHMuQkVUV0VFTj00LFRzLk9SSUdJTj01LFRzLkRFU1RJTkFUSU9OPTYsaChQcyxUcyksZShQcy5wcm90b3R5cGUse2dldENvbnN0cmFpbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJhaW50fSxzZXRPbkNvbnN0cmFpbnQ6ZnVuY3Rpb24odCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9dH0sbWVyZ2U6ZnVuY3Rpb24odCl7dC5faXNPbkNvbnN0cmFpbnQmJih0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLmNvbnN0cmFpbnQ9dC5jb25zdHJhaW50KX0saXNPbkNvbnN0cmFpbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNPbkNvbnN0cmFpbnR9LHNldENvbnN0cmFpbnQ6ZnVuY3Rpb24odCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5jb25zdHJhaW50PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFBzfX0pLGUoYnMucHJvdG90eXBlLHtlcXVhbHNOb25PcmllbnRlZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lcXVhbHNPcmllbnRlZCh0KT8hMDohIXRoaXMuZXF1YWxzT3JpZW50ZWQodC5zeW0oKSl9LHRvTGluZVNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGNlKHRoaXMudmVydGV4LmdldENvb3JkaW5hdGUoKSx0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfSxkZXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltKCkub3JpZygpfSxvTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHR9LGVxdWFsc09yaWVudGVkOmZ1bmN0aW9uKHQpe3JldHVybiEoIXRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCkpfHwhdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSkpfSxkTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCkuc3ltKCl9LGxQcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dC5zeW0oKX0sclByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpfSxyb3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90fSxvUHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3QubmV4dC5fcm90fSxzeW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90Ll9yb3R9LHNldE9yaWc6ZnVuY3Rpb24odCl7dGhpcy52ZXJ0ZXg9dH0sbE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLnJvdCgpfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9LGludlJvdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3Quc3ltKCl9LHNldERlc3Q6ZnVuY3Rpb24odCl7dGhpcy5zeW0oKS5zZXRPcmlnKHQpfSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZGVsZXRlOmZ1bmN0aW9uKCl7dGhpcy5fcm90PW51bGx9LG9yaWc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJ0ZXh9LHJOZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5uZXh0LmludlJvdCgpfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PXRoaXMudmVydGV4LmdldENvb3JkaW5hdGUoKSxlPXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKTtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKHQsZSl9LGlzTGl2ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5fcm90fSxnZXRQcmltYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTw9MD90aGlzOnRoaXMuc3ltKCl9LGRQcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5pbnZSb3QoKX0sc2V0TmV4dDpmdW5jdGlvbih0KXt0aGlzLm5leHQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYnN9fSksYnMubWFrZUVkZ2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgYnMsaT1uZXcgYnMscj1uZXcgYnMscz1uZXcgYnM7bi5fcm90PWksaS5fcm90PXIsci5fcm90PXMscy5fcm90PW4sbi5zZXROZXh0KG4pLGkuc2V0TmV4dChzKSxyLnNldE5leHQocikscy5zZXROZXh0KGkpO3ZhciBvPW47cmV0dXJuIG8uc2V0T3JpZyh0KSxvLnNldERlc3QoZSksb30sYnMuc3dhcD1mdW5jdGlvbih0KXt2YXIgZT10Lm9QcmV2KCksbj10LnN5bSgpLm9QcmV2KCk7YnMuc3BsaWNlKHQsZSksYnMuc3BsaWNlKHQuc3ltKCksbiksYnMuc3BsaWNlKHQsZS5sTmV4dCgpKSxicy5zcGxpY2UodC5zeW0oKSxuLmxOZXh0KCkpLHQuc2V0T3JpZyhlLmRlc3QoKSksdC5zZXREZXN0KG4uZGVzdCgpKX0sYnMuc3BsaWNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5vTmV4dCgpLnJvdCgpLGk9ZS5vTmV4dCgpLnJvdCgpLHI9ZS5vTmV4dCgpLHM9dC5vTmV4dCgpLG89aS5vTmV4dCgpLGE9bi5vTmV4dCgpO3Quc2V0TmV4dChyKSxlLnNldE5leHQocyksbi5zZXROZXh0KG8pLGkuc2V0TmV4dChhKX0sYnMuY29ubmVjdD1mdW5jdGlvbih0LGUpe3ZhciBuPWJzLm1ha2VFZGdlKHQuZGVzdCgpLGUub3JpZygpKTtyZXR1cm4gYnMuc3BsaWNlKG4sdC5sTmV4dCgpKSxicy5zcGxpY2Uobi5zeW0oKSxlKSxufSxlKE9zLnByb3RvdHlwZSx7aW5zZXJ0U2l0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnN1YmRpdi5sb2NhdGUodCk7aWYodGhpcy5zdWJkaXYuaXNWZXJ0ZXhPZkVkZ2UoZSx0KSlyZXR1cm4gZTt0aGlzLnN1YmRpdi5pc09uRWRnZShlLHQuZ2V0Q29vcmRpbmF0ZSgpKSYmKGU9ZS5vUHJldigpLHRoaXMuc3ViZGl2LmRlbGV0ZShlLm9OZXh0KCkpKTt2YXIgbj10aGlzLnN1YmRpdi5tYWtlRWRnZShlLm9yaWcoKSx0KTticy5zcGxpY2UobixlKTt2YXIgaT1uO2RvIG49dGhpcy5zdWJkaXYuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpO3doaWxlKGUubE5leHQoKSE9PWkpO2Zvcig7Oyl7dmFyIHI9ZS5vUHJldigpO2lmKHIuZGVzdCgpLnJpZ2h0T2YoZSkmJnQuaXNJbkNpcmNsZShlLm9yaWcoKSxyLmRlc3QoKSxlLmRlc3QoKSkpYnMuc3dhcChlKSxlPWUub1ByZXYoKTtlbHNle2lmKGUub05leHQoKT09PWkpcmV0dXJuIG47ZT1lLm9OZXh0KCkubFByZXYoKX19fSxpbnNlcnRTaXRlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKG4pfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT3N9fSksZShfcy5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9zfX0pLGUoTXMucHJvdG90eXBlLHtpbml0OmZ1bmN0aW9uKCl7dGhpcy5sYXN0RWRnZT10aGlzLmZpbmRFZGdlKCl9LGxvY2F0ZTpmdW5jdGlvbih0KXt0aGlzLmxhc3RFZGdlLmlzTGl2ZSgpfHx0aGlzLmluaXQoKTt2YXIgZT10aGlzLnN1YmRpdi5sb2NhdGVGcm9tRWRnZSh0LHRoaXMubGFzdEVkZ2UpO3JldHVybiB0aGlzLmxhc3RFZGdlPWUsZX0sZmluZEVkZ2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN1YmRpdi5nZXRFZGdlcygpO3JldHVybiB0Lml0ZXJhdG9yKCkubmV4dCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltfc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE1zfX0pLGgoRHMsbCksZShEcy5wcm90b3R5cGUse2dldFNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWd9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERzfX0pLERzLm1zZ1dpdGhTcGF0aWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitlK1wiIF1cIjp0fSxlKEFzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBc319KSxlKEZzLnByb3RvdHlwZSx7Z2V0VHJpYW5nbGVWZXJ0aWNlczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgQnM7cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlVmVydGljZXMoKX0saXNGcmFtZVZlcnRleDpmdW5jdGlvbih0KXtyZXR1cm4gdC5lcXVhbHModGhpcy5mcmFtZVZlcnRleFswXSk/ITA6dC5lcXVhbHModGhpcy5mcmFtZVZlcnRleFsxXSk/ITA6ISF0LmVxdWFscyh0aGlzLmZyYW1lVmVydGV4WzJdKX0saXNWZXJ0ZXhPZkVkZ2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4hKCFlLmVxdWFscyh0Lm9yaWcoKSx0aGlzLnRvbGVyYW5jZSkmJiFlLmVxdWFscyh0LmRlc3QoKSx0aGlzLnRvbGVyYW5jZSkpfSxjb25uZWN0OmZ1bmN0aW9uKHQsZSl7dmFyIG49YnMuY29ubmVjdCh0LGUpO3JldHVybiB0aGlzLnF1YWRFZGdlcy5hZGQobiksbn0sZ2V0Vm9yb25vaUNlbGxQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEksaT10O2Rve3ZhciByPXQucm90KCkub3JpZygpLmdldENvb3JkaW5hdGUoKTtuLmFkZChyKSx0PXQub1ByZXYoKX13aGlsZSh0IT09aSk7dmFyIHM9bmV3IE47cy5hZGRBbGwobiwhMSkscy5jbG9zZVJpbmcoKSxzLnNpemUoKTw0JiYoQS5vdXQucHJpbnRsbihzKSxzLmFkZChzLmdldChzLnNpemUoKS0xKSwhMCkpO3ZhciBvPXMudG9Db29yZGluYXRlQXJyYXkoKSxhPWUuY3JlYXRlUG9seWdvbihlLmNyZWF0ZUxpbmVhclJpbmcobyksbnVsbCksdT1pLm9yaWcoKTtyZXR1cm4gYS5zZXRVc2VyRGF0YSh1LmdldENvb3JkaW5hdGUoKSksYX0sc2V0TG9jYXRvcjpmdW5jdGlvbih0KXt0aGlzLmxvY2F0b3I9dH0saW5pdFN1YmRpdjpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWFrZUVkZ2UodGhpcy5mcmFtZVZlcnRleFswXSx0aGlzLmZyYW1lVmVydGV4WzFdKSxlPXRoaXMubWFrZUVkZ2UodGhpcy5mcmFtZVZlcnRleFsxXSx0aGlzLmZyYW1lVmVydGV4WzJdKTticy5zcGxpY2UodC5zeW0oKSxlKTt2YXIgbj10aGlzLm1ha2VFZGdlKHRoaXMuZnJhbWVWZXJ0ZXhbMl0sdGhpcy5mcmFtZVZlcnRleFswXSk7cmV0dXJuIGJzLnNwbGljZShlLnN5bSgpLG4pLGJzLnNwbGljZShuLnN5bSgpLHQpLHR9LGlzRnJhbWVCb3JkZXJFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO0ZzLmdldFRyaWFuZ2xlRWRnZXModCxlKTt2YXIgbj1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtGcy5nZXRUcmlhbmdsZUVkZ2VzKHQuc3ltKCksbik7dmFyIGk9dC5sTmV4dCgpLmRlc3QoKTtpZih0aGlzLmlzRnJhbWVWZXJ0ZXgoaSkpcmV0dXJuITA7dmFyIHI9dC5zeW0oKS5sTmV4dCgpLmRlc3QoKTtyZXR1cm4hIXRoaXMuaXNGcmFtZVZlcnRleChyKX0sbWFrZUVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj1icy5tYWtlRWRnZSh0LGUpO3JldHVybiB0aGlzLnF1YWRFZGdlcy5hZGQobiksbn0sdmlzaXRUcmlhbmdsZXM6ZnVuY3Rpb24odCxlKXt0aGlzLnZpc2l0ZWRLZXkrKzt2YXIgbj1uZXcgcGU7bi5wdXNoKHRoaXMuc3RhcnRpbmdFZGdlKTtmb3IodmFyIGk9bmV3IEo7IW4uZW1wdHkoKTspe3ZhciByPW4ucG9wKCk7aWYoIWkuY29udGFpbnMocikpe3ZhciBzPXRoaXMuZmV0Y2hUcmlhbmdsZVRvVmlzaXQocixuLGUsaSk7bnVsbCE9PXMmJnQudmlzaXQocyl9fX0saXNGcmFtZUVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuISghdGhpcy5pc0ZyYW1lVmVydGV4KHQub3JpZygpKSYmIXRoaXMuaXNGcmFtZVZlcnRleCh0LmRlc3QoKSkpfSxpc09uRWRnZTpmdW5jdGlvbih0LGUpe3RoaXMuc2VnLnNldENvb3JkaW5hdGVzKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSx0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpO3ZhciBuPXRoaXMuc2VnLmRpc3RhbmNlKGUpO3JldHVybiBuPHRoaXMuZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiBuZXcgQyh0aGlzLmZyYW1lRW52KX0sY3JlYXRlRnJhbWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKSxpPTA7aT1lPm4/MTAqZToxMCpuLHRoaXMuZnJhbWVWZXJ0ZXhbMF09bmV3IFRzKCh0LmdldE1heFgoKSt0LmdldE1pblgoKSkvMix0LmdldE1heFkoKStpKSx0aGlzLmZyYW1lVmVydGV4WzFdPW5ldyBUcyh0LmdldE1pblgoKS1pLHQuZ2V0TWluWSgpLWkpLHRoaXMuZnJhbWVWZXJ0ZXhbMl09bmV3IFRzKHQuZ2V0TWF4WCgpK2ksdC5nZXRNaW5ZKCktaSksdGhpcy5mcmFtZUVudj1uZXcgQyh0aGlzLmZyYW1lVmVydGV4WzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLmZyYW1lVmVydGV4WzFdLmdldENvb3JkaW5hdGUoKSksdGhpcy5mcmFtZUVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5mcmFtZVZlcnRleFsyXS5nZXRDb29yZGluYXRlKCkpfSxnZXRUcmlhbmdsZUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB6cztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVzKCl9LGdldFZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSixuPXRoaXMucXVhZEVkZ2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkub3JpZygpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKHIpO3ZhciBzPWkuZGVzdCgpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocyl8fGUuYWRkKHMpfXJldHVybiBlfSxmZXRjaFRyaWFuZ2xlVG9WaXNpdDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10LHM9MCxvPSExO2Rve3RoaXMudHJpRWRnZXNbc109cix0aGlzLmlzRnJhbWVFZGdlKHIpJiYobz0hMCk7dmFyIGE9ci5zeW0oKTtpLmNvbnRhaW5zKGEpfHxlLnB1c2goYSksaS5hZGQocikscysrLHI9ci5sTmV4dCgpfXdoaWxlKHIhPT10KTtyZXR1cm4gbyYmIW4/bnVsbDp0aGlzLnRyaUVkZ2VzfSxnZXRFZGdlczpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnF1YWRFZGdlcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0UHJpbWFyeUVkZ2VzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKSxpPTAscj1lLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtuW2krK109dC5jcmVhdGVMaW5lU3RyaW5nKFtzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkscy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpXSl9cmV0dXJuIHQuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG4pfX0sZ2V0VmVydGV4VW5pcXVlRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49bmV3IEosaT10aGlzLnF1YWRFZGdlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCkscz1yLm9yaWcoKTtuLmNvbnRhaW5zKHMpfHwobi5hZGQocyksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChzKXx8ZS5hZGQocikpO3ZhciBvPXIuc3ltKCksYT1vLm9yaWcoKTtuLmNvbnRhaW5zKGEpfHwobi5hZGQoYSksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChhKXx8ZS5hZGQobykpfXJldHVybiBlfSxnZXRUcmlhbmdsZUVkZ2VzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBxcztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVFZGdlcygpfSxnZXRQcmltYXJ5RWRnZXM6ZnVuY3Rpb24odCl7dGhpcy52aXNpdGVkS2V5Kys7dmFyIGU9bmV3IEksbj1uZXcgcGU7bi5wdXNoKHRoaXMuc3RhcnRpbmdFZGdlKTtmb3IodmFyIGk9bmV3IEo7IW4uZW1wdHkoKTspe3ZhciByPW4ucG9wKCk7aWYoIWkuY29udGFpbnMocikpe3ZhciBzPXIuZ2V0UHJpbWFyeSgpOyF0JiZ0aGlzLmlzRnJhbWVFZGdlKHMpfHxlLmFkZChzKSxuLnB1c2goci5vTmV4dCgpKSxuLnB1c2goci5zeW0oKS5vTmV4dCgpKSxpLmFkZChyKSxpLmFkZChyLnN5bSgpKX19cmV0dXJuIGV9LGRlbGV0ZTpmdW5jdGlvbih0KXticy5zcGxpY2UodCx0Lm9QcmV2KCkpLGJzLnNwbGljZSh0LnN5bSgpLHQuc3ltKCkub1ByZXYoKSk7dmFyIGU9dC5zeW0oKSxuPXQucm90KCksaT10LnJvdCgpLnN5bSgpO3RoaXMucXVhZEVkZ2VzLnJlbW92ZSh0KSx0aGlzLnF1YWRFZGdlcy5yZW1vdmUoZSksdGhpcy5xdWFkRWRnZXMucmVtb3ZlKG4pLHRoaXMucXVhZEVkZ2VzLnJlbW92ZShpKSx0LmRlbGV0ZSgpLGUuZGVsZXRlKCksbi5kZWxldGUoKSxpLmRlbGV0ZSgpfSxsb2NhdGVGcm9tRWRnZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLGk9dGhpcy5xdWFkRWRnZXMuc2l6ZSgpLHI9ZTs7KXtpZihuKyssbj5pKXRocm93IG5ldyBEcyhyLnRvTGluZVNlZ21lbnQoKSk7aWYodC5lcXVhbHMoci5vcmlnKCkpfHx0LmVxdWFscyhyLmRlc3QoKSkpYnJlYWs7aWYodC5yaWdodE9mKHIpKXI9ci5zeW0oKTtlbHNlIGlmKHQucmlnaHRPZihyLm9OZXh0KCkpKXtpZih0LnJpZ2h0T2Yoci5kUHJldigpKSlicmVhaztyPXIuZFByZXYoKX1lbHNlIHI9ci5vTmV4dCgpfXJldHVybiByfSxnZXRUb2xlcmFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2xlcmFuY2V9LGdldFZvcm9ub2lDZWxsUG9seWdvbnM6ZnVuY3Rpb24odCl7dGhpcy52aXNpdFRyaWFuZ2xlcyhuZXcgR3MsITApO2Zvcih2YXIgZT1uZXcgSSxuPXRoaXMuZ2V0VmVydGV4VW5pcXVlRWRnZXMoITEpLGk9bi5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ZS5hZGQodGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb24ocix0KSl9cmV0dXJuIGV9LGdldFZvcm9ub2lEaWFncmFtOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KTtyZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KGUpKX0sZ2V0VHJpYW5nbGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmdldFRyaWFuZ2xlQ29vcmRpbmF0ZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpLGk9MCxyPWUuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO25baSsrXT10LmNyZWF0ZVBvbHlnb24odC5jcmVhdGVMaW5lYXJSaW5nKHMpLG51bGwpfXJldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuKX0saW5zZXJ0U2l0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmxvY2F0ZSh0KTtpZih0LmVxdWFscyhlLm9yaWcoKSx0aGlzLnRvbGVyYW5jZSl8fHQuZXF1YWxzKGUuZGVzdCgpLHRoaXMudG9sZXJhbmNlKSlyZXR1cm4gZTt2YXIgbj10aGlzLm1ha2VFZGdlKGUub3JpZygpLHQpO2JzLnNwbGljZShuLGUpO3ZhciBpPW47ZG8gbj10aGlzLmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKTt3aGlsZShlLmxOZXh0KCkhPT1pKTtyZXR1cm4gaX0sbG9jYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHMpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5sb2NhdG9yLmxvY2F0ZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5sb2NhdG9yLmxvY2F0ZShuZXcgVHMoZSkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj10aGlzLmxvY2F0b3IubG9jYXRlKG5ldyBUcyhuKSk7aWYobnVsbD09PXIpcmV0dXJuIG51bGw7dmFyIHM9cjtyLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQobikmJihzPXIuc3ltKCkpO3ZhciBvPXM7ZG97aWYoby5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKGkpKXJldHVybiBvO289by5vTmV4dCgpfXdoaWxlKG8hPT1zKTtyZXR1cm4gbnVsbH19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZzfX0pLEZzLmdldFRyaWFuZ2xlRWRnZXM9ZnVuY3Rpb24odCxlKXtpZihlWzBdPXQsZVsxXT1lWzBdLmxOZXh0KCksZVsyXT1lWzFdLmxOZXh0KCksZVsyXS5sTmV4dCgpIT09ZVswXSl0aHJvdyBuZXcgaShcIkVkZ2VzIGRvIG5vdCBmb3JtIGEgdHJpYW5nbGVcIil9LGUoR3MucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dFswXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLG49dFsxXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLGk9dFsyXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHI9Y2kuY2lyY3VtY2VudHJlKGUsbixpKSxzPW5ldyBUcyhyKSxvPTA7Mz5vO28rKyl0W29dLnJvdCgpLnNldE9yaWcocyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR3N9fSksZShxcy5wcm90b3R5cGUse2dldFRyaWFuZ2xlRWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmlMaXN0fSx2aXNpdDpmdW5jdGlvbih0KXt0aGlzLnRyaUxpc3QuYWRkKHQuY2xvbmUoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcXN9fSksZShCcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe3RoaXMudHJpTGlzdC5hZGQoW3RbMF0ub3JpZygpLHRbMV0ub3JpZygpLHRbMl0ub3JpZygpXSl9LGdldFRyaWFuZ2xlVmVydGljZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmlMaXN0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJzfX0pLGUoenMucHJvdG90eXBlLHtjaGVja1RyaWFuZ2xlU2l6ZTpmdW5jdGlvbih0KXt2YXIgZT1cIlwiO3QubGVuZ3RoPj0yP2U9c2UudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSk6dC5sZW5ndGg+PTEmJihlPXNlLnRvUG9pbnQodFswXSkpfSx2aXNpdDpmdW5jdGlvbih0KXt0aGlzLmNvb3JkTGlzdC5jbGVhcigpO2Zvcih2YXIgZT0wOzM+ZTtlKyspe3ZhciBuPXRbZV0ub3JpZygpO3RoaXMuY29vcmRMaXN0LmFkZChuLmdldENvb3JkaW5hdGUoKSl9aWYodGhpcy5jb29yZExpc3Quc2l6ZSgpPjApe3RoaXMuY29vcmRMaXN0LmNsb3NlUmluZygpO3ZhciBpPXRoaXMuY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7aWYoNCE9PWkubGVuZ3RoKXJldHVybiBudWxsO3RoaXMudHJpQ29vcmRzLmFkZChpKX19LGdldFRyaWFuZ2xlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyaUNvb3Jkc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQXNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6c319KSxGcy5UcmlhbmdsZUNpcmN1bWNlbnRyZVZpc2l0b3I9R3MsRnMuVHJpYW5nbGVFZGdlc0xpc3RWaXNpdG9yPXFzLEZzLlRyaWFuZ2xlVmVydGV4TGlzdFZpc2l0b3I9QnMsRnMuVHJpYW5nbGVDb29yZGluYXRlc1Zpc2l0b3I9enMsRnMuRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SPTFlMyxlKFZzLnByb3RvdHlwZSx7Z2V0TGluZVNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sc30sZ2V0RW5kWjpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKTtyZXR1cm4gdC56fSxnZXRTdGFydFo6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMCk7cmV0dXJuIHQuen0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxzLmludGVyc2VjdGlvbih0LmdldExpbmVTZWdtZW50KCkpfSxnZXRTdGFydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzLmdldENvb3JkaW5hdGUoMCl9LGdldEVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzLmdldENvb3JkaW5hdGUoMSl9LGdldEVuZFk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMSk7cmV0dXJuIHQueX0sZ2V0U3RhcnRYOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDApO3JldHVybiB0Lnh9LGVxdWFsc1RvcG86ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubHMuZXF1YWxzVG9wbyh0LmdldExpbmVTZWdtZW50KCkpfSxnZXRTdGFydFk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMCk7cmV0dXJuIHQueX0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGdldEVuZFg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMSk7cmV0dXJuIHQueH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5scy50b1N0cmluZygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWc319KSxlKGtzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrc319KSxlKFlzLnByb3RvdHlwZSx7aXNSZXBlYXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvdW50PjF9LGdldFJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmlnaHR9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wfSxzZXRMZWZ0OmZ1bmN0aW9uKHQpe3RoaXMubGVmdD10fSxnZXRYOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC54fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZ2V0Q291bnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb3VudH0sZ2V0TGVmdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlZnR9LGdldFk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnl9LGluY3JlbWVudDpmdW5jdGlvbigpe3RoaXMuY291bnQ9dGhpcy5jb3VudCsxfSxzZXRSaWdodDpmdW5jdGlvbih0KXt0aGlzLnJpZ2h0PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFlzfX0pLGUoVXMucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluc2VydCh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07aWYobnVsbD09PXRoaXMucm9vdClyZXR1cm4gdGhpcy5yb290PW5ldyBZcyhlLG4pLHRoaXMucm9vdDtpZih0aGlzLnRvbGVyYW5jZT4wKXt2YXIgaT10aGlzLmZpbmRCZXN0TWF0Y2hOb2RlKGUpO2lmKG51bGwhPT1pKXJldHVybiBpLmluY3JlbWVudCgpLGl9cmV0dXJuIHRoaXMuaW5zZXJ0RXhhY3QoZSxuKX19LHF1ZXJ5OmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLGU9dGhpcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9bmV3IEk7cmV0dXJuIHRoaXMucXVlcnkobixpKSxpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyYmUihhcmd1bWVudHNbMV0seSkpIWZ1bmN0aW9uKCl7dmFyIG49dFswXSxpPXRbMV07ZS5xdWVyeU5vZGUoZS5yb290LG4sITAse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2tzXX0sdmlzaXQ6ZnVuY3Rpb24odCl7aS5hZGQodCl9fSl9KCk7ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMmJlIoYXJndW1lbnRzWzFdLGtzKSl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMucm9vdCxyLCEwLHMpfX0scXVlcnlOb2RlOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKG51bGw9PT10KXJldHVybiBudWxsO3ZhciByPW51bGwscz1udWxsLG89bnVsbDtuPyhyPWUuZ2V0TWluWCgpLHM9ZS5nZXRNYXhYKCksbz10LmdldFgoKSk6KHI9ZS5nZXRNaW5ZKCkscz1lLmdldE1heFkoKSxvPXQuZ2V0WSgpKTt2YXIgYT1vPnIsdT1zPj1vO2EmJnRoaXMucXVlcnlOb2RlKHQuZ2V0TGVmdCgpLGUsIW4saSksZS5jb250YWlucyh0LmdldENvb3JkaW5hdGUoKSkmJmkudmlzaXQodCksdSYmdGhpcy5xdWVyeU5vZGUodC5nZXRSaWdodCgpLGUsIW4saSl9LGZpbmRCZXN0TWF0Y2hOb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBYcyh0LHRoaXMudG9sZXJhbmNlKTtyZXR1cm4gdGhpcy5xdWVyeShlLnF1ZXJ5RW52ZWxvcGUoKSxlKSxlLmdldE5vZGUoKX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yb290fSxpbnNlcnRFeGFjdDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLnJvb3QsaT10aGlzLnJvb3Qscj0hMCxzPSEwO251bGwhPT1uOyl7aWYobnVsbCE9PW4pe3ZhciBvPXQuZGlzdGFuY2Uobi5nZXRDb29yZGluYXRlKCkpPD10aGlzLnRvbGVyYW5jZTtpZihvKXJldHVybiBuLmluY3JlbWVudCgpLG59cz1yP3QueDxuLmdldFgoKTp0Lnk8bi5nZXRZKCksaT1uLG49cz9uLmdldExlZnQoKTpuLmdldFJpZ2h0KCkscj0hcn10aGlzLm51bWJlck9mTm9kZXM9dGhpcy5udW1iZXJPZk5vZGVzKzE7dmFyIGE9bmV3IFlzKHQsZSk7cmV0dXJuIHM/aS5zZXRMZWZ0KGEpOmkuc2V0UmlnaHQoYSksYX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVXN9fSksVXMudG9Db29yZGluYXRlcz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIFVzLnRvQ29vcmRpbmF0ZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1uZXcgTixyPWUuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspZm9yKHZhciBzPXIubmV4dCgpLG89bj9zLmdldENvdW50KCk6MSxhPTA7bz5hO2ErKylpLmFkZChzLmdldENvb3JkaW5hdGUoKSwhMCk7cmV0dXJuIGkudG9Db29yZGluYXRlQXJyYXkoKX19LGUoWHMucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnAuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpLG49ZTw9dGhpcy50b2xlcmFuY2U7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGk9ITE7KG51bGw9PT10aGlzLm1hdGNoTm9kZXx8ZTx0aGlzLm1hdGNoRGlzdHx8bnVsbCE9PXRoaXMubWF0Y2hOb2RlJiZlPT09dGhpcy5tYXRjaERpc3QmJnQuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLm1hdGNoTm9kZS5nZXRDb29yZGluYXRlKCkpPDEpJiYoaT0hMCksaSYmKHRoaXMubWF0Y2hOb2RlPXQsdGhpcy5tYXRjaERpc3Q9ZSl9LHF1ZXJ5RW52ZWxvcGU6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQyh0aGlzLnApO3JldHVybiB0LmV4cGFuZEJ5KHRoaXMudG9sZXJhbmNlKSx0fSxnZXROb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF0Y2hOb2RlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltrc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhzfX0pLFVzLkJlc3RNYXRjaFZpc2l0b3I9WHMsZShIcy5wcm90b3R5cGUse2dldEluaXRpYWxWZXJ0aWNlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXRpYWxWZXJ0aWNlc30sZ2V0S0RUOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2R0fSxlbmZvcmNlQ29uc3RyYWludHM6ZnVuY3Rpb24oKXt0aGlzLmFkZENvbnN0cmFpbnRWZXJ0aWNlcygpO3ZhciB0PTAsZT0wO2RvIGU9dGhpcy5lbmZvcmNlR2FicmllbCh0aGlzLnNlZ21lbnRzKSx0Kys7d2hpbGUoZT4wJiZ0PEhzLk1BWF9TUExJVF9JVEVSKX0saW5zZXJ0U2l0ZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZShuKX19LGdldFZlcnRleEZhY3Rvcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJ0ZXhGYWN0b3J5fSxnZXRQb2ludEFycmF5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmluaXRpYWxWZXJ0aWNlcy5zaXplKCkrdGhpcy5zZWdWZXJ0aWNlcy5zaXplKCkpLmZpbGwobnVsbCksZT0wLG49dGhpcy5pbml0aWFsVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RbZSsrXT1pLmdldENvb3JkaW5hdGUoKX1mb3IodmFyIHI9dGhpcy5zZWdWZXJ0aWNlcy5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIGk9ci5uZXh0KCk7dFtlKytdPWkuZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiB0fSxzZXRDb25zdHJhaW50czpmdW5jdGlvbih0LGUpe3RoaXMuc2VnbWVudHM9dCx0aGlzLnNlZ1ZlcnRpY2VzPWV9LGNvbXB1dGVDb252ZXhIdWxsOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGllLGU9dGhpcy5nZXRQb2ludEFycmF5KCksbj1uZXcgbWUoZSx0KTt0aGlzLmNvbnZleEh1bGw9bi5nZXRDb252ZXhIdWxsKCl9LGFkZENvbnN0cmFpbnRWZXJ0aWNlczpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZUNvbnZleEh1bGwoKSx0aGlzLmluc2VydFNpdGVzKHRoaXMuc2VnVmVydGljZXMpfSxmaW5kTm9uR2FicmllbFBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0U3RhcnQoKSxuPXQuZ2V0RW5kKCksaT1uZXcgZygoZS54K24ueCkvMiwoZS55K24ueSkvMikscz1lLmRpc3RhbmNlKGkpLG89bmV3IEMoaSk7by5leHBhbmRCeShzKTtmb3IodmFyIGE9dGhpcy5rZHQucXVlcnkobyksdT1udWxsLGw9ci5NQVhfVkFMVUUsaD1hLml0ZXJhdG9yKCk7aC5oYXNOZXh0KCk7KXt2YXIgYz1oLm5leHQoKSxmPWMuZ2V0Q29vcmRpbmF0ZSgpO2lmKCFmLmVxdWFsczJEKGUpJiYhZi5lcXVhbHMyRChuKSl7dmFyIGQ9aS5kaXN0YW5jZShmKTtpZihzPmQpe3ZhciBwPWQ7KG51bGw9PT11fHxsPnApJiYodT1mLGw9cCl9fX1yZXR1cm4gdX0sZ2V0Q29uc3RyYWludFNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnbWVudHN9LHNldFNwbGl0UG9pbnRGaW5kZXI6ZnVuY3Rpb24odCl7dGhpcy5zcGxpdEZpbmRlcj10fSxnZXRDb252ZXhIdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udmV4SHVsbH0sZ2V0VG9sZXJhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9sZXJhbmNlfSxlbmZvcmNlR2FicmllbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wLGk9bmV3IEkscj10Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXRoaXMuZmluZE5vbkdhYnJpZWxQb2ludChzKTtpZihudWxsIT09byl7dGhpcy5zcGxpdFB0PXRoaXMuc3BsaXRGaW5kZXIuZmluZFNwbGl0UG9pbnQocyxvKTt2YXIgYT10aGlzLmNyZWF0ZVZlcnRleCh0aGlzLnNwbGl0UHQscyksdT0odGhpcy5pbnNlcnRTaXRlKGEpLG5ldyBWcyhzLmdldFN0YXJ0WCgpLHMuZ2V0U3RhcnRZKCkscy5nZXRTdGFydFooKSxhLmdldFgoKSxhLmdldFkoKSxhLmdldFooKSxzLmdldERhdGEoKSkpLGw9bmV3IFZzKGEuZ2V0WCgpLGEuZ2V0WSgpLGEuZ2V0WigpLHMuZ2V0RW5kWCgpLHMuZ2V0RW5kWSgpLHMuZ2V0RW5kWigpLHMuZ2V0RGF0YSgpKTtlLmFkZCh1KSxlLmFkZChsKSxpLmFkZChzKSxuKz0xfX1yZXR1cm4gdC5yZW1vdmVBbGwoaSksdC5hZGRBbGwoZSksbn0sY3JlYXRlVmVydGV4OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW51bGw7cmV0dXJuIGU9bnVsbCE9PXRoaXMudmVydGV4RmFjdG9yeT90aGlzLnZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsbnVsbCk6bmV3IFBzKHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1udWxsO3JldHVybiBlPW51bGwhPT10aGlzLnZlcnRleEZhY3Rvcnk/dGhpcy52ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleChuLGkpOm5ldyBQcyhuKSxlLnNldE9uQ29uc3RyYWludCghMCksZX19LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ViZGl2fSxjb21wdXRlQm91bmRpbmdCb3g6ZnVuY3Rpb24oKXt2YXIgdD1Icy5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5pbml0aWFsVmVydGljZXMpLGU9SHMuY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuc2VnVmVydGljZXMpLG49bmV3IEModCk7bi5leHBhbmRUb0luY2x1ZGUoZSk7dmFyIGk9LjIqbi5nZXRXaWR0aCgpLHI9LjIqbi5nZXRIZWlnaHQoKSxzPU1hdGgubWF4KGkscik7dGhpcy5jb21wdXRlQXJlYUVudj1uZXcgQyhuKSx0aGlzLmNvbXB1dGVBcmVhRW52LmV4cGFuZEJ5KHMpfSxzZXRWZXJ0ZXhGYWN0b3J5OmZ1bmN0aW9uKHQpe3RoaXMudmVydGV4RmFjdG9yeT10fSxmb3JtSW5pdGlhbERlbGF1bmF5OmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLnN1YmRpdj1uZXcgRnModGhpcy5jb21wdXRlQXJlYUVudix0aGlzLnRvbGVyYW5jZSksdGhpcy5zdWJkaXYuc2V0TG9jYXRvcihuZXcgTXModGhpcy5zdWJkaXYpKSx0aGlzLmluY0RlbD1uZXcgT3ModGhpcy5zdWJkaXYpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5pbml0aWFsVmVydGljZXMpfSxpbnNlcnRTaXRlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQcyl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5rZHQuaW5zZXJ0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpO2lmKGUuaXNSZXBlYXRlZCgpKXt2YXIgbj1lLmdldERhdGEoKTtyZXR1cm4gbi5tZXJnZSh0KSxufXJldHVybiB0aGlzLmluY0RlbC5pbnNlcnRTaXRlKHQpLHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRTaXRlKHRoaXMuY3JlYXRlVmVydGV4KGkpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhzfX0pLEhzLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEMsbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZShpLmdldENvb3JkaW5hdGUoKSl9cmV0dXJuIGV9LEhzLk1BWF9TUExJVF9JVEVSPTk5LGUoV3MucHJvdG90eXBlLHtjcmVhdGU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5zdWJkaXYpcmV0dXJuIG51bGw7dmFyIHQ9V3MuZW52ZWxvcGUodGhpcy5zaXRlQ29vcmRzKSxlPVdzLnRvVmVydGljZXModGhpcy5zaXRlQ29vcmRzKTt0aGlzLnN1YmRpdj1uZXcgRnModCx0aGlzLnRvbGVyYW5jZSk7dmFyIG49bmV3IE9zKHRoaXMuc3ViZGl2KTtuLmluc2VydFNpdGVzKGUpfSxzZXRUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy50b2xlcmFuY2U9dH0sc2V0U2l0ZXM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MudW5pcXVlKEgudG9Db29yZGluYXRlQXJyYXkoZSkpfX0sZ2V0RWRnZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0RWRnZXModCl9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGdldFRyaWFuZ2xlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRUcmlhbmdsZXModCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdzfX0pLFdzLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcz1mdW5jdGlvbih0KXtpZihudWxsPT09dClyZXR1cm4gbmV3IE47dmFyIGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiBXcy51bmlxdWUoZSl9LFdzLmVudmVsb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQyxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKGkpfXJldHVybiBlfSxXcy51bmlxdWU9ZnVuY3Rpb24odCl7dmFyIGU9SC5jb3B5RGVlcCh0KTt1dC5zb3J0KGUpO3ZhciBuPW5ldyBOKGUsITEpO3JldHVybiBufSxXcy50b1ZlcnRpY2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuYWRkKG5ldyBUcyhpKSl9cmV0dXJuIGV9LGUoanMucHJvdG90eXBlLHtjcmVhdGVTaXRlVmVydGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5jb25zdHJhaW50VmVydGV4TWFwLmNvbnRhaW5zS2V5KGkpfHxlLmFkZChuZXcgUHMoaSkpfXJldHVybiBlfSxjcmVhdGU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5zdWJkaXYpcmV0dXJuIG51bGw7dmFyIHQ9V3MuZW52ZWxvcGUodGhpcy5zaXRlQ29vcmRzKSxlPW5ldyBJO251bGwhPT10aGlzLmNvbnN0cmFpbnRMaW5lcyYmKHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY29uc3RyYWludExpbmVzLmdldEVudmVsb3BlSW50ZXJuYWwoKSksdGhpcy5jcmVhdGVWZXJ0aWNlcyh0aGlzLmNvbnN0cmFpbnRMaW5lcyksZT1qcy5jcmVhdGVDb25zdHJhaW50U2VnbWVudHModGhpcy5jb25zdHJhaW50TGluZXMpKTt2YXIgbj10aGlzLmNyZWF0ZVNpdGVWZXJ0aWNlcyh0aGlzLnNpdGVDb29yZHMpLGk9bmV3IEhzKG4sdGhpcy50b2xlcmFuY2UpO2kuc2V0Q29uc3RyYWludHMoZSxuZXcgSSh0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXAudmFsdWVzKCkpKSxpLmZvcm1Jbml0aWFsRGVsYXVuYXkoKSxpLmVuZm9yY2VDb25zdHJhaW50cygpLHRoaXMuc3ViZGl2PWkuZ2V0U3ViZGl2aXNpb24oKX0sc2V0VG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMudG9sZXJhbmNlPXR9LHNldENvbnN0cmFpbnRzOmZ1bmN0aW9uKHQpe3RoaXMuY29uc3RyYWludExpbmVzPXR9LHNldFNpdGVzOmZ1bmN0aW9uKHQpe3RoaXMuc2l0ZUNvb3Jkcz1Xcy5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9LGdldEVkZ2VzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2LmdldEVkZ2VzKHQpfSxnZXRTdWJkaXZpc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2fSxnZXRUcmlhbmdsZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfSxjcmVhdGVWZXJ0aWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRDb29yZGluYXRlcygpLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9bmV3IFBzKGVbbl0pO3RoaXMuY29uc3RyYWludFZlcnRleE1hcC5wdXQoZVtuXSxpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGpzfX0pLGpzLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9a24uZ2V0TGluZXModCksbj1uZXcgSSxpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2pzLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyhyLG4pfXJldHVybiBufWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1zLmdldENvb3JkaW5hdGVzKCksaT0xO2k8YS5sZW5ndGg7aSsrKW8uYWRkKG5ldyBWcyhhW2ktMV0sYVtpXSkpfSxlKEtzLnByb3RvdHlwZSx7Y3JlYXRlOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMuc3ViZGl2KXJldHVybiBudWxsO3ZhciB0PVdzLmVudmVsb3BlKHRoaXMuc2l0ZUNvb3Jkcyk7dGhpcy5kaWFncmFtRW52PXQ7dmFyIGU9TWF0aC5tYXgodGhpcy5kaWFncmFtRW52LmdldFdpZHRoKCksdGhpcy5kaWFncmFtRW52LmdldEhlaWdodCgpKTt0aGlzLmRpYWdyYW1FbnYuZXhwYW5kQnkoZSksbnVsbCE9PXRoaXMuY2xpcEVudiYmdGhpcy5kaWFncmFtRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmNsaXBFbnYpO3ZhciBuPVdzLnRvVmVydGljZXModGhpcy5zaXRlQ29vcmRzKTt0aGlzLnN1YmRpdj1uZXcgRnModCx0aGlzLnRvbGVyYW5jZSk7dmFyIGk9bmV3IE9zKHRoaXMuc3ViZGl2KTtpLmluc2VydFNpdGVzKG4pfSxnZXREaWFncmFtOmZ1bmN0aW9uKHQpe3RoaXMuY3JlYXRlKCk7dmFyIGU9dGhpcy5zdWJkaXYuZ2V0Vm9yb25vaURpYWdyYW0odCk7cmV0dXJuIEtzLmNsaXBHZW9tZXRyeUNvbGxlY3Rpb24oZSx0aGlzLmRpYWdyYW1FbnYpfSxzZXRUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy50b2xlcmFuY2U9dH0sc2V0U2l0ZXM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MudW5pcXVlKEgudG9Db29yZGluYXRlQXJyYXkoZSkpfX0sc2V0Q2xpcEVudmVsb3BlOmZ1bmN0aW9uKHQpe3RoaXMuY2xpcEVudj10fSxnZXRTdWJkaXZpc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLc319KSxLcy5jbGlwR2VvbWV0cnlDb2xsZWN0aW9uPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkoZSksaT1uZXcgSSxyPTA7cjx0LmdldE51bUdlb21ldHJpZXMoKTtyKyspe3ZhciBzPXQuZ2V0R2VvbWV0cnlOKHIpLG89bnVsbDtlLmNvbnRhaW5zKHMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9vPXM6ZS5pbnRlcnNlY3RzKHMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKG89bi5pbnRlcnNlY3Rpb24ocyksby5zZXRVc2VyRGF0YShzLmdldFVzZXJEYXRhKCkpKSxudWxsPT09b3x8by5pc0VtcHR5KCl8fGkuYWRkKG8pfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KGkpKX07dmFyIERvPU9iamVjdC5mcmVlemUoe0NvbmZvcm1pbmdEZWxhdW5heVRyaWFuZ3VsYXRpb25CdWlsZGVyOmpzLERlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6V3MsVm9yb25vaURpYWdyYW1CdWlsZGVyOktzfSk7ZShacy5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFpzfX0pLFpzLnVuaW9uPWZ1bmN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLlVOSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1yZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuVU5JT04pfSxlKEIucHJvdG90eXBlLHtlcXVhbHNUb3BvOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5lcXVhbHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpP1lyLnJlbGF0ZSh0aGlzLHQpLmlzRXF1YWxzKHRoaXMuZ2V0RGltZW5zaW9uKCksdC5nZXREaW1lbnNpb24oKSk6ITF9LHVuaW9uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGpyLnVuaW9uKHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIFpzLnVuaW9uKHRoaXMsdCl9fSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIGxzLmlzVmFsaWQodGhpcyl9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtpZih0aGlzLmlzRW1wdHkoKXx8dC5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLklOVEVSU0VDVElPTix0aGlzLHQsdGhpcy5mYWN0b3J5KTtpZih0aGlzLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe3ZhciBlPXQ7cmV0dXJuIGhuLm1hcCh0aGlzLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltNYXBPcF19LG1hcDpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcnNlY3Rpb24oZSl9fSl9cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSxzaS5vdmVybGF5T3AodGhpcyx0LGlpLklOVEVSU0VDVElPTil9LGNvdmVyczpmdW5jdGlvbih0KXtyZXR1cm4gWXIuY292ZXJzKHRoaXMsdCl9LGNvdmVyZWRCeTpmdW5jdGlvbih0KXtyZXR1cm4gWXIuY292ZXJlZEJ5KHRoaXMsdCl9LHRvdWNoZXM6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLnRvdWNoZXModGhpcyx0KX0saW50ZXJzZWN0czpmdW5jdGlvbih0KXtyZXR1cm4gWXIuaW50ZXJzZWN0cyh0aGlzLHQpfSx3aXRoaW46ZnVuY3Rpb24odCl7cmV0dXJuIFlyLndpdGhpbih0aGlzLHQpfSxvdmVybGFwczpmdW5jdGlvbih0KXtyZXR1cm4gWXIub3ZlcmxhcHModGhpcyx0KX0sZGlzam9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLmRpc2pvaW50KHRoaXMsdCl9LGNyb3NzZXM6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLmNyb3NzZXModGhpcyx0KX0sYnVmZmVyOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc3IuYnVmZmVyT3AodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBzci5idWZmZXJPcCh0aGlzLGUsbil9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtyZXR1cm4gc3IuYnVmZmVyT3AodGhpcyxpLHIscyl9fSxjb252ZXhIdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBtZSh0aGlzKS5nZXRDb252ZXhIdWxsKCl9LHJlbGF0ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9QXJyYXkodCksbj0wO3Q+bjtuKyspZVtuXT1hcmd1bWVudHNbbl07cmV0dXJuIFlyLnJlbGF0ZS5hcHBseShZcixbdGhpc10uY29uY2F0KGUpKX0sZ2V0Q2VudHJvaWQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvaW50KCk7dmFyIHQ9Z2UuZ2V0Q2VudHJvaWQodGhpcyk7cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LHRoaXMpfSxnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2ludCgpO3ZhciB0PW51bGwsZT10aGlzLmdldERpbWVuc2lvbigpO2lmKDA9PT1lKXt2YXIgbj1uZXcgbGkodGhpcyk7dD1uLmdldEludGVyaW9yUG9pbnQoKX1lbHNlIGlmKDE9PT1lKXt2YXIgbj1uZXcgdWkodGhpcyk7dD1uLmdldEludGVyaW9yUG9pbnQoKX1lbHNle3ZhciBuPW5ldyBvaSh0aGlzKTt0PW4uZ2V0SW50ZXJpb3JQb2ludCgpfXJldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCx0aGlzKX0sc3ltRGlmZmVyZW5jZTpmdW5jdGlvbih0KXtpZih0aGlzLmlzRW1wdHkoKXx8dC5pc0VtcHR5KCkpe2lmKHRoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuU1lNRElGRkVSRU5DRSx0aGlzLHQsdGhpcy5mYWN0b3J5KTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuY29weSgpfXJldHVybiB0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksc2kub3ZlcmxheU9wKHRoaXMsdCxpaS5TWU1ESUZGRVJFTkNFKX0sY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZDpmdW5jdGlvbih0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9LHRvVGV4dDpmdW5jdGlvbigpe3ZhciB0PW5ldyBzZTtyZXR1cm4gdC53cml0ZSh0aGlzKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt0aGlzLnRvVGV4dCgpfSxjb250YWluczpmdW5jdGlvbih0KXtyZXR1cm4gWXIuY29udGFpbnModGhpcyx0KX0sZGlmZmVyZW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/aWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuRElGRkVSRU5DRSx0aGlzLHQsdGhpcy5mYWN0b3J5KTp0LmlzRW1wdHkoKT90aGlzLmNvcHkoKToodGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSx0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHNpLm92ZXJsYXlPcCh0aGlzLHQsaWkuRElGRkVSRU5DRSkpfSxpc1NpbXBsZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBHaSh0aGlzKTtyZXR1cm4gdC5pc1NpbXBsZSgpfSxpc1dpdGhpbkRpc3RhbmNlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UodC5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiBuPmU/ITE6aHIuaXNXaXRoaW5EaXN0YW5jZSh0aGlzLHQsZSl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQpe3JldHVybiBoci5kaXN0YW5jZSh0aGlzLHQpfSxpc0VxdWl2YWxlbnRDbGFzczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRDbGFzcygpPT09dC5nZXRDbGFzcygpfX0pO3ZhciBBbz1cIjEuMS4yICgyNDhkYWI4KVwiO3QudmVyc2lvbj1Bbyx0LmFsZ29yaXRobT1jbyx0LmRlbnNpZnk9Zm8sdC5kaXNzb2x2ZT1nbyx0Lmdlb209bG8sdC5pbmRleD1tbyx0LmlvPUlvLHQubm9kaW5nPU5vLHQub3BlcmF0aW9uPU9vLHQucHJlY2lzaW9uPV9vLHQuc2ltcGxpZnk9TW8sdC50cmlhbmd1bGF0ZT1Eb30pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuKGZ1bmN0aW9uIChmYWN0b3J5LCB3aW5kb3cpIHtcbiAgICAvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUqL1xuXG4gICAgLy8gZGVmaW5lIGFuIEFNRCBtb2R1bGUgdGhhdCByZWxpZXMgb24gJ2xlYWZsZXQnXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydsZWFmbGV0J10sIGZhY3RvcnkpO1xuXG5cbiAgICAvLyBkZWZpbmUgYSBDb21tb24gSlMgbW9kdWxlIHRoYXQgcmVsaWVzIG9uICdsZWFmbGV0J1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdsZWFmbGV0JykpO1xuICAgIH1cblxuICAgIC8vIGF0dGFjaCB5b3VyIHBsdWdpbiB0byB0aGUgZ2xvYmFsICdMJyB2YXJpYWJsZVxuICAgIGlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5MKXtcbiAgICAgICAgZmFjdG9yeSh3aW5kb3cuTCk7XG4gICAgfVxuXG59KGZ1bmN0aW9uIChMKSB7XG4gICAgTC5FZGl0YWJsZSA9IEwuRXZlbnRlZC5leHRlbmQoe1xuXG4gICAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgICAgIEZPUldBUkQ6IDEsXG4gICAgICAgICAgICBCQUNLV0FSRDogLTFcbiAgICAgICAgfSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB6SW5kZXg6IDEwMDAsXG4gICAgICAgICAgICBwb2x5Z29uQ2xhc3M6IEwuUG9seWdvbixcbiAgICAgICAgICAgIHBvbHlsaW5lQ2xhc3M6IEwuUG9seWxpbmUsXG4gICAgICAgICAgICBtYXJrZXJDbGFzczogTC5NYXJrZXIsXG4gICAgICAgICAgICByZWN0YW5nbGVDbGFzczogTC5SZWN0YW5nbGUsXG4gICAgICAgICAgICBjaXJjbGVDbGFzczogTC5DaXJjbGUsXG4gICAgICAgICAgICBkcmF3aW5nQ1NTQ2xhc3M6ICdsZWFmbGV0LWVkaXRhYmxlLWRyYXdpbmcnLFxuICAgICAgICAgICAgZHJhd2luZ0N1cnNvcjogJ2Nyb3NzaGFpcidcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0WkluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIgPSB0aGlzLmNyZWF0ZUVkaXRMYXllcigpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc0xheWVyID0gdGhpcy5jcmVhdGVGZWF0dXJlc0xheWVyKCk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUgPSB0aGlzLmNyZWF0ZUxpbmVHdWlkZSgpO1xuICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZSA9IHRoaXMuY3JlYXRlTGluZUd1aWRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZUFuZEZvcndhcmQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgICAgICBlID0gZSB8fCB7fTtcbiAgICAgICAgICAgIGUuZWRpdFRvb2xzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZmlyZSh0eXBlLCBlKTtcbiAgICAgICAgICAgIHRoaXMubWFwLmZpcmUodHlwZSwgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTGluZUd1aWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IEwuZXh0ZW5kKHtkYXNoQXJyYXk6ICc1LDEwJywgd2VpZ2h0OiAxLCBpbnRlcmFjdGl2ZTogZmFsc2V9LCB0aGlzLm9wdGlvbnMubGluZUd1aWRlT3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gTC5wb2x5bGluZShbXSwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVmVydGV4SWNvbjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBMLkJyb3dzZXIudG91Y2ggPyBuZXcgTC5FZGl0YWJsZS5Ub3VjaFZlcnRleEljb24ob3B0aW9ucykgOiBuZXcgTC5FZGl0YWJsZS5WZXJ0ZXhJY29uKG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUVkaXRMYXllcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lZGl0TGF5ZXIgfHwgbmV3IEwuTGF5ZXJHcm91cCgpLmFkZFRvKHRoaXMubWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVGZWF0dXJlc0xheWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZlYXR1cmVzTGF5ZXIgfHwgbmV3IEwuTGF5ZXJHcm91cCgpLmFkZFRvKHRoaXMubWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9yd2FyZExpbmVHdWlkZS5fbGF0bG5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMV0gPSBsYXRsbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLnJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2xhdGxuZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5nc1sxXSA9IGxhdGxuZztcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhbmNob3JGb3J3YXJkTGluZUd1aWRlOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMF0gPSBsYXRsbmc7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5yZWRyYXcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhbmNob3JCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5nc1swXSA9IGxhdGxuZztcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUucmVkcmF3KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5mb3J3YXJkTGluZUd1aWRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5iYWNrd2FyZExpbmVHdWlkZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLnNldExhdExuZ3MoW10pO1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIucmVtb3ZlTGF5ZXIodGhpcy5mb3J3YXJkTGluZUd1aWRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5zZXRMYXRMbmdzKFtdKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJsb2NrRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBIYWNrOiBmb3JjZSBtYXAgbm90IHRvIGxpc3RlbiB0byBvdGhlciBsYXllcnMgZXZlbnRzIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX29sZFRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRUYXJnZXRzID0gdGhpcy5tYXAuX3RhcmdldHM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuX3RhcmdldHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmJsb2NrRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0LCBidXQga2VlcCB0YXJnZXRzIGNyZWF0ZWQgd2hpbGUgZHJhd2luZy5cbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5fdGFyZ2V0cyA9IEwuZXh0ZW5kKHRoaXMubWFwLl90YXJnZXRzLCB0aGlzLl9vbGRUYXJnZXRzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb2xkVGFyZ2V0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWdpc3RlckZvckRyYXdpbmc6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nRWRpdG9yKSB0aGlzLnVucmVnaXN0ZXJGb3JEcmF3aW5nKHRoaXMuX2RyYXdpbmdFZGl0b3IpO1xuICAgICAgICAgICAgdGhpcy5tYXAub24oJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCBlZGl0b3Iub25EcmF3aW5nTW91c2VNb3ZlLCBlZGl0b3IpO1xuICAgICAgICAgICAgdGhpcy5ibG9ja0V2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0VkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNldXAsIHRoaXMpO1xuICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMubWFwLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5kcmF3aW5nQ1NTQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TWFwQ3Vyc29yID0gdGhpcy5tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3I7XG4gICAgICAgICAgICB0aGlzLm1hcC5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9IHRoaXMub3B0aW9ucy5kcmF3aW5nQ3Vyc29yO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVucmVnaXN0ZXJGb3JEcmF3aW5nOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnVuYmxvY2tFdmVudHMoKTtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLm1hcC5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMuZHJhd2luZ0NTU0NsYXNzKTtcbiAgICAgICAgICAgIHRoaXMubWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gdGhpcy5kZWZhdWx0TWFwQ3Vyc29yO1xuICAgICAgICAgICAgZWRpdG9yID0gZWRpdG9yIHx8IHRoaXMuX2RyYXdpbmdFZGl0b3I7XG4gICAgICAgICAgICBpZiAoIWVkaXRvcikgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5tYXAub2ZmKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZWRpdG9yLm9uRHJhd2luZ01vdXNlTW92ZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9mZignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93biwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1hcC5vZmYoJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoZWRpdG9yICE9PSB0aGlzLl9kcmF3aW5nRWRpdG9yKSByZXR1cm47XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZHJhd2luZ0VkaXRvcjtcbiAgICAgICAgICAgIGlmIChlZGl0b3IuX2RyYXdpbmcpIGVkaXRvci5jYW5jZWxEcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBlO1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0VkaXRvci5vbkRyYXdpbmdNb3VzZURvd24oZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZXVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlRG93bikge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBMLnBvaW50KHRoaXMuX21vdXNlRG93bi5vcmlnaW5hbEV2ZW50LmNsaWVudFgsIHRoaXMuX21vdXNlRG93bi5vcmlnaW5hbEV2ZW50LmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IEwucG9pbnQoZS5vcmlnaW5hbEV2ZW50LmNsaWVudFgsIGUub3JpZ2luYWxFdmVudC5jbGllbnRZKS5kaXN0YW5jZVRvKG9yaWdpbik7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlKSA8IDkgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpIHRoaXMuX2RyYXdpbmdFZGl0b3Iub25EcmF3aW5nQ2xpY2soZSk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLl9kcmF3aW5nRWRpdG9yLm9uRHJhd2luZ01vdXNlVXAoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcmF3aW5nRWRpdG9yICYmIHRoaXMuX2RyYXdpbmdFZGl0b3IuZHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0b3BEcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJGb3JEcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0RHJhd2luZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZHJhd2luZ0VkaXRvcikgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0VkaXRvci5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbm5lY3RDcmVhdGVkVG9NYXA6IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNMYXllci5hZGRMYXllcihsYXllcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnRQb2x5bGluZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmNyZWF0ZVBvbHlsaW5lKFtdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGxpbmUuZW5hYmxlRWRpdCh0aGlzLm1hcCkubmV3U2hhcGUobGF0bG5nKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0UG9seWdvbjogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHBvbHlnb24gPSB0aGlzLmNyZWF0ZVBvbHlnb24oW10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgcG9seWdvbi5lbmFibGVFZGl0KHRoaXMubWFwKS5uZXdTaGFwZShsYXRsbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnRNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxhdGxuZyA9IGxhdGxuZyB8fCB0aGlzLm1hcC5nZXRDZW50ZXIoKS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuY3JlYXRlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG4gICAgICAgICAgICBtYXJrZXIuZW5hYmxlRWRpdCh0aGlzLm1hcCkuc3RhcnREcmF3aW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0UmVjdGFuZ2xlOiBmdW5jdGlvbihsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBjb3JuZXIgPSBsYXRsbmcgfHwgTC5sYXRMbmcoWzAsIDBdKTtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoY29ybmVyLCBjb3JuZXIpO1xuICAgICAgICAgICAgdmFyIHJlY3RhbmdsZSA9IHRoaXMuY3JlYXRlUmVjdGFuZ2xlKGJvdW5kcywgb3B0aW9ucyk7XG4gICAgICAgICAgICByZWN0YW5nbGUuZW5hYmxlRWRpdCh0aGlzLm1hcCkuc3RhcnREcmF3aW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0Q2lyY2xlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBsYXRsbmcgPSBsYXRsbmcgfHwgdGhpcy5tYXAuZ2V0Q2VudGVyKCkuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLmNyZWF0ZUNpcmNsZShsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2lyY2xlLmVuYWJsZUVkaXQodGhpcy5tYXApLnN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydEhvbGU6IGZ1bmN0aW9uIChlZGl0b3IsIGxhdGxuZykge1xuICAgICAgICAgICAgZWRpdG9yLm5ld0hvbGUobGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMYXllcjogZnVuY3Rpb24gKGtsYXNzLCBsYXRsbmdzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gTC5VdGlsLmV4dGVuZCh7ZWRpdE9wdGlvbnM6IHtlZGl0VG9vbHM6IHRoaXN9fSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBuZXcga2xhc3MobGF0bG5ncywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpjcmVhdGVkJywge2xheWVyOiBsYXllcn0pO1xuICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVBvbHlsaW5lOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLnBvbHlsaW5lQ2xhc3MgfHwgdGhpcy5vcHRpb25zLnBvbHlsaW5lQ2xhc3MsIGxhdGxuZ3MsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVBvbHlnb246IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihvcHRpb25zICYmIG9wdGlvbnMucG9seWdvbkNsYXNzIHx8IHRoaXMub3B0aW9ucy5wb2x5Z29uQ2xhc3MsIGxhdGxuZ3MsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZU1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlckNsYXNzIHx8IHRoaXMub3B0aW9ucy5tYXJrZXJDbGFzcywgbGF0bG5nLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVSZWN0YW5nbGU6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWN0YW5nbGVDbGFzcyB8fCB0aGlzLm9wdGlvbnMucmVjdGFuZ2xlQ2xhc3MsIGJvdW5kcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihvcHRpb25zICYmIG9wdGlvbnMuY2lyY2xlQ2xhc3MgfHwgdGhpcy5vcHRpb25zLmNpcmNsZUNsYXNzLCBsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuZXh0ZW5kKEwuRWRpdGFibGUsIHtcblxuICAgICAgICBtYWtlQ2FuY2VsbGFibGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlLl9jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgICAgICBlZGl0VG9vbHNDbGFzczogTC5FZGl0YWJsZVxuICAgIH0pO1xuXG4gICAgTC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMud2hlblJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRUb29scyA9IG5ldyB0aGlzLm9wdGlvbnMuZWRpdFRvb2xzQ2xhc3ModGhpcywgdGhpcy5vcHRpb25zLmVkaXRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUuVmVydGV4SWNvbiA9IEwuRGl2SWNvbi5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCg4LCA4KVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUuVG91Y2hWZXJ0ZXhJY29uID0gTC5FZGl0YWJsZS5WZXJ0ZXhJY29uLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgaWNvblNpemU6IG5ldyBMLlBvaW50KDIwLCAyMClcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cblxuICAgIEwuRWRpdGFibGUuVmVydGV4TWFya2VyID0gTC5NYXJrZXIuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtdmVydGV4LWljb24nXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncywgZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgdGhpcy5fbGF0bG5nLCBiZWNhdXNlIG9uIGRyYWcgTGVhZmxldCByZXBsYWNlIGl0IHdoaWxlXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGtlZXAgcmVmZXJlbmNlLlxuICAgICAgICAgICAgdGhpcy5sYXRsbmcgPSBsYXRsbmc7XG4gICAgICAgICAgICB0aGlzLmxhdGxuZ3MgPSBsYXRsbmdzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGxhdGxuZywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaWNvbiA9IHRoaXMuZWRpdG9yLnRvb2xzLmNyZWF0ZVZlcnRleEljb24oe2NsYXNzTmFtZTogdGhpcy5vcHRpb25zLmNsYXNzTmFtZX0pO1xuICAgICAgICAgICAgdGhpcy5sYXRsbmcuX192ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZWRpdExheWVyLmFkZExheWVyKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRaSW5kZXhPZmZzZXQoZWRpdG9yLnRvb2xzLl9sYXN0WkluZGV4ICsgMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIEwuTWFya2VyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICB0aGlzLm9uKCdkcmFnJywgdGhpcy5vbkRyYWcpO1xuICAgICAgICAgICAgdGhpcy5vbignZHJhZ3N0YXJ0JywgdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICAgICAgICB0aGlzLm9uKCdkcmFnZW5kJywgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgICAgICAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMub25Nb3VzZXVwKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51KTtcbiAgICAgICAgICAgIHRoaXMub24oJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICB0aGlzLmFkZE1pZGRsZU1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWlkZGxlTWFya2VyKSB0aGlzLm1pZGRsZU1hcmtlci5kZWxldGUoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxhdGxuZy5fX3ZlcnRleDtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdkcmFnJywgdGhpcy5vbkRyYWcpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2RyYWdlbmQnLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgICAgICAgICB0aGlzLm9mZignbW91c2V1cCcsIHRoaXMub25Nb3VzZXVwKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLm9mZignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnUpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyRHJhZyhlKTtcbiAgICAgICAgICAgIHZhciBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2ljb24pLFxuICAgICAgICAgICAgICAgIGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG4gICAgICAgICAgICB0aGlzLmxhdGxuZy51cGRhdGUobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGxuZyA9IHRoaXMubGF0bG5nOyAgLy8gUHVzaCBiYWNrIHRvIExlYWZsZXQgb3VyIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZGRsZU1hcmtlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWlkZGxlTWFya2VyLnVwZGF0ZUxhdExuZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubWlkZGxlTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbmV4dC5taWRkbGVNYXJrZXIudXBkYXRlTGF0TG5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckRyYWdTdGFydChlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckRyYWdFbmQoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyQ2xpY2soZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZXVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5Eb21FdmVudC5zdG9wKGUpO1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IubWFwLmZpcmUoJ21vdXNldXAnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJDb250ZXh0TWVudShlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyTW91c2VEb3duKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKTsgIC8vIENvbXB1dGUgYmVmb3JlIGNoYW5naW5nIGxhdGxuZ1xuICAgICAgICAgICAgdGhpcy5sYXRsbmdzLnNwbGljZSh0aGlzLmdldEluZGV4KCksIDEpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhEZWxldGVkKHtsYXRsbmc6IHRoaXMubGF0bG5nLCB2ZXJ0ZXg6IHRoaXN9KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5sYXRsbmdzLmxlbmd0aCkgdGhpcy5lZGl0b3IuZGVsZXRlU2hhcGUodGhpcy5sYXRsbmdzKTtcbiAgICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnJlc2V0TWlkZGxlTWFya2VyKCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhdGxuZ3MuaW5kZXhPZih0aGlzLmxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGFzdEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXRsbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGxuZ3MubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXggPSBpbmRleCAtIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5lZGl0b3IuQ0xPU0VEKSBwcmV2aW91c0luZGV4ID0gdGhpcy5nZXRMYXN0SW5kZXgoKTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMubGF0bG5nc1twcmV2aW91c0luZGV4XTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cykgcmV0dXJuIHByZXZpb3VzLl9fdmVydGV4O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGxuZ3MubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5nZXRMYXN0SW5kZXgoKSAmJiB0aGlzLmVkaXRvci5DTE9TRUQpIG5leHRJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMubGF0bG5nc1tuZXh0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5leHQpIHJldHVybiBuZXh0Ll9fdmVydGV4O1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZE1pZGRsZU1hcmtlcjogZnVuY3Rpb24gKHByZXZpb3VzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmhhc01pZGRsZU1hcmtlcnMoKSkgcmV0dXJuO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBwcmV2aW91cyB8fCB0aGlzLmdldFByZXZpb3VzKCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMgJiYgIXRoaXMubWlkZGxlTWFya2VyKSB0aGlzLm1pZGRsZU1hcmtlciA9IHRoaXMuZWRpdG9yLmFkZE1pZGRsZU1hcmtlcihwcmV2aW91cywgdGhpcywgdGhpcy5sYXRsbmdzLCB0aGlzLmVkaXRvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTWlkZGxlTWFya2VyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5oYXNNaWRkbGVNYXJrZXJzKCkpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuZ2V0UHJldmlvdXMoKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWlkZGxlTWFya2VyKHByZXZpb3VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIG5leHQucmVzZXRNaWRkbGVNYXJrZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXNldE1pZGRsZU1hcmtlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWlkZGxlTWFya2VyKSB0aGlzLm1pZGRsZU1hcmtlci5kZWxldGUoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkTWlkZGxlTWFya2VyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BsaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3Iuc3BsaXRTaGFwZSkgcmV0dXJuOyAgLy8gT25seSBmb3IgUG9seWxpbmVFZGl0b3JcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNwbGl0U2hhcGUodGhpcy5sYXRsbmdzLCB0aGlzLmdldEluZGV4KCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmNvbnRpbnVlQmFja3dhcmQpIHJldHVybjsgIC8vIE9ubHkgZm9yIFBvbHlsaW5lRWRpdG9yXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHRoaXMuZWRpdG9yLmNvbnRpbnVlQmFja3dhcmQodGhpcy5sYXRsbmdzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmdldExhc3RJbmRleCgpKSB0aGlzLmVkaXRvci5jb250aW51ZUZvcndhcmQodGhpcy5sYXRsbmdzKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLm1lcmdlT3B0aW9ucyh7XG4gICAgICAgIHZlcnRleE1hcmtlckNsYXNzOiBMLkVkaXRhYmxlLlZlcnRleE1hcmtlclxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5NaWRkbGVNYXJrZXIgPSBMLk1hcmtlci5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1taWRkbGUtaWNvbicsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGxhdGxuZ3MsIGVkaXRvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgICAgdGhpcy5sYXRsbmdzID0gbGF0bG5ncztcbiAgICAgICAgICAgIEwuTWFya2VyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5jb21wdXRlTGF0TG5nKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmljb24gPSB0aGlzLmVkaXRvci50b29scy5jcmVhdGVWZXJ0ZXhJY29uKHtjbGFzc05hbWU6IHRoaXMub3B0aW9ucy5jbGFzc05hbWV9KTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5hZGRMYXllcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFZpc2liaWxpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0UG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLmxlZnQubGF0bG5nKSxcbiAgICAgICAgICAgICAgICByaWdodFBvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5yaWdodC5sYXRsbmcpLFxuICAgICAgICAgICAgICAgIHNpemUgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMuaWNvblNpemUpO1xuICAgICAgICAgICAgaWYgKGxlZnRQb2ludC5kaXN0YW5jZVRvKHJpZ2h0UG9pbnQpIDwgc2l6ZS54ICogMykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldE9wYWNpdHkodGhpcy5fb3BhY2l0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcGFjaXR5KDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUxhdExuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRMYXRMbmcodGhpcy5jb21wdXRlTGF0TG5nKCkpO1xuICAgICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcHV0ZUxhdExuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnRQb2ludCA9IHRoaXMuZWRpdG9yLm1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRoaXMubGVmdC5sYXRsbmcpLFxuICAgICAgICAgICAgICAgIHJpZ2h0UG9pbnQgPSB0aGlzLmVkaXRvci5tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLnJpZ2h0LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgeSA9IChsZWZ0UG9pbnQueSArIHJpZ2h0UG9pbnQueSkgLyAyLFxuICAgICAgICAgICAgICAgIHggPSAobGVmdFBvaW50LnggKyByaWdodFBvaW50LngpIC8gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbeCwgeV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgTC5Eb21FdmVudC5vbih0aGlzLl9pY29uLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCB0aGlzLm9uTW91c2VEb3duLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vbignem9vbWVuZCcsIHRoaXMuc2V0VmlzaWJpbGl0eSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJpZ2h0Lm1pZGRsZU1hcmtlcjtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQub2ZmKHRoaXMuX2ljb24sICdtb3VzZWRvd24gdG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZURvd24sIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9mZignem9vbWVuZCcsIHRoaXMuc2V0VmlzaWJpbGl0eSwgdGhpcyk7XG4gICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGljb25Qb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5faWNvbiksXG4gICAgICAgICAgICAgICAgbGF0bG5nID0gdGhpcy5lZGl0b3IubWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcbiAgICAgICAgICAgIGUgPSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICBsYXRsbmc6IGxhdGxuZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5tYWtlQ2FuY2VsbGFibGUoZSk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vbk1pZGRsZU1hcmtlck1vdXNlRG93bihlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubGF0bG5ncy5zcGxpY2UodGhpcy5pbmRleCgpLCAwLCBlLmxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB2YXIgaWNvbiA9IHRoaXMuX2ljb247XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5lZGl0b3IuYWRkVmVydGV4TWFya2VyKGUubGF0bG5nLCB0aGlzLmxhdGxuZ3MpO1xuICAgICAgICAgICAgLyogSGFjayB0byB3b3JrYXJvdW5kIGJyb3dzZXIgbm90IGZpcmluZyB0b3VjaGVuZCB3aGVuIGVsZW1lbnQgaXMgbm8gbW9yZSBvbiBET00gKi9cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBtYXJrZXIuX2ljb24ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChtYXJrZXIuX2ljb24pO1xuICAgICAgICAgICAgbWFya2VyLl9pY29uID0gaWNvbjtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChtYXJrZXIuX2ljb24pO1xuICAgICAgICAgICAgbWFya2VyLl9pbml0SWNvbigpO1xuICAgICAgICAgICAgbWFya2VyLl9pbml0SW50ZXJhY3Rpb24oKTtcbiAgICAgICAgICAgIG1hcmtlci5zZXRPcGFjaXR5KDEpO1xuICAgICAgICAgICAgLyogRW5kIGhhY2sgKi9cbiAgICAgICAgICAgIC8vIFRyYW5zZmVyIG9uZ29pbmcgZHJhZ2dpbmcgdG8gcmVhbCBtYXJrZXJcbiAgICAgICAgICAgIEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgbWFya2VyLmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uRG93bihlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF0bG5ncy5pbmRleE9mKHRoaXMucmlnaHQubGF0bG5nKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLm1lcmdlT3B0aW9ucyh7XG4gICAgICAgIG1pZGRsZU1hcmtlckNsYXNzOiBMLkVkaXRhYmxlLk1pZGRsZU1hcmtlclxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yID0gTC5DbGFzcy5leHRlbmQoe1xuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIGZlYXR1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5lZGl0b3IgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIgPSBuZXcgTC5MYXllckdyb3VwKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2xzID0gdGhpcy5vcHRpb25zLmVkaXRUb29scyB8fCBtYXAuZWRpdFRvb2xzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkgdGhpcy50b29scy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5lZGl0TGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy5vbkVuYWJsZSgpO1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUub24oJ3JlbW92ZScsIHRoaXMuZGlzYWJsZSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUub2ZmKCdyZW1vdmUnLCB0aGlzLmRpc2FibGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMuZWRpdExheWVyKTtcbiAgICAgICAgICAgIHRoaXMub25EaXNhYmxlKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZW5hYmxlZDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nKSB0aGlzLmNhbmNlbERyYXdpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX2RyYXdpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzTWlkZGxlTWFya2VyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm9wdGlvbnMuc2tpcE1pZGRsZU1hcmtlcnMgJiYgIXRoaXMudG9vbHMub3B0aW9ucy5za2lwTWlkZGxlTWFya2VycztcbiAgICAgICAgfSxcblxuICAgICAgICBmaXJlQW5kRm9yd2FyZDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgICAgICAgICAgIGUgPSBlIHx8IHt9O1xuICAgICAgICAgICAgZS5sYXllciA9IHRoaXMuZmVhdHVyZTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5maXJlKHR5cGUsIGUpO1xuICAgICAgICAgICAgdGhpcy50b29scy5maXJlQW5kRm9yd2FyZCh0eXBlLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZW5hYmxlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkaXNhYmxlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FZGl0aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTplZGl0aW5nJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25TdGFydERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6c3RhcnQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkVuZERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6ZW5kJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYW5jZWxEcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmNhbmNlbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29tbWl0RHJhd2luZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y29tbWl0JywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzptb3VzZWRvd24nLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzptb3VzZXVwJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdpbmcpIHRoaXMuX2RyYXdpbmcgPSBMLkVkaXRhYmxlLkZPUldBUkQ7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLnJlZ2lzdGVyRm9yRHJhd2luZyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25TdGFydERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21taXREcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICB0aGlzLmVuZERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWxEcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2FuY2VsRHJhd2luZygpO1xuICAgICAgICAgICAgdGhpcy5lbmREcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kRHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50b29scy51bnJlZ2lzdGVyRm9yRHJhd2luZyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25FbmREcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZHJhd2luZykgcmV0dXJuO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5tYWtlQ2FuY2VsbGFibGUoZSk7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmNsaWNrJywgZSk7XG4gICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkgdGhpcy5jb25uZWN0KGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRHJhd2luZ0NsaWNrKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQ29ubmVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzTGF5ZXIodGhpcy5mZWF0dXJlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb25uZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy50b29scy5jb25uZWN0Q3JlYXRlZFRvTWFwKHRoaXMuZmVhdHVyZSk7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmVkaXRMYXllci5hZGRMYXllcih0aGlzLmVkaXRMYXllcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzptb3ZlJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbk1vdmUoZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5NYXJrZXJFZGl0b3IgPSBMLkVkaXRhYmxlLkJhc2VFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB0aGlzLmVuYWJsZURyYWdnaW5nKCk7XG4gICAgICAgICAgICBlbHNlIHRoaXMuZmVhdHVyZS5vbignYWRkJywgdGhpcy5lbmFibGVEcmFnZ2luZywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUub24oJ2RyYWdzdGFydCcsIHRoaXMub25FZGl0aW5nLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5vbignZHJhZycsIHRoaXMub25Nb3ZlLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5kcmFnZ2luZykgdGhpcy5mZWF0dXJlLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5vZmYoJ2RyYWdzdGFydCcsIHRoaXMub25FZGl0aW5nLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5vZmYoJ2RyYWcnLCB0aGlzLm9uTW92ZSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGVEcmFnZ2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmRyYWdnaW5nLmVuYWJsZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUub25EcmF3aW5nTW91c2VNb3ZlLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZykgdGhpcy5mZWF0dXJlLnNldExhdExuZyhlLmxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvY2Vzc0RyYXdpbmdDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2xpY2tlZCcsIGUpO1xuICAgICAgICAgICAgdGhpcy5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBPbiB0b3VjaCwgdGhlIGxhdGxuZyBoYXMgbm90IGJlZW4gdXBkYXRlZCBiZWNhdXNlIHRoZXJlIGlzXG4gICAgICAgICAgICAvLyBubyBtb3VzZW1vdmUuXG4gICAgICAgICAgICBpZiAoZSkgdGhpcy5mZWF0dXJlLl9sYXRsbmcgPSBlLmxhdGxuZztcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUuUGF0aEVkaXRvciA9IEwuRWRpdGFibGUuQmFzZUVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgIENMT1NFRDogZmFsc2UsXG4gICAgICAgIE1JTl9WRVJURVg6IDIsXG5cbiAgICAgICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0VmVydGV4TWFya2VyczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0TGF0TG5ncygpO1xuICAgICAgICAgICAgaWYgKEwuUG9seWxpbmUuX2ZsYXQobGF0bG5ncykpIHRoaXMuYWRkVmVydGV4TWFya2VycyhsYXRsbmdzKTtcbiAgICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB0aGlzLmluaXRWZXJ0ZXhNYXJrZXJzKGxhdGxuZ3NbaV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUuZ2V0TGF0TG5ncygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRMYXllci5jbGVhckxheWVycygpO1xuICAgICAgICAgICAgdGhpcy5pbml0VmVydGV4TWFya2VycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFZlcnRleE1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLnRvb2xzLm9wdGlvbnMudmVydGV4TWFya2VyQ2xhc3MobGF0bG5nLCBsYXRsbmdzLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRWZXJ0ZXhNYXJrZXJzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRWZXJ0ZXhNYXJrZXIobGF0bG5nc1tpXSwgbGF0bG5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVmcmVzaFZlcnRleE1hcmtlcnM6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYXRsbmdzW2ldLl9fdmVydGV4LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZE1pZGRsZU1hcmtlcjogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBsYXRsbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMudG9vbHMub3B0aW9ucy5taWRkbGVNYXJrZXJDbGFzcyhsZWZ0LCByaWdodCwgbGF0bG5ncywgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmNsaWNrJywgZSk7XG4gICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy50b29scy5kcmF3aW5nKCkgJiYgdGhpcy50b29scy5fZHJhd2luZ0VkaXRvciAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZS52ZXJ0ZXguZ2V0SW5kZXgoKSwgY29tbWl0O1xuICAgICAgICAgICAgaWYgKGUub3JpZ2luYWxFdmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlckN0cmxDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJBbHRDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlclNoaWZ0Q2xpY2soZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlck1ldGFLZXlDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGUudmVydGV4LmdldExhc3RJbmRleCgpICYmIHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLk1JTl9WRVJURVggLSAxKSBjb21taXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCAmJiB0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkJBQ0tXQVJEICYmIHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPj0gdGhpcy5NSU5fVkVSVEVYKSB7XG4gICAgICAgICAgICAgICAgY29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEICYmIHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPj0gdGhpcy5NSU5fVkVSVEVYICYmIHRoaXMuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgY29tbWl0ID0gdHJ1ZTsgIC8vIEFsbG93IHRvIGNsb3NlIG9uIGZpcnN0IHBvaW50IGFsc28gZm9yIHBvbHlnb25zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhSYXdNYXJrZXJDbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpjbGlja2VkJywgZSk7XG4gICAgICAgICAgICBpZiAoY29tbWl0KSB0aGlzLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhSYXdNYXJrZXJDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpyYXdjbGljaycsIGUpO1xuICAgICAgICAgICAgaWYgKGUuX2NhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZlcnRleENhbkJlRGVsZXRlZChlLnZlcnRleCkpIHJldHVybjtcbiAgICAgICAgICAgIGUudmVydGV4LmRlbGV0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZlcnRleENhbkJlRGVsZXRlZDogZnVuY3Rpb24gKHZlcnRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlcnRleC5sYXRsbmdzLmxlbmd0aCA+IHRoaXMuTUlOX1ZFUlRFWDtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleERlbGV0ZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6ZGVsZXRlZCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyQ3RybENsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmN0cmxjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyU2hpZnRDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpzaGlmdGNsaWNrJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJNZXRhS2V5Q2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6bWV0YWtleWNsaWNrJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJBbHRDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDphbHRjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6Y29udGV4dG1lbnUnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlck1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDptb3VzZWRvd24nLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1pZGRsZU1hcmtlck1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOm1pZGRsZW1hcmtlcjptb3VzZWRvd24nLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW92ZShlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUuX2JvdW5kcykgdGhpcy5leHRlbmRCb3VuZHMoZSk7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRyYWdzdGFydCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpkcmFnZW5kJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RHJhd25MYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgdGhpcy5fZHJhd25MYXRMbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXduTGF0TG5ncykgdGhpcy5zZXREcmF3bkxhdExuZ3MoKTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuc3RhcnREcmF3aW5nLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nRm9yd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYXR0YWNoRm9yd2FyZExpbmVHdWlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuZGV0YWNoRm9yd2FyZExpbmVHdWlkZSgpO1xuICAgICAgICAgICAgdGhpcy50b29scy5kZXRhY2hCYWNrd2FyZExpbmVHdWlkZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXduTGF0TG5ncyAmJiB0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoIDwgdGhpcy5NSU5fVkVSVEVYKSB0aGlzLmRlbGV0ZVNoYXBlKHRoaXMuX2RyYXduTGF0TG5ncyk7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLmVuZERyYXdpbmcuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kcmF3bkxhdExuZ3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEKSB0aGlzLl9kcmF3bkxhdExuZ3MucHVzaChsYXRsbmcpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLl9kcmF3bkxhdExuZ3MudW5zaGlmdChsYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmFkZFZlcnRleE1hcmtlcihsYXRsbmcsIHRoaXMuX2RyYXduTGF0TG5ncyk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICBuZXdQb2ludEZvcndhcmQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTGF0TG5nKGxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmFuY2hvckZvcndhcmRMaW5lR3VpZGUobGF0bG5nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy50b29scy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5nc1swXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUobGF0bG5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuZXdQb2ludEJhY2t3YXJkOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICB0aGlzLmFkZExhdExuZyhsYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy50b29scy5hbmNob3JCYWNrd2FyZExpbmVHdWlkZShsYXRsbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIGlmICghbGF0bG5nKSByZXR1cm4gY29uc29sZS5lcnJvcignTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnB1c2ggZXhwZWN0IGEgdmFpbGQgbGF0bG5nIGFzIHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgdGhpcy5uZXdQb2ludEZvcndhcmQobGF0bG5nKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5uZXdQb2ludEJhY2t3YXJkKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICBsYXRsbmcuX192ZXJ0ZXguZGVsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoIDw9IDEpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBsYXRsbmc7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEKSBsYXRsbmcgPSB0aGlzLl9kcmF3bkxhdExuZ3NbdGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZWxzZSBsYXRsbmcgPSB0aGlzLl9kcmF3bkxhdExuZ3NbMF07XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxhdExuZyhsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgdGhpcy50b29scy5hbmNob3JGb3J3YXJkTGluZUd1aWRlKHRoaXMuX2RyYXduTGF0TG5nc1t0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgZWxzZSB0aGlzLnRvb2xzLmFuY2hvckZvcndhcmRMaW5lR3VpZGUodGhpcy5fZHJhd25MYXRMbmdzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiBsYXRsbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvY2Vzc0RyYXdpbmdDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnZlcnRleCAmJiBlLnZlcnRleC5lZGl0b3IgPT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGUubGF0bG5nKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5uZXdQb2ludEJhY2t3YXJkKGUubGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2xpY2tlZCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUub25EcmF3aW5nTW91c2VNb3ZlLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHMubW92ZUZvcndhcmRMaW5lR3VpZGUoZS5sYXRsbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHMubW92ZUJhY2t3YXJkTGluZUd1aWRlKGUubGF0bG5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUucmVkcmF3KCk7XG4gICAgICAgICAgICB0aGlzLm9uRWRpdGluZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5ld1NoYXBlOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmFkZE5ld0VtcHR5U2hhcGUoKTtcbiAgICAgICAgICAgIGlmICghc2hhcGUpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd25MYXRMbmdzKHNoYXBlWzBdIHx8IHNoYXBlKTsgIC8vIFBvbHlnb24gb3IgcG9seWxpbmVcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nRm9yd2FyZCgpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6c2hhcGU6bmV3Jywge3NoYXBlOiBzaGFwZX0pO1xuICAgICAgICAgICAgaWYgKGxhdGxuZykgdGhpcy5uZXdQb2ludEZvcndhcmQobGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVTaGFwZTogZnVuY3Rpb24gKHNoYXBlLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHtzaGFwZTogc2hhcGV9O1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5tYWtlQ2FuY2VsbGFibGUoZSk7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpzaGFwZTpkZWxldGUnLCBlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNoYXBlID0gdGhpcy5fZGVsZXRlU2hhcGUoc2hhcGUsIGxhdGxuZ3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5zdXJlTm90RmxhdCkgdGhpcy5lbnN1cmVOb3RGbGF0KCk7ICAvLyBQb2x5Z29uLlxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLnNldExhdExuZ3ModGhpcy5nZXRMYXRMbmdzKCkpOyAgLy8gRm9yY2UgYm91bmRzIHJlc2V0LlxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpzaGFwZTpkZWxldGVkJywge3NoYXBlOiBzaGFwZX0pO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kZWxldGVTaGFwZTogZnVuY3Rpb24gKHNoYXBlLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldExhdExuZ3MoKTtcbiAgICAgICAgICAgIGlmICghbGF0bG5ncy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpbnBsYWNlRGVsZXRlID0gZnVuY3Rpb24gKGxhdGxuZ3MsIHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxlZCB3aGVuIGRlbGV0aW5nIGEgZmxhdCBsYXRsbmdzXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlID0gbGF0bG5ncy5zcGxpY2UoMCwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNwbGljZURlbGV0ZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsZWQgd2hlbiByZW1vdmluZyBhIGxhdGxuZ3MgaW5zaWRlIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGxhdGxuZ3Muc3BsaWNlKGxhdGxuZ3MuaW5kZXhPZihzaGFwZSksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSBzZWxmLl9kZWxldGVTaGFwZShsYXRsbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobGF0bG5ncyA9PT0gc2hhcGUpIHJldHVybiBpbnBsYWNlRGVsZXRlKGxhdGxuZ3MsIHNoYXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsYXRsbmdzW2ldID09PSBzaGFwZSkgcmV0dXJuIHNwbGljZURlbGV0ZShsYXRsbmdzLCBzaGFwZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGF0bG5nc1tpXS5pbmRleE9mKHNoYXBlKSAhPT0gLTEpIHJldHVybiBzcGxpY2VEZWxldGUobGF0bG5nc1tpXSwgc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGV0ZVNoYXBlQXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuZmVhdHVyZS5zaGFwZUF0KGxhdGxuZyk7XG4gICAgICAgICAgICBpZiAoc2hhcGUpIHJldHVybiB0aGlzLmRlbGV0ZVNoYXBlKHNoYXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcHBlbmRTaGFwZTogZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydFNoYXBlKHNoYXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmVwZW5kU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFwZShzaGFwZSwgMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZXJ0U2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTXVsdGkoKTtcbiAgICAgICAgICAgIHNoYXBlID0gdGhpcy5mb3JtYXRTaGFwZShzaGFwZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgaW5kZXggPSB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnNwbGljZShpbmRleCwgMCwgc2hhcGUpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRlbmRCb3VuZHM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2JvdW5kcy5leHRlbmQoZS52ZXJ0ZXgubGF0bG5nKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlBvbHlsaW5lRWRpdG9yID0gTC5FZGl0YWJsZS5QYXRoRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgc3RhcnREcmF3aW5nQmFja3dhcmQ6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nID0gTC5FZGl0YWJsZS5CQUNLV0FSRDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nKGxhdGxuZ3MpO1xuICAgICAgICAgICAgdGhpcy50b29scy5hdHRhY2hCYWNrd2FyZExpbmVHdWlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRpbnVlQmFja3dhcmQ6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmF3aW5nKCkpIHJldHVybjtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd25MYXRMbmdzKGxhdGxuZ3MpO1xuICAgICAgICAgICAgdGhpcy50b29scy5hbmNob3JCYWNrd2FyZExpbmVHdWlkZShsYXRsbmdzWzBdKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nQmFja3dhcmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250aW51ZUZvcndhcmQ6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmF3aW5nKCkpIHJldHVybjtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd25MYXRMbmdzKGxhdGxuZ3MpO1xuICAgICAgICAgICAgdGhpcy50b29scy5hbmNob3JGb3J3YXJkTGluZUd1aWRlKGxhdGxuZ3NbbGF0bG5ncy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ0ZvcndhcmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREZWZhdWx0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgIGlmICghbGF0bG5ncy5sZW5ndGggfHwgbGF0bG5nc1swXSBpbnN0YW5jZW9mIEwuTGF0TG5nKSByZXR1cm4gbGF0bG5ncztcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MobGF0bG5nc1swXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5zdXJlTXVsdGk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoICYmIEwuUG9seWxpbmUuX2ZsYXQodGhpcy5mZWF0dXJlLl9sYXRsbmdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fbGF0bG5ncyA9IFt0aGlzLmZlYXR1cmUuX2xhdGxuZ3NdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZE5ld0VtcHR5U2hhcGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTaGFwZShzaGFwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlLl9sYXRsbmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIGlmIChMLlBvbHlsaW5lLl9mbGF0KHNoYXBlKSkgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVbMF0pIHJldHVybiB0aGlzLmZvcm1hdFNoYXBlKHNoYXBlWzBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzcGxpdFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWluZGV4IHx8IGluZGV4ID49IHNoYXBlLmxlbmd0aCAtIDEpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTXVsdGkoKTtcbiAgICAgICAgICAgIHZhciBzaGFwZUluZGV4ID0gdGhpcy5mZWF0dXJlLl9sYXRsbmdzLmluZGV4T2Yoc2hhcGUpO1xuICAgICAgICAgICAgaWYgKHNoYXBlSW5kZXggPT09IC0xKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBzaGFwZS5zbGljZSgwLCBpbmRleCArIDEpLFxuICAgICAgICAgICAgICAgIHNlY29uZCA9IHNoYXBlLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICAgIC8vIFdlIGRlYWwgd2l0aCByZWZlcmVuY2UsIHdlIGRvbid0IHdhbnQgdHdpY2UgdGhlIHNhbWUgbGF0bG5nIGFyb3VuZC5cbiAgICAgICAgICAgIHNlY29uZFswXSA9IEwubGF0TG5nKHNlY29uZFswXS5sYXQsIHNlY29uZFswXS5sbmcsIHNlY29uZFswXS5hbHQpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnNwbGljZShzaGFwZUluZGV4LCAxLCBmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUuUG9seWdvbkVkaXRvciA9IEwuRWRpdGFibGUuUGF0aEVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgIENMT1NFRDogdHJ1ZSxcbiAgICAgICAgTUlOX1ZFUlRFWDogMyxcblxuICAgICAgICBzdGFydERyYXdpbmdGb3J3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLnN0YXJ0RHJhd2luZ0ZvcndhcmQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYXR0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGROZXdFbXB0eUhvbGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTm90RmxhdCgpO1xuICAgICAgICAgICAgdmFyIGxhdGxuZ3MgPSB0aGlzLmZlYXR1cmUuc2hhcGVBdChsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG9sZXMgPSBbXTtcbiAgICAgICAgICAgIGxhdGxuZ3MucHVzaChob2xlcyk7XG4gICAgICAgICAgICByZXR1cm4gaG9sZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV3SG9sZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdmFyIGhvbGVzID0gdGhpcy5hZGROZXdFbXB0eUhvbGUobGF0bG5nKTtcbiAgICAgICAgICAgIGlmICghaG9sZXMpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd25MYXRMbmdzKGhvbGVzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nRm9yd2FyZCgpO1xuICAgICAgICAgICAgaWYgKGxhdGxuZykgdGhpcy5uZXdQb2ludEZvcndhcmQobGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGROZXdFbXB0eVNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCAmJiB0aGlzLmZlYXR1cmUuX2xhdGxuZ3NbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTaGFwZShzaGFwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlLl9sYXRsbmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVuc3VyZU11bHRpOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCAmJiBMLlBvbHlsaW5lLl9mbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5nc1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MgPSBbdGhpcy5mZWF0dXJlLl9sYXRsbmdzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVOb3RGbGF0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggfHwgTC5Qb2x5bGluZS5fZmxhdCh0aGlzLmZlYXR1cmUuX2xhdGxuZ3MpKSB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MgPSBbdGhpcy5mZWF0dXJlLl9sYXRsbmdzXTtcbiAgICAgICAgfSxcblxuICAgICAgICB2ZXJ0ZXhDYW5CZURlbGV0ZWQ6IGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmZlYXR1cmUucGFyZW50U2hhcGUodmVydGV4LmxhdGxuZ3MpLFxuICAgICAgICAgICAgICAgIGlkeCA9IEwuVXRpbC5pbmRleE9mKHBhcmVudCwgdmVydGV4LmxhdGxuZ3MpO1xuICAgICAgICAgICAgaWYgKGlkeCA+IDApIHJldHVybiB0cnVlOyAgLy8gSG9sZXMgY2FuIGJlIHRvdGFsbHkgZGVsZXRlZCB3aXRob3V0IHJlbW92aW5nIHRoZSBsYXllciBpdHNlbGYuXG4gICAgICAgICAgICByZXR1cm4gTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS52ZXJ0ZXhDYW5CZURlbGV0ZWQuY2FsbCh0aGlzLCB2ZXJ0ZXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGgpIHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5wdXNoKFtdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUuX2xhdGxuZ3NbMF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0U2hhcGU6IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgLy8gW1sxLCAyXSwgWzMsIDRdXSA9PiBtdXN0IGJlIG5lc3RlZFxuICAgICAgICAgICAgLy8gW10gPT4gbXVzdCBiZSBuZXN0ZWRcbiAgICAgICAgICAgIC8vIFtbXV0gPT4gaXMgYWxyZWFkeSBuZXN0ZWRcbiAgICAgICAgICAgIGlmIChMLlBvbHlsaW5lLl9mbGF0KHNoYXBlKSAmJiAoIXNoYXBlWzBdIHx8IHNoYXBlWzBdLmxlbmd0aCAhPT0gMCkpIHJldHVybiBbc2hhcGVdO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gc2hhcGU7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5SZWN0YW5nbGVFZGl0b3IgPSBMLkVkaXRhYmxlLlBhdGhFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICBDTE9TRUQ6IHRydWUsXG4gICAgICAgIE1JTl9WRVJURVg6IDQsXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2tpcE1pZGRsZU1hcmtlcnM6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBleHRlbmRCb3VuZHM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBlLnZlcnRleC5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICAgIG9wcG9zaXRlSW5kZXggPSAoaW5kZXggKyAyKSAlIDQsXG4gICAgICAgICAgICAgICAgb3Bwb3NpdGUgPSBlLnZlcnRleC5sYXRsbmdzW29wcG9zaXRlSW5kZXhdLFxuICAgICAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcyhlLmxhdGxuZywgb3Bwb3NpdGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlRG93bi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB2YXIgbGF0bG5ncyA9IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIC8vIEwuUG9seWdvbi5fY29udmVydExhdExuZ3MgcmVtb3ZlcyBsYXN0IGxhdGxuZyBpZiBpdCBlcXVhbHMgZmlyc3QgcG9pbnQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyB0aGUgY2FzZSBoZXJlIGFzIGFsbCBsYXRsbmdzIGFyZSBbMCwgMF1cbiAgICAgICAgICAgIGlmIChsYXRsbmdzLmxlbmd0aCA9PT0gMykgbGF0bG5ncy5wdXNoKGUubGF0bG5nKTtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoZS5sYXRsbmcsIGUubGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRzKGJvdW5kcyk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0RHJhd2luZyhlKTtcbiAgICAgICAgICAgIC8vIFN0b3AgZHJhZ2dpbmcgbWFwLlxuICAgICAgICAgICAgdGhpcy5tYXAuZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25VcChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgLy8gTm93IHRyYW5zZmVyIG9uZ29pbmcgZHJhZyBhY3Rpb24gdG8gdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXG4gICAgICAgICAgICAvLyBTaG91bGQgd2UgcmVmaW5lIHdoaWNoIGNvcm5lIHdpbGwgaGFuZGxlIHRoZSBkcmFnIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gZHJhZyBkaXJlY3Rpb24/XG4gICAgICAgICAgICBsYXRsbmdzWzNdLl9fdmVydGV4LmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uRG93bihlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgcmV0dXJuIGxhdGxuZ3MgfHwgdGhpcy5mZWF0dXJlLl9sYXRsbmdzWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9ib3VuZHMgPSBib3VuZHM7XG4gICAgICAgICAgICB2YXIgbGF0bG5ncyA9IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKSxcbiAgICAgICAgICAgICAgICBuZXdMYXRsbmdzID0gdGhpcy5mZWF0dXJlLl9ib3VuZHNUb0xhdExuZ3MoYm91bmRzKTtcbiAgICAgICAgICAgIC8vIEtlZXAgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxhdGxuZ3NbaV0udXBkYXRlKG5ld0xhdGxuZ3NbaV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLkNpcmNsZUVkaXRvciA9IEwuRWRpdGFibGUuUGF0aEVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgIE1JTl9WRVJURVg6IDIsXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2tpcE1pZGRsZU1hcmtlcnM6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIGZlYXR1cmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nID0gdGhpcy5jb21wdXRlUmVzaXplTGF0TG5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcHV0ZVJlc2l6ZUxhdExuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gV2hpbGUgY2lyY2xlIGlzIG5vdCBhZGRlZCB0byB0aGUgbWFwLCBfcmFkaXVzIGlzIG5vdCBzZXQuXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAodGhpcy5mZWF0dXJlLl9yYWRpdXMgfHwgdGhpcy5mZWF0dXJlLl9tUmFkaXVzKSAqIE1hdGguY29zKE1hdGguUEkgLyA0KSxcbiAgICAgICAgICAgICAgICBwb2ludCA9IHRoaXMubWFwLnByb2plY3QodGhpcy5mZWF0dXJlLl9sYXRsbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLnVucHJvamVjdChbcG9pbnQueCArIGRlbHRhLCBwb2ludC55IC0gZGVsdGFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVSZXNpemVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy51cGRhdGUodGhpcy5jb21wdXRlUmVzaXplTGF0TG5nKCkpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nLl9fdmVydGV4LnVwZGF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5mZWF0dXJlLl9sYXRsbmcsIHRoaXMuX3Jlc2l6ZUxhdExuZ107XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGVmYXVsdExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExhdExuZ3MoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS52ZXJ0ZXguZ2V0SW5kZXgoKSA9PT0gMSkgdGhpcy5yZXNpemUoZSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMudXBkYXRlUmVzaXplTGF0TG5nKGUpO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vblZlcnRleE1hcmtlckRyYWcuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5mZWF0dXJlLl9sYXRsbmcuZGlzdGFuY2VUbyhlLmxhdGxuZylcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5zZXRSYWRpdXMocmFkaXVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlRG93bi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nLnVwZGF0ZShlLmxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2xhdGxuZy51cGRhdGUoZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICAvLyBTdG9wIGRyYWdnaW5nIG1hcC5cbiAgICAgICAgICAgIHRoaXMubWFwLmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uVXAoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIC8vIE5vdyB0cmFuc2ZlciBvbmdvaW5nIGRyYWcgYWN0aW9uIHRvIHRoZSByYWRpdXMgaGFuZGxlci5cbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy5fX3ZlcnRleC5kcmFnZ2luZy5fZHJhZ2dhYmxlLl9vbkRvd24oZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlTW92ZS5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmcudXBkYXRlKGUubGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fbGF0bG5nLl9fdmVydGV4LnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHZhciBFZGl0YWJsZU1peGluID0ge1xuXG4gICAgICAgIGNyZWF0ZUVkaXRvcjogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgbWFwID0gbWFwIHx8IHRoaXMuX21hcDtcbiAgICAgICAgICAgIHZhciBLbGFzcyA9IHRoaXMub3B0aW9ucy5lZGl0b3JDbGFzcyB8fCB0aGlzLmdldEVkaXRvckNsYXNzKG1hcCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtsYXNzKG1hcCwgdGhpcywgdGhpcy5vcHRpb25zLmVkaXRPcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGVFZGl0OiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yKSB0aGlzLmNyZWF0ZUVkaXRvcihtYXApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmVuYWJsZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVkaXRFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IgJiYgdGhpcy5lZGl0b3IuX2VuYWJsZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzYWJsZUVkaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5lZGl0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlRWRpdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZUVkaXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVFZGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uRWRpdGFibGVBZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvcikgdGhpcy5lbmFibGVFZGl0KCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBMLlBvbHlsaW5lLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgTC5Qb2x5Z29uLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgTC5NYXJrZXIuaW5jbHVkZShFZGl0YWJsZU1peGluKTtcbiAgICBMLlJlY3RhbmdsZS5pbmNsdWRlKEVkaXRhYmxlTWl4aW4pO1xuICAgIEwuQ2lyY2xlLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG5cbiAgICBMLlBvbHlsaW5lLmluY2x1ZGUoe1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKG1hcCAmJiBtYXAub3B0aW9ucy5wb2x5bGluZUVkaXRvckNsYXNzKSA/IG1hcC5vcHRpb25zLnBvbHlsaW5lRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLlBvbHlsaW5lRWRpdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNoYXBlQXQ6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBoYXZlIHRob3NlIGNhc2VzOlxuICAgICAgICAgICAgLy8gLSBsYXRsbmdzIGFyZSBqdXN0IGEgZmxhdCBhcnJheSBvZiBsYXRsbmdzLCB1c2UgdGhpc1xuICAgICAgICAgICAgLy8gLSBsYXRsbmdzIGlzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCBsb29wIG92ZXJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG51bGw7XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9sYXRsbmdzO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzLmxlbmd0aCkgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgZWxzZSBpZiAoTC5Qb2x5bGluZS5fZmxhdChsYXRsbmdzKSAmJiB0aGlzLmlzSW5MYXRMbmdzKGxhdGxuZywgbGF0bG5ncykpIHNoYXBlID0gbGF0bG5ncztcbiAgICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSBpZiAodGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3NbaV0pKSByZXR1cm4gbGF0bG5nc1tpXTtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0luTGF0TG5nczogZnVuY3Rpb24gKGwsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGlmICghbGF0bG5ncykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGksIGssIGxlbiwgcGFydCA9IFtdLCBwLFxuICAgICAgICAgICAgICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5ncywgcGFydCwgdGhpcy5fcHhCb3VuZHMpO1xuICAgICAgICAgICAgcGFydCA9IHBhcnRbMF07XG4gICAgICAgICAgICBwID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHBhcnQubGVuZ3RoLCBrID0gMDsgaSA8IGxlbjsgayA9IGkrKykge1xuXG4gICAgICAgICAgICAgICAgaWYgKEwuTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2ldKSA8PSB3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLlBvbHlnb24uaW5jbHVkZSh7XG5cbiAgICAgICAgZ2V0RWRpdG9yQ2xhc3M6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHJldHVybiAobWFwICYmIG1hcC5vcHRpb25zLnBvbHlnb25FZGl0b3JDbGFzcykgPyBtYXAub3B0aW9ucy5wb2x5Z29uRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLlBvbHlnb25FZGl0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcGVBdDogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICAgICAgICAgICAgLy8gV2UgY2FuIGhhdmUgdGhvc2UgY2FzZXM6XG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgYXJlIGp1c3QgYSBmbGF0IGFycmF5IG9mIGxhdGxuZ3MsIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHRoaXMgaXMgYSBzaW1wbGUgcG9seWdvbiAobWF5YmUgd2l0aCBob2xlcyksIHVzZSB0aGUgZmlyc3RcbiAgICAgICAgICAgIC8vIC0gbGF0bG5ncyBpcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgYXJyYXlzLCB0aGlzIGlzIGEgbXVsdGksIGxvb3Agb3ZlclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2xhdGxuZ3M7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICBlbHNlIGlmIChMLlBvbHlsaW5lLl9mbGF0KGxhdGxuZ3MpICYmIHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzKSkgc2hhcGUgPSBsYXRsbmdzO1xuICAgICAgICAgICAgZWxzZSBpZiAoTC5Qb2x5bGluZS5fZmxhdChsYXRsbmdzWzBdKSAmJiB0aGlzLmlzSW5MYXRMbmdzKGxhdGxuZywgbGF0bG5nc1swXSkpIHNoYXBlID0gbGF0bG5ncztcbiAgICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSBpZiAodGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3NbaV1bMF0pKSByZXR1cm4gbGF0bG5nc1tpXTtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0luTGF0TG5nczogZnVuY3Rpb24gKGwsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSBmYWxzZSwgbDEsIGwyLCBqLCBrLCBsZW4yO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4yID0gbGF0bG5ncy5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcbiAgICAgICAgICAgICAgICBsMSA9IGxhdGxuZ3Nbal07XG4gICAgICAgICAgICAgICAgbDIgPSBsYXRsbmdzW2tdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgobDEubGF0ID4gbC5sYXQpICE9PSAobDIubGF0ID4gbC5sYXQpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGwubG5nIDwgKGwyLmxuZyAtIGwxLmxuZykgKiAobC5sYXQgLSBsMS5sYXQpIC8gKGwyLmxhdCAtIGwxLmxhdCkgKyBsMS5sbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcmVudFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2xhdGxuZ3M7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpZHggPSBMLlV0aWwuaW5kZXhPZihsYXRsbmdzLCBzaGFwZSk7XG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkgcmV0dXJuIGxhdGxuZ3M7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZHggPSBMLlV0aWwuaW5kZXhPZihsYXRsbmdzW2ldLCBzaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHJldHVybiBsYXRsbmdzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuTWFya2VyLmluY2x1ZGUoe1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKG1hcCAmJiBtYXAub3B0aW9ucy5tYXJrZXJFZGl0b3JDbGFzcykgPyBtYXAub3B0aW9ucy5tYXJrZXJFZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuTWFya2VyRWRpdG9yO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuUmVjdGFuZ2xlLmluY2x1ZGUoe1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKG1hcCAmJiBtYXAub3B0aW9ucy5yZWN0YW5nbGVFZGl0b3JDbGFzcykgPyBtYXAub3B0aW9ucy5yZWN0YW5nbGVFZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuUmVjdGFuZ2xlRWRpdG9yO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuQ2lyY2xlLmluY2x1ZGUoe1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKG1hcCAmJiBtYXAub3B0aW9ucy5jaXJjbGVFZGl0b3JDbGFzcykgPyBtYXAub3B0aW9ucy5jaXJjbGVFZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuQ2lyY2xlRWRpdG9yO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHZhciBrZWVwRWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB5b3UgY2FuIHJlbW92ZS9yZWFkZCBhbiBlZGl0YWJsZSBsYXllci5cbiAgICAgICAgdGhpcy5vbignYWRkJywgdGhpcy5fb25FZGl0YWJsZUFkZCk7XG4gICAgfTtcbiAgICBMLk1hcmtlci5hZGRJbml0SG9vayhrZWVwRWRpdGFibGUpO1xuICAgIEwuUG9seWxpbmUuYWRkSW5pdEhvb2soa2VlcEVkaXRhYmxlKTtcblxuICAgIEwuTGF0TG5nLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgIHRoaXMubGF0ID0gbGF0bG5nLmxhdDtcbiAgICAgICAgdGhpcy5sbmcgPSBsYXRsbmcubG5nO1xuICAgIH1cblxufSwgd2luZG93KSk7XG4iLCIvKlxuIExlYWZsZXQgMS4wLjAtcmMuMiwgYSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzLiBodHRwOi8vbGVhZmxldGpzLmNvbVxuIChjKSAyMDEwLTIwMTUgVmxhZGltaXIgQWdhZm9ua2luLCAoYykgMjAxMC0yMDExIENsb3VkTWFkZVxuKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XHJcbnZhciBMID0ge1xyXG5cdHZlcnNpb246IFwiMS4wLjAtcmMuMlwiXHJcbn07XHJcblxyXG5mdW5jdGlvbiBleHBvc2UoKSB7XHJcblx0dmFyIG9sZEwgPSB3aW5kb3cuTDtcclxuXHJcblx0TC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0d2luZG93LkwgPSBvbGRMO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHJcblx0d2luZG93LkwgPSBMO1xyXG59XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBmb3IgTm9kZSBtb2R1bGUgcGF0dGVybiBsb2FkZXJzLCBpbmNsdWRpbmcgQnJvd3NlcmlmeVxyXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTDtcclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGFzIGFuIEFNRCBtb2R1bGVcclxufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuXHRkZWZpbmUoTCk7XHJcbn1cclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGFzIGEgZ2xvYmFsIEwgdmFyaWFibGUsIHNhdmluZyB0aGUgb3JpZ2luYWwgTCB0byByZXN0b3JlIGxhdGVyIGlmIG5lZWRlZFxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRleHBvc2UoKTtcclxufVxyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuTC5VdGlsID0ge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcblx0Ly8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChkZXN0KSB7XHJcblx0XHR2YXIgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG5cdFx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBkZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG5cdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG5cdGNyZWF0ZTogT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdFx0ZnVuY3Rpb24gRigpIHt9XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0XHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRcdHJldHVybiBuZXcgRigpO1xyXG5cdFx0fTtcclxuXHR9KSgpLFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG5cdC8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcblx0YmluZDogZnVuY3Rpb24gKGZuLCBvYmopIHtcclxuXHRcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0XHRpZiAoZm4uYmluZCkge1xyXG5cdFx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ2luZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG5cdHN0YW1wOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0XHRvYmouX2xlYWZsZXRfaWQgPSBvYmouX2xlYWZsZXRfaWQgfHwgKytMLlV0aWwubGFzdElkO1xyXG5cdFx0cmV0dXJuIG9iai5fbGVhZmxldF9pZDtcclxuXHRcdC8qZXNsaW50LWVuYWJsZSAqL1xyXG5cdH0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG5cdC8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcblx0bGFzdElkOiAwLFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcblx0Ly8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcblx0Ly8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuXHQvLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcblx0Ly8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG5cdC8vIEhhcyBhbiBgTC5iaW5kYCBzaG9ydGN1dC5cclxuXHR0aHJvdHRsZTogZnVuY3Rpb24gKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcblx0XHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuXHRcdFx0bG9jayA9IGZhbHNlO1xyXG5cdFx0XHRpZiAoYXJncykge1xyXG5cdFx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0XHRhcmdzID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAobG9jaykge1xyXG5cdFx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuXHRcdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRcdGxvY2sgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiB3cmFwcGVyRm47XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG5cdC8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuXHQvLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuXHR3cmFwTnVtOiBmdW5jdGlvbiAoeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuXHRcdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHRcdCAgICBtaW4gPSByYW5nZVswXSxcclxuXHRcdCAgICBkID0gbWF4IC0gbWluO1xyXG5cdFx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcblx0ZmFsc2VGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIGRpZ2l0cz86IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHRvIGBkaWdpdHNgIGRlY2ltYWxzLCBvciB0byA1IGRlY2ltYWxzIGJ5IGRlZmF1bHQuXHJcblx0Zm9ybWF0TnVtOiBmdW5jdGlvbiAobnVtLCBkaWdpdHMpIHtcclxuXHRcdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgZGlnaXRzIHx8IDUpO1xyXG5cdFx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG5cdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG5cdHRyaW06IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRcdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuXHQvLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcblx0c3BsaXRXb3JkczogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIEwuVXRpbC50cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcblx0Ly8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5cdHNldE9wdGlvbnM6IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcclxuXHRcdGlmICghb2JqLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpIHtcclxuXHRcdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IEwuVXRpbC5jcmVhdGUob2JqLm9wdGlvbnMpIDoge307XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuXHQvLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcblx0Ly8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG5cdC8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcblx0Ly8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG5cdGdldFBhcmFtU3RyaW5nOiBmdW5jdGlvbiAob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcblx0XHR2YXIgcGFyYW1zID0gW107XHJcblx0XHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG5cdC8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcblx0Ly8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcblx0Ly8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcblx0dGVtcGxhdGU6IGZ1bmN0aW9uIChzdHIsIGRhdGEpIHtcclxuXHRcdHJldHVybiBzdHIucmVwbGFjZShMLlV0aWwudGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcblx0XHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dGVtcGxhdGVSZTogL1xceyAqKFtcXHdfXFwtXSspICpcXH0vZyxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG5cdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcblx0Ly8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LnByb3RvdHlwZS5pbmRleE9mXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxyXG5cdGluZGV4T2Y6IGZ1bmN0aW9uIChhcnJheSwgZWwpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuXHQvLyBEYXRhIFVSSSBzdHJpbmcgY29udGFpbmluZyBhIGJhc2U2NC1lbmNvZGVkIGVtcHR5IEdJRiBpbWFnZS5cclxuXHQvLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuXHQvLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcblx0ZW1wdHlJbWFnZVVybDogJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nXHJcbn07XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cdC8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5cdGZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRcdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG5cdH1cclxuXHJcblx0dmFyIGxhc3RUaW1lID0gMDtcclxuXHJcblx0Ly8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5cdGZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdFx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHRcdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdFx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyLFxyXG5cdCAgICBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdCAgICAgICAgICAgICAgIGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuXHQvLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcblx0Ly8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuXHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcblx0Ly8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG5cdC8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5cdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lID0gZnVuY3Rpb24gKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRcdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIEwuYmluZChmbiwgY29udGV4dCkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG5cdC8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5cdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGlmIChpZCkge1xyXG5cdFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBzaG9ydGN1dHMgZm9yIG1vc3QgdXNlZCB1dGlsaXR5IGZ1bmN0aW9uc1xyXG5MLmV4dGVuZCA9IEwuVXRpbC5leHRlbmQ7XHJcbkwuYmluZCA9IEwuVXRpbC5iaW5kO1xyXG5MLnN0YW1wID0gTC5VdGlsLnN0YW1wO1xyXG5MLnNldE9wdGlvbnMgPSBMLlV0aWwuc2V0T3B0aW9ucztcclxuXG5cblxuXHJcbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbkwuQ2xhc3MgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbkwuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcblx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcblx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGNhbGwgdGhlIGNvbnN0cnVjdG9yXHJcblx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcblx0dmFyIHByb3RvID0gTC5VdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdEwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0TC5VdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm90by5vcHRpb25zKSB7XHJcblx0XHRwcm9wcy5vcHRpb25zID0gTC5VdGlsLmV4dGVuZChMLlV0aWwuY3JlYXRlKHByb3RvLm9wdGlvbnMpLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdEwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkwuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdEwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbkwuQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRMLmV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbi8vIEFkZHMgYSBbY29uc3RydWN0b3IgaG9va10oI2NsYXNzLWNvbnN0cnVjdG9yLWhvb2tzKSB0byB0aGUgY2xhc3MuXHJcbkwuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIEV2ZW50ZWRcclxuICogQGFrYSBMLkV2ZW50ZWRcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAqIH0gKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVhbHMgd2l0aCBldmVudCBsaXN0ZW5lcnMgYnkgcmVmZXJlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgYSBsaXN0ZW5lciBhbmQgdGhlbiByZW1vdmUgaXQsIGRlZmluZSBpdCBhcyBhIGZ1bmN0aW9uOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiBvbkNsaWNrKGUpIHsgLi4uIH1cclxuICpcclxuICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBtYXAub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuTC5FdmVudGVkID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgb2YgdGhlIG9iamVjdC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyIChvYmplY3QgdGhlIHRoaXMga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb24oZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0ICovXHJcblx0b246IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcblx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cclxuXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIXR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0dHlwZUxpc3RlbmVycyA9IHtcclxuXHRcdFx0XHRsaXN0ZW5lcnM6IHt9LFxyXG5cdFx0XHRcdGNvdW50OiAwXHJcblx0XHRcdH07XHJcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNvbnRleHRJZCA9IGNvbnRleHQgJiYgY29udGV4dCAhPT0gdGhpcyAmJiBMLnN0YW1wKGNvbnRleHQpLFxyXG5cdFx0ICAgIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fTtcclxuXHJcblx0XHRpZiAoIWNvbnRleHRJZCkge1xyXG5cdFx0XHRjb250ZXh0SWQgPSAnbm9fY29udGV4dCc7XHJcblx0XHRcdG5ld0xpc3RlbmVyLmN0eCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmbiBhcnJheSBmb3IgY29udGV4dFxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF07XHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSBbXTtcclxuXHRcdFx0dHlwZUxpc3RlbmVycy5saXN0ZW5lcnNbY29udGV4dElkXSA9IGxpc3RlbmVycztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdFx0dHlwZUxpc3RlbmVycy5jb3VudCsrO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMsXHJcblx0XHQgICAgY29udGV4dElkLFxyXG5cdFx0ICAgIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoIWZuKSB7XHJcblx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcCBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0dHlwZUxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0aWYgKHR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHRmb3IgKGNvbnRleHRJZCBpbiB0eXBlTGlzdGVuZXJzLmxpc3RlbmVycykge1xyXG5cdFx0XHRcdFx0bGlzdGVuZXJzID0gdHlwZUxpc3RlbmVycy5saXN0ZW5lcnNbY29udGV4dElkXTtcclxuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIXR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHRJZCA9IGNvbnRleHQgJiYgY29udGV4dCAhPT0gdGhpcyAmJiBMLnN0YW1wKGNvbnRleHQpO1xyXG5cdFx0aWYgKCFjb250ZXh0SWQpIHtcclxuXHRcdFx0Y29udGV4dElkID0gJ25vX2NvbnRleHQnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF07XHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdFx0dHlwZUxpc3RlbmVycy5jb3VudC0tO1xyXG5cclxuXHRcdFx0XHRcdGlmIChsZW4gPiAxKSB7XHJcblx0XHRcdFx0XHRcdGlmICghdGhpcy5faXNGaXJpbmcpIHtcclxuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcblx0XHRcdFx0XHRcdFx0dHlwZUxpc3RlbmVycy5saXN0ZW5lcnNbY29udGV4dElkXSA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG5cdFx0XHRcdFx0XHRcdHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzW2NvbnRleHRJZF0uc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgdHlwZUxpc3RlbmVycy5saXN0ZW5lcnNbY29udGV4dElkXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRkZWxldGUgdHlwZUxpc3RlbmVycy5saXN0ZW5lcnNbY29udGV4dElkXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IG1pZ2h0IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gTC5VdGlsLmV4dGVuZCh7fSwgZGF0YSwge3R5cGU6IHR5cGUsIHRhcmdldDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRpZiAodHlwZUxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2lzRmlyaW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Ly8gZWFjaCBjb250ZXh0XHJcblx0XHRcdFx0Zm9yICh2YXIgY29udGV4dElkIGluIHR5cGVMaXN0ZW5lcnMubGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0XHR2YXIgbGlzdGVuZXJzID0gdHlwZUxpc3RlbmVycy5saXN0ZW5lcnNbY29udGV4dElkXTtcclxuXHJcblx0XHRcdFx0XHQvLyBlYWNoIGZuIGluIGNvbnRleHRcclxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9pc0ZpcmluZyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAodHlwZUxpc3RlbmVycyAmJiB0eXBlTGlzdGVuZXJzLmNvdW50KSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gTC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdC8vIGFkZCBhIGxpc3RlbmVyIHRoYXQncyBleGVjdXRlZCBvbmNlIGFuZCByZW1vdmVkIGFmdGVyIHRoYXRcclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLm9uKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAub24odHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tMLnN0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW0wuc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgTC5leHRlbmQoe2xheWVyOiBlLnRhcmdldH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIHByb3RvID0gTC5FdmVudGVkLnByb3RvdHlwZTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxucHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbnByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gcHJvdG8ub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxucHJvdG8uYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBwcm90by5vbmNlO1xyXG5cclxuLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbnByb3RvLmZpcmVFdmVudCA9IHByb3RvLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5wcm90by5oYXNFdmVudExpc3RlbmVycyA9IHByb3RvLmxpc3RlbnM7XHJcblxyXG5MLk1peGluID0ge0V2ZW50czogcHJvdG99O1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICogQGFrYSBMLkJyb3dzZXJcclxuICpcclxuICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogaWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG4gKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXHJcblx0ICAgIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuXHJcblx0ICAgIGllID0gJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdyxcclxuXHJcblx0ICAgIHdlYmtpdCAgICA9IHVhLmluZGV4T2YoJ3dlYmtpdCcpICE9PSAtMSxcclxuXHQgICAgcGhhbnRvbWpzID0gdWEuaW5kZXhPZigncGhhbnRvbScpICE9PSAtMSxcclxuXHQgICAgYW5kcm9pZDIzID0gdWEuc2VhcmNoKCdhbmRyb2lkIFsyM10nKSAhPT0gLTEsXHJcblx0ICAgIGNocm9tZSAgICA9IHVhLmluZGV4T2YoJ2Nocm9tZScpICE9PSAtMSxcclxuXHQgICAgZ2Vja28gICAgID0gdWEuaW5kZXhPZignZ2Vja28nKSAhPT0gLTEgICYmICF3ZWJraXQgJiYgIXdpbmRvdy5vcGVyYSAmJiAhaWUsXHJcblxyXG5cdCAgICB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDAsXHJcblxyXG5cdCAgICBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVhLmluZGV4T2YoJ21vYmlsZScpICE9PSAtMSxcclxuXHQgICAgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50LFxyXG5cdCAgICBwb2ludGVyID0gd2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIsXHJcblxyXG5cdCAgICBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBkb2Muc3R5bGUpLFxyXG5cdCAgICB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzLFxyXG5cdCAgICBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBkb2Muc3R5bGUsXHJcblx0ICAgIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIGRvYy5zdHlsZTtcclxuXHJcblxyXG5cdHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdFx0KHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcblx0TC5Ccm93c2VyID0ge1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuXHRcdGllOiBpZSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcblx0XHRpZWx0OTogaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcblx0XHRlZGdlOiAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxuXHRcdHdlYmtpdDogd2Via2l0LFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcblx0XHRnZWNrbzogZ2Vja28sXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG5cdFx0YW5kcm9pZDogdWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxuXHRcdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG5cdFx0Y2hyb21lOiBjaHJvbWUsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcblx0XHRzYWZhcmk6ICFjaHJvbWUgJiYgdWEuaW5kZXhPZignc2FmYXJpJykgIT09IC0xLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgd2luOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG5cdFx0d2luOiB3aW4sXHJcblxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBpZTNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0aWUzZDogaWUzZCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdGdlY2tvM2Q6IGdlY2tvM2QsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcblx0XHRvcGVyYTEyOiBvcGVyYTEyLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdGFueTNkOiAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbWpzLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuXHRcdG1vYmlsZTogbW9iaWxlLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQ6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGVXZWJraXQ6IG1vYmlsZSAmJiB3ZWJraXQsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRtb2JpbGVXZWJraXQzZDogbW9iaWxlICYmIHdlYmtpdDNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGVPcGVyYTogbW9iaWxlICYmIHdpbmRvdy5vcGVyYSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlR2Vja286IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGVHZWNrbzogbW9iaWxlICYmIGdlY2tvLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgdG91Y2g6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcblx0XHR0b3VjaDogISF0b3VjaCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxuXHRcdG1zUG9pbnRlcjogISFtc1BvaW50ZXIsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3BvaW50ZXIgZXZlbnRzXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQ0JTI4dj12cy44NSUyOS5hc3B4KS5cclxuXHRcdHBvaW50ZXI6ICEhcG9pbnRlcixcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHJldGluYTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbi5cclxuXHRcdHJldGluYTogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxXHJcblx0fTtcclxuXHJcbn0oKSk7XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBQb2ludFxyXG4gKiBAYWthIEwuUG9pbnRcclxuICpcclxuICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgcm91bmQpIHtcclxuXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59O1xyXG5cclxuTC5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZChMLnBvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KEwucG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcblx0fSxcclxuXHJcblx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbkwucG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgcm91bmQpIHtcclxuXHRpZiAoeCBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoTC5VdGlsLmlzQXJyYXkoeCkpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHksIHJvdW5kKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIEJvdW5kc1xyXG4gKiBAYWthIEwuQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuQm91bmRzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcblx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG5cdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTC5Qb2ludCkge1xyXG5cdFx0XHRvYmogPSBMLnBvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmJvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSBMLmJvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IEwuYm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHModG9wTGVmdDogUG9pbnQsIGJvdHRvbVJpZ2h0OiBQb2ludClcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0d28gY29vcmRpbmF0ZXMgKHVzdWFsbHkgdG9wLWxlZnQgYW5kIGJvdHRvbS1yaWdodCBjb3JuZXJzKS5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgcG9pbnRzIGl0IGNvbnRhaW5zXHJcbkwuYm91bmRzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEwuQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkJvdW5kcyhhLCBiKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXHJcbiAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjogYSBzZXQgb2YgY29lZmZpY2llbnRzIGBhYCwgYGJgLCBgY2AsIGBkYFxyXG4gKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuTC5UcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn07XHJcblxyXG5MLlRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIHRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcblx0Ly8gT25seSBhY2NlcHRzIHJlYWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG5cdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIHJlYWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcbkwuRG9tVXRpbCA9IHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuXHQvLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG5cdGdldDogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG5cdC8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuXHRnZXRTdHlsZTogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xyXG5cclxuXHRcdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRcdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcblx0XHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcblx0Y3JlYXRlOiBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHJcblx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuXHRcdGlmIChjb250YWluZXIpIHtcclxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdFx0aWYgKHBhcmVudCkge1xyXG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuXHQvLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkcmVuIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5cdHRvRnJvbnQ6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0ZWwucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGRyZW4gb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiYWNrIGZyb20gdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5cdHRvQmFjazogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IEwuRG9tVXRpbC5nZXRDbGFzcyhlbCk7XHJcblx0XHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuXHQvLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuXHRhZGRDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dmFyIGNsYXNzZXMgPSBMLlV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKCFMLkRvbVV0aWwuaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcblx0Ly8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRDbGFzcyhlbCwgTC5VdGlsLnRyaW0oKCcgJyArIEwuRG9tVXRpbC5nZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuXHQvLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcblx0c2V0Q2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcblx0Z2V0Q2xhc3M6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuXHQvLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuXHQvLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xyXG5cclxuXHRcdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLl9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfc2V0T3BhY2l0eUlFOiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XHJcblx0XHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0XHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdFx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0XHR0cnkge1xyXG5cdFx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0XHRpZiAoZmlsdGVyKSB7XHJcblx0XHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcblx0Ly8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG5cdC8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcblx0Ly8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcblx0dGVzdFByb3A6IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuXHQvLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG5cdC8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuXHQvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuXHRzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdFx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgTC5Qb2ludCgwLCAwKTtcclxuXHJcblx0XHRlbC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9XHJcblx0XHRcdChMLkJyb3dzZXIuaWUzZCA/XHJcblx0XHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuXHQvLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG5cdC8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsLCBwb2ludCkgeyAvLyAoSFRNTEVsZW1lbnQsIFBvaW50WywgQm9vbGVhbl0pXHJcblxyXG5cdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0XHQvKmVzbGludC1lbmFibGUgKi9cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHRcdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdFx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgTC5Qb2ludCgwLCAwKTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHQvLyBwcmVmaXggc3R5bGUgcHJvcGVydHkgbmFtZXNcclxuXHJcblx0Ly8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcblx0Ly8gVmVuZG9yLXByZWZpeGVkIGZyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcblx0TC5Eb21VdGlsLlRSQU5TRk9STSA9IEwuRG9tVXRpbC50ZXN0UHJvcChcclxuXHRcdFx0Wyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuXHJcblx0Ly8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG5cdC8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuXHQvLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcblx0Ly8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lLlxyXG5cdHZhciB0cmFuc2l0aW9uID0gTC5Eb21VdGlsLlRSQU5TSVRJT04gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuXHRMLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQgPVxyXG5cdFx0XHR0cmFuc2l0aW9uID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgdHJhbnNpdGlvbiA9PT0gJ09UcmFuc2l0aW9uJyA/IHRyYW5zaXRpb24gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuXHQvLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG5cdC8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcblx0Ly8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG5cdC8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcblx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5cdGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0XHR0aGlzLl91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IHRoaXMuX3VzZXJTZWxlY3Q7XHJcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3VzZXJTZWxlY3Q7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcblx0Ly8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG5cdC8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5cdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuXHQvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuXHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuXHQvLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG5cdC8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcblx0Ly8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG5cdC8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuXHRMLkRvbVV0aWwucHJldmVudE91dGxpbmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG5cdFx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcblx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcblx0XHRMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUoKTtcclxuXHRcdHRoaXMuX291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuXHRcdGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICdub25lJztcclxuXHRcdEwuRG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIEwuRG9tVXRpbC5yZXN0b3JlT3V0bGluZSwgdGhpcyk7XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuXHQvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwucHJldmVudE91dGxpbmVgXSgpLlxyXG5cdEwuRG9tVXRpbC5yZXN0b3JlT3V0bGluZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fb3V0bGluZUVsZW1lbnQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLl9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gdGhpcy5fb3V0bGluZVN0eWxlO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX291dGxpbmVFbGVtZW50O1xyXG5cdFx0ZGVsZXRlIHRoaXMuX291dGxpbmVTdHlsZTtcclxuXHRcdEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ2tleWRvd24nLCBMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUsIHRoaXMpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxuXG5cbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5MYXRMbmcgPSBmdW5jdGlvbiAobGF0LCBsbmcsIGFsdCkge1xyXG5cdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG5cdH1cclxuXHJcblx0Ly8gQHByb3BlcnR5IGxhdDogTnVtYmVyXHJcblx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubGF0ID0gK2xhdDtcclxuXHJcblx0Ly8gQHByb3BlcnR5IGxuZzogTnVtYmVyXHJcblx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxuZyA9ICtsbmc7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBhbHQ6IE51bWJlclxyXG5cdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcblx0aWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLmFsdCA9ICthbHQ7XHJcblx0fVxyXG59O1xyXG5cclxuTC5MYXRMbmcucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYExhdExuZ2AgcG9pbnQgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMubG5nLCBwcmVjaXNpb24pICsgJyknO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgKGluIG1ldGVycykgdG8gdGhlIGdpdmVuIGBMYXRMbmdgIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFtIYXZlcnNpbmUgZm9ybXVsYV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYSkuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7XHJcblx0XHRyZXR1cm4gTC5DUlMuRWFydGguZGlzdGFuY2UodGhpcywgTC5sYXRMbmcob3RoZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXAoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuQ1JTLkVhcnRoLndyYXBMYXRMbmcodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JvdW5kcyhzaXplSW5NZXRlcnM6IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGluIHdoaWNoIGVhY2ggYm91bmRhcnkgaXMgYHNpemVJbk1ldGVyc2AgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiBMLmxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZywgdGhpcy5hbHQpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcobGF0aXR1ZGU6IE51bWJlciwgbG9uZ2l0dWRlOiBOdW1iZXIsIGFsdGl0dWRlPzogTnVtYmVyKTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogT2JqZWN0KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbkwubGF0TG5nID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKEwuVXRpbC5pc0FycmF5KGEpICYmIHR5cGVvZiBhWzBdICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcblx0fVxyXG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEsIGIsIGMpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgc291dGhXZXN0ID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICogbm9ydGhFYXN0ID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoc291dGhXZXN0LCBub3J0aEVhc3QpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmdCb3VuZHMgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5maXRCb3VuZHMoW1xyXG4gKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAqIF0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkxhdExuZ0JvdW5kcyA9IGZ1bmN0aW9uIChzb3V0aFdlc3QsIG5vcnRoRWFzdCkgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuXHRpZiAoIXNvdXRoV2VzdCkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIGxhdGxuZ3MgPSBub3J0aEVhc3QgPyBbc291dGhXZXN0LCBub3J0aEVhc3RdIDogc291dGhXZXN0O1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRzdzIgPSBvYmo7XHJcblx0XHRcdG5lMiA9IG9iajtcclxuXHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG5cdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcblx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQoTC5sYXRMbmcob2JqKSB8fCBMLmxhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IEwuTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTC5MYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG5cdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG5cdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG5cdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJpZ2dlciBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcGVyY2VudGFnZSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBuZXcgTC5MYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMLkxhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XHJcblx0XHRcdG9iaiA9IEwubGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcblx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKHNvdXRoV2VzdDogTGF0TG5nLCBub3J0aEVhc3Q6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyBzb3V0aC13ZXN0IGFuZCBub3J0aC1lYXN0IGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBkZWZpbmVkIGJ5IHRoZSBnZW9ncmFwaGljYWwgcG9pbnRzIGl0IGNvbnRhaW5zLiBWZXJ5IHVzZWZ1bCBmb3Igem9vbWluZyB0aGUgbWFwIHRvIGZpdCBhIHBhcnRpY3VsYXIgc2V0IG9mIGxvY2F0aW9ucyB3aXRoIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5MLmxhdExuZ0JvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoYSwgYik7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAc2VjdGlvblxyXG4gKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gKlxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAqXHJcbiAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gKiBgRVBTRzozMzk1YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbiA9IHt9O1xyXG5cclxuTC5Qcm9qZWN0aW9uLkxvbkxhdCA9IHtcclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBMLmJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IDYzNzgxMzcsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoXHJcblx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuXHRcdFx0cG9pbnQueCAqIGQgLyB0aGlzLlIpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkID0gNjM3ODEzNyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gTC5ib3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgQ1JTXHJcbiAqIEBha2EgTC5DUlNcclxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db29yZGluYXRlX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gKi9cclxuXHJcbkwuQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5ndG8gYSBzY2FsZVxyXG5cdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xyXG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlIC8gMjU2KSAvIE1hdGguTE4yO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UHJvamVjdGVkQm91bmRzKHpvb20pOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gTC5ib3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcxOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSBjb29yZGluYXRlIGF4aXNcclxuXHQvLyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IEwuVXRpbC53cmFwTnVtKGxhdGxuZy5sbmcsIHRoaXMud3JhcExuZywgdHJ1ZSkgOiBsYXRsbmcubG5nLFxyXG5cdFx0ICAgIGxhdCA9IHRoaXMud3JhcExhdCA/IEwuVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIEwubGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbkwuQ1JTLlNpbXBsZSA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcblx0fSxcblxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG5cdH0sXG5cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcblx0XHQgICAgZHkgPSBsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0O1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdH0sXG5cblx0aW5maW5pdGU6IHRydWVcbn0pO1xuXG5cblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLkVhcnRoXG4gKlxuICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIG1ldGVycy5cbiAqL1xuXG5MLkNSUy5FYXJ0aCA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xuXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHQvLyBzZWUgaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIGEgPSBNYXRoLnNpbihsYXQxKSAqIE1hdGguc2luKGxhdDIpICtcblx0XHQgICAgICAgIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcygobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuUiAqIE1hdGguYWNvcyhNYXRoLm1pbihhLCAxKSk7XG5cdH1cbn0pO1xuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gKlxyXG4gKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHMzg1NyA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiBuZXcgTC5UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbkwuQ1JTLkVQU0c5MDA5MTMgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAqXHJcbiAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0c0MzI2ID0gTC5leHRlbmQoe30sIEwuQ1JTLkVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLkxvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuTC5NYXAgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xyXG5cdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG5cdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBMLkNSUy5FUFNHMzg1NyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuXHRcdGNlbnRlcjogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcblx0XHR6b29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBPdmVycmlkZXMgYW55IGBtaW5ab29tYCBvcHRpb24gc2V0IG9uIG1hcCBsYXllcnMuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBPdmVycmlkZXMgYW55IGBtYXhab29tYCBvcHRpb24gc2V0IG9uIG1hcCBsYXllcnMuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayB3aGVuIGhlIHRyaWVzIHRvIHBhblxyXG5cdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcblx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXHJcblx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuXHRcdC8vIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZHJhd2luZyB2ZWN0b3IgbGF5ZXJzIG9uIHRoZSBtYXAuIGBMLlNWR2BcclxuXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG5cdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBMLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhMLmxhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0Ly8gcmVwbGFjZWQgYnkgYW5pbWF0aW9uLXBvd2VyZWQgaW1wbGVtZW50YXRpb24gaW4gTWFwLlBhbkFuaW1hdGlvbi5qc1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbTtcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhMLmxhdExuZyhjZW50ZXIpLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbSh6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEwuQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChMLkJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuXHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXHJcblx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIEwuUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IEwucG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSBMLnBvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM6IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcblx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0V29ybGQob3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG5cdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhblRvKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG5cdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHsgLy8gKFBvaW50KVxyXG5cdFx0Ly8gcmVwbGFjZWQgd2l0aCBhbmltYXRlZCBwYW5CeSBpbiBNYXAuUGFuQW5pbWF0aW9uLmpzXHJcblx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cclxuXHRcdHRoaXMuX3Jhd1BhbkJ5KEwucG9pbnQob2Zmc2V0KSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcblx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG5cdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxyXG5cdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgTC5sYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG5cdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL1BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG5cdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG5cdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcblx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLmV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG5cdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG5cdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblx0Ly8gQG1ldGhvZCBzdG9wKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIFRPRE8gaGFuZGxlci5hZGRUb1xyXG5cdC8vIFRPRE8gQXBwcm9waWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0O1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG5cdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkcmVuIG9mIGBjb250YWluZXJgLCBvclxyXG5cdC8vIGFzIGEgY2hpbGRyZW4gb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcblx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG5cdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblx0XHRwYWRkaW5nID0gTC5wb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuXHRcdCAgICBib3VuZHNTaXplID0gdGhpcy5wcm9qZWN0KHNlLCB6b29tKS5zdWJ0cmFjdCh0aGlzLnByb2plY3QobncsIHpvb20pKSxcclxuXHRcdCAgICBzbmFwID0gTC5Ccm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHJcblx0XHR2YXIgc2NhbGUgPSBNYXRoLm1pbihzaXplLnggLyBib3VuZHNTaXplLngsIHNpemUueSAvIGJvdW5kc1NpemUueSk7XHJcblx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBMLlBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgTC5Cb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG5cdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcblx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcblx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcblx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG5cdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG5cdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG5cdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KEwubGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKEwucG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QoTC5sYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKEwubGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKEwubGF0TG5nKGxhdGxuZzEpLCBMLmxhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoTC5wb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQoTC5sYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuXHRcdGNvbnRhaW5lci5fbGVhZmxldCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgTC5Ccm93c2VyLmFueTNkO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBMLlBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvciBvdmVybGF5cyAoYFBhdGhgcyksIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgbWFya2VyUGFuZTogSFRNTEVsZW1lbnQgPSA2MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHRvb2x0aXBQYW5lOiBIVE1MRWxlbWVudCA9IDY1MFxyXG5cdFx0Ly8gUGFuZSBmb3IgdG9vbHRpcC5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHBvcHVwUGFuZTogSFRNTEVsZW1lbnQgPSA3MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBMLlBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhKSB7XHJcblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHJcblx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcblx0XHR0aGlzLl9waXhlbE9yaWdpbiA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBldGVhZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsIGluY2x1ZGluZyB6b29tXHJcblx0XHQvLyBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZXRlYWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsIGluY2x1ZGluZyBwYW4gYW5kXHJcblx0XHQvLyBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBoYXMgY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0b3BwZWRcclxuXHRcdC8vIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdGlmICghTC5Eb21FdmVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcblx0XHR0aGlzLl90YXJnZXRzW0wuc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJztcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRMLkRvbUV2ZW50W29uT2ZmXSh0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50W29uT2ZmXSh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHR0aGlzW29uT2ZmXSgnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcblx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tMLnN0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmICFlLl9zaW11bGF0ZWQgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIUwuRG9tRXZlbnQuX2lzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgTC5Eb21FdmVudC5faXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlID09PSAna2V5cHJlc3MnICYmIGUua2V5Q29kZSA9PT0gMTMgPyAnY2xpY2snIDogZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJykge1xyXG5cdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuXHRcdFx0TC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG5cdH0sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCB0YXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gTC5VdGlsLmV4dGVuZCh7fSwgZSk7XHJcblx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG5cdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuXHRcdHRhcmdldHMgPSAodGFyZ2V0cyB8fCBbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycpIHtcclxuXHRcdFx0dmFyIGlzTWFya2VyID0gdGFyZ2V0IGluc3RhbmNlb2YgTC5NYXJrZXI7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0XHR0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XHJcblx0XHRcdGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XHJcblx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLm5vbkJ1YmJsaW5nRXZlbnRzICYmIEwuVXRpbC5pbmRleE9mKHRhcmdldHNbaV0ub3B0aW9ucy5ub25CdWJibGluZ0V2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgTC5Qb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBMLkJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAob2Zmc2V0LnJvdW5kKCkuZXF1YWxzKFswLCAwXSkpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBMLkJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gTC5ib3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc25hcCA9IEwuQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gdGhlIERPTSBJRCBvZiBhIGA8ZGl2PmAgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbi8vXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuTC5tYXAgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTWFwKGlkLCBvcHRpb25zKTtcclxufTtcclxuXG5cblxuXG4vKlxuICogQGNsYXNzIExheWVyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogQGFrYSBMLkxheWVyXG4gKiBAYWthIElMYXllclxuICpcbiAqIEEgc2V0IG9mIG1ldGhvZHMgZnJvbSB0aGUgTGF5ZXIgYmFzZSBjbGFzcyB0aGF0IGFsbCBMZWFmbGV0IGxheWVycyB1c2UuXG4gKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5NYXJrZXIobGF0bG5nKS5hZGRUbyhtYXApO1xuICogbGF5ZXIuYWRkVG8obWFwKTtcbiAqIGxheWVyLnJlbW92ZSgpO1xuICogYGBgXG4gKlxuICogQGV2ZW50IGFkZDogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyBhZGRlZCB0byBhIG1hcFxuICpcbiAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgbWFwXG4gKi9cblxuXG5MLkxheWVyID0gTC5FdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblx0XHRub25CdWJibGluZ0V2ZW50czogW10gIC8vIEFycmF5IG9mIGV2ZW50cyB0aGF0IHNob3VsZCBub3QgYmUgYnViYmxlZCB0byBET00gcGFyZW50cyAobGlrZSB0aGUgbWFwKVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xuXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW0wuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbTC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdGlmICh0aGlzLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuX21hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdHRoaXMuX21hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuYWRkQXR0cmlidXRpb24odGhpcy5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuXHR9XG59KTtcblxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAqIEB1bmluaGVyaXRhYmxlXG4gKlxuICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICpcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICpcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gKlxuICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gKlxuICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFwXG4gKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAqXG4gKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICpcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAqL1xuTC5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cblx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG5cdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gTC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24obGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gISFsYXllciAmJiAoTC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcblx0fSxcblxuXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG5cdCAqIGBgYFxuXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcblx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoTC5VdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW0wuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gVGFrZXMgaW50byBhY2NvdW50IHRoYXQgRWFydGggaXMgYSBnZW9pZCwgbm90IGEgcGVyZmVjdCBzcGhlcmUuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLk1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogTC5ib3VuZHMoWy0yMDAzNzUwOC4zNDI3OSwgLTE1NDk2NTcwLjczOTcyXSwgWzIwMDM3NTA4LjM0Mjc5LCAxODc2NDY1Ni4yMzEzOF0pLFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2coTWF0aC5tYXgodHMsIDFFLTEwKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gKlxyXG4gKiBSYXJlbHkgdXNlZCBieSBzb21lIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIFVzZXMgRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0czMzk1ID0gTC5leHRlbmQoe30sIEwuQ1JTLkVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlRyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cblxuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG5MLkdyaWRMYXllciA9IEwuTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBJZiBgZmFsc2VgLCBuZXcgdGlsZXMgYXJlIGxvYWRlZCBkdXJpbmcgcGFubmluZywgb3RoZXJ3aXNlIG9ubHkgYWZ0ZXIgaXQgKGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UpLiBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIG90aGVyd2lzZSBgZmFsc2VgLlxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBMLkJyb3dzZXIubW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSwgZS5nLiBcIsKpIE1hcGJveFwiLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdHpJbmRleDogMSxcblxuXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcblx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0Ym91bmRzOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCB0aGF0IHRpbGVzIHdpbGwgYmUgbG9hZGVkIGF0LiBCeSBkZWZhdWx0IHRoZSBlbnRpcmUgbWFwLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdGhhdCB0aWxlcyB3aWxsIGJlIGxvYWRlZCBhdC5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cblx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fcmVzZXRWaWV3KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gbnVsbDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdEwuRG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0TC5Eb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IFN0cmluZ1xuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gTC5VdGlsLnRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIEwuUG9pbnQgPyBzIDogbmV3IEwuUG9pbnQocywgcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcblx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cblx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cblx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcblx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG5cdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHsgd2lsbFBydW5lID0gdHJ1ZTsgfVxuXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuXHRcdGlmIChuZXh0RnJhbWUpIHtcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdEwuVXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cdH0sXG5cblx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcblx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcblx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcblx0XHQgICAgejIgPSB6IC0gMSxcblx0XHQgICAgY29vcmRzMiA9IG5ldyBMLlBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgTC5Qb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcblx0XHR2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBMLkJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuXHR9LFxuXG5cdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cblx0XHR2YXIgem9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEwuQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhMLnBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgTC5Qb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcblx0XHRcdFx0aWYgKHRpbGUpIHtcblx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG5cdFx0fSk7XG5cblx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHQvLyBpZiBpdHMgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIEwubGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cblx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcblxuXHRcdCAgICBudyA9IG1hcC53cmFwTGF0TG5nKG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopKSxcblx0XHQgICAgc2UgPSBtYXAud3JhcExhdExuZyhtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KSk7XG5cblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKG53LCBzZSk7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG5cdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuXHRcdCAgICBjb29yZHMgPSBuZXcgTC5Qb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRpbGUuZWwpO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gTC5VdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IEwuVXRpbC5mYWxzZUZuO1xuXG5cdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKEwuQnJvd3Nlci5hbmRyb2lkICYmICFMLkJyb3dzZXIuYW5kcm9pZDIzKSB7XG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBMLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcblx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHMsXG5cdFx0XHRjdXJyZW50OiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHR9KTtcblx0fSxcblxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChMLkJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cblx0XHRcdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKTtcblx0fSxcblxuXHRfd3JhcENvb3JkczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBuZXdDb29yZHMgPSBuZXcgTC5Qb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gTC5VdGlsLndyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuXHRcdFx0dGhpcy5fd3JhcFkgPyBMLlV0aWwud3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG5cdFx0cmV0dXJuIG5ld0Nvb3Jkcztcblx0fSxcblxuXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRyZXR1cm4gbmV3IEwuQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5MLmdyaWRMYXllciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5HcmlkTGF5ZXIob3B0aW9ucyk7XG59O1xuXG5cblxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnRpbGUub3NtLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJ30pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICogQGV4YW1wbGVcclxuICpcclxuICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gKlxyXG4gKiBgYGBcclxuICogJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBAMnggdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICpcclxuICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuTC5UaWxlTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIuXHJcblx0XHRtaW5ab29tOiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gMThcclxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IG51bGxcclxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcclxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXHJcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXHJcblx0XHRtYXhOYXRpdmVab29tOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcclxuXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvclRpbGVVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JUaWxlVXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG5cdFx0dG1zOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21SZXZlcnNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGRldGVjdFJldGluYTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiB0cnVlLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gJycuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9waWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG5cdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRpbGUsICdsb2FkJywgTC5iaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHRcdEwuRG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgTC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbikge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IEwuQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuXHRcdFx0eDogY29vcmRzLngsXHJcblx0XHRcdHk6IGNvb3Jkcy55LFxyXG5cdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuXHRcdH07XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpIHtcclxuXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG5cdFx0XHRcdGRhdGFbJ3knXSA9IGludmVydGVkWTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBMLmV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IEwuR3JpZExheWVyLnByb3RvdHlwZS5nZXRUaWxlU2l6ZS5jYWxsKHRoaXMpLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl90aWxlWm9vbSArIHRoaXMub3B0aW9ucy56b29tT2Zmc2V0LFxyXG5cdFx0ICAgIHpvb21OID0gdGhpcy5vcHRpb25zLm1heE5hdGl2ZVpvb207XHJcblxyXG5cdFx0Ly8gaW5jcmVhc2UgdGlsZSBzaXplIHdoZW4gb3ZlcnNjYWxpbmdcclxuXHRcdHJldHVybiB6b29tTiAhPT0gbnVsbCAmJiB6b29tID4gem9vbU4gP1xyXG5cdFx0XHRcdHRpbGVTaXplLmRpdmlkZUJ5KG1hcC5nZXRab29tU2NhbGUoem9vbU4sIHpvb20pKS5yb3VuZCgpIDpcclxuXHRcdFx0XHR0aWxlU2l6ZTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICB6b29tID0gdGhpcy5fdGlsZVpvb207XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG9wdGlvbnMubWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0em9vbSArPSBvcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbSAhPT0gbnVsbCA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4TmF0aXZlWm9vbSkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCB0aWxlO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gTC5VdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBMLlV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHRcdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5MLnRpbGVMYXllciA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllci5XTVNcclxuICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG5leHJhZCA9IEwudGlsZUxheWVyLndtcyhcImh0dHA6Ly9tZXNvbmV0LmFncm9uLmlhc3RhdGUuZWR1L2NnaS1iaW4vd21zL25leHJhZC9uMHIuY2dpXCIsIHtcclxuICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICogXHR0cmFuc3BhcmVudDogdHJ1ZSxcclxuICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuVGlsZUxheWVyLldNUyA9IEwuVGlsZUxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuXHQvLyBJZiBhbnkgY3VzdG9tIG9wdGlvbnMgbm90IGRvY3VtZW50ZWQgaGVyZSBhcmUgdXNlZCwgdGhleSB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcblx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cDovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG5cdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG5cdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcblx0XHRsYXllcnM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuXHRcdHN0eWxlczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG5cdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcblx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcblx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG5cdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBMLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHdtc1BhcmFtcy53aWR0aCA9IHdtc1BhcmFtcy5oZWlnaHQgPSBvcHRpb25zLnRpbGVTaXplICogKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEgPyAyIDogMSk7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRMLlRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpLFxyXG5cdFx0ICAgIG53ID0gdGhpcy5fY3JzLnByb2plY3QodGlsZUJvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgc2UgPSB0aGlzLl9jcnMucHJvamVjdCh0aWxlQm91bmRzLmdldFNvdXRoRWFzdCgpKSxcclxuXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEwuQ1JTLkVQU0c0MzI2ID9cclxuXHRcdFx0ICAgIFtzZS55LCBudy54LCBudy55LCBzZS54XSA6XHJcblx0XHRcdCAgICBbbncueCwgc2UueSwgc2UueCwgbncueV0pLmpvaW4oJywnKSxcclxuXHJcblx0XHQgICAgdXJsID0gTC5UaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLCBjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRMLlV0aWwuZ2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0TC5leHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbkwudGlsZUxheWVyLndtcyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyLldNUyh1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgSW1hZ2VPdmVybGF5XHJcbiAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBpbWFnZVVybCA9ICdodHRwOi8vd3d3LmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gKiBcdGltYWdlQm91bmRzID0gW1s0MC43MTIyMTYsIC03NC4yMjY1NV0sIFs0MC43NzM5NDEsIC03NC4xMjU0NF1dO1xyXG4gKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuSW1hZ2VPdmVybGF5ID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXHJcblx0XHQvLyBBbiBvcHRpb25hbCBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGBcclxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eSgpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG5cdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcblx0XHRcdHRoaXMuc2V0T3BhY2l0eShzdHlsZU9wdHMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRMLkRvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dGhpcy5fYm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gTC5Eb21VdGlsLmNyZWF0ZSgnaW1nJyxcclxuXHRcdFx0XHQnbGVhZmxldC1pbWFnZS1sYXllciAnICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnIDogJycpKTtcclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cdFx0aW1nLm9ubW91c2Vtb3ZlID0gTC5VdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0aW1nLm9ubG9hZCA9IEwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbikge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSAnJztcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuc3JjID0gdGhpcy5fdXJsO1xyXG5cdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSwgZS56b29tLCBlLmNlbnRlcik7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBib3VuZHMgPSBuZXcgTC5Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbkwuaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBJY29uXHJcbiAqIEBha2EgTC5JY29uXHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxuTC5JY29uID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcblx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IEwucG9pbnQoc2l6ZU9wdGlvbiksXHJcblx0XHQgICAgYW5jaG9yID0gTC5wb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIEwuQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuTC5pY29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuSWNvbihvcHRpb25zKTtcclxufTtcclxuXG5cblxuLypcbiAqIEwuSWNvbi5EZWZhdWx0IGlzIHRoZSBibHVlIG1hcmtlciBpY29uIHVzZWQgYnkgZGVmYXVsdCBpbiBMZWFmbGV0LlxuICovXG5cbkwuSWNvbi5EZWZhdWx0ID0gTC5JY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiAgWzEyLCA0MV0sXG5cdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcblx0XHRzaGFkb3dTaXplOiAgWzQxLCA0MV1cblx0fSxcblxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHR2YXIga2V5ID0gbmFtZSArICdVcmwnO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9uc1trZXldKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW2tleV07XG5cdFx0fVxuXG5cdFx0dmFyIHBhdGggPSBMLkljb24uRGVmYXVsdC5pbWFnZVBhdGg7XG5cblx0XHRpZiAoIXBhdGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCBhdXRvZGV0ZWN0IEwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCwgc2V0IGl0IG1hbnVhbGx5LicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoICsgJy9tYXJrZXItJyArIG5hbWUgKyAoTC5Ccm93c2VyLnJldGluYSAmJiBuYW1lID09PSAnaWNvbicgPyAnLTJ4JyA6ICcnKSArICcucG5nJztcblx0fVxufSk7XG5cbkwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLFxuXHQgICAgbGVhZmxldFJlID0gL1tcXC9eXWxlYWZsZXRbXFwtXFwuX10/KFtcXHdcXC1cXC5fXSopXFwuanNcXD8/LztcblxuXHR2YXIgaSwgbGVuLCBzcmMsIHBhdGg7XG5cblx0Zm9yIChpID0gMCwgbGVuID0gc2NyaXB0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHNyYyA9IHNjcmlwdHNbaV0uc3JjIHx8ICcnO1xuXG5cdFx0aWYgKHNyYy5tYXRjaChsZWFmbGV0UmUpKSB7XG5cdFx0XHRwYXRoID0gc3JjLnNwbGl0KGxlYWZsZXRSZSlbMF07XG5cdFx0XHRyZXR1cm4gKHBhdGggPyBwYXRoICsgJy8nIDogJycpICsgJ2ltYWdlcyc7XG5cdFx0fVxuXHR9XG59KCkpO1xuXG5cblxuLypcclxuICogQGNsYXNzIE1hcmtlclxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICogQGFrYSBMLk1hcmtlclxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5NYXJrZXIgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuXHRcdC8vIEljb24gY2xhc3MgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci4gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLiBTZXQgdG8gbmV3IGBMLkljb24uRGVmYXVsdCgpYCBieSBkZWZhdWx0LlxyXG5cdFx0aWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEZJWE1FOiBzaGFkb3dQYW5lIGlzIG5vIGxvbmdlciBhIHZhbGlkIG9wdGlvblxyXG5cdFx0bm9uQnViYmxpbmdFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J11cclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqXHJcblx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMudXBkYXRlXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmFsdCkge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCdzaGFkb3dQYW5lJykuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5faWNvbik7XHJcblx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTC5IYW5kbGVyLk1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTC5IYW5kbGVyLk1hcmtlckRyYWcodGhpcyk7XHJcblxyXG5cdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuTC5tYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxuTC5EaXZJY29uID0gTC5JY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gTC5wb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuZGl2SWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5EaXZJY29uKG9wdGlvbnMpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIHBvcHVwIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAqIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHBvcHVwcyB0byBjbG9zZSB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAuXHJcbiAqL1xyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbkwuRGl2T3ZlcmxheSA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDcpXHJcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBwb3B1cCBwb3NpdGlvbi4gVXNlZnVsIHRvIGNvbnRyb2wgdGhlIGFuY2hvclxyXG5cdFx0Ly8gb2YgdGhlIHBvcHVwIHdoZW4gb3BlbmluZyBpdCBvbiBzb21lIG92ZXJsYXlzLlxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0byBhbmltYXRlIHRoZSBwb3B1cCBvbiB6b29tLiBEaXNhYmxlIGl0IGlmIHlvdSBoYXZlXHJcblx0XHQvLyBwcm9ibGVtcyB3aXRoIEZsYXNoIGNvbnRlbnQgaW5zaWRlIHBvcHVwcy5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ3BvcHVwUGFuZSdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KTtcclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQoTC5Eb21VdGlsLnJlbW92ZSwgTC5Eb21VdGlsLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHBvcHVwLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cC5cclxuXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIHBvcHVwLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIHBvcHVwLlxyXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIEFsaWFzIGZvciBbZ2V0Q29udGVudCgpXSgjcG9wdXAtZ2V0Y29udGVudClcclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXHJcblx0Ly8gVXBkYXRlcyB0aGUgcG9wdXAgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgcG9wdXAgYWZ0ZXIgc29tZXRoaW5nIGluc2lkZSBjaGFuZ2VkLCBlLmcuIGltYWdlIGxvYWRlZC5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG5cdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIHdoZW4gdGhlIHBvcHVwIGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCBpbiBmcm9udCBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRMLkRvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcblx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55LFxyXG5cdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgcG9wdXAgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cCBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tID0gYm90dG9tICsgJ3B4JztcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFswLCAwXTtcclxuXHR9XHJcblxyXG59KTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICogSGVyZSdzIGEgbW9yZSBjb21wbGljYXRlZCB3YXkgdG8gb3BlbiBhIHBvcHVwIG9uIGEgbWFwOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5MLlBvcHVwID0gTC5EaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBQb3B1cCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcblx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcblx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcblx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG5cdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcCAoc2V0IGdsb2JhbGx5IGJ5XHJcblx0XHQvLyB0aGUgTWFwJ3MgW2Nsb3NlUG9wdXBPbkNsaWNrXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24pLlxyXG5cdFx0YXV0b0Nsb3NlOiB0cnVlXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgc2FtZSBhcyBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9wZW5Qb3B1cCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBMLkRpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICgnY2xvc2VPbkNsaWNrJyBpbiB0aGlzLm9wdGlvbnMgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJykpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cclxuXHRcdFx0TC5Eb21FdmVudC5vbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHdyYXBwZXIpXHJcblx0XHRcdC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpXHJcblx0XHRcdC5vbih3cmFwcGVyLCAnY29udGV4dG1lbnUnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX3RpcCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbiB8fCAodGhpcy5fbWFwLl9wYW5BbmltICYmIHRoaXMuX21hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcblx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgTC5Qb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGxheWVyUG9zLl9hZGQoTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25DbG9zZUJ1dHRvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fY2xvc2UoKTtcclxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIEwucG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbkwucG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBMLlBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChwb3B1cDogUG9wdXApOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCBwb3B1cCB3aGlsZSBjbG9zaW5nIHRoZSBwcmV2aW91c2x5IG9wZW5lZCAodG8gbWFrZSBzdXJlIG9ubHkgb25lIGlzIG9wZW5lZCBhdCBvbmUgdGltZSBmb3IgdXNhYmlsaXR5KS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDcmVhdGVzIGEgcG9wdXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW5zIGl0IGluIHRoZSBnaXZlbiBwb2ludCBvbiBhIG1hcC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIShwb3B1cCBpbnN0YW5jZW9mIEwuUG9wdXApKSB7XHJcblx0XHRcdHBvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChwb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblBvcHVwKCk7XG4gKiBsYXllci5jbG9zZVBvcHVwKCk7XG4gKiBgYGBcbiAqXG4gKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cbiAqL1xuXG4vLyBAc2VjdGlvbiBQb3B1cCBtZXRob2RzXG5MLkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgcG9wdXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Nlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBMLlBvcHVwKSB7XG5cdFx0XHRMLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8IG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgTC5Qb3B1cChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcblx0XHRcdHRoaXMub24oe1xuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRQb3B1cCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMub2ZmKHtcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmljZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTC5MYXllcikpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyO1xuXHRcdFx0bGF5ZXIgPSB0aGlzO1xuXHRcdH1cblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuRmVhdHVyZUdyb3VwKSB7XG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWxhdGxuZykge1xuXHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0Q2VudGVyID8gbGF5ZXIuZ2V0Q2VudGVyKCkgOiBsYXllci5nZXRMYXRMbmcoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XG5cdFx0XHQvLyBzZXQgcG9wdXAgc291cmNlIHRvIHRoaXMgbGF5ZXJcblx0XHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSBsYXllcjtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBwb3B1cCAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXG5cdFx0XHR0aGlzLl9wb3B1cC51cGRhdGUoKTtcblxuXHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxuXHQvLyBSZXR1cm5zIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcblx0fSxcblxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3BvcHVwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcblxuXHRcdC8vIGlmIHRoaXMgaW5oZXJpdHMgZnJvbSBQYXRoIGl0cyBhIHZlY3RvciBhbmQgd2UgY2FuIGp1c3Rcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5QYXRoKSB7XG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxheWVyIHx8IGUudGFyZ2V0LCBlLmxhdGxuZyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXJ3aXNlIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXG5cdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkgJiYgdGhpcy5fcG9wdXAuX3NvdXJjZSA9PT0gbGF5ZXIpIHtcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChsYXllciwgZS5sYXRsbmcpO1xuXHRcdH1cblx0fSxcblxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XG5cdH1cbn0pO1xuXG5cblxuLypcclxuICogUG9wdXAgZXh0ZW5zaW9uIHRvIEwuTWFya2VyLCBhZGRpbmcgcG9wdXAtcmVsYXRlZCBtZXRob2RzLlxyXG4gKi9cclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3IgfHwgWzAsIDBdO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbi8qXG4gKiBAY2xhc3MgVG9vbHRpcFxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAqIEBha2EgTC5Ub29sdGlwXG4gKiBVc2VkIHRvIGRpc3BsYXkgc21hbGwgdGV4dHMgb24gdG9wIG9mIG1hcCBsYXllcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmJpbmRUb29sdGlwKFwibXkgdG9vbHRpcCB0ZXh0XCIpLm9wZW5Ub29sdGlwKCk7XG4gKiBgYGBcbiAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICogZm9yIGNvbXB1dGluZyB0b29sdGlwIG9mZnNldGluZzpcbiAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbNiwgLTZdLCBiZWNhdXNlIHRoZSB0b29sdGlwXG4gKiAgIHRpcCBpcyA2cHggd2lkdGggYW5kIGhlaWdodC4gUmVtZW1iZXIgdG8gY2hhbmdlIHRoaXMgdmFsdWUgaWYgeW91IG92ZXJyaWRlXG4gKiAgIHRoZSB0aXAgaW4gQ1NTLlxuICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gKi9cblxuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbkwuVG9vbHRpcCA9IEwuRGl2T3ZlcmxheS5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDYsIC02KVxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uIFVwZGF0ZSBpdCBpZiB5b3UgY3VzdG9taXplIHRoZVxuXHRcdC8vIHRvb2x0aXAgdGlwIGluIENTUy5cblx0XHRvZmZzZXQ6IFs2LCAtNl0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBmZWF0dXJlIGV2ZW50cy5cblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0b3BhY2l0eTogMC45XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdEwuRGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XG5cdH0sXG5cblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge30sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcG9zID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IEwucG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHBvcyA9IHBvcy5hZGQoTC5wb2ludCgtdG9vbHRpcFdpZHRoIC8gMiwgLXRvb2x0aXBIZWlnaHQgKyBvZmZzZXQueSArIGFuY2hvci55KSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QoTC5wb2ludCh0b29sdGlwV2lkdGggLyAyLCBvZmZzZXQueSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KEwucG9pbnQodG9vbHRpcFdpZHRoIC8gMiwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHBvcyA9IHBvcy5hZGQoW29mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDJdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KEwucG9pbnQob2Zmc2V0LnggKyB0b29sdGlwV2lkdGggKyBhbmNob3IueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSkpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXRvcCcpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLCBvZmZzZXQ7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vZmZzZXQpIHtcblx0XHRcdG9mZnNldCA9IEwucG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCk7XG5cdFx0XHRwb3MgPSBwb3MuYWRkKG9mZnNldCk7XG5cdFx0fVxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gTC5wb2ludCh0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdH1cblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuLy8gSW5zdGFudGlhdGVzIGEgVG9vbHRpcCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbkwudG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcblx0cmV0dXJuIG5ldyBMLlRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5MLk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIEwuVG9vbHRpcCkpIHtcblx0XHRcdHRvb2x0aXAgPSBuZXcgTC5Ub29sdGlwKG9wdGlvbnMpLnNldENvbnRlbnQodG9vbHRpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0dG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cblxuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICogYGBgXG4gKi9cblxuLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5MLkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Ub29sdGlwKSB7XG5cdFx0XHRMLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBMLnRvb2x0aXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHsgdGhpcy5vcGVuVG9vbHRpcCgpOyB9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoKSB7XG5cdFx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmljZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXIpKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcblx0XHRcdGxheWVyID0gdGhpcztcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkge1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFsYXRsbmcpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5fbWFwKSB7XG5cblx0XHRcdC8vIHNldCB0b29sdGlwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBsYXllcjtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSB0b29sdGlwIChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlKCk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAsIGxhdGxuZyk7XG5cblx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0Ly8gb3BlbmVkLlxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLl9jbG9zZSgpO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX21hcCkge1xuXHRcdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fSxcblxuXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub3BlblRvb2x0aXAobGF5ZXIsIHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdH0sXG5cblx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdH1cblx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHR9XG59KTtcblxuXG5cbi8qXHJcbiAqIFRvb2x0aXAgZXh0ZW5zaW9uIHRvIEwuTWFya2VyLCBhZGRpbmcgdG9vbHRpcC1yZWxhdGVkIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuTC5NYXJrZXIuaW5jbHVkZSh7XHJcblx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3IgfHwgWzAsIDBdO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTGF5ZXJHcm91cCA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiAhIWxheWVyICYmIChsYXllciBpbiB0aGlzLl9sYXllcnMgfHwgdGhpcy5nZXRMYXllcklkKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuXHQvLyBgYGBqc1xyXG5cdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG5cdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG5cdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJzKCk6IExheWVyW11cclxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllcnMucHVzaCh0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBMLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM6IExheWVyW10pXHJcbi8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycy5cclxuTC5sYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgTC5MYXllckdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBhbHNvIGhhcyBtb3VzZSBldmVudHMgKHByb3BhZ2F0ZWQgZnJvbSBtZW1iZXJzIG9mIHRoZSBncm91cCkgYW5kIGEgc2hhcmVkIGJpbmRQb3B1cCBtZXRob2QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuRmVhdHVyZUdyb3VwID0gTC5MYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMLkxheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMLkxheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzOiBMYXllcltdKVxyXG4vLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycy5cclxuTC5mZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqL1xuXG5MLlJlbmRlcmVyID0gTC5MYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcblx0XHQvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cblx0XHRwYWRkaW5nOiAwLjFcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRMLnN0YW1wKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZVxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMLkJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcblxuXG5MLk1hcC5pbmNsdWRlKHtcblx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG5cdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG5cdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0aWYgKCFyZW5kZXJlcikge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cblx0XHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9ICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIEwuY2FudmFzKCkpIHx8IEwuc3ZnKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuXHRcdFx0dGhpcy5hZGRMYXllcihyZW5kZXJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfZ2V0UGFuZVJlbmRlcmVyOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG5cdFx0aWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbmRlcmVyID0gKEwuU1ZHICYmIEwuc3ZnKHtwYW5lOiBuYW1lfSkpIHx8IChMLkNhbnZhcyAmJiBMLmNhbnZhcyh7cGFuZTogbmFtZX0pKTtcblx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9XG59KTtcblxuXG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxuTC5QYXRoID0gTC5MYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHpvb21lbmQ6IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkcmVuIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICsgKEwuQnJvd3Nlci50b3VjaCA/IDEwIDogMCk7XG5cdH1cbn0pO1xuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5aW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG5MLkxpbmVVdGlsID0ge1xyXG5cclxuXHQvLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuXHQvLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuXHQvLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG5cdC8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcblx0Ly8gW0RvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcblx0Ly8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG5cdC8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuXHQvLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG5cdC8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5jb20vc2ltcGxpZnktanMvKS5cclxuXHRzaW1wbGlmeTogZnVuY3Rpb24gKHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0XHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHRcdC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0XHQvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcblx0cG9pbnRUb1NlZ21lbnREaXN0YW5jZTogIGZ1bmN0aW9uIChwLCBwMSwgcDIpIHtcclxuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuXHRjbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uIChwLCBwMSwgcDIpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5cdF9zaW1wbGlmeURQOiBmdW5jdGlvbiAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHRcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0XHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdFx0bWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHRcdHZhciBpLFxyXG5cdFx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3UG9pbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcDogZnVuY3Rpb24gKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdFx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0XHQgICAgaW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0XHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0XHRzcURpc3QgPSB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5cdF9yZWR1Y2VQb2ludHM6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0XHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0XHRwcmV2ID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG5cdC8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcblx0Ly8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG5cdC8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcblx0Y2xpcFNlZ21lbnQ6IGZ1bmN0aW9uIChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdFx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyB0aGlzLl9sYXN0Q29kZSA6IHRoaXMuX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHRcdCAgICBjb2RlQiA9IHRoaXMuX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0XHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0XHQvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHRcdHRoaXMuX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG5cdFx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcblx0XHRcdHAgPSB0aGlzLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRuZXdDb2RlID0gdGhpcy5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdFx0YSA9IHA7XHJcblx0XHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGIgPSBwO1xyXG5cdFx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdFx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG5cdFx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4LCB5O1xyXG5cclxuXHRcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG5cdFx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG5cdFx0XHR5ID0gbWluLnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0XHR4ID0gbWF4Lng7XHJcblx0XHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdFx0eCA9IG1pbi54O1xyXG5cdFx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHksIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qml0Q29kZTogZnVuY3Rpb24gKHAsIGJvdW5kcykge1xyXG5cdFx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRcdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG5cdFx0XHRjb2RlIHw9IDE7XHJcblx0XHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0XHRjb2RlIHw9IDI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdFx0Y29kZSB8PSA0O1xyXG5cdFx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRcdGNvZGUgfD0gODtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29kZTtcclxuXHR9LFxyXG5cclxuXHQvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocDEsIHAyKSB7XHJcblx0XHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5cdF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0XHR2YXIgeCA9IHAxLngsXHJcblx0XHQgICAgeSA9IHAxLnksXHJcblx0XHQgICAgZHggPSBwMi54IC0geCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdFx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdFx0ICAgIHQ7XHJcblxyXG5cdFx0aWYgKGRvdCA+IDApIHtcclxuXHRcdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHRcdHkgPSBwMi55O1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRkeCA9IHAueCAtIHg7XHJcblx0XHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdFx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IEwuUG9pbnQoeCwgeSk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFBvbHlsaW5lXG4gKiBAYWthIEwuUG9seWxpbmVcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFstMTIyLjY4LCA0NS41MV0sXG4gKiBcdFstMTIyLjQzLCAzNy43N10sXG4gKiBcdFstMTE4LjIsIDM0LjA0XVxuICogXTtcbiAqXG4gKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0W1stMTIyLjY4LCA0NS41MV0sXG4gKiBcdCBbLTEyMi40MywgMzcuNzddLFxuICogXHQgWy0xMTguMiwgMzQuMDRdXSxcbiAqIFx0W1stNzMuOTEsIDQwLjc4XSxcbiAqIFx0IFstODcuNjIsIDQxLjgzXSxcbiAqIFx0IFstOTYuNzIsIDMyLjc2XV1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5MLlBvbHlsaW5lID0gTC5QYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuXHRcdG5vQ2xpcDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG5cdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcblx0fSxcblxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gTC5MaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuXHRcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz8gTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gTC5Qb2x5bGluZS5fZmxhdChsYXRsbmdzKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSBMLmxhdExuZyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweEJvdW5kcyA9IG5ldyBMLkJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBMLlBvaW50KHcsIHcpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHRweEJvdW5kcy5taW4uX3N1YnRyYWN0KHApO1xuXHRcdFx0cHhCb3VuZHMubWF4Ll9hZGQocCk7XG5cdFx0XHR0aGlzLl9weEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdH1cblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMLkxhdExuZyxcblx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0ICAgIGksIHJpbmc7XG5cblx0XHRpZiAoZmxhdCkge1xuXHRcdFx0cmluZyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2Vcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG5cdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBMLkxpbmVVdGlsLmNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBMLkxpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbkwucG9seWxpbmUgPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG59O1xuXG5MLlBvbHlsaW5lLl9mbGF0ID0gZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0Ly8gdHJ1ZSBpZiBpdCdzIGEgZmxhdCBhcnJheSBvZiBsYXRsbmdzOyBmYWxzZSBpZiBuZXN0ZWRcblx0cmV0dXJuICFMLlV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XG59O1xuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29uIGdlb21ldHJpZXMuXHJcbiAqL1xyXG5cclxuTC5Qb2x5VXRpbCA9IHt9O1xyXG5cclxuLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICogQ2xpcHMgdGhlIHBvbHlnb24gZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYHBvaW50c2AgYnkgdGhlIGdpdmVuIGJvdW5kcyAodXNpbmcgdGhlIFtTdXRoZXJsYW5kLUhvZGdlbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGVyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5MLlBvbHlVdGlsLmNsaXBQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwLFxyXG5cdCAgICBsdSA9IEwuTGluZVV0aWw7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gbHUuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IGx1Ll9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IGx1Ll9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IGx1Ll9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn07XHJcblxuXG5cbi8qXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGFrYSBMLlBvbHlnb25cbiAqIEBpbmhlcml0cyBQb2x5bGluZVxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICpcbiAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbWy0xMTEuMDMsIDQxXSxbLTExMS4wNCwgNDVdLFstMTA0LjA1LCA0NV0sWy0xMDQuMDUsIDQxXV07XG4gKlxuICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFtbLTExMS4wMywgNDFdLFstMTExLjA0LCA0NV0sWy0xMDQuMDUsIDQ1XSxbLTEwNC4wNSwgNDFdXSwgLy8gb3V0ZXIgcmluZ1xuICogICBbWy0xMDguNTgsMzcuMjldLFstMTA4LjU4LDQwLjcxXSxbLTEwMi41MCw0MC43MV0sWy0xMDIuNTAsMzcuMjldXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWy0xMTEuMDMsIDQxXSxbLTExMS4wNCwgNDVdLFstMTA0LjA1LCA0NV0sWy0xMDQuMDUsIDQxXV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWy0xMDguNTgsMzcuMjldLFstMTA4LjU4LDQwLjcxXSxbLTEwMi41MCw0MC43MV0sWy0xMDIuNTAsMzcuMjldXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWy0xMDkuMDUsIDM3XSxbLTEwOS4wMywgNDFdLFstMTAyLjA1LCA0MV0sWy0xMDIuMDQsIDM3XSxbLTEwOS4wNSwgMzhdXVxuICogICBdXG4gKiBdO1xuICogYGBgXG4gKi9cblxuTC5Qb2x5Z29uID0gTC5Qb2x5bGluZS5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuXHRcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IEwuUG9seWxpbmUucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpLFxuXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG5cdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuXHRcdGlmIChsZW4gPj0gMiAmJiByZXN1bHRbMF0gaW5zdGFuY2VvZiBMLkxhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcblx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHRMLlBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG5cdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdH1cblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5nc1swXSkgPyB0aGlzLl9sYXRsbmdzWzBdIDogdGhpcy5fbGF0bG5nc1swXVswXTtcblx0fSxcblxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcblx0XHQgICAgcCA9IG5ldyBMLlBvaW50KHcsIHcpO1xuXG5cdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuXHRcdGJvdW5kcyA9IG5ldyBMLkJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IEwuUG9seVV0aWwuY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG5cdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbkwucG9seWdvbiA9IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufTtcblxuXG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmV0YW5nbGVcbiAqIEBpbmhlcml0cyBQb2x5Z29uXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gKlxuICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAqIGBgYFxuICpcbiAqL1xuXG5cbkwuUmVjdGFuZ2xlID0gTC5Qb2x5Z29uLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRMLlBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gTC5sYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuTC5yZWN0YW5nbGUgPSBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5SZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbn07XG5cblxuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuTC5DaXJjbGVNYXJrZXIgPSBMLlBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7bGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0TC5QYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBMLkJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdH0sXG5cblx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5MLmNpcmNsZU1hcmtlciA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xufTtcblxuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIDIwMCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbkwuQ2lyY2xlID0gTC5DaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gTC5leHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IEwuUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEwuQ1JTLkVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gTC5DUlMuRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IE1hdGgubWF4KE1hdGgucm91bmQocC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54KSwgMSk7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gTWF0aC5tYXgoTWF0aC5yb3VuZChwLnkgLSB0b3AueSksIDEpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4vLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG5MLmNpcmNsZSA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xufTtcblxuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5TVkdcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9c3ZnKSwgU1ZHIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAqIHRoaXMgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5zdmcoKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5MLlNWRyA9IEwuUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gTC5SZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnpvb21zdGFydCA9IHRoaXMuX29uWm9vbVN0YXJ0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBMLlNWRy5jcmVhdGUoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gTC5TVkcuY3JlYXRlKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X29uWm9vbVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gRHJhZy10aGVuLXBpbmNoIGludGVyYWN0aW9ucyBtaWdodCBtZXNzIHVwIHRoZSBjZW50ZXIgYW5kIHpvb20uXG5cdFx0Ly8gSW4gdGhpcyBjYXNlLCB0aGUgZWFzaWVzdCB3YXkgdG8gcHJldmVudCB0aGlzIGlzIHJlLWRvIHRoZSByZW5kZXJlclxuXHRcdC8vICAgYm91bmRzIGFuZCBwYWRkaW5nIHdoZW4gdGhlIHpvb21pbmcgc3RhcnRzLlxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdEwuUmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBMLlNWRy5jcmVhdGUoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgTC5TVkcucG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBsYXllci5fcmFkaXVzLFxuXHRcdCAgICByMiA9IGxheWVyLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG5cdFx0dmFyIGQgPSBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRcdGFyYyArICgtciAqIDIpICsgJywwICc7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG5cdH0sXG5cblx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuXG4vLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5MLmV4dGVuZChMLlNWRywge1xuXHQvLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG5cdC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG5cdC8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cblx0Y3JlYXRlOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG5cdH0sXG5cblx0Ly8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG5cdC8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcblx0Ly8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuXHRwb2ludHNUb1BhdGg6IGZ1bmN0aW9uIChyaW5ncywgY2xvc2VkKSB7XG5cdFx0dmFyIHN0ciA9ICcnLFxuXHRcdCAgICBpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBvaW50c1tqXTtcblx0XHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuXHRcdFx0c3RyICs9IGNsb3NlZCA/IChMLkJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHRcdH1cblxuXHRcdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdFx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG5cdH1cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIEJyb3dzZXI7IEBwcm9wZXJ0eSBzdmc6IEJvb2xlYW5cbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG5MLkJyb3dzZXIuc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIEwuU1ZHLmNyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XG5cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuTC5zdmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gTC5Ccm93c2VyLnN2ZyB8fCBMLkJyb3dzZXIudm1sID8gbmV3IEwuU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn07XG5cblxuXG4vKlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0IFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW4gdGhpcyBjYXNlLlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgQnJvd3NlcjsgQHByb3BlcnR5IHZtbDogQm9vbGVhblxuLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxuTC5Ccm93c2VyLnZtbCA9ICFMLkJyb3dzZXIuc3ZnICYmIChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xuXG5cdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xuXG5cdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XG5cblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSgpKTtcblxuLy8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbkwuU1ZHLmluY2x1ZGUoIUwuQnJvd3Nlci52bWwgPyB7fSA6IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IEwuU1ZHLmNyZWF0ZSgnc2hhcGUnKTtcblxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gTC5TVkcuY3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUoY29udGFpbmVyKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gTC5TVkcuY3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBMLlV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcblx0XHRcdH1cblx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG5cdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSBMLlNWRy5jcmVhdGUoJ2ZpbGwnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0Zyb250KGxheWVyLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufSk7XG5cbmlmIChMLkJyb3dzZXIudm1sKSB7XG5cdEwuU1ZHLmNyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9KSgpO1xufVxuXG5cblxuLypcbiAqIEBjbGFzcyBDYW52YXNcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLkNhbnZhc1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gKiBub3QgZGlzcGxheSBwcm9wZXJseSBpbiBzb21lIGVkZ2UgY2FzZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuTC5DYW52YXMgPSBMLlJlbmRlcmVyLmV4dGVuZCh7XG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXG5cdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdFx0Lm9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIEwuVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdXNlTW92ZSwgMzIsIHRoaXMpLCB0aGlzKVxuXHRcdFx0Lm9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcylcblx0XHRcdC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzID0ge307XG5cblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIG0gPSBMLkJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci5yZXRpbmEpIHtcblx0XHRcdHRoaXMuX2N0eC5zY2FsZSgyLCAyKTtcblx0XHR9XG5cblx0XHQvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzIGVsZW1lbnQgbW92ZXNcblx0XHR0aGlzLl9jdHgudHJhbnNsYXRlKC1iLm1pbi54LCAtYi5taW4ueSk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tMLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogTC5VdGlsLmZhbHNlRm4sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9yZW1vdmVkID0gdHJ1ZTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbGF5ZXIuX3B4Qm91bmRzO1xuXHRcdHRoaXMuX2RyYXcodHJ1ZSk7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fZHJhdygpO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5vcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoJywnKSxcblx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKE51bWJlcihwYXJ0c1tpXSkpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBMLkJvdW5kcygpO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHR0aGlzLl9kcmF3KHRydWUpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uIChjbGVhcikge1xuXHRcdHRoaXMuX2NsZWFyID0gY2xlYXI7XG5cdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54LCBib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkpO1xuXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHRcdGlmIChjbGVhciAmJiBsYXllci5fcmVtb3ZlZCkge1xuXHRcdFx0XHRkZWxldGUgbGF5ZXIuX3JlbW92ZWQ7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cblx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcblx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG5cdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9kcmF3bkxheWVyc1tsYXllci5fbGVhZmxldF9pZF0gPSBsYXllcjtcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAobGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gbGF5ZXIuX3JhZGl1cyxcblx0XHQgICAgcyA9IChsYXllci5fcmFkaXVzWSB8fCByKSAvIHI7XG5cblx0XHR0aGlzLl9kcmF3bkxheWVyc1tsYXllci5fbGVhZmxldF9pZF0gPSBsYXllcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIGNsZWFyID0gdGhpcy5fY2xlYXIsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNsZWFyID8gJ2Rlc3RpbmF0aW9uLW91dCcgOiAnc291cmNlLW92ZXInO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY2xlYXIgPyAxIDogb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY2xlYXIgPyAxIDogb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHQvLyBpZiBjbGVhcmluZyBzaGFwZSwgZG8gaXQgd2l0aCB0aGUgcHJldmlvdXNseSBkcmF3biBsaW5lIHdpZHRoXG5cdFx0XHRsYXllci5fcHJldldlaWdodCA9IGN0eC5saW5lV2lkdGggPSBjbGVhciA/IGxheWVyLl9wcmV2V2VpZ2h0ICsgMSA6IG9wdGlvbnMud2VpZ2h0O1xuXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcblx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVycyA9IFtdLCBsYXllcjtcblxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRMLkRvbUV2ZW50Ll9mYWtlU3RvcChlKTtcblx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobGF5ZXJzLmxlbmd0aCkgIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChsYXllcnMsIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUsIHBvaW50KTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllciAmJiAoZS50eXBlID09PSAnbW91c2VvdXQnIHx8ICFsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHR2YXIgaWQsIGxheWVyO1xuXG5cdFx0Zm9yIChpZCBpbiB0aGlzLl9kcmF3bkxheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9kcmF3bkxheWVyc1tpZF07XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbiAobGF5ZXJzLCBlLCB0eXBlKSB7XG5cdFx0dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoZSwgdHlwZSB8fCBlLnR5cGUsIGxheWVycyk7XG5cdH0sXG5cblx0Ly8gVE9ETyBfYnJpbmdUb0Zyb250ICYgX2JyaW5nVG9CYWNrLCBwcmV0dHkgdHJpY2t5XG5cblx0X2JyaW5nVG9Gcm9udDogTC5VdGlsLmZhbHNlRm4sXG5cdF9icmluZ1RvQmFjazogTC5VdGlsLmZhbHNlRm5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIEJyb3dzZXI7IEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG5MLkJyb3dzZXIuY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcbn0oKSk7XG5cbi8vIEBuYW1lc3BhY2UgQ2FudmFzXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuY2FudmFzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIEwuQnJvd3Nlci5jYW52YXMgPyBuZXcgTC5DYW52YXMob3B0aW9ucykgOiBudWxsO1xufTtcblxuTC5Qb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRpZiAoIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmIChMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuTC5Qb2x5Z29uLnByb3RvdHlwZS5fY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG5cdHZhciBpbnNpZGUgPSBmYWxzZSxcblx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0cDEgPSBwYXJ0W2pdO1xuXHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRyZXR1cm4gaW5zaWRlIHx8IEwuUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG59O1xuXG5MLkNpcmNsZU1hcmtlci5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocCkge1xuXHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9Kc29uKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5HZW9KU09OID0gTC5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gc2hvdyBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNob3cgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IExheWVyXHJcblx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gTC5VdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IEwuR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IEwuR2VvSlNPTi5hc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXIgKTogTGF5ZXJcclxuXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0bGF5ZXIub3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogTGF5ZXJcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcbkwuZXh0ZW5kKEwuR2VvSlNPTiwge1xyXG5cdC8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcblx0Ly8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG5cdC8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG5cdC8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5cdGdlb21ldHJ5VG9MYXllcjogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdFx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdFx0ICAgIGxheWVycyA9IFtdLFxyXG5cdFx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcblx0XHQgICAgY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZyxcclxuXHRcdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0XHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0XHRjYXNlICdQb2ludCc6XHJcblx0XHRcdGxhdGxuZyA9IGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRcdHJldHVybiBwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBMLk1hcmtlcihsYXRsbmcpO1xyXG5cclxuXHRcdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBjb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IEwuTWFya2VyKGxhdGxuZykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0XHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRcdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdQb2x5Z29uJzpcclxuXHRcdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLmdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0XHRpZiAobGF5ZXIpIHtcclxuXHRcdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG5cdC8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcblx0Ly8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcblx0Y29vcmRzVG9MYXRMbmc6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuXHQvLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcblx0Ly8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG5cdC8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuXHRjb29yZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChjb29yZHMsIGxldmVsc0RlZXAsIGNvb3Jkc1RvTGF0TG5nKSB7XHJcblx0XHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0ICAgICAgICB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBjb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQgICAgICAgIChjb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZ3M7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nKTogQXJyYXlcclxuXHQvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuXHRsYXRMbmdUb0Nvb3JkczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdFx0W2xhdGxuZy5sbmcsIGxhdGxuZy5sYXQsIGxhdGxuZy5hbHRdIDpcclxuXHRcdFx0XHRbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF07XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcblx0Ly8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuXHQvLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcblx0bGF0TG5nc1RvQ29vcmRzOiBmdW5jdGlvbiAobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdFx0TC5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkKSA6XHJcblx0XHRcdFx0TC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0pKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvb3JkcztcclxuXHR9LFxyXG5cclxuXHRnZXRGZWF0dXJlOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRcdFx0TC5leHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRcdFx0TC5HZW9KU09OLmFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuXHRhc0ZlYXR1cmU6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIHtcclxuXHRcdFx0cmV0dXJuIGdlb2pzb247XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBMLkdlb0pTT04ubGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSlcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTC5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkwuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuTC5Qb2x5bGluZS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBtdWx0aSA9ICFMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHR2YXIgY29vcmRzID0gTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwKTtcclxuXHJcblx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0fSk7XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5MLlBvbHlnb24ucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgaG9sZXMgPSAhTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHQgICAgbXVsdGkgPSBob2xlcyAmJiAhTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0dmFyIGNvb3JkcyA9IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSk7XHJcblxyXG5cdGlmICghaG9sZXMpIHtcclxuXHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkwuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgR2VvbWV0cnlDb2xsZWN0aW9uYCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKCk7XHJcblx0XHRcdFx0anNvbnMucHVzaChpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGpzb24uZ2VvbWV0cnkgOiBMLkdlb0pTT04uYXNGZWF0dXJlKGpzb24pKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sKSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuTC5nZW9KU09OID0gZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufTtcclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuTC5nZW9Kc29uID0gTC5nZW9KU09OO1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcblxyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuTC5Eb21FdmVudCA9IHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG5cdC8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcblx0Ly8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuXHQvLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0b246IGZ1bmN0aW9uIChvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vbihvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24ob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLFxyXG5cdC8vIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBET00gZXZlbnQgZnJvbSB0aGUgZWxlbWVudC5cclxuXHQvLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcblx0Ly8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0b2ZmOiBmdW5jdGlvbiAob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGlkID0gdHlwZSArIEwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBMLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuXHRcdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0dGhpcy5hZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMuYWRkRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5hZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICgodHlwZSA9PT0gJ21vdXNlZW50ZXInKSB8fCAodHlwZSA9PT0gJ21vdXNlbGVhdmUnKSkge1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdFx0aWYgKEwuRG9tRXZlbnQuX2lzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycgJiYgTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gTC5Eb21FdmVudC5fZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdFx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdHZhciBpZCA9IHR5cGUgKyBMLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgTC5zdGFtcChjb250ZXh0KSA6ICcnKSxcclxuXHRcdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRcdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMucmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuXHRcdFx0XHRcdHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDpcclxuXHRcdFx0XHRcdHR5cGUgPT09ICdtb3VzZWxlYXZlJyA/ICdtb3VzZW91dCcgOiB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuXHQvLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuXHQvLyBgYGBqc1xyXG5cdC8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuXHQvLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcHBlZChlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuXHQvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdtb3VzZXdoZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5cdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5vbihlbCwgJ21vdXNld2hlZWwnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuXHQvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcblx0Ly8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5cdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbihlbCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCBzdG9wKTtcclxuXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5vbihlbCwge1xyXG5cdFx0XHRjbGljazogTC5Eb21FdmVudC5fZmFrZVN0b3AsXHJcblx0XHRcdGRibGNsaWNrOiBzdG9wXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG5cdC8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuXHQvLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcblx0Ly8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuXHQvLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3RvcChldik6IHRoaXNcclxuXHQvLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcblx0c3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50XHJcblx0XHRcdC5wcmV2ZW50RGVmYXVsdChlKVxyXG5cdFx0XHQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG5cdC8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIGBjb250YWluZXJgIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcblx0Z2V0TW91c2VQb3NpdGlvbjogZnVuY3Rpb24gKGUsIGNvbnRhaW5lcikge1xyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHRcdGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0XHRlLmNsaWVudFkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3ApO1xyXG5cdH0sXHJcblxyXG5cdC8vIENocm9tZSBvbiBXaW4gc2Nyb2xscyBkb3VibGUgdGhlIHBpeGVscyBhcyBpbiBvdGhlciBwbGF0Zm9ybXMgKHNlZSAjNDUzOCksXHJcblx0Ly8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG5cdF93aGVlbFB4RmFjdG9yOiAoTC5Ccm93c2VyLndpbiAmJiBMLkJyb3dzZXIuY2hyb21lKSA/IDIgOlxyXG5cdCAgICAgICAgICAgICAgICBMLkJyb3dzZXIuZ2Vja28gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcblx0ICAgICAgICAgICAgICAgIDEsXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG5cdC8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2V3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcblx0Ly8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcblx0Ly8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuXHQvLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5cdGdldFdoZWVsRGVsdGE6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gKEwuQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0XHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIEwuRG9tRXZlbnQuX3doZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHRcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG5cdFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0XHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdFx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG5cdFx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHRcdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0XHQgICAgICAgMDtcclxuXHR9LFxyXG5cclxuXHRfc2tpcEV2ZW50czoge30sXHJcblxyXG5cdF9mYWtlU3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggTC5Eb21FdmVudC5fc2tpcHBlZChlKVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfc2tpcHBlZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBza2lwcGVkID0gdGhpcy5fc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdFx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRcdHRoaXMuX3NraXBFdmVudHNbZS50eXBlXSA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHNraXBwZWQ7XHJcblx0fSxcclxuXHJcblx0Ly8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcblx0X2lzRXh0ZXJuYWxUYXJnZXQ6IGZ1bmN0aW9uIChlbCwgZSkge1xyXG5cclxuXHRcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcblx0fSxcclxuXHJcblx0Ly8gdGhpcyBpcyBhIGhvcnJpYmxlIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIEFuZHJvaWQgd2hlcmUgYSBzaW5nbGUgdG91Y2ggdHJpZ2dlcnMgdHdvIGNsaWNrIGV2ZW50c1xyXG5cdF9maWx0ZXJDbGljazogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcclxuXHRcdHZhciB0aW1lU3RhbXAgPSAoZS50aW1lU3RhbXAgfHwgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQudGltZVN0YW1wKSksXHJcblx0XHQgICAgZWxhcHNlZCA9IEwuRG9tRXZlbnQuX2xhc3RDbGljayAmJiAodGltZVN0YW1wIC0gTC5Eb21FdmVudC5fbGFzdENsaWNrKTtcclxuXHJcblx0XHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXHJcblx0XHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0XHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRcdGlmICgoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCA1MDApIHx8IChlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgJiYgIWUuX3NpbXVsYXRlZCkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdFx0aGFuZGxlcihlKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub25gXSgjZG9tZXZlbnQtb24pXHJcbkwuRG9tRXZlbnQuYWRkTGlzdGVuZXIgPSBMLkRvbUV2ZW50Lm9uO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9mZmBdKCNkb21ldmVudC1vZmYpXHJcbkwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIgPSBMLkRvbUV2ZW50Lm9mZjtcclxuXG5cblxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5EcmFnZ2FibGUgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0U1RBUlQ6IEwuQnJvd3Nlci50b3VjaCA/IFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nXSA6IFsnbW91c2Vkb3duJ10sXHJcblx0XHRFTkQ6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0XHRcdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcblx0XHR9LFxyXG5cdFx0TU9WRToge1xyXG5cdFx0XHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU6IEJvb2xlYW4pXHJcblx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUpIHtcclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBMLkRyYWdnYWJsZS5TVEFSVC5qb2luKCcgJyksIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChMLkRvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHRcdEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRydWU7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHRcdC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgbmV3UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGlmICgod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkgJiYgKHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpKSB7XHJcblx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlUG9zaXRpb24sIHRoaXMsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIEwuRHJhZ2dhYmxlLk1PVkUpIHtcclxuXHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcylcclxuXHRcdFx0XHQub2ZmKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZykge1xyXG5cdFx0XHQvLyBlbnN1cmUgZHJhZyBpcyBub3QgZmlyZWQgYWZ0ZXIgZHJhZ2VuZFxyXG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuLy8gQGNsYXNzIEhhbmRsZXJcbi8vIEBha2EgTC5IYW5kbGVyXG4vLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbkwuSGFuZGxlciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG5cblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBiZSBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXG5cdGRyYWdnaW5nOiB0cnVlLFxuXG5cdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG5cdC8vIEBvcHRpb24gaW5lcnRpYTogQm9vbGVhbiA9ICpcblx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuXHQvLyB0aGUgc2FtZSBkaXJlY3Rpb24gZm9yIHNvbWUgdGltZS4gRmVlbHMgZXNwZWNpYWxseSBuaWNlIG9uIHRvdWNoXG5cdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdCB1bmxlc3MgcnVubmluZyBvbiBvbGQgQW5kcm9pZCBkZXZpY2VzLlxuXHRpbmVydGlhOiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbkwuTWFwLkRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkb3duOiB0aGlzLl9vbkRvd24sXG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5fc3RvcCgpO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gTC5ib3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0aWYgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcblx0fSxcblxuXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cblx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcblx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG5cdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG5cdFx0aWYgKG5vSW5lcnRpYSkge1xuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG5cdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgTC5NYXAuRHJhZyk7XG5cblxuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG5cdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcblx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Eb3VibGVDbGlja1pvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBMLk1hcC5Eb3VibGVDbGlja1pvb20pO1xuXG5cblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gTW91c2V3aGVlbCBvcHRpb25zXG5cdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcblx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcblx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcblx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG5cdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG5cdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcblx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cblx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbn0pO1xuXG5MLk1hcC5TY3JvbGxXaGVlbFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cblx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcblx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcblx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG5cdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbi8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBMLk1hcC5TY3JvbGxXaGVlbFpvb20pO1xuXG5cblxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcclxuXHJcblx0X3RvdWNoc3RhcnQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBMLkJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCcsXHJcblx0X3RvdWNoZW5kOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnLFxyXG5cclxuXHQvLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5cdGFkZERvdWJsZVRhcExpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdFx0dmFyIGxhc3QsIHRvdWNoLFxyXG5cdFx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxyXG5cdFx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblx0XHRcdHZhciBjb3VudDtcclxuXHJcblx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdGNvdW50ID0gTC5Eb21FdmVudC5fcG9pbnRlcnNDb3VudDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb3VudCA9IGUudG91Y2hlcy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb3VudCA+IDEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdFx0ICAgIGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcblx0XHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRcdGxhc3QgPSBub3c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcclxuXHRcdFx0aWYgKGRvdWJsZVRhcCAmJiAhdG91Y2guY2FuY2VsQnViYmxlKSB7XHJcblx0XHRcdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXHJcblx0XHRcdFx0XHR2YXIgbmV3VG91Y2ggPSB7fSxcclxuXHRcdFx0XHRcdCAgICBwcm9wLCBpO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gpIDogcHJvcDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxyXG5cdFx0ICAgIHRvdWNoc3RhcnQgPSB0aGlzLl90b3VjaHN0YXJ0LFxyXG5cdFx0ICAgIHRvdWNoZW5kID0gdGhpcy5fdG91Y2hlbmQ7XHJcblxyXG5cdFx0b2JqW3ByZSArIHRvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0XHRvYmpbcHJlICsgdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cdFx0b2JqW3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xyXG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHJcblx0XHQvLyBPbiBzb21lIHBsYXRmb3JtcyAobm90YWJseSwgY2hyb21lIG9uIHdpbjEwICsgdG91Y2hzY3JlZW4gKyBtb3VzZSksXHJcblx0XHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcblx0XHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcblx0XHRpZiAoIUwuQnJvd3Nlci5lZGdlKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgaWQpIHtcclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaHN0YXJ0ID0gb2JqW3ByZSArIHRoaXMuX3RvdWNoc3RhcnQgKyBpZF0sXHJcblx0XHQgICAgdG91Y2hlbmQgPSBvYmpbcHJlICsgdGhpcy5fdG91Y2hlbmQgKyBpZF0sXHJcblx0XHQgICAgZGJsY2xpY2sgPSBvYmpbcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBmYWxzZSk7XHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaGVuZCwgdG91Y2hlbmQsIGZhbHNlKTtcclxuXHRcdGlmICghTC5Ccm93c2VyLmVkZ2UpIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZGJsY2xpY2ssIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG5MLmV4dGVuZChMLkRvbUV2ZW50LCB7XG5cblx0UE9JTlRFUl9ET1dOOiAgIEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bicsXG5cdFBPSU5URVJfTU9WRTogICBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnLFxuXHRQT0lOVEVSX1VQOiAgICAgTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCcsXG5cdFBPSU5URVJfQ0FOQ0VMOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCcsXG5cdFRBR19XSElURV9MSVNUOiBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXSxcblxuXHRfcG9pbnRlcnM6IHt9LFxuXHRfcG9pbnRlcnNDb3VudDogMCxcblxuXHQvLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG5cdC8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cblx0YWRkUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXG5cdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdFx0dGhpcy5fYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdFx0dGhpcy5fYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBpZCkge1xuXHRcdHZhciBoYW5kbGVyID0gb2JqWydfbGVhZmxldF8nICsgdHlwZSArIGlkXTtcblxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfTU9WRSwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkUG9pbnRlclN0YXJ0OiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBvbkRvd24gPSBMLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcblx0XHRcdFx0Ly8gSW4gSUUxMSwgc29tZSB0b3VjaCBldmVudHMgbmVlZHMgdG8gZmlyZSBmb3IgZm9ybSBjb250cm9scywgb3Jcblx0XHRcdFx0Ly8gdGhlIGNvbnRyb2xzIHdpbGwgc3RvcCB3b3JraW5nLiBXZSBrZWVwIGEgd2hpdGVsaXN0IG9mIHRhZyBuYW1lcyB0aGF0XG5cdFx0XHRcdC8vIG5lZWQgdGhlc2UgZXZlbnRzLiBGb3Igb3RoZXIgdGFyZ2V0IHRhZ3MsIHdlIHByZXZlbnQgZGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5cdFx0XHRcdGlmICh0aGlzLlRBR19XSElURV9MSVNULmluZGV4T2YoZS50YXJnZXQudGFnTmFtZSkgPCAwKSB7XG5cdFx0XHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIG9uRG93biwgZmFsc2UpO1xuXG5cdFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdFx0aWYgKCF0aGlzLl9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHRcdHZhciBwb2ludGVyVXAgPSBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlclVwLCB0aGlzKTtcblxuXHRcdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlckRvd24sIHRoaXMpLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlck1vdmUsIHRoaXMpLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgcG9pbnRlclVwLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIHBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9nbG9iYWxQb2ludGVyRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRcdHRoaXMuX3BvaW50ZXJzQ291bnQrKztcblx0fSxcblxuXHRfZ2xvYmFsUG9pbnRlck1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdFx0dGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0XHR9XG5cdH0sXG5cblx0X2dsb2JhbFBvaW50ZXJVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRkZWxldGUgdGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdO1xuXHRcdHRoaXMuX3BvaW50ZXJzQ291bnQtLTtcblx0fSxcblxuXHRfaGFuZGxlUG9pbnRlcjogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcblx0XHRlLnRvdWNoZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3BvaW50ZXJzKSB7XG5cdFx0XHRlLnRvdWNoZXMucHVzaCh0aGlzLl9wb2ludGVyc1tpXSk7XG5cdFx0fVxuXHRcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0XHRoYW5kbGVyKGUpO1xuXHR9LFxuXG5cdF9hZGRQb2ludGVyTW92ZTogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgb25Nb3ZlID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuXHRcdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfTU9WRSwgb25Nb3ZlLCBmYWxzZSk7XG5cdH0sXG5cblx0X2FkZFBvaW50ZXJFbmQ6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIG9uVXAgPSBMLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgb25VcCwgZmFsc2UpO1xuXHR9XG59KTtcblxuXG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG5cdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG5cdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdC8vIGJyb3dzZXJzIGV4Y2VwdCBmb3Igb2xkIEFuZHJvaWRzLlxuXHR0b3VjaFpvb206IEwuQnJvd3Nlci50b3VjaCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuTC5NYXAuVG91Y2hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG5cdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IEwuYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0pO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpXG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHNuYXBab29tIGlzIG9mZiwgc28gc25hcFpvb20gYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy5zbmFwWm9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBMLk1hcC5Ub3VjaFpvb20pO1xuXG5cblxuLypcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIEVuYWJsZXMgbW9iaWxlIGhhY2tzIGZvciBzdXBwb3J0aW5nIGluc3RhbnQgdGFwcyAoZml4aW5nIDIwMG1zIGNsaWNrXG5cdC8vIGRlbGF5IG9uIGlPUy9BbmRyb2lkKSBhbmQgdG91Y2ggaG9sZHMgKGZpcmVkIGFzIGBjb250ZXh0bWVudWAgZXZlbnRzKS5cblx0dGFwOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbkwuTWFwLlRhcCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cblx0XHR0aGlzLl9maXJlQ2xpY2sgPSB0cnVlO1xuXG5cdFx0Ly8gZG9uJ3Qgc2ltdWxhdGUgY2xpY2sgb3IgdHJhY2sgbG9uZ3ByZXNzIGlmIG1vcmUgdGhhbiAxIHRvdWNoXG5cdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdLFxuXHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuXHRcdFx0dmFyIGZpcnN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXSxcblx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0aWYgKGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlbW92ZScsIGZpcnN0KTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcblx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuXHRcdCAgICAgICAgZS5jbGllbnRYLCBlLmNsaWVudFksXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdGFwOiBIYW5kbGVyXG4vLyBNb2JpbGUgdG91Y2ggaGFja3MgKHF1aWNrIHRhcCBhbmQgdG91Y2ggaG9sZCkgaGFuZGxlci5cbmlmIChMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5wb2ludGVyKSB7XG5cdEwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIEwuTWFwLlRhcCk7XG59XG5cblxuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Cb3hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogTC5Eb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEwuQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBMLkRvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9maW5pc2goKTtcblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG5cdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBMLk1hcC5Cb3hab29tKTtcblxuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5MLk1hcC5LZXlib2FyZCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblxuXHRcdFx0aWYgKG1hcC5fcGFuQW5pbSAmJiBtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdG9mZnNldCA9IEwucG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblxuXHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcpIHtcblx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEwuTWFwLktleWJvYXJkKTtcblxuXG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG4gKi9cblxuTC5IYW5kbGVyLk1hcmtlckRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5jbG9zZVBvcHVwKClcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuXG5cblxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXHJcblx0XHQvLyBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgKG9uZSBvZiB0aGUgbWFwIGNvcm5lcnMpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndG9wbGVmdCdgLFxyXG5cdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRQb3NpdGlvbjogc3RyaW5nXHJcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0ICovXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2wuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcblx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gKiBAdW5pbmhlcml0YWJsZVxyXG4gKlxyXG4gKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICovXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAqL1xyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbC5ab29tID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJy0nXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRleHQ6ICctJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuXHRcdCAgICBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHQgICAgLm9uKGxpbmssICdtb3VzZWRvd24gZGJsY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcylcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gbGluaztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IEwuQ29udHJvbC5ab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbkwuY29udHJvbC56b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5ab29tKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuQXR0cmlidXRpb24gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cDovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0aWYgKEwuRG9tRXZlbnQpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdGV4dCBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJ1ZlY3RvciBkYXRhICZjb3B5OyBNYXBib3gnYCkuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG5cdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcblx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIHwgJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIGF0dHJpYnV0aW9uQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5MLmNvbnRyb2wuYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLkF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5MLkNvbnRyb2wuU2NhbGUgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cblx0XHRtYXhXaWR0aDogMTAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG5cdFx0bWV0cmljOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cblx0XHRpbXBlcmlhbDogdHJ1ZVxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG5cdFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuY29udHJvbC5zY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5Db250cm9sLlNjYWxlKG9wdGlvbnMpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gKiBAYWthIEwuQ29udHJvbC5MYXllcnNcclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGxheWVycyBjb250cm9sIGdpdmVzIHVzZXJzIHRoZSBhYmlsaXR5IHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBiYXNlIGxheWVycyBhbmQgc3dpdGNoIG92ZXJsYXlzIG9uL29mZiAoY2hlY2sgb3V0IHRoZSBbZGV0YWlsZWQgZXhhbXBsZV0oaHR0cDovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wuaHRtbCkpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbkwuQ29udHJvbC5MYXllcnMgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyIG9yIHRvdWNoLlxyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuXHRcdGF1dG9aSW5kZXg6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG5cdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihMLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX2Zvcm0uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fZm9ybS5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZvcm0gPSB0aGlzLl9mb3JtID0gTC5Eb21VdGlsLmNyZWF0ZSgnZm9ybScsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdGlmICghTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xyXG5cdFx0XHRcdFx0bW91c2VlbnRlcjogdGhpcy5leHBhbmQsXHJcblx0XHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gd29yayBhcm91bmQgZm9yIEZpcmVmb3ggQW5kcm9pZCBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDMzXHJcblx0XHRcdEwuRG9tRXZlbnQub24oZm9ybSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyksIDApO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHRcdFx0Ly8gVE9ETyBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1iYXNlJywgZm9ybSk7XHJcblx0XHR0aGlzLl9zZXBhcmF0b3IgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIGZvcm0pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIGZvcm0pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgTC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHRMLkRvbVV0aWwuZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihMLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnMnLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHRpbnB1dC5sYXllcklkID0gTC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2Zvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JyksXHJcblx0XHQgICAgaW5wdXQsIGxheWVyLCBoYXNMYXllcjtcclxuXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG5cdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRoYXNMYXllciA9IHRoaXMuX21hcC5oYXNMYXllcihsYXllcik7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCAmJiAhaGFzTGF5ZXIpIHtcclxuXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQgJiYgaGFzTGF5ZXIpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9mb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGxheWVyLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuY29sbGFwc2UoKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuTC5jb250cm9sLmxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLkxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8qXG4gKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAqXG4gKi9cblxuTC5Qb3NBbmltYXRpb24gPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc3RvcCgpXG5cdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG5cdFx0dGhpcy5fY29tcGxldGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5fYW5pbUlkID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdC8vIEBldmVudCBlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcblxuXG5cbi8qXG4gKiBFeHRlbmRzIEwuTWFwIHRvIGhhbmRsZSBwYW5uaW5nIGFuaW1hdGlvbnMuXG4gKi9cblxuTC5NYXAuaW5jbHVkZSh7XG5cblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoTC5sYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR0aGlzLl9zdG9wKCk7XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcblxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xuXHRcdFx0XHRvcHRpb25zLnBhbiA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xuXG5cdFx0XHRpZiAobW92ZWQpIHtcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XG5cdFx0b2Zmc2V0ID0gTC5wb2ludChvZmZzZXQpLnJvdW5kKCk7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuXHRcdH1cblx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcblxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xuXHR9LFxuXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0fSxcblxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZmxvb3IoKTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG5cblxuLypcbiAqIEV4dGVuZHMgTC5NYXAgdG8gaGFuZGxlIHpvb20gYW5pbWF0aW9ucy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXG5cdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cblx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcblx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxuXHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0XG59KTtcblxudmFyIHpvb21BbmltYXRlZCA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OICYmIEwuQnJvd3Nlci5hbnkzZCAmJiAhTC5Ccm93c2VyLm1vYmlsZU9wZXJhO1xuXG5pZiAoem9vbUFuaW1hdGVkKSB7XG5cblx0TC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xuXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcblxuXHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9wcm94eSwgTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG59XG5cbkwuTWFwLmluY2x1ZGUoIXpvb21BbmltYXRlZCA/IHt9IDoge1xuXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XG5cblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgcHJvcCA9IEwuRG9tVXRpbC5UUkFOU0ZPUk0sXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gcHJveHkuc3R5bGVbcHJvcF07XG5cblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0ocHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XG5cblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSBwcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcblx0XHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHByb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHR9XG5cdH0sXG5cblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XG5cdH0sXG5cblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSlcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcblx0XHRpZiAoc3RhcnRBbmltKSB7XG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcblxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XG5cdFx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcblxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xuXHRcdH1cblxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxuXHRcdC8vIEZpcmVkIG9uIGV2ZXJ5IGZyYW1lIG9mIGEgem9vbSBhbmltYXRpb25cblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHR6b29tOiB6b29tLFxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXG5cdFx0fSk7XG5cblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXG5cdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XG5cdH0sXG5cblx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XG5cblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XG5cblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSk7XG5cblx0XHQvLyBUaGlzIGFuaW0gZnJhbWUgc2hvdWxkIHByZXZlbnQgYW4gb2JzY3VyZSBpT1Mgd2Via2l0IHRpbGUgbG9hZGluZyByYWNlIGNvbmRpdGlvbi5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xuXHRcdH0sIHRoaXMpO1xuXHR9XG59KTtcblxuXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXG5MLk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9QYW4gb3B0aW9ucyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cblx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8ICFMLkJyb3dzZXIuYW55M2QpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdG9wKCk7XG5cblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcblx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xuXG5cdFx0dGFyZ2V0Q2VudGVyID0gTC5sYXRMbmcodGFyZ2V0Q2VudGVyKTtcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcblxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXG5cdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXG5cdFx0ICAgIHJobyA9IDEuNDIsXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XG5cblx0XHRmdW5jdGlvbiByKGkpIHtcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXG5cdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXG5cdFx0XHQgICAgYiA9IHQxIC8gYjEsXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XG5cblx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcblxuXHRcdFx0cmV0dXJuIGxvZztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxuXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cblxuXHRcdHZhciByMCA9IHIoMCk7XG5cblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XG5cblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxuXG5cdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xuXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXG5cdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xuXG5cdFx0XHRpZiAodCA8PSAxKSB7XG5cdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XG5cblx0XHRcdFx0dGhpcy5fbW92ZShcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXG5cdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlKTtcblxuXHRcdGZyYW1lLmNhbGwodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXG5cdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xuXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcblx0fVxufSk7XG5cblxuXG4vKlxyXG4gKiBQcm92aWRlcyBMLk1hcCB3aXRoIGNvbnZlbmllbnQgc2hvcnRjdXRzIGZvciB1c2luZyBicm93c2VyIGdlb2xvY2F0aW9uIGZlYXR1cmVzLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0X2RlZmF1bHRMb2NhdGVPcHRpb25zOiB7XHJcblx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdHdhdGNoOiBmYWxzZVxyXG5cdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcblx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLl9kZWZhdWx0TG9jYXRlT3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBMLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IEwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMLkxhdExuZyhsYXQsIGxuZyksXHJcblx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcblx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcblx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbn0od2luZG93LCBkb2N1bWVudCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC1zcmMubWFwIiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyJyk7XG52YXIgcmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpLmJpbmQobnVsbCwgUmVxdWVzdCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJpc29uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciB0cmltID0gJycudHJpbVxuICA/IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9XG4gIDogZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTsgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChudWxsICE9IG9ialtrZXldKSB7XG4gICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogSGVscHMgJ3NlcmlhbGl6ZScgd2l0aCBzZXJpYWxpemluZyBhcnJheXMuXG4gKiBNdXRhdGVzIHRoZSBwYWlycyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKi9cblxuZnVuY3Rpb24gcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGZvcih2YXIgc3Via2V5IGluIHZhbCkge1xuICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSArICdbJyArIHN1YmtleSArICddJywgdmFsW3N1YmtleV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbiAvKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYWlyO1xuICB2YXIgcG9zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwb3MgPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgICBpZiAocG9zID09IC0xKSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIpXSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UoMCwgcG9zKSldID1cbiAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UocG9zICsgMSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5yZXF1ZXN0LnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5cbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICdhcHBsaWNhdGlvbi94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxuIHJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHNlcmlhbGl6ZSxcbiAgICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnlcbiB9O1xuXG4gLyoqXG4gICogRGVmYXVsdCBwYXJzZXJzLlxuICAqXG4gICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24oc3RyKXtcbiAgKiAgICAgICByZXR1cm4geyBvYmplY3QgcGFyc2VkIGZyb20gc3RyIH07XG4gICogICAgIH07XG4gICpcbiAgKi9cblxucmVxdWVzdC5wYXJzZSA9IHtcbiAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHBhcnNlU3RyaW5nLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04ucGFyc2Vcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgdmFyIGluZGV4O1xuICB2YXIgbGluZTtcbiAgdmFyIGZpZWxkO1xuICB2YXIgdmFsO1xuXG4gIGxpbmVzLnBvcCgpOyAvLyB0cmFpbGluZyBDUkxGXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgcmV0dXJuIC9bXFwvK11qc29uXFxiLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbWltZSB0eXBlIGZvciB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHlwZShzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJhbXMoc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKSxcbiAgICAgICAga2V5ID0gcGFydHMuc2hpZnQoKSxcbiAgICAgICAgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICAgIGlmIChrZXkgJiYgdmFsKSBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMucmVxID0gcmVxO1xuICB0aGlzLnhociA9IHRoaXMucmVxLnhocjtcbiAgLy8gcmVzcG9uc2VUZXh0IGlzIGFjY2Vzc2libGUgb25seSBpZiByZXNwb25zZVR5cGUgaXMgJycgb3IgJ3RleHQnIGFuZCBvbiBvbGRlciBicm93c2Vyc1xuICB0aGlzLnRleHQgPSAoKHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyAmJiAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHx8IHR5cGVvZiB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKVxuICAgICA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dFxuICAgICA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG4gIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICA/IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSlcbiAgICA6IG51bGw7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gIC8vIGNvbnRlbnQtdHlwZVxuICB2YXIgY3QgPSB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gIHRoaXMudHlwZSA9IHR5cGUoY3QpO1xuXG4gIC8vIHBhcmFtc1xuICB2YXIgb2JqID0gcGFyYW1zKGN0KTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgdGhpc1trZXldID0gb2JqW2tleV07XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpe1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICghcGFyc2UgJiYgaXNKU09OKHRoaXMudHlwZSkpIHtcbiAgICBwYXJzZSA9IHJlcXVlc3QucGFyc2VbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgfVxuICByZXR1cm4gcGFyc2UgJiYgc3RyICYmIChzdHIubGVuZ3RoIHx8IHN0ciBpbnN0YW5jZW9mIE9iamVjdClcbiAgICA/IHBhcnNlKHN0cilcbiAgICA6IG51bGw7XG59O1xuXG4vKipcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxuICpcbiAqIEZvciBleGFtcGxlIGEgMnh4IHJlc3BvbnNlIHdpbGwgZ2l2ZSB5b3UgYSBgLm9rYCBvZiBfX3RydWVfX1xuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxuICogYC5jbGllbnRFcnJvcmAgYW5kIGAuc2VydmVyRXJyb3JgIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBiZSBtb3JlXG4gKiBzcGVjaWZpYywgYW5kIGAuc3RhdHVzVHlwZWAgaXMgdGhlIGNsYXNzIG9mIGVycm9yIHJhbmdpbmcgZnJvbSAxLi41XG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cbiAqXG4gKiBcInN1Z2FyXCIgcHJvcGVydGllcyBhcmUgYWxzbyBkZWZpbmVkIGZvciBjb21tb24gY2FzZXMuIEN1cnJlbnRseSBwcm92aWRpbmc6XG4gKlxuICogICAtIC5ub0NvbnRlbnRcbiAqICAgLSAuYmFkUmVxdWVzdFxuICogICAtIC51bmF1dGhvcml6ZWRcbiAqICAgLSAubm90QWNjZXB0YWJsZVxuICogICAtIC5ub3RGb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuXG4gIHZhciB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAvLyBzdGF0dXMgLyBjbGFzc1xuICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAvLyBiYXNpY3NcbiAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgIDogZmFsc2U7XG5cbiAgLy8gc3VnYXJcbiAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgdGhpcy5iYWRSZXF1ZXN0ID0gNDAwID09IHN0YXR1cztcbiAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gc2VsZi54aHIgJiYgc2VsZi54aHIucmVzcG9uc2VUZXh0ID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogbnVsbDtcbiAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgZXJyLnN0YXR1c0NvZGUgPSBzZWxmLnhociAmJiBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcblxuICAgIHZhciBuZXdfZXJyO1xuICAgIHRyeSB7XG4gICAgICBpZiAocmVzLnN0YXR1cyA8IDIwMCB8fCByZXMuc3RhdHVzID49IDMwMCkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgICBuZXdfZXJyLnJlc3BvbnNlID0gcmVzO1xuICAgICAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBuZXdfZXJyID0gZTsgLy8gIzk4NSB0b3VjaGluZyByZXMgbWF5IGNhdXNlIElOVkFMSURfU1RBVEVfRVJSIG9uIG9sZCBBbmRyb2lkXG4gICAgfVxuXG4gICAgLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG4gICAgaWYgKG5ld19lcnIpIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgcmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuZm9yICh2YXIga2V5IGluIHJlcXVlc3RCYXNlKSB7XG4gIFJlcXVlc3QucHJvdG90eXBlW2tleV0gPSByZXF1ZXN0QmFzZVtrZXldO1xufVxuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCByZXNwb25zZVR5cGUgdG8gYHZhbGAuIFByZXNlbnRseSB2YWxpZCByZXNwb25zZVR5cGVzIGFyZSAnYmxvYicgYW5kXG4gKiAnYXJyYXlidWZmZXInLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycgb3IgJ2Jhc2ljJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdiYXNpYydcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHZhciBzdHIgPSBidG9hKHVzZXIgKyAnOicgKyBwYXNzKTtcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBzdHIpO1xuICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4qXG4qIEV4YW1wbGVzOlxuKlxuKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4qIEBhcGkgcHVibGljXG4qL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYGZpbGVuYW1lYC5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2goJ2NvbnRlbnQnLCBuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmaWVsZCwgZmlsZSwgZmlsZW5hbWUpe1xuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgZmlsZW5hbWUgfHwgZmlsZS5uYW1lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG5cbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcblxuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcigndGltZW91dCBvZiAnICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdGhpcy51cmwgKz0gfnRoaXMudXJsLmluZGV4T2YoJz8nKVxuICAgICAgPyAnJicgKyBxdWVyeVxuICAgICAgOiAnPycgKyBxdWVyeTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4aHIgPSB0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCk7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIC8vIHN0b3JlIGNhbGxiYWNrXG4gIHRoaXMuX2NhbGxiYWNrID0gZm4gfHwgbm9vcDtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICB2YXIgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICgwID09IHN0YXR1cykge1xuICAgICAgaWYgKHNlbGYudGltZWRvdXQpIHJldHVybiBzZWxmLl90aW1lb3V0RXJyb3IoKTtcbiAgICAgIGlmIChzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgdmFyIGhhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24oZSl7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gJ2Rvd25sb2FkJztcbiAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gIH07XG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3M7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAoeGhyLnVwbG9hZCAmJiB0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3M7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gIH1cblxuICAvLyB0aW1lb3V0XG4gIGlmICh0aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi50aW1lZG91dCA9IHRydWU7XG4gICAgICBzZWxmLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICAvLyBxdWVyeXN0cmluZ1xuICB0aGlzLl9hcHBlbmRRdWVyeVN0cmluZygpO1xuXG4gIC8vIGluaXRpYXRlIHJlcXVlc3RcbiAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSwgdGhpcy51c2VybmFtZSwgdGhpcy5wYXNzd29yZCk7XG4gIH0gZWxzZSB7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgfVxuXG4gIC8vIENPUlNcbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cbiAgLy8gYm9keVxuICBpZiAoJ0dFVCcgIT0gdGhpcy5tZXRob2QgJiYgJ0hFQUQnICE9IHRoaXMubWV0aG9kICYmICdzdHJpbmcnICE9IHR5cGVvZiBkYXRhICYmICF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIHZhciBzZXJpYWxpemUgPSB0aGlzLl9zZXJpYWxpemVyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIGlmIChzZXJpYWxpemUpIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XG4gIH1cblxuICAvLyBzZXQgaGVhZGVyIGZpZWxkc1xuICBmb3IgKHZhciBmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgIGlmIChudWxsID09IHRoaXMuaGVhZGVyW2ZpZWxkXSkgY29udGludWU7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3Jlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8vIHNlbmQgc3R1ZmZcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG5cbiAgLy8gSUUxMSB4aHIuc2VuZCh1bmRlZmluZWQpIHNlbmRzICd1bmRlZmluZWQnIHN0cmluZyBhcyBQT1NUIHBheWxvYWQgKGluc3RlYWQgb2Ygbm90aGluZylcbiAgLy8gV2UgbmVlZCBudWxsIGhlcmUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnID8gZGF0YSA6IG51bGwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RgLlxuICovXG5cbnJlcXVlc3QuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdIRUFEJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnT1BUSU9OUycsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxucmVxdWVzdFsnZGVsJ10gPSBkZWw7XG5yZXF1ZXN0WydkZWxldGUnXSA9IGRlbDtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucHV0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQVVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbiIsIi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG51bGwgIT09IG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gX2NsZWFyVGltZW91dCgpe1xuICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVzcG9uc2UgYm9keSBwYXJzZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgaW5jb21pbmcgZGF0YSBpbnRvIHJlcXVlc3QuYm9keVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXF1ZXN0IGJvZHkgc2VyaWFsaXplclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBkYXRhIHNldCB2aWEgLnNlbmQgb3IgLmF0dGFjaCBpbnRvIHBheWxvYWQgdG8gc2VuZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXQgdG8gYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnRpbWVvdXQgPSBmdW5jdGlvbiB0aW1lb3V0KG1zKXtcbiAgdGhpcy5fdGltZW91dCA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHJvbWlzZSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cbmV4cG9ydHMudGhlbiA9IGZ1bmN0aW9uIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmICghdGhpcy5fZnVsbGZpbGxlZFByb21pc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KXtcbiAgICAgIHNlbGYuZW5kKGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTsgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuZXhwb3J0cy5nZXRIZWFkZXIgPSBleHBvcnRzLmdldDtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5leHBvcnRzLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAgZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiXG4gKiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSByZXF1ZXN0LCBhbmQgY2xlYXIgcG90ZW50aWFsIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMuYWJvcnQgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIHRoaXMucmVxICYmIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbigpe1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCByZWRpcmVjdHMgdG8gYG5gLiBEb2VzIG5vdGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVkaXJlY3RzID0gZnVuY3Rpb24obil7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudG9KU09OID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXJcbiAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogVE9ETzogZnV0dXJlIHByb29mLCBtb3ZlIHRvIGNvbXBvZW50IGxhbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5faXNIb3N0ID0gZnVuY3Rpb24gX2lzSG9zdChvYmopIHtcbiAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcblxuICBzd2l0Y2ggKHN0cikge1xuICAgIGNhc2UgJ1tvYmplY3QgRmlsZV0nOlxuICAgIGNhc2UgJ1tvYmplY3QgQmxvYl0nOlxuICAgIGNhc2UgJ1tvYmplY3QgRm9ybURhdGFdJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIG9iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKG9iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IHRoaXMuX2RhdGEgKyAnJicgKyBkYXRhXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFvYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSByZXR1cm4gdGhpcztcblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiLy8gVGhlIG5vZGUgYW5kIGJyb3dzZXIgbW9kdWxlcyBleHBvc2UgdmVyc2lvbnMgb2YgdGhpcyB3aXRoIHRoZVxuLy8gYXBwcm9wcmlhdGUgY29uc3RydWN0b3IgZnVuY3Rpb24gYm91bmQgYXMgZmlyc3QgYXJndW1lbnRcbi8qKlxuICogSXNzdWUgYSByZXF1ZXN0OlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgIHJlcXVlc3QoJ0dFVCcsICcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXG4gKiAgICByZXF1ZXN0KCcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXG4gKiAgICByZXF1ZXN0KCcvdXNlcnMnLCBjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdXJsIG9yIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByZXF1ZXN0KFJlcXVlc3RDb25zdHJ1Y3RvciwgbWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdENvbnN0cnVjdG9yKCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgyID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcignR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVxdWVzdENvbnN0cnVjdG9yKG1ldGhvZCwgdXJsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbnlRdWV1ZTtcblxuZnVuY3Rpb24gVGlueVF1ZXVlKGRhdGEsIGNvbXBhcmUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGlueVF1ZXVlKSkgcmV0dXJuIG5ldyBUaW55UXVldWUoZGF0YSwgY29tcGFyZSk7XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IFtdO1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlO1xuXG4gICAgaWYgKGRhdGEpIGZvciAodmFyIGkgPSBNYXRoLmZsb29yKHRoaXMubGVuZ3RoIC8gMik7IGkgPj0gMDsgaS0tKSB0aGlzLl9kb3duKGkpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG5UaW55UXVldWUucHJvdG90eXBlID0ge1xuXG4gICAgcHVzaDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goaXRlbSk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIHRoaXMuX3VwKHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfSxcblxuICAgIHBvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9wID0gdGhpcy5kYXRhWzBdO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmRhdGFbdGhpcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgdGhpcy5kYXRhLnBvcCgpO1xuICAgICAgICB0aGlzLl9kb3duKDApO1xuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH0sXG5cbiAgICBwZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gICAgfSxcblxuICAgIF91cDogZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBNYXRoLmZsb29yKChwb3MgLSAxKSAvIDIpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUoZGF0YVtwb3NdLCBkYXRhW3BhcmVudF0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHN3YXAoZGF0YSwgcGFyZW50LCBwb3MpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBhcmVudDtcblxuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kb3duOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgY29tcGFyZSA9IHRoaXMuY29tcGFyZSxcbiAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IDIgKiBwb3MgKyAxLFxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIDEsXG4gICAgICAgICAgICAgICAgbWluID0gcG9zO1xuXG4gICAgICAgICAgICBpZiAobGVmdCA8IGxlbiAmJiBjb21wYXJlKGRhdGFbbGVmdF0sIGRhdGFbbWluXSkgPCAwKSBtaW4gPSBsZWZ0O1xuICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbGVuICYmIGNvbXBhcmUoZGF0YVtyaWdodF0sIGRhdGFbbWluXSkgPCAwKSBtaW4gPSByaWdodDtcblxuICAgICAgICAgICAgaWYgKG1pbiA9PT0gcG9zKSByZXR1cm47XG5cbiAgICAgICAgICAgIHN3YXAoZGF0YSwgbWluLCBwb3MpO1xuICAgICAgICAgICAgcG9zID0gbWluO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3dhcChkYXRhLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGRhdGFbal07XG4gICAgZGF0YVtqXSA9IHRtcDtcbn1cbiIsInZhciBzaWduZWRBcmVhID0gcmVxdWlyZSgnLi9zaWduZWRfYXJlYScpO1xuXG4vKipcbiAqIEBwYXJhbSAge1N3ZWVwRXZlbnR9IGUxXG4gKiBAcGFyYW0gIHtTd2VlcEV2ZW50fSBlMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN3ZWVwRXZlbnRzQ29tcChlMSwgZTIpIHtcbiAgdmFyIHAxID0gZTEucG9pbnQ7XG4gIHZhciBwMiA9IGUyLnBvaW50O1xuXG4gIC8vIERpZmZlcmVudCB4LWNvb3JkaW5hdGVcbiAgaWYgKHAxWzBdID4gcDJbMF0pIHJldHVybiAxO1xuICBpZiAocDFbMF0gPCBwMlswXSkgcmV0dXJuIC0xO1xuXG4gIC8vIERpZmZlcmVudCBwb2ludHMsIGJ1dCBzYW1lIHgtY29vcmRpbmF0ZVxuICAvLyBFdmVudCB3aXRoIGxvd2VyIHktY29vcmRpbmF0ZSBpcyBwcm9jZXNzZWQgZmlyc3RcbiAgaWYgKHAxWzFdICE9PSBwMlsxXSkgcmV0dXJuIHAxWzFdID4gcDJbMV0gPyAxIDogLTE7XG5cbiAgcmV0dXJuIHNwZWNpYWxDYXNlcyhlMSwgZTIsIHAxLCBwMik7XG59O1xuXG5cbmZ1bmN0aW9uIHNwZWNpYWxDYXNlcyhlMSwgZTIsIHAxLCBwMikge1xuICAvLyBTYW1lIGNvb3JkaW5hdGVzLCBidXQgb25lIGlzIGEgbGVmdCBlbmRwb2ludCBhbmQgdGhlIG90aGVyIGlzXG4gIC8vIGEgcmlnaHQgZW5kcG9pbnQuIFRoZSByaWdodCBlbmRwb2ludCBpcyBwcm9jZXNzZWQgZmlyc3RcbiAgaWYgKGUxLmxlZnQgIT09IGUyLmxlZnQpXG4gICAgcmV0dXJuIGUxLmxlZnQgPyAxIDogLTE7XG5cbiAgLy8gU2FtZSBjb29yZGluYXRlcywgYm90aCBldmVudHNcbiAgLy8gYXJlIGxlZnQgZW5kcG9pbnRzIG9yIHJpZ2h0IGVuZHBvaW50cy5cbiAgLy8gbm90IGNvbGxpbmVhclxuICBpZiAoc2lnbmVkQXJlYSAocDEsIGUxLm90aGVyRXZlbnQucG9pbnQsIGUyLm90aGVyRXZlbnQucG9pbnQpICE9PSAwKSB7XG4gICAgLy8gdGhlIGV2ZW50IGFzc29jaWF0ZSB0byB0aGUgYm90dG9tIHNlZ21lbnQgaXMgcHJvY2Vzc2VkIGZpcnN0XG4gICAgcmV0dXJuICghZTEuaXNCZWxvdyhlMi5vdGhlckV2ZW50LnBvaW50KSkgPyAxIDogLTE7XG4gIH1cblxuICBpZiAoZTEuaXNTdWJqZWN0ID09PSBlMi5pc1N1YmplY3QpIHtcbiAgICByZXR1cm4gZTEuY29udG91cklkID4gZTIuY29udG91cklkID8gLTEgOiAxO1xuICB9XG4gIHJldHVybiAoIWUxLmlzU3ViamVjdCAmJiBlMi5pc1N1YmplY3QpID8gMSA6IC0xO1xuICAvL3JldHVybiBlMS5pc1N1YmplY3QgPyAtMSA6IDE7XG59IiwidmFyIHNpZ25lZEFyZWEgICAgPSByZXF1aXJlKCcuL3NpZ25lZF9hcmVhJyk7XG52YXIgY29tcGFyZUV2ZW50cyA9IHJlcXVpcmUoJy4vY29tcGFyZV9ldmVudHMnKTtcbnZhciBlcXVhbHMgICAgICAgID0gcmVxdWlyZSgnLi9lcXVhbHMnKTtcblxuXG4vKipcbiAqIEBwYXJhbSAge1N3ZWVwRXZlbnR9IGxlMVxuICogQHBhcmFtICB7U3dlZXBFdmVudH0gbGUyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcGFyZVNlZ21lbnRzKGxlMSwgbGUyKSB7XG4gIGlmIChsZTEgPT09IGxlMikgcmV0dXJuIDA7XG5cbiAgLy8gU2VnbWVudHMgYXJlIG5vdCBjb2xsaW5lYXJcbiAgaWYgKHNpZ25lZEFyZWEobGUxLnBvaW50LCBsZTEub3RoZXJFdmVudC5wb2ludCwgbGUyLnBvaW50KSAhPT0gMCB8fFxuICAgIHNpZ25lZEFyZWEobGUxLnBvaW50LCBsZTEub3RoZXJFdmVudC5wb2ludCwgbGUyLm90aGVyRXZlbnQucG9pbnQpICE9PSAwKSB7XG5cbiAgICAvLyBJZiB0aGV5IHNoYXJlIHRoZWlyIGxlZnQgZW5kcG9pbnQgdXNlIHRoZSByaWdodCBlbmRwb2ludCB0byBzb3J0XG4gICAgaWYgKGVxdWFscyhsZTEucG9pbnQsIGxlMi5wb2ludCkpIHJldHVybiBsZTEuaXNCZWxvdyhsZTIub3RoZXJFdmVudC5wb2ludCkgPyAtMSA6IDE7XG5cbiAgICAvLyBEaWZmZXJlbnQgbGVmdCBlbmRwb2ludDogdXNlIHRoZSBsZWZ0IGVuZHBvaW50IHRvIHNvcnRcbiAgICBpZiAobGUxLnBvaW50WzBdID09PSBsZTIucG9pbnRbMF0pIHJldHVybiBsZTEucG9pbnRbMV0gPCBsZTIucG9pbnRbMV0gPyAtMSA6IDE7XG5cbiAgICAvLyBoYXMgdGhlIGxpbmUgc2VnbWVudCBhc3NvY2lhdGVkIHRvIGUxIGJlZW4gaW5zZXJ0ZWRcbiAgICAvLyBpbnRvIFMgYWZ0ZXIgdGhlIGxpbmUgc2VnbWVudCBhc3NvY2lhdGVkIHRvIGUyID9cbiAgICBpZiAoY29tcGFyZUV2ZW50cyhsZTEsIGxlMikgPT09IDEpIHJldHVybiBsZTIuaXNBYm92ZShsZTEucG9pbnQpID8gLTEgOiAxO1xuXG4gICAgLy8gVGhlIGxpbmUgc2VnbWVudCBhc3NvY2lhdGVkIHRvIGUyIGhhcyBiZWVuIGluc2VydGVkXG4gICAgLy8gaW50byBTIGFmdGVyIHRoZSBsaW5lIHNlZ21lbnQgYXNzb2NpYXRlZCB0byBlMVxuICAgIHJldHVybiBsZTEuaXNCZWxvdyhsZTIucG9pbnQpID8gLTEgOiAxO1xuICB9XG5cbiAgLy8gU2VnbWVudHMgYXJlIGNvbGxpbmVhclxuICBpZiAobGUxLmlzU3ViamVjdCAhPT0gbGUyLmlzU3ViamVjdCkgcmV0dXJuIChsZTEuaXNTdWJqZWN0ICYmICFsZTIuaXNTdWJqZWN0KSA/IDEgOiAtMTtcblxuICAvLyBKdXN0IGEgY29uc2lzdGVudCBjcml0ZXJpb24gaXMgdXNlZFxuICBpZiAoZXF1YWxzKGxlMS5wb2ludCwgbGUyLnBvaW50KSkge1xuICAgIHJldHVybiBsZTEuY29udG91cklkID4gbGUyLmNvbnRvdXJJZCA/IC0xIDogMTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlRXZlbnRzKGxlMSwgbGUyKSA9PT0gMSA/IDEgOiAtMTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXG4gIE5PUk1BTDogICAgICAgICAgICAgICAwLCBcbiAgTk9OX0NPTlRSSUJVVElORzogICAgIDEsIFxuICBTQU1FX1RSQU5TSVRJT046ICAgICAgMiwgXG4gIERJRkZFUkVOVF9UUkFOU0lUSU9OOiAzXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gIHJldHVybiBwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdO1xufTsiLCJ2YXIgSU5URVJTRUNUSU9OICAgID0gMDtcbnZhciBVTklPTiAgICAgICAgICAgPSAxO1xudmFyIERJRkZFUkVOQ0UgICAgICA9IDI7XG52YXIgWE9SICAgICAgICAgICAgID0gMztcblxudmFyIEVNUFRZICAgICAgICAgICA9IFtdO1xuXG52YXIgZWRnZVR5cGUgICAgICAgID0gcmVxdWlyZSgnLi9lZGdlX3R5cGUnKTtcblxudmFyIFF1ZXVlICAgICAgICAgICA9IHJlcXVpcmUoJ3RpbnlxdWV1ZScpO1xudmFyIFRyZWUgICAgICAgICAgICA9IHJlcXVpcmUoJ2JpbnRyZWVzJykuUkJUcmVlO1xudmFyIFN3ZWVwRXZlbnQgICAgICA9IHJlcXVpcmUoJy4vc3dlZXBfZXZlbnQnKTtcblxudmFyIGNvbXBhcmVFdmVudHMgICA9IHJlcXVpcmUoJy4vY29tcGFyZV9ldmVudHMnKTtcbnZhciBjb21wYXJlU2VnbWVudHMgPSByZXF1aXJlKCcuL2NvbXBhcmVfc2VnbWVudHMnKTtcbnZhciBpbnRlcnNlY3Rpb24gICAgPSByZXF1aXJlKCcuL3NlZ21lbnRfaW50ZXJzZWN0aW9uJyk7XG52YXIgZXF1YWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9lcXVhbHMnKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEBwYXJhbSAgezxBcnJheS48TnVtYmVyPn0gczFcbiAqIEBwYXJhbSAgezxBcnJheS48TnVtYmVyPn0gczJcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICAgaXNTdWJqZWN0XG4gKiBAcGFyYW0gIHtRdWV1ZX0gICAgICAgICAgIGV2ZW50UXVldWVcbiAqIEBwYXJhbSAge0FycmF5LjxOdW1iZXI+fSAgYmJveFxuICovXG5mdW5jdGlvbiBwcm9jZXNzU2VnbWVudChzMSwgczIsIGlzU3ViamVjdCwgZGVwdGgsIGV2ZW50UXVldWUsIGJib3gpIHtcbiAgLy8gdmFyIGUgPSAxZTU7XG4gIC8vIHMxID0gW01hdGgucm91bmQoczFbMF0gKiBlKSAvIGUsIE1hdGgucm91bmQoczFbMV0gKiBlKSAvIGVdO1xuICAvLyBzMiA9IFtNYXRoLnJvdW5kKHMyWzBdICogZSkgLyBlLCBNYXRoLnJvdW5kKHMyWzFdICogZSkgLyBlXTtcbiAgLy8gUG9zc2libGUgZGVnZW5lcmF0ZSBjb25kaXRpb24uXG4gIC8vIGlmIChlcXVhbHMoczEsIHMyKSkgcmV0dXJuO1xuXG4gIHZhciBlMSA9IG5ldyBTd2VlcEV2ZW50KHMxLCBmYWxzZSwgdW5kZWZpbmVkLCBpc1N1YmplY3QpO1xuICB2YXIgZTIgPSBuZXcgU3dlZXBFdmVudChzMiwgZmFsc2UsIGUxLCAgICAgICAgaXNTdWJqZWN0KTtcbiAgZTEub3RoZXJFdmVudCA9IGUyO1xuXG4gIGUxLmNvbnRvdXJJZCA9IGUyLmNvbnRvdXJJZCA9IGRlcHRoO1xuXG4gIGlmIChjb21wYXJlRXZlbnRzKGUxLCBlMikgPiAwKSB7XG4gICAgZTIubGVmdCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZTEubGVmdCA9IHRydWU7XG4gIH1cblxuICBiYm94WzBdID0gbWluKGJib3hbMF0sIHMxWzBdKTtcbiAgYmJveFsxXSA9IG1pbihiYm94WzFdLCBzMVsxXSk7XG4gIGJib3hbMl0gPSBtYXgoYmJveFsyXSwgczFbMF0pO1xuICBiYm94WzNdID0gbWF4KGJib3hbM10sIHMxWzFdKTtcblxuICAvLyBQdXNoaW5nIGl0IHNvIHRoZSBxdWV1ZSBpcyBzb3J0ZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LFxuICAvLyB3aXRoIG9iamVjdCBvbiB0aGUgbGVmdCBoYXZpbmcgdGhlIGhpZ2hlc3QgcHJpb3JpdHkuXG4gIGV2ZW50UXVldWUucHVzaChlMSk7XG4gIGV2ZW50UXVldWUucHVzaChlMik7XG59XG5cbnZhciBjb250b3VySWQgPSAwO1xuXG5mdW5jdGlvbiBwcm9jZXNzUG9seWdvbihwb2x5Z29uLCBpc1N1YmplY3QsIGRlcHRoLCBxdWV1ZSwgYmJveCkge1xuICB2YXIgaSwgbGVuO1xuICBpZiAodHlwZW9mIHBvbHlnb25bMF1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcG9seWdvbi5sZW5ndGggLSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHByb2Nlc3NTZWdtZW50KHBvbHlnb25baV0sIHBvbHlnb25baSArIDFdLCBpc1N1YmplY3QsIGRlcHRoICsgMSwgcXVldWUsIGJib3gpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb250b3VySWQrKztcbiAgICAgIHByb2Nlc3NQb2x5Z29uKHBvbHlnb25baV0sIGlzU3ViamVjdCwgY29udG91cklkLCBxdWV1ZSwgYmJveCk7XG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gZmlsbFF1ZXVlKHN1YmplY3QsIGNsaXBwaW5nLCBzYmJveCwgY2Jib3gpIHtcbiAgdmFyIGV2ZW50UXVldWUgPSBuZXcgUXVldWUobnVsbCwgY29tcGFyZUV2ZW50cyk7XG4gIGNvbnRvdXJJZCA9IDA7XG5cbiAgcHJvY2Vzc1BvbHlnb24oc3ViamVjdCwgIHRydWUsICAwLCBldmVudFF1ZXVlLCBzYmJveCk7XG4gIHByb2Nlc3NQb2x5Z29uKGNsaXBwaW5nLCBmYWxzZSwgMCwgZXZlbnRRdWV1ZSwgY2Jib3gpO1xuXG4gIHJldHVybiBldmVudFF1ZXVlO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXB1dGVGaWVsZHMoZXZlbnQsIHByZXYsIHN3ZWVwTGluZSwgb3BlcmF0aW9uKSB7XG4gIC8vIGNvbXB1dGUgaW5PdXQgYW5kIG90aGVySW5PdXQgZmllbGRzXG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgZXZlbnQuaW5PdXQgICAgICA9IGZhbHNlO1xuICAgIGV2ZW50Lm90aGVySW5PdXQgPSB0cnVlO1xuXG4gIC8vIHByZXZpb3VzIGxpbmUgc2VnbWVudCBpbiBzd2VlcGxpbmUgYmVsb25ncyB0byB0aGUgc2FtZSBwb2x5Z29uXG4gIH0gZWxzZSBpZiAoZXZlbnQuaXNTdWJqZWN0ID09PSBwcmV2LmlzU3ViamVjdCkge1xuICAgIGV2ZW50LmluT3V0ICAgICAgPSAhcHJldi5pbk91dDtcbiAgICBldmVudC5vdGhlckluT3V0ID0gcHJldi5vdGhlckluT3V0O1xuXG4gIC8vIHByZXZpb3VzIGxpbmUgc2VnbWVudCBpbiBzd2VlcGxpbmUgYmVsb25ncyB0byB0aGUgY2xpcHBpbmcgcG9seWdvblxuICB9IGVsc2Uge1xuICAgIGV2ZW50LmluT3V0ICAgICAgPSAhcHJldi5vdGhlckluT3V0O1xuICAgIGV2ZW50Lm90aGVySW5PdXQgPSBwcmV2LmlzVmVydGljYWwoKSA/ICFwcmV2LmluT3V0IDogcHJldi5pbk91dDtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgcHJldkluUmVzdWx0IGZpZWxkXG4gIGlmIChwcmV2KSB7XG4gICAgZXZlbnQucHJldkluUmVzdWx0ID0gKCFpblJlc3VsdChwcmV2LCBvcGVyYXRpb24pIHx8IHByZXYuaXNWZXJ0aWNhbCgpKSA/XG4gICAgICAgcHJldi5wcmV2SW5SZXN1bHQgOiBwcmV2O1xuICB9XG4gIC8vIGNoZWNrIGlmIHRoZSBsaW5lIHNlZ21lbnQgYmVsb25ncyB0byB0aGUgQm9vbGVhbiBvcGVyYXRpb25cbiAgZXZlbnQuaW5SZXN1bHQgPSBpblJlc3VsdChldmVudCwgb3BlcmF0aW9uKTtcbn1cblxuXG5mdW5jdGlvbiBpblJlc3VsdChldmVudCwgb3BlcmF0aW9uKSB7XG4gIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgZWRnZVR5cGUuTk9STUFMOlxuICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgY2FzZSBJTlRFUlNFQ1RJT046XG4gICAgICAgICAgcmV0dXJuICFldmVudC5vdGhlckluT3V0O1xuICAgICAgICBjYXNlIFVOSU9OOlxuICAgICAgICAgIHJldHVybiBldmVudC5vdGhlckluT3V0O1xuICAgICAgICBjYXNlIERJRkZFUkVOQ0U6XG4gICAgICAgICAgcmV0dXJuIChldmVudC5pc1N1YmplY3QgJiYgZXZlbnQub3RoZXJJbk91dCkgfHxcbiAgICAgICAgICAgICAgICAgKCFldmVudC5pc1N1YmplY3QgJiYgIWV2ZW50Lm90aGVySW5PdXQpO1xuICAgICAgICBjYXNlIFhPUjpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICBjYXNlIGVkZ2VUeXBlLlNBTUVfVFJBTlNJVElPTjpcbiAgICAgIHJldHVybiBvcGVyYXRpb24gPT09IElOVEVSU0VDVElPTiB8fCBvcGVyYXRpb24gPT09IFVOSU9OO1xuICAgIGNhc2UgZWRnZVR5cGUuRElGRkVSRU5UX1RSQU5TSVRJT046XG4gICAgICByZXR1cm4gb3BlcmF0aW9uID09PSBESUZGRVJFTkNFO1xuICAgIGNhc2UgZWRnZVR5cGUuTk9OX0NPTlRSSUJVVElORzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0gIHtTd2VlcEV2ZW50fSBzZTFcbiAqIEBwYXJhbSAge1N3ZWVwRXZlbnR9IHNlMlxuICogQHBhcmFtICB7UXVldWV9ICAgICAgcXVldWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gcG9zc2libGVJbnRlcnNlY3Rpb24oc2UxLCBzZTIsIHF1ZXVlKSB7XG4gIC8vIHRoYXQgZGlzYWxsb3dzIHNlbGYtaW50ZXJzZWN0aW5nIHBvbHlnb25zLFxuICAvLyBkaWQgY29zdCB1cyBoYWxmIGEgZGF5LCBzbyBJJ2xsIGxlYXZlIGl0XG4gIC8vIG91dCBvZiByZXNwZWN0XG4gIC8vIGlmIChzZTEuaXNTdWJqZWN0ID09PSBzZTIuaXNTdWJqZWN0KSByZXR1cm47XG5cbiAgdmFyIGludGVyID0gaW50ZXJzZWN0aW9uKFxuICAgIHNlMS5wb2ludCwgc2UxLm90aGVyRXZlbnQucG9pbnQsXG4gICAgc2UyLnBvaW50LCBzZTIub3RoZXJFdmVudC5wb2ludFxuICApO1xuXG4gIHZhciBuaW50ZXJzZWN0aW9ucyA9IGludGVyID8gaW50ZXIubGVuZ3RoIDogMDtcbiAgaWYgKG5pbnRlcnNlY3Rpb25zID09PSAwKSByZXR1cm4gMDsgLy8gbm8gaW50ZXJzZWN0aW9uXG5cbiAgLy8gdGhlIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0IGF0IGFuIGVuZHBvaW50IG9mIGJvdGggbGluZSBzZWdtZW50c1xuICBpZiAoKG5pbnRlcnNlY3Rpb25zID09PSAxKSAmJlxuICAgICAgKGVxdWFscyhzZTEucG9pbnQsIHNlMi5wb2ludCkgfHxcbiAgICAgICBlcXVhbHMoc2UxLm90aGVyRXZlbnQucG9pbnQsIHNlMi5vdGhlckV2ZW50LnBvaW50KSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChuaW50ZXJzZWN0aW9ucyA9PT0gMiAmJiBzZTEuaXNTdWJqZWN0ID09PSBzZTIuaXNTdWJqZWN0KSB7XG4gICAgLy8gY29uc29sZS53YXJuKCdFZGdlcyBvZiB0aGUgc2FtZSBwb2x5Z29uIG92ZXJsYXAnLFxuICAgIC8vICAgc2UxLnBvaW50LCBzZTEub3RoZXJFdmVudC5wb2ludCwgc2UyLnBvaW50LCBzZTIub3RoZXJFdmVudC5wb2ludCk7XG4gICAgLy90aHJvdyBuZXcgRXJyb3IoJ0VkZ2VzIG9mIHRoZSBzYW1lIHBvbHlnb24gb3ZlcmxhcCcpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gVGhlIGxpbmUgc2VnbWVudHMgYXNzb2NpYXRlZCB0byBzZTEgYW5kIHNlMiBpbnRlcnNlY3RcbiAgaWYgKG5pbnRlcnNlY3Rpb25zID09PSAxKSB7XG5cbiAgICAvLyBpZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGlzIG5vdCBhbiBlbmRwb2ludCBvZiBzZTFcbiAgICBpZiAoIWVxdWFscyhzZTEucG9pbnQsIGludGVyWzBdKSAmJiAhZXF1YWxzKHNlMS5vdGhlckV2ZW50LnBvaW50LCBpbnRlclswXSkpIHtcbiAgICAgIGRpdmlkZVNlZ21lbnQoc2UxLCBpbnRlclswXSwgcXVldWUpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgbm90IGFuIGVuZHBvaW50IG9mIHNlMlxuICAgIGlmICghZXF1YWxzKHNlMi5wb2ludCwgaW50ZXJbMF0pICYmICFlcXVhbHMoc2UyLm90aGVyRXZlbnQucG9pbnQsIGludGVyWzBdKSkge1xuICAgICAgZGl2aWRlU2VnbWVudChzZTIsIGludGVyWzBdLCBxdWV1ZSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gVGhlIGxpbmUgc2VnbWVudHMgYXNzb2NpYXRlZCB0byBzZTEgYW5kIHNlMiBvdmVybGFwXG4gIHZhciBldmVudHMgICAgICAgID0gW107XG4gIHZhciBsZWZ0Q29pbmNpZGUgID0gZmFsc2U7XG4gIHZhciByaWdodENvaW5jaWRlID0gZmFsc2U7XG5cbiAgaWYgKGVxdWFscyhzZTEucG9pbnQsIHNlMi5wb2ludCkpIHtcbiAgICBsZWZ0Q29pbmNpZGUgPSB0cnVlOyAvLyBsaW5rZWRcbiAgfSBlbHNlIGlmIChjb21wYXJlRXZlbnRzKHNlMSwgc2UyKSA9PT0gMSkge1xuICAgIGV2ZW50cy5wdXNoKHNlMiwgc2UxKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMucHVzaChzZTEsIHNlMik7XG4gIH1cblxuICBpZiAoZXF1YWxzKHNlMS5vdGhlckV2ZW50LnBvaW50LCBzZTIub3RoZXJFdmVudC5wb2ludCkpIHtcbiAgICByaWdodENvaW5jaWRlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjb21wYXJlRXZlbnRzKHNlMS5vdGhlckV2ZW50LCBzZTIub3RoZXJFdmVudCkgPT09IDEpIHtcbiAgICBldmVudHMucHVzaChzZTIub3RoZXJFdmVudCwgc2UxLm90aGVyRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cy5wdXNoKHNlMS5vdGhlckV2ZW50LCBzZTIub3RoZXJFdmVudCk7XG4gIH1cblxuICBpZiAoKGxlZnRDb2luY2lkZSAmJiByaWdodENvaW5jaWRlKSB8fCBsZWZ0Q29pbmNpZGUpIHtcbiAgICAvLyBib3RoIGxpbmUgc2VnbWVudHMgYXJlIGVxdWFsIG9yIHNoYXJlIHRoZSBsZWZ0IGVuZHBvaW50XG4gICAgc2UxLnR5cGUgPSBlZGdlVHlwZS5OT05fQ09OVFJJQlVUSU5HO1xuICAgIHNlMi50eXBlID0gKHNlMS5pbk91dCA9PT0gc2UyLmluT3V0KSA/XG4gICAgICBlZGdlVHlwZS5TQU1FX1RSQU5TSVRJT04gOlxuICAgICAgZWRnZVR5cGUuRElGRkVSRU5UX1RSQU5TSVRJT047XG5cbiAgICBpZiAobGVmdENvaW5jaWRlICYmICFyaWdodENvaW5jaWRlKSB7XG4gICAgICBkaXZpZGVTZWdtZW50KGV2ZW50c1syXS5vdGhlckV2ZW50LCBldmVudHNbMV0ucG9pbnQsIHF1ZXVlKTtcbiAgICB9XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICAvLyB0aGUgbGluZSBzZWdtZW50cyBzaGFyZSB0aGUgcmlnaHQgZW5kcG9pbnRcbiAgaWYgKHJpZ2h0Q29pbmNpZGUpIHtcbiAgICBkaXZpZGVTZWdtZW50KGV2ZW50c1swXSwgZXZlbnRzWzFdLnBvaW50LCBxdWV1ZSk7XG4gICAgcmV0dXJuIDM7XG4gIH1cblxuICAvLyBubyBsaW5lIHNlZ21lbnQgaW5jbHVkZXMgdG90YWxseSB0aGUgb3RoZXIgb25lXG4gIGlmIChldmVudHNbMF0gIT09IGV2ZW50c1szXS5vdGhlckV2ZW50KSB7XG4gICAgZGl2aWRlU2VnbWVudChldmVudHNbMF0sIGV2ZW50c1sxXS5wb2ludCwgcXVldWUpO1xuICAgIGRpdmlkZVNlZ21lbnQoZXZlbnRzWzFdLCBldmVudHNbMl0ucG9pbnQsIHF1ZXVlKTtcbiAgICByZXR1cm4gMztcbiAgfVxuXG4gIC8vIG9uZSBsaW5lIHNlZ21lbnQgaW5jbHVkZXMgdGhlIG90aGVyIG9uZVxuICBkaXZpZGVTZWdtZW50KGV2ZW50c1swXSwgZXZlbnRzWzFdLnBvaW50LCBxdWV1ZSk7XG4gIGRpdmlkZVNlZ21lbnQoZXZlbnRzWzNdLm90aGVyRXZlbnQsIGV2ZW50c1syXS5wb2ludCwgcXVldWUpO1xuXG4gIHJldHVybiAzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtICB7U3dlZXBFdmVudH0gc2VcbiAqIEBwYXJhbSAge0FycmF5LjxOdW1iZXI+fSBwXG4gKiBAcGFyYW0gIHtRdWV1ZX0gcXVldWVcbiAqIEByZXR1cm4ge1F1ZXVlfVxuICovXG5mdW5jdGlvbiBkaXZpZGVTZWdtZW50KHNlLCBwLCBxdWV1ZSkgIHtcbiAgdmFyIHIgPSBuZXcgU3dlZXBFdmVudChwLCBmYWxzZSwgc2UsICAgICAgICAgICAgc2UuaXNTdWJqZWN0KTtcbiAgdmFyIGwgPSBuZXcgU3dlZXBFdmVudChwLCB0cnVlLCAgc2Uub3RoZXJFdmVudCwgc2UuaXNTdWJqZWN0KTtcblxuICAvLyBhdm9pZCBhIHJvdW5kaW5nIGVycm9yLiBUaGUgbGVmdCBldmVudCB3b3VsZCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHJpZ2h0IGV2ZW50XG4gIGlmIChjb21wYXJlRXZlbnRzKGwsIHNlLm90aGVyRXZlbnQpID4gMCkge1xuICAgIHNlLm90aGVyRXZlbnQubGVmdCA9IHRydWU7XG4gICAgbC5sZWZ0ID0gZmFsc2U7XG4gIH1cblxuICAvLyBhdm9pZCBhIHJvdW5kaW5nIGVycm9yLiBUaGUgbGVmdCBldmVudCB3b3VsZCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHJpZ2h0IGV2ZW50XG4gIC8vIGlmIChjb21wYXJlRXZlbnRzKHNlLCByKSA+IDApIHt9XG5cbiAgc2Uub3RoZXJFdmVudC5vdGhlckV2ZW50ID0gbDtcbiAgc2Uub3RoZXJFdmVudCA9IHI7XG5cbiAgcXVldWUucHVzaChsKTtcbiAgcXVldWUucHVzaChyKTtcblxuICByZXR1cm4gcXVldWU7XG59XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLWRlYnVnZ2VyICovXG5mdW5jdGlvbiBpdGVyYXRvckVxdWFscyhpdDEsIGl0Mikge1xuICByZXR1cm4gaXQxLl9jdXJzb3IgPT09IGl0Mi5fY3Vyc29yO1xufVxuXG5cbmZ1bmN0aW9uIF9yZW5kZXJTd2VlcExpbmUoc3dlZXBMaW5lLCBwb3MsIGV2ZW50KSB7XG4gIHZhciBtYXAgPSB3aW5kb3cubWFwO1xuICBpZiAoIW1hcCkgcmV0dXJuO1xuICBpZiAod2luZG93LnN3cykgd2luZG93LnN3cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICBtYXAucmVtb3ZlTGF5ZXIocCk7XG4gIH0pO1xuICB3aW5kb3cuc3dzID0gW107XG4gIHN3ZWVwTGluZS5lYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcG9seSA9IEwucG9seWxpbmUoW2UucG9pbnQuc2xpY2UoKS5yZXZlcnNlKCksIGUub3RoZXJFdmVudC5wb2ludC5zbGljZSgpLnJldmVyc2UoKV0sIHsgY29sb3I6ICdncmVlbicgfSkuYWRkVG8obWFwKTtcbiAgICB3aW5kb3cuc3dzLnB1c2gocG9seSk7XG4gIH0pO1xuXG4gIGlmICh3aW5kb3cudnQpIG1hcC5yZW1vdmVMYXllcih3aW5kb3cudnQpO1xuICB2YXIgdiA9IHBvcy5zbGljZSgpO1xuICB2YXIgYiA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgd2luZG93LnZ0ID0gTC5wb2x5bGluZShbW2IuZ2V0Tm9ydGgoKSwgdlswXV0sIFtiLmdldFNvdXRoKCksIHZbMF1dXSwge2NvbG9yOiAnZ3JlZW4nLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuXG4gIGlmICh3aW5kb3cucHMpIG1hcC5yZW1vdmVMYXllcih3aW5kb3cucHMpO1xuICB3aW5kb3cucHMgPSBMLnBvbHlsaW5lKFtldmVudC5wb2ludC5zbGljZSgpLnJldmVyc2UoKSwgZXZlbnQub3RoZXJFdmVudC5wb2ludC5zbGljZSgpLnJldmVyc2UoKV0sIHtjb2xvcjogJ2JsYWNrJywgd2VpZ2h0OiA5LCBvcGFjaXR5OiAwLjR9KS5hZGRUbyhtYXApO1xuICBkZWJ1Z2dlcjtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLWRlYnVnZ2VyICovXG5cblxuZnVuY3Rpb24gc3ViZGl2aWRlU2VnbWVudHMoZXZlbnRRdWV1ZSwgc3ViamVjdCwgY2xpcHBpbmcsIHNiYm94LCBjYmJveCwgb3BlcmF0aW9uKSB7XG4gIHZhciBzb3J0ZWRFdmVudHMgPSBbXTtcbiAgdmFyIHByZXYsIG5leHQ7XG5cbiAgdmFyIHN3ZWVwTGluZSA9IG5ldyBUcmVlKGNvbXBhcmVTZWdtZW50cyk7XG4gIHZhciBzb3J0ZWRFdmVudHMgPSBbXTtcblxuICB2YXIgcmlnaHRib3VuZCA9IG1pbihzYmJveFsyXSwgY2Jib3hbMl0pO1xuXG4gIHZhciBwcmV2LCBuZXh0O1xuXG4gIHdoaWxlIChldmVudFF1ZXVlLmxlbmd0aCkge1xuICAgIHZhciBldmVudCA9IGV2ZW50UXVldWUucG9wKCk7XG4gICAgc29ydGVkRXZlbnRzLnB1c2goZXZlbnQpO1xuXG4gICAgLy8gb3B0aW1pemF0aW9uIGJ5IGJib3hlcyBmb3IgaW50ZXJzZWN0aW9uIGFuZCBkaWZmZXJlbmNlIGdvZXMgaGVyZVxuICAgIGlmICgob3BlcmF0aW9uID09PSBJTlRFUlNFQ1RJT04gJiYgZXZlbnQucG9pbnRbMF0gPiByaWdodGJvdW5kKSB8fFxuICAgICAgICAob3BlcmF0aW9uID09PSBESUZGRVJFTkNFICAgJiYgZXZlbnQucG9pbnRbMF0gPiBzYmJveFsyXSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChldmVudC5sZWZ0KSB7XG4gICAgICBzd2VlcExpbmUuaW5zZXJ0KGV2ZW50KTtcbiAgICAgIC8vIF9yZW5kZXJTd2VlcExpbmUoc3dlZXBMaW5lLCBldmVudC5wb2ludCwgZXZlbnQpO1xuXG4gICAgICBuZXh0ID0gc3dlZXBMaW5lLmZpbmRJdGVyKGV2ZW50KTtcbiAgICAgIHByZXYgPSBzd2VlcExpbmUuZmluZEl0ZXIoZXZlbnQpO1xuICAgICAgZXZlbnQuaXRlcmF0b3IgPSBzd2VlcExpbmUuZmluZEl0ZXIoZXZlbnQpO1xuXG4gICAgICBpZiAocHJldi5kYXRhKCkgIT09IHN3ZWVwTGluZS5taW4oKSkge1xuICAgICAgICBwcmV2LnByZXYoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYgPSBzd2VlcExpbmUuZmluZEl0ZXIoc3dlZXBMaW5lLm1heCgpKTtcbiAgICAgICAgcHJldi5uZXh0KCk7XG4gICAgICB9XG4gICAgICBuZXh0Lm5leHQoKTtcblxuICAgICAgY29tcHV0ZUZpZWxkcyhldmVudCwgcHJldi5kYXRhKCksIHN3ZWVwTGluZSwgb3BlcmF0aW9uKTtcblxuICAgICAgaWYgKG5leHQuZGF0YSgpKSB7XG4gICAgICAgIGlmIChwb3NzaWJsZUludGVyc2VjdGlvbihldmVudCwgbmV4dC5kYXRhKCksIGV2ZW50UXVldWUpID09PSAyKSB7XG4gICAgICAgICAgY29tcHV0ZUZpZWxkcyhldmVudCwgcHJldi5kYXRhKCksIHN3ZWVwTGluZSwgb3BlcmF0aW9uKTtcbiAgICAgICAgICBjb21wdXRlRmllbGRzKGV2ZW50LCBuZXh0LmRhdGEoKSwgc3dlZXBMaW5lLCBvcGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2LmRhdGEoKSkge1xuICAgICAgICBpZiAocG9zc2libGVJbnRlcnNlY3Rpb24ocHJldi5kYXRhKCksIGV2ZW50LCBldmVudFF1ZXVlKSA9PT0gMikge1xuICAgICAgICAgIHZhciBwcmV2cHJldiA9IHN3ZWVwTGluZS5maW5kSXRlcihwcmV2LmRhdGEoKSk7XG4gICAgICAgICAgaWYgKHByZXZwcmV2LmRhdGEoKSAhPT0gc3dlZXBMaW5lLm1pbigpKSB7XG4gICAgICAgICAgICBwcmV2cHJldi5wcmV2KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZwcmV2ID0gc3dlZXBMaW5lLmZpbmRJdGVyKHN3ZWVwTGluZS5tYXgoKSk7XG4gICAgICAgICAgICBwcmV2cHJldi5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB1dGVGaWVsZHMocHJldi5kYXRhKCksIHByZXZwcmV2LmRhdGEoKSwgc3dlZXBMaW5lLCBvcGVyYXRpb24pO1xuICAgICAgICAgIGNvbXB1dGVGaWVsZHMoZXZlbnQsIHByZXYuZGF0YSgpLCBzd2VlcExpbmUsIG9wZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQgPSBldmVudC5vdGhlckV2ZW50O1xuICAgICAgbmV4dCA9IHN3ZWVwTGluZS5maW5kSXRlcihldmVudCk7XG4gICAgICBwcmV2ID0gc3dlZXBMaW5lLmZpbmRJdGVyKGV2ZW50KTtcblxuICAgICAgLy8gX3JlbmRlclN3ZWVwTGluZShzd2VlcExpbmUsIGV2ZW50Lm90aGVyRXZlbnQucG9pbnQsIGV2ZW50KTtcblxuICAgICAgaWYgKCEocHJldiAmJiBuZXh0KSkgY29udGludWU7XG5cbiAgICAgIGlmIChwcmV2LmRhdGEoKSAhPT0gc3dlZXBMaW5lLm1pbigpKSB7XG4gICAgICAgIHByZXYucHJldigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldiA9IHN3ZWVwTGluZS5maW5kSXRlcihzd2VlcExpbmUubWF4KCkpO1xuICAgICAgICBwcmV2Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIG5leHQubmV4dCgpO1xuICAgICAgc3dlZXBMaW5lLnJlbW92ZShldmVudCk7XG5cbiAgICAgIC8vX3JlbmRlclN3ZWVwTGluZShzd2VlcExpbmUsIGV2ZW50Lm90aGVyRXZlbnQucG9pbnQsIGV2ZW50KTtcblxuICAgICAgaWYgKG5leHQuZGF0YSgpICYmIHByZXYuZGF0YSgpKSB7XG4gICAgICAgIHBvc3NpYmxlSW50ZXJzZWN0aW9uKHByZXYuZGF0YSgpLCBuZXh0LmRhdGEoKSwgZXZlbnRRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzb3J0ZWRFdmVudHM7XG59XG5cblxuZnVuY3Rpb24gc3dhcCAoYXJyLCBpLCBuKSB7XG4gIHZhciB0ZW1wID0gYXJyW2ldO1xuICBhcnJbaV0gPSBhcnJbbl07XG4gIGFycltuXSA9IHRlbXA7XG59XG5cblxuZnVuY3Rpb24gY2hhbmdlT3JpZW50YXRpb24oY29udG91cikge1xuICByZXR1cm4gY29udG91ci5yZXZlcnNlKCk7XG59XG5cblxuZnVuY3Rpb24gaXNBcnJheSAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuXG5mdW5jdGlvbiBhZGRIb2xlKGNvbnRvdXIsIGlkeCkge1xuICBpZiAoIWlzQXJyYXkoY29udG91clswXVswXSkpIHtcbiAgICBjb250b3VyID0gW2NvbnRvdXJdO1xuICB9XG4gIGNvbnRvdXJbaWR4XSA9IFtdO1xuICByZXR1cm4gY29udG91cjtcbn1cblxuXG5mdW5jdGlvbiBjb25uZWN0RWRnZXMoc29ydGVkRXZlbnRzKSB7XG4gIC8vIGNvcHkgdGhlIGV2ZW50cyBpbiB0aGUgcmVzdWx0IHBvbHlnb24gdG8gcmVzdWx0RXZlbnRzIGFycmF5XG4gIHZhciByZXN1bHRFdmVudHMgPSBbXTtcbiAgdmFyIGV2ZW50LCBpLCBsZW47XG5cbiAgZm9yIChpID0gMCwgbGVuID0gc29ydGVkRXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZXZlbnQgPSBzb3J0ZWRFdmVudHNbaV07XG4gICAgaWYgKChldmVudC5sZWZ0ICYmIGV2ZW50LmluUmVzdWx0KSB8fFxuICAgICAgKCFldmVudC5sZWZ0ICYmIGV2ZW50Lm90aGVyRXZlbnQuaW5SZXN1bHQpKSB7XG4gICAgICByZXN1bHRFdmVudHMucHVzaChldmVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRHVlIHRvIG92ZXJsYXBwaW5nIGVkZ2VzIHRoZSByZXN1bHRFdmVudHMgYXJyYXkgY2FuIGJlIG5vdCB3aG9sbHkgc29ydGVkXG4gIHZhciBzb3J0ZWQgPSBmYWxzZTtcbiAgd2hpbGUgKCFzb3J0ZWQpIHtcbiAgICBzb3J0ZWQgPSB0cnVlO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlc3VsdEV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKChpICsgMSkgPCBsZW4gJiZcbiAgICAgICAgY29tcGFyZUV2ZW50cyhyZXN1bHRFdmVudHNbaV0sIHJlc3VsdEV2ZW50c1tpICsgMV0pID09PSAxKSB7XG4gICAgICAgIHN3YXAocmVzdWx0RXZlbnRzLCBpLCBpICsgMSk7XG4gICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHJlc3VsdEV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdEV2ZW50c1tpXS5wb3MgPSBpO1xuICAgIGlmICghcmVzdWx0RXZlbnRzW2ldLmxlZnQpIHtcbiAgICAgIHZhciB0ZW1wID0gcmVzdWx0RXZlbnRzW2ldLnBvcztcbiAgICAgIHJlc3VsdEV2ZW50c1tpXS5wb3MgPSByZXN1bHRFdmVudHNbaV0ub3RoZXJFdmVudC5wb3M7XG4gICAgICByZXN1bHRFdmVudHNbaV0ub3RoZXJFdmVudC5wb3MgPSB0ZW1wO1xuICAgIH1cbiAgfVxuXG4gIC8vIFwiZmFsc2VcIi1maWxsZWQgYXJyYXlcbiAgdmFyIHByb2Nlc3NlZCA9IEFycmF5KHJlc3VsdEV2ZW50cy5sZW5ndGgpO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgdmFyIGRlcHRoICA9IFtdO1xuICB2YXIgaG9sZU9mID0gW107XG4gIHZhciBpc0hvbGUgPSB7fTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSByZXN1bHRFdmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAocHJvY2Vzc2VkW2ldKSBjb250aW51ZTtcblxuICAgIHZhciBjb250b3VyID0gW107XG4gICAgcmVzdWx0LnB1c2goY29udG91cik7XG5cbiAgICB2YXIgY29udG91cklkID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgZGVwdGgucHVzaCgwKTtcbiAgICBob2xlT2YucHVzaCgtMSk7XG5cblxuICAgIGlmIChyZXN1bHRFdmVudHNbaV0ucHJldkluUmVzdWx0KSB7XG4gICAgICB2YXIgbG93ZXJDb250b3VySWQgPSByZXN1bHRFdmVudHNbaV0ucHJldkluUmVzdWx0LmNvbnRvdXJJZDtcbiAgICAgIGlmICghcmVzdWx0RXZlbnRzW2ldLnByZXZJblJlc3VsdC5yZXN1bHRJbk91dCkge1xuICAgICAgICBhZGRIb2xlKHJlc3VsdFtsb3dlckNvbnRvdXJJZF0sIGNvbnRvdXJJZCk7XG4gICAgICAgIGhvbGVPZltjb250b3VySWRdID0gbG93ZXJDb250b3VySWQ7XG4gICAgICAgIGRlcHRoW2NvbnRvdXJJZF0gID0gZGVwdGhbbG93ZXJDb250b3VySWRdICsgMTtcbiAgICAgICAgaXNIb2xlW2NvbnRvdXJJZF0gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0hvbGVbbG93ZXJDb250b3VySWRdKSB7XG4gICAgICAgIGFkZEhvbGUocmVzdWx0W2hvbGVPZltsb3dlckNvbnRvdXJJZF1dLCBjb250b3VySWQpO1xuICAgICAgICBob2xlT2ZbY29udG91cklkXSA9IGhvbGVPZltsb3dlckNvbnRvdXJJZF07XG4gICAgICAgIGRlcHRoW2NvbnRvdXJJZF0gID0gZGVwdGhbbG93ZXJDb250b3VySWRdO1xuICAgICAgICBpc0hvbGVbY29udG91cklkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IGk7XG4gICAgdmFyIGluaXRpYWwgPSByZXN1bHRFdmVudHNbaV0ucG9pbnQ7XG4gICAgY29udG91ci5wdXNoKGluaXRpYWwpO1xuXG4gICAgd2hpbGUgKHBvcyA+PSBpKSB7XG4gICAgICBwcm9jZXNzZWRbcG9zXSA9IHRydWU7XG5cbiAgICAgIGlmIChyZXN1bHRFdmVudHNbcG9zXS5sZWZ0KSB7XG4gICAgICAgIHJlc3VsdEV2ZW50c1twb3NdLnJlc3VsdEluT3V0ID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdEV2ZW50c1twb3NdLmNvbnRvdXJJZCAgID0gY29udG91cklkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0RXZlbnRzW3Bvc10ub3RoZXJFdmVudC5yZXN1bHRJbk91dCA9IHRydWU7XG4gICAgICAgIHJlc3VsdEV2ZW50c1twb3NdLm90aGVyRXZlbnQuY29udG91cklkICAgPSBjb250b3VySWQ7XG4gICAgICB9XG5cbiAgICAgIHBvcyA9IHJlc3VsdEV2ZW50c1twb3NdLnBvcztcbiAgICAgIHByb2Nlc3NlZFtwb3NdID0gdHJ1ZTtcblxuICAgICAgY29udG91ci5wdXNoKHJlc3VsdEV2ZW50c1twb3NdLnBvaW50KTtcbiAgICAgIHBvcyA9IG5leHRQb3MocG9zLCByZXN1bHRFdmVudHMsIHByb2Nlc3NlZCk7XG4gICAgfVxuXG4gICAgcG9zID0gcG9zID09PSAtMSA/IGkgOiBwb3M7XG5cbiAgICBwcm9jZXNzZWRbcG9zXSA9IHByb2Nlc3NlZFtyZXN1bHRFdmVudHNbcG9zXS5wb3NdID0gdHJ1ZTtcbiAgICByZXN1bHRFdmVudHNbcG9zXS5vdGhlckV2ZW50LnJlc3VsdEluT3V0ID0gdHJ1ZTtcbiAgICByZXN1bHRFdmVudHNbcG9zXS5vdGhlckV2ZW50LmNvbnRvdXJJZCAgID0gY29udG91cklkO1xuXG5cblxuXG4gICAgLy8gZGVwdGggaXMgZXZlblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBpZiAoZGVwdGhbY29udG91cklkXSAmIDEpIHtcbiAgICAgIGNoYW5nZU9yaWVudGF0aW9uKGNvbnRvdXIpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc1xuICogQHBhcmFtICB7QXJyYXkuPFN3ZWVwRXZlbnQ+fSByZXN1bHRFdmVudHNcbiAqIEBwYXJhbSAge0FycmF5LjxCb29sZWFuPn0gICAgcHJvY2Vzc2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG5leHRQb3MocG9zLCByZXN1bHRFdmVudHMsIHByb2Nlc3NlZCkge1xuICB2YXIgbmV3UG9zID0gcG9zICsgMTtcbiAgdmFyIGxlbmd0aCA9IHJlc3VsdEV2ZW50cy5sZW5ndGg7XG4gIHdoaWxlIChuZXdQb3MgPCBsZW5ndGggJiZcbiAgICAgICAgIGVxdWFscyhyZXN1bHRFdmVudHNbbmV3UG9zXS5wb2ludCwgcmVzdWx0RXZlbnRzW3Bvc10ucG9pbnQpKSB7XG4gICAgaWYgKCFwcm9jZXNzZWRbbmV3UG9zXSkge1xuICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3UG9zID0gbmV3UG9zICsgMTtcbiAgICB9XG4gIH1cblxuICBuZXdQb3MgPSBwb3MgLSAxO1xuXG4gIHdoaWxlIChwcm9jZXNzZWRbbmV3UG9zXSkge1xuICAgIG5ld1BvcyA9IG5ld1BvcyAtIDE7XG4gIH1cbiAgcmV0dXJuIG5ld1Bvcztcbn1cblxuXG5mdW5jdGlvbiB0cml2aWFsT3BlcmF0aW9uKHN1YmplY3QsIGNsaXBwaW5nLCBvcGVyYXRpb24pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIGlmIChzdWJqZWN0Lmxlbmd0aCAqIGNsaXBwaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvcGVyYXRpb24gPT09IElOVEVSU0VDVElPTikge1xuICAgICAgcmVzdWx0ID0gRU1QVFk7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09IERJRkZFUkVOQ0UpIHtcbiAgICAgIHJlc3VsdCA9IHN1YmplY3Q7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09IFVOSU9OIHx8IG9wZXJhdGlvbiA9PT0gWE9SKSB7XG4gICAgICByZXN1bHQgPSAoc3ViamVjdC5sZW5ndGggPT09IDApID8gY2xpcHBpbmcgOiBzdWJqZWN0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBhcmVCQm94ZXMoc3ViamVjdCwgY2xpcHBpbmcsIHNiYm94LCBjYmJveCwgb3BlcmF0aW9uKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICBpZiAoc2Jib3hbMF0gPiBjYmJveFsyXSB8fFxuICAgICAgY2Jib3hbMF0gPiBzYmJveFsyXSB8fFxuICAgICAgc2Jib3hbMV0gPiBjYmJveFszXSB8fFxuICAgICAgY2Jib3hbMV0gPiBzYmJveFszXSkge1xuICAgIGlmIChvcGVyYXRpb24gPT09IElOVEVSU0VDVElPTikge1xuICAgICAgcmVzdWx0ID0gRU1QVFk7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09IERJRkZFUkVOQ0UpIHtcbiAgICAgIHJlc3VsdCA9IHN1YmplY3Q7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09IFVOSU9OIHx8IG9wZXJhdGlvbiA9PT0gWE9SKSB7XG4gICAgICByZXN1bHQgPSBzdWJqZWN0LmNvbmNhdChjbGlwcGluZyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gYm9vbGVhbihzdWJqZWN0LCBjbGlwcGluZywgb3BlcmF0aW9uKSB7XG4gIHZhciB0cml2aWFsID0gdHJpdmlhbE9wZXJhdGlvbihzdWJqZWN0LCBjbGlwcGluZywgb3BlcmF0aW9uKTtcbiAgaWYgKHRyaXZpYWwpIHtcbiAgICByZXR1cm4gdHJpdmlhbCA9PT0gRU1QVFkgPyBudWxsIDogdHJpdmlhbDtcbiAgfVxuICB2YXIgc2Jib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gIHZhciBjYmJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcblxuICB2YXIgZXZlbnRRdWV1ZSA9IGZpbGxRdWV1ZShzdWJqZWN0LCBjbGlwcGluZywgc2Jib3gsIGNiYm94KTtcblxuICB0cml2aWFsID0gY29tcGFyZUJCb3hlcyhzdWJqZWN0LCBjbGlwcGluZywgc2Jib3gsIGNiYm94LCBvcGVyYXRpb24pO1xuICBpZiAodHJpdmlhbCkge1xuICAgIHJldHVybiB0cml2aWFsID09PSBFTVBUWSA/IG51bGwgOiB0cml2aWFsO1xuICB9XG4gIHZhciBzb3J0ZWRFdmVudHMgPSBzdWJkaXZpZGVTZWdtZW50cyhldmVudFF1ZXVlLCBzdWJqZWN0LCBjbGlwcGluZywgc2Jib3gsIGNiYm94LCBvcGVyYXRpb24pO1xuICByZXR1cm4gY29ubmVjdEVkZ2VzKHNvcnRlZEV2ZW50cyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBib29sZWFuO1xuXG5cbm1vZHVsZS5leHBvcnRzLnVuaW9uID0gZnVuY3Rpb24oc3ViamVjdCwgY2xpcHBpbmcpIHtcbiAgcmV0dXJuIGJvb2xlYW4oc3ViamVjdCwgY2xpcHBpbmcsIFVOSU9OKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuZGlmZiA9IGZ1bmN0aW9uKHN1YmplY3QsIGNsaXBwaW5nKSB7XG4gIHJldHVybiBib29sZWFuKHN1YmplY3QsIGNsaXBwaW5nLCBESUZGRVJFTkNFKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMueG9yID0gZnVuY3Rpb24oc3ViamVjdCwgY2xpcHBpbmcpIHtcbiAgcmV0dXJuIGJvb2xlYW4oc3ViamVjdCwgY2xpcHBpbmcsIFhPUik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHN1YmplY3QsIGNsaXBwaW5nKSB7XG4gIHJldHVybiBib29sZWFuKHN1YmplY3QsIGNsaXBwaW5nLCBJTlRFUlNFQ1RJT04pO1xufTtcblxuXG4vKipcbiAqIEBlbnVtIHtOdW1iZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzLm9wZXJhdGlvbnMgPSB7XG4gIElOVEVSU0VDVElPTjogSU5URVJTRUNUSU9OLFxuICBESUZGRVJFTkNFOiAgIERJRkZFUkVOQ0UsXG4gIFVOSU9OOiAgICAgICAgVU5JT04sXG4gIFhPUjogICAgICAgICAgWE9SXG59O1xuXG5cbi8vIGZvciB0ZXN0aW5nXG5tb2R1bGUuZXhwb3J0cy5maWxsUXVldWUgICAgICAgICAgICA9IGZpbGxRdWV1ZTtcbm1vZHVsZS5leHBvcnRzLmNvbXB1dGVGaWVsZHMgICAgICAgID0gY29tcHV0ZUZpZWxkcztcbm1vZHVsZS5leHBvcnRzLnN1YmRpdmlkZVNlZ21lbnRzICAgID0gc3ViZGl2aWRlU2VnbWVudHM7XG5tb2R1bGUuZXhwb3J0cy5kaXZpZGVTZWdtZW50ICAgICAgICA9IGRpdmlkZVNlZ21lbnQ7XG5tb2R1bGUuZXhwb3J0cy5wb3NzaWJsZUludGVyc2VjdGlvbiA9IHBvc3NpYmxlSW50ZXJzZWN0aW9uO1xuIiwidmFyIEVQU0lMT04gPSAxZS05O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMgKGlmIHdlIHByZXRlbmRcbiAqIHRoZXkncmUgaW4gdGhyZWUgZGltZW5zaW9ucylcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBGaXJzdCB2ZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFNlY29uZCB2ZWN0b3JcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbWFnbml0dWRlIG9mIHRoZSBjcm9zcyBwcm9kdWN0XG4gKi9cbmZ1bmN0aW9uIGtyb3NzUHJvZHVjdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBGaXJzdCB2ZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFNlY29uZCB2ZWN0b3JcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZG90IHByb2R1Y3RcbiAqL1xuZnVuY3Rpb24gZG90UHJvZHVjdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBpbnRlcnNlY3Rpb24gKGlmIGFueSkgYmV0d2VlbiB0d28gbGluZSBzZWdtZW50cyBhIGFuZCBiLCBnaXZlbiB0aGVcbiAqIGxpbmUgc2VnbWVudHMnIGVuZCBwb2ludHMgYTEsIGEyIGFuZCBiMSwgYjIuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgYmFzZWQgb24gU2NobmVpZGVyIGFuZCBFYmVybHkuXG4gKiBodHRwOi8vd3d3LmNpbWVjLm9yZy5hci9+bmNhbHZvL1NjaG5laWRlcl9FYmVybHkucGRmXG4gKiBQYWdlIDI0NC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSBhMSBwb2ludCBvZiBmaXJzdCBsaW5lXG4gKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSBhMiBwb2ludCBvZiBmaXJzdCBsaW5lXG4gKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSBiMSBwb2ludCBvZiBzZWNvbmQgbGluZVxuICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gYjIgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbj19ICAgICAgIG5vRW5kcG9pbnRUb3VjaCB3aGV0aGVyIHRvIHNraXAgc2luZ2xlIHRvdWNocG9pbnRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lYW5pbmcgY29ubmVjdGVkIHNlZ21lbnRzKSBhc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPE51bWJlcj4+fE51bGx9IElmIHRoZSBsaW5lcyBpbnRlcnNlY3QsIHRoZSBwb2ludCBvZlxuICogaW50ZXJzZWN0aW9uLiBJZiB0aGV5IG92ZXJsYXAsIHRoZSB0d28gZW5kIHBvaW50cyBvZiB0aGUgb3ZlcmxhcHBpbmcgc2VnbWVudC5cbiAqIE90aGVyd2lzZSwgbnVsbC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhMSwgYTIsIGIxLCBiMiwgbm9FbmRwb2ludFRvdWNoKSB7XG4gIC8vIFRoZSBhbGdvcml0aG0gZXhwZWN0cyBvdXIgbGluZXMgaW4gdGhlIGZvcm0gUCArIHNkLCB3aGVyZSBQIGlzIGEgcG9pbnQsXG4gIC8vIHMgaXMgb24gdGhlIGludGVydmFsIFswLCAxXSwgYW5kIGQgaXMgYSB2ZWN0b3IuXG4gIC8vIFdlIGFyZSBwYXNzZWQgdHdvIHBvaW50cy4gUCBjYW4gYmUgdGhlIGZpcnN0IHBvaW50IG9mIGVhY2ggcGFpci4gVGhlXG4gIC8vIHZlY3RvciwgdGhlbiwgY291bGQgYmUgdGhvdWdodCBvZiBhcyB0aGUgZGlzdGFuY2UgKGluIHggYW5kIHkgY29tcG9uZW50cylcbiAgLy8gZnJvbSB0aGUgZmlyc3QgcG9pbnQgdG8gdGhlIHNlY29uZCBwb2ludC5cbiAgLy8gU28gZmlyc3QsIGxldCdzIG1ha2Ugb3VyIHZlY3RvcnM6XG4gIHZhciB2YSA9IFthMlswXSAtIGExWzBdLCBhMlsxXSAtIGExWzFdXTtcbiAgdmFyIHZiID0gW2IyWzBdIC0gYjFbMF0sIGIyWzFdIC0gYjFbMV1dO1xuICAvLyBXZSBhbHNvIGRlZmluZSBhIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYmFjayB0byByZWd1bGFyIHBvaW50IGZvcm06XG5cbiAgLyogZXNsaW50LWRpc2FibGUgYXJyb3ctYm9keS1zdHlsZSAqL1xuXG4gIGZ1bmN0aW9uIHRvUG9pbnQocCwgcywgZCkge1xuICAgIHJldHVybiBbXG4gICAgICBwWzBdICsgcyAqIGRbMF0sXG4gICAgICBwWzFdICsgcyAqIGRbMV1cbiAgICBdO1xuICB9XG5cbiAgLyogZXNsaW50LWVuYWJsZSBhcnJvdy1ib2R5LXN0eWxlICovXG5cbiAgLy8gVGhlIHJlc3QgaXMgcHJldHR5IG11Y2ggYSBzdHJhaWdodCBwb3J0IG9mIHRoZSBhbGdvcml0aG0uXG4gIHZhciBlID0gW2IxWzBdIC0gYTFbMF0sIGIxWzFdIC0gYTFbMV1dO1xuICB2YXIga3Jvc3MgPSBrcm9zc1Byb2R1Y3QodmEsIHZiKTtcbiAgdmFyIHNxcktyb3NzID0ga3Jvc3MgKiBrcm9zcztcbiAgdmFyIHNxckxlbkEgPSBkb3RQcm9kdWN0KHZhLCB2YSk7XG4gIHZhciBzcXJMZW5CID0gZG90UHJvZHVjdCh2YiwgdmIpO1xuXG4gIC8vIENoZWNrIGZvciBsaW5lIGludGVyc2VjdGlvbi4gVGhpcyB3b3JrcyBiZWNhdXNlIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZVxuICAvLyBjcm9zcyBwcm9kdWN0IC0tIHNwZWNpZmljYWxseSwgdHdvIHZlY3RvcnMgYXJlIHBhcmFsbGVsIGlmIGFuZCBvbmx5IGlmIHRoZVxuICAvLyBjcm9zcyBwcm9kdWN0IGlzIHRoZSAwIHZlY3Rvci4gVGhlIGZ1bGwgY2FsY3VsYXRpb24gaW52b2x2ZXMgcmVsYXRpdmUgZXJyb3JcbiAgLy8gdG8gYWNjb3VudCBmb3IgcG9zc2libGUgdmVyeSBzbWFsbCBsaW5lIHNlZ21lbnRzLiBTZWUgU2NobmVpZGVyICYgRWJlcmx5XG4gIC8vIGZvciBkZXRhaWxzLlxuICBpZiAoc3FyS3Jvc3MgPiBFUFNJTE9OICogc3FyTGVuQSAqIHNxckxlbkIpIHtcbiAgICAvLyBJZiB0aGV5J3JlIG5vdCBwYXJhbGxlbCwgdGhlbiAoYmVjYXVzZSB0aGVzZSBhcmUgbGluZSBzZWdtZW50cykgdGhleVxuICAgIC8vIHN0aWxsIG1pZ2h0IG5vdCBhY3R1YWxseSBpbnRlcnNlY3QuIFRoaXMgY29kZSBjaGVja3MgdGhhdCB0aGVcbiAgICAvLyBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgdGhlIGxpbmVzIGlzIGFjdHVhbGx5IG9uIGJvdGggbGluZSBzZWdtZW50cy5cbiAgICB2YXIgcyA9IGtyb3NzUHJvZHVjdChlLCB2YikgLyBrcm9zcztcbiAgICBpZiAocyA8IDAgfHwgcyA+IDEpIHtcbiAgICAgIC8vIG5vdCBvbiBsaW5lIHNlZ21lbnQgYVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB0ID0ga3Jvc3NQcm9kdWN0KGUsIHZhKSAvIGtyb3NzO1xuICAgIGlmICh0IDwgMCB8fCB0ID4gMSkge1xuICAgICAgLy8gbm90IG9uIGxpbmUgc2VnbWVudCBiXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5vRW5kcG9pbnRUb3VjaCA/IG51bGwgOiBbdG9Qb2ludChhMSwgcywgdmEpXTtcbiAgfVxuXG4gIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhpcyBwb2ludCwgdGhlbiB0aGUgbGluZXMgYXJlIGVpdGhlciBwYXJhbGxlbCBvciB0aGVcbiAgLy8gc2FtZSwgYnV0IHRoZSBzZWdtZW50cyBjb3VsZCBvdmVybGFwIHBhcnRpYWxseSBvciBmdWxseSwgb3Igbm90IGF0IGFsbC5cbiAgLy8gU28gd2UgbmVlZCB0byBmaW5kIHRoZSBvdmVybGFwLCBpZiBhbnkuIFRvIGRvIHRoYXQsIHdlIGNhbiB1c2UgZSwgd2hpY2ggaXNcbiAgLy8gdGhlICh2ZWN0b3IpIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGluaXRpYWwgcG9pbnRzLiBJZiB0aGlzIGlzIHBhcmFsbGVsXG4gIC8vIHdpdGggdGhlIGxpbmUgaXRzZWxmLCB0aGVuIHRoZSB0d28gbGluZXMgYXJlIHRoZSBzYW1lIGxpbmUsIGFuZCB0aGVyZSB3aWxsXG4gIC8vIGJlIG92ZXJsYXAuXG4gIHZhciBzcXJMZW5FID0gZG90UHJvZHVjdChlLCBlKTtcbiAga3Jvc3MgPSBrcm9zc1Byb2R1Y3QoZSwgdmEpO1xuICBzcXJLcm9zcyA9IGtyb3NzICoga3Jvc3M7XG5cbiAgaWYgKHNxcktyb3NzID4gRVBTSUxPTiAqIHNxckxlbkEgKiBzcXJMZW5FKSB7XG4gICAgLy8gTGluZXMgYXJlIGp1c3QgcGFyYWxsZWwsIG5vdCB0aGUgc2FtZS4gTm8gb3ZlcmxhcC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzYSA9IGRvdFByb2R1Y3QodmEsIGUpIC8gc3FyTGVuQTtcbiAgdmFyIHNiID0gc2EgKyBkb3RQcm9kdWN0KHZhLCB2YikgLyBzcXJMZW5BO1xuICB2YXIgc21pbiA9IE1hdGgubWluKHNhLCBzYik7XG4gIHZhciBzbWF4ID0gTWF0aC5tYXgoc2EsIHNiKTtcblxuICAvLyB0aGlzIGlzLCBlc3NlbnRpYWxseSwgdGhlIEZpbmRJbnRlcnNlY3Rpb24gYWN0aW5nIG9uIGZsb2F0cyBmcm9tXG4gIC8vIFNjaG5laWRlciAmIEViZXJseSwganVzdCBpbmxpbmVkIGludG8gdGhpcyBmdW5jdGlvbi5cbiAgaWYgKHNtaW4gPD0gMSAmJiBzbWF4ID49IDApIHtcblxuICAgIC8vIG92ZXJsYXAgb24gYW4gZW5kIHBvaW50XG4gICAgaWYgKHNtaW4gPT09IDEpIHtcbiAgICAgIHJldHVybiBub0VuZHBvaW50VG91Y2ggPyBudWxsIDogW3RvUG9pbnQoYTEsIHNtaW4gPiAwID8gc21pbiA6IDAsIHZhKV07XG4gICAgfVxuXG4gICAgaWYgKHNtYXggPT09IDApIHtcbiAgICAgIHJldHVybiBub0VuZHBvaW50VG91Y2ggPyBudWxsIDogW3RvUG9pbnQoYTEsIHNtYXggPCAxID8gc21heCA6IDEsIHZhKV07XG4gICAgfVxuXG4gICAgaWYgKG5vRW5kcG9pbnRUb3VjaCAmJiBzbWluID09PSAwICYmIHNtYXggPT09IDEpIHJldHVybiBudWxsO1xuXG4gICAgLy8gVGhlcmUncyBvdmVybGFwIG9uIGEgc2VnbWVudCAtLSB0d28gcG9pbnRzIG9mIGludGVyc2VjdGlvbi4gUmV0dXJuIGJvdGguXG4gICAgcmV0dXJuIFtcbiAgICAgIHRvUG9pbnQoYTEsIHNtaW4gPiAwID8gc21pbiA6IDAsIHZhKSxcbiAgICAgIHRvUG9pbnQoYTEsIHNtYXggPCAxID8gc21heCA6IDEsIHZhKSxcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuIiwiLyoqXG4gKiBTaWduZWQgYXJlYSBvZiB0aGUgdHJpYW5nbGUgKHAwLCBwMSwgcDIpXG4gKiBAcGFyYW0gIHtBcnJheS48TnVtYmVyPn0gcDBcbiAqIEBwYXJhbSAge0FycmF5LjxOdW1iZXI+fSBwMVxuICogQHBhcmFtICB7QXJyYXkuPE51bWJlcj59IHAyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2lnbmVkQXJlYShwMCwgcDEsIHAyKSB7XG4gIHJldHVybiAocDBbMF0gLSBwMlswXSkgKiAocDFbMV0gLSBwMlsxXSkgLSAocDFbMF0gLSBwMlswXSkgKiAocDBbMV0gLSBwMlsxXSk7XG59O1xuIiwidmFyIHNpZ25lZEFyZWEgPSByZXF1aXJlKCcuL3NpZ25lZF9hcmVhJyk7XG52YXIgRWRnZVR5cGUgICA9IHJlcXVpcmUoJy4vZWRnZV90eXBlJyk7XG5cblxuLyoqXG4gKiBTd2VlcGxpbmUgZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSAgcG9pbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICBsZWZ0XG4gKiBAcGFyYW0ge1N3ZWVwRXZlbnQ9fSAgICAgb3RoZXJFdmVudFxuICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgIGlzU3ViamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIGVkZ2VUeXBlXG4gKi9cbmZ1bmN0aW9uIFN3ZWVwRXZlbnQocG9pbnQsIGxlZnQsIG90aGVyRXZlbnQsIGlzU3ViamVjdCwgZWRnZVR5cGUpIHtcblxuICAvKipcbiAgICogSXMgbGVmdCBlbmRwb2ludD9cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmxlZnQgPSBsZWZ0O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPE51bWJlcj59XG4gICAqL1xuICB0aGlzLnBvaW50ID0gcG9pbnQ7XG5cbiAgLyoqXG4gICAqIE90aGVyIGVkZ2UgcmVmZXJlbmNlXG4gICAqIEB0eXBlIHtTd2VlcEV2ZW50fVxuICAgKi9cbiAgdGhpcy5vdGhlckV2ZW50ID0gb3RoZXJFdmVudDtcblxuICAvKipcbiAgICogQmVsb25ncyB0byBzb3VyY2Ugb3IgY2xpcHBpbmcgcG9seWdvblxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNTdWJqZWN0ID0gaXNTdWJqZWN0O1xuXG4gIC8qKlxuICAgKiBFZGdlIGNvbnRyaWJ1dGlvbiB0eXBlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLnR5cGUgPSBlZGdlVHlwZSB8fCBFZGdlVHlwZS5OT1JNQUw7XG5cblxuICAvKipcbiAgICogSW4tb3V0IHRyYW5zaXRpb24gZm9yIHRoZSBzd2VlcGxpbmUgY3Jvc3NpbmcgcG9seWdvblxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaW5PdXQgPSBmYWxzZTtcblxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMub3RoZXJJbk91dCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBldmVudCBpbiByZXN1bHQ/XG4gICAqIEB0eXBlIHtTd2VlcEV2ZW50fVxuICAgKi9cbiAgdGhpcy5wcmV2SW5SZXN1bHQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBEb2VzIGV2ZW50IGJlbG9uZyB0byByZXN1bHQ/XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5pblJlc3VsdCA9IGZhbHNlO1xuXG5cbiAgLy8gY29ubmVjdGlvbiBzdGVwXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5yZXN1bHRJbk91dCA9IGZhbHNlO1xufVxuXG5cblN3ZWVwRXZlbnQucHJvdG90eXBlID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtBcnJheS48TnVtYmVyPn0gIHBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQmVsb3c6IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0ID9cbiAgICAgIHNpZ25lZEFyZWEgKHRoaXMucG9pbnQsIHRoaXMub3RoZXJFdmVudC5wb2ludCwgcCkgPiAwIDpcbiAgICAgIHNpZ25lZEFyZWEgKHRoaXMub3RoZXJFdmVudC5wb2ludCwgdGhpcy5wb2ludCwgcCkgPiAwO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0FycmF5LjxOdW1iZXI+fSAgcFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBYm92ZTogZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhdGhpcy5pc0JlbG93KHApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1ZlcnRpY2FsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludFswXSA9PT0gdGhpcy5vdGhlckV2ZW50LnBvaW50WzBdO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN3ZWVwRXZlbnQ7XG4iXX0=
